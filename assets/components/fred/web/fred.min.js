(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Fred", [], factory);
	else if(typeof exports === 'object')
		exports["Fred"] = factory();
	else
		root["Fred"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EE = __webpack_require__(1);\n\nvar _EE2 = _interopRequireDefault(_EE);\n\nvar _Sidebar = __webpack_require__(3);\n\nvar _Sidebar2 = _interopRequireDefault(_Sidebar);\n\nvar _Launcher = __webpack_require__(33);\n\nvar _Launcher2 = _interopRequireDefault(_Launcher);\n\nvar _isomorphicFetch = __webpack_require__(6);\n\nvar _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);\n\nvar _Drake = __webpack_require__(10);\n\nvar _Drake2 = _interopRequireDefault(_Drake);\n\nvar _ImageEditor = __webpack_require__(24);\n\nvar _ImageEditor2 = _interopRequireDefault(_ImageEditor);\n\nvar _IconEditor = __webpack_require__(26);\n\nvar _IconEditor2 = _interopRequireDefault(_IconEditor);\n\nvar _ContentElement = __webpack_require__(23);\n\nvar _ContentElement2 = _interopRequireDefault(_ContentElement);\n\nvar _ElementSettings = __webpack_require__(34);\n\nvar _ElementSettings2 = _interopRequireDefault(_ElementSettings);\n\nvar _RegisterPlugins = __webpack_require__(36);\n\nvar _RegisterPlugins2 = _interopRequireDefault(_RegisterPlugins);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Fred = function () {\n    function Fred() {\n        var _this = this;\n\n        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Fred);\n\n        this.config = config || {};\n        this.drake = null;\n        this.loading = null;\n        this.wrapper = null;\n        this.config.pageSettings = {};\n\n        document.addEventListener(\"DOMContentLoaded\", function () {\n            _this.init();\n        });\n    }\n\n    _createClass(Fred, [{\n        key: 'render',\n        value: function render() {\n            this.wrapper = document.createElement('div');\n            this.wrapper.classList.add('fred');\n\n            this.config.fredWrapper = this.wrapper;\n\n            document.body.appendChild(this.wrapper);\n        }\n    }, {\n        key: 'renderComponents',\n        value: function renderComponents() {\n            new _Launcher2.default(this.config.launcherPosition || 'bottom_left');\n            new _Sidebar2.default(this.config, this.wrapper);\n            new _ElementSettings2.default();\n        }\n    }, {\n        key: 'getDataFromDropZone',\n        value: function getDataFromDropZone(dropZone) {\n            var data = [];\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = dropZone.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var child = _step.value;\n\n                    data.push(child.fredEl.getContent());\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return data;\n        }\n    }, {\n        key: 'getCleanDropZoneContent',\n        value: function getCleanDropZoneContent(dropZone) {\n            var cleanedContent = '';\n\n            var promises = [];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = dropZone.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var child = _step2.value;\n\n                    promises.push(child.fredEl.cleanRender());\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return Promise.all(promises).then(function (values) {\n                values.forEach(function (el) {\n                    cleanedContent += el.innerHTML;\n                });\n\n                return cleanedContent;\n            });\n        }\n    }, {\n        key: 'save',\n        value: function save() {\n            var _this2 = this;\n\n            _EE2.default.emit('fred-loading', 'Saving Page');\n            var body = {};\n            var data = {};\n\n            var promises = [];\n\n            var _loop = function _loop(i) {\n                data[_this2.dropzones[i].dataset.fredDropzone] = _this2.getDataFromDropZone(_this2.dropzones[i]);\n\n                var targets = _this2.dropzones[i].querySelectorAll('[data-fred-target]:not([data-fred-target=\"\"])');\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = targets[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var target = _step3.value;\n\n                        if (!_this2.config.pageSettings.hasOwnProperty(target.dataset.fredTarget)) {\n                            body[target.dataset.fredTarget] = target.innerHTML;\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n\n                promises.push(_this2.getCleanDropZoneContent(_this2.dropzones[i]).then(function (content) {\n                    body[_this2.dropzones[i].dataset.fredDropzone] = content;\n                }));\n            };\n\n            for (var i = 0; i < this.dropzones.length; i++) {\n                _loop(i);\n            }\n\n            body.id = this.config.resource.id;\n            body.data = data;\n            body.pageSettings = this.config.pageSettings;\n\n            Promise.all(promises).then(function () {\n                console.log('body: ', body);\n\n                (0, _isomorphicFetch2.default)(_this2.config.assetsUrl + 'endpoints/ajax.php?action=save-content', {\n                    method: \"post\",\n                    credentials: 'same-origin',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify(body)\n                }).then(function (response) {\n                    return response.json();\n                }).then(function (json) {\n                    if (json.url) {\n                        location.href = json.url;\n                    }\n\n                    _EE2.default.emit('fred-loading-hide');\n                });\n            });\n        }\n    }, {\n        key: 'loadContent',\n        value: function loadContent() {\n            var _this3 = this;\n\n            _EE2.default.emit('fred-loading', 'Preparing Content');\n\n            return (0, _isomorphicFetch2.default)(this.config.assetsUrl + 'endpoints/ajax.php?action=load-content&id=' + this.config.resource.id, {\n                credentials: 'same-origin'\n            }).then(function (response) {\n                return response.json();\n            }).then(function (json) {\n                var zones = json.data.data;\n                _this3.config.pageSettings = json.data.pageSettings || {};\n                var dzPromises = [];\n\n                var _loop2 = function _loop2(zoneName) {\n                    if (zones.hasOwnProperty(zoneName)) {\n                        var zoneEl = document.querySelector('[data-fred-dropzone=\"' + zoneName + '\"]');\n                        if (zoneEl) {\n                            var promises = [];\n\n                            zoneEl.innerHTML = '';\n                            zones[zoneName].forEach(function (element) {\n                                var chunk = document.createElement('div');\n                                chunk.classList.add('chunk');\n                                chunk.setAttribute('hidden', 'hidden');\n                                chunk.dataset.fredElementId = element.widget;\n                                chunk.innerHTML = json.data.elements[element.widget].html;\n                                chunk.elementOptions = json.data.elements[element.widget].options;\n\n                                var contentElement = new _ContentElement2.default(_this3.config, chunk, zoneName, null, element.values, element.settings || {});\n                                promises.push(contentElement.render().then(function (wrapper) {\n                                    _this3.loadChildren(element.children, contentElement, json.data.elements);\n                                    return wrapper;\n                                }));\n                            });\n\n                            dzPromises.push(Promise.all(promises).then(function (wrappers) {\n                                wrappers.forEach(function (wrapper) {\n                                    zoneEl.appendChild(wrapper);\n                                });\n                            }));\n                        }\n                    }\n                };\n\n                for (var zoneName in zones) {\n                    _loop2(zoneName);\n                }\n\n                Promise.all(dzPromises).then(function () {\n                    _Drake2.default.reloadContainers();\n\n                    _EE2.default.emit('fred-loading-hide');\n                });\n            });\n        }\n    }, {\n        key: 'loadChildren',\n        value: function loadChildren(zones, parent, elements) {\n            var _this4 = this;\n\n            var _loop3 = function _loop3(zoneName) {\n                if (zones.hasOwnProperty(zoneName)) {\n                    zones[zoneName].forEach(function (element) {\n                        var chunk = document.createElement('div');\n                        chunk.classList.add('chunk');\n                        chunk.setAttribute('hidden', 'hidden');\n                        chunk.dataset.fredElementId = element.widget;\n                        chunk.innerHTML = elements[element.widget].html;\n                        chunk.elementOptions = elements[element.widget].options || {};\n\n                        var contentElement = new _ContentElement2.default(_this4.config, chunk, zoneName, parent, element.values, element.settings || {});\n                        contentElement.render().then(function () {\n                            parent.addElementToDropZone(zoneName, contentElement);\n\n                            _this4.loadChildren(element.children, contentElement, elements);\n                        });\n                    });\n                }\n            };\n\n            for (var zoneName in zones) {\n                _loop3(zoneName);\n            }\n        }\n    }, {\n        key: 'registerListeners',\n        value: function registerListeners() {\n            var _this5 = this;\n\n            _EE2.default.on('fred-save', function () {\n                _this5.save();\n            });\n\n            _EE2.default.on('fred-wrapper-insert', function (el) {\n                _this5.wrapper.appendChild(el);\n            });\n\n            _EE2.default.on('fred-loading', function (text) {\n                if (_this5.loading !== null) return;\n\n                text = text || '';\n\n                _this5.loading = document.createElement('section');\n                _this5.loading.classList.add('fred--modal-bg');\n\n                _this5.loading.innerHTML = '<div class=\"fred--modal\" aria-hidden=\"false\"><div style=\"color:white;text-align:center;\"><span class=\"fred--loading\"></span> ' + text + '</div></div>';\n\n                _this5.wrapper.appendChild(_this5.loading);\n            });\n\n            _EE2.default.on('fred-loading-hide', function () {\n                if (_this5.loading !== null) {\n                    _this5.loading.remove();\n                    _this5.loading = null;\n                }\n            });\n\n            _EE2.default.on('fred-page-setting-change', function (settingName, settingValue, sourceEl) {\n                _this5.dropzones.forEach(function (dz) {\n                    var targets = dz.querySelectorAll('[data-fred-target=\"' + settingName + '\"');\n                    var _iteratorNormalCompletion4 = true;\n                    var _didIteratorError4 = false;\n                    var _iteratorError4 = undefined;\n\n                    try {\n                        for (var _iterator4 = targets[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                            var target = _step4.value;\n\n                            if (target !== sourceEl) {\n                                target.fredEl.setElValue(target, settingValue);\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError4 = true;\n                        _iteratorError4 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                _iterator4.return();\n                            }\n                        } finally {\n                            if (_didIteratorError4) {\n                                throw _iteratorError4;\n                            }\n                        }\n                    }\n                });\n            });\n\n            _EE2.default.on('fred-undo', function () {\n                console.log('Undo not yet implemented.');\n            });\n        }\n    }, {\n        key: 'init',\n        value: function init() {\n            var _this6 = this;\n\n            console.log('Hello from Fred!');\n\n            (0, _RegisterPlugins2.default)(this);\n\n            this.registerListeners();\n\n            this.dropzones = document.querySelectorAll('[data-fred-dropzone]:not([data-fred-dropzone=\"\"])');\n            var registeredDropzones = [];\n\n            for (var zoneIndex = 0; zoneIndex < this.dropzones.length; zoneIndex++) {\n                if (registeredDropzones.indexOf(this.dropzones[zoneIndex].dataset.fredDropzone) != -1) {\n                    console.error('There are several dropzones with same name: ' + this.dropzones[zoneIndex].dataset.fredDropzone + '. The name of each dropzone has to be unique.');\n                    return false;\n                }\n\n                registeredDropzones.push(this.dropzones[zoneIndex].dataset.fredDropzone);\n            }\n\n            this.render();\n            _Drake2.default.initDrake(this.config);\n            _ImageEditor2.default.init(this.wrapper);\n            _IconEditor2.default.init(this.wrapper);\n\n            this.loadContent().then(function () {\n                _this6.renderComponents();\n            });\n        }\n    }]);\n\n    return Fred;\n}();\n\nexports.default = Fred;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL2luZGV4LmpzP2FlNzkiXSwibmFtZXMiOlsiRnJlZCIsImNvbmZpZyIsImRyYWtlIiwibG9hZGluZyIsIndyYXBwZXIiLCJwYWdlU2V0dGluZ3MiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbml0IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImZyZWRXcmFwcGVyIiwiYm9keSIsImFwcGVuZENoaWxkIiwibGF1bmNoZXJQb3NpdGlvbiIsImRyb3Bab25lIiwiZGF0YSIsImNoaWxkcmVuIiwiY2hpbGQiLCJwdXNoIiwiZnJlZEVsIiwiZ2V0Q29udGVudCIsImNsZWFuZWRDb250ZW50IiwicHJvbWlzZXMiLCJjbGVhblJlbmRlciIsIlByb21pc2UiLCJhbGwiLCJ0aGVuIiwidmFsdWVzIiwiZm9yRWFjaCIsImVsIiwiaW5uZXJIVE1MIiwiZW1pdCIsImkiLCJkcm9wem9uZXMiLCJkYXRhc2V0IiwiZnJlZERyb3B6b25lIiwiZ2V0RGF0YUZyb21Ecm9wWm9uZSIsInRhcmdldHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwidGFyZ2V0IiwiaGFzT3duUHJvcGVydHkiLCJmcmVkVGFyZ2V0IiwiZ2V0Q2xlYW5Ecm9wWm9uZUNvbnRlbnQiLCJjb250ZW50IiwibGVuZ3RoIiwiaWQiLCJyZXNvdXJjZSIsImNvbnNvbGUiLCJsb2ciLCJhc3NldHNVcmwiLCJtZXRob2QiLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJqc29uIiwidXJsIiwibG9jYXRpb24iLCJocmVmIiwiem9uZXMiLCJkelByb21pc2VzIiwiem9uZU5hbWUiLCJ6b25lRWwiLCJxdWVyeVNlbGVjdG9yIiwiY2h1bmsiLCJzZXRBdHRyaWJ1dGUiLCJmcmVkRWxlbWVudElkIiwiZWxlbWVudCIsIndpZGdldCIsImVsZW1lbnRzIiwiaHRtbCIsImVsZW1lbnRPcHRpb25zIiwib3B0aW9ucyIsImNvbnRlbnRFbGVtZW50Iiwic2V0dGluZ3MiLCJyZW5kZXIiLCJsb2FkQ2hpbGRyZW4iLCJ3cmFwcGVycyIsInJlbG9hZENvbnRhaW5lcnMiLCJwYXJlbnQiLCJhZGRFbGVtZW50VG9Ecm9wWm9uZSIsIm9uIiwic2F2ZSIsInRleHQiLCJyZW1vdmUiLCJzZXR0aW5nTmFtZSIsInNldHRpbmdWYWx1ZSIsInNvdXJjZUVsIiwiZHoiLCJzZXRFbFZhbHVlIiwicmVnaXN0ZXJMaXN0ZW5lcnMiLCJyZWdpc3RlcmVkRHJvcHpvbmVzIiwiem9uZUluZGV4IiwiaW5kZXhPZiIsImVycm9yIiwiaW5pdERyYWtlIiwibG9hZENvbnRlbnQiLCJyZW5kZXJDb21wb25lbnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7OztJQUVxQkEsSTtBQUNqQixvQkFBeUI7QUFBQTs7QUFBQSxZQUFiQyxNQUFhLHVFQUFKLEVBQUk7O0FBQUE7O0FBQ3JCLGFBQUtBLE1BQUwsR0FBY0EsVUFBVSxFQUF4QjtBQUNBLGFBQUtDLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxhQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNBLGFBQUtILE1BQUwsQ0FBWUksWUFBWixHQUEyQixFQUEzQjs7QUFFQUMsaUJBQVNDLGdCQUFULENBQTBCLGtCQUExQixFQUE4QyxZQUFNO0FBQ2hELGtCQUFLQyxJQUFMO0FBQ0gsU0FGRDtBQUdIOzs7O2lDQUVRO0FBQ0wsaUJBQUtKLE9BQUwsR0FBZUUsU0FBU0csYUFBVCxDQUF1QixLQUF2QixDQUFmO0FBQ0EsaUJBQUtMLE9BQUwsQ0FBYU0sU0FBYixDQUF1QkMsR0FBdkIsQ0FBMkIsTUFBM0I7O0FBRUEsaUJBQUtWLE1BQUwsQ0FBWVcsV0FBWixHQUEwQixLQUFLUixPQUEvQjs7QUFFQUUscUJBQVNPLElB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LENBQWpCO0FBQ0EsZ0JBQUlzRCxzQkFBc0IsRUFBMUI7O0FBRUEsaUJBQUssSUFBSUMsWUFBWSxDQUFyQixFQUF3QkEsWUFBWSxLQUFLNUQsU0FBTCxDQUFlVyxNQUFuRCxFQUEyRGlELFdBQTNELEVBQXdFO0FBQ3BFLG9CQUFJRCxvQkFBb0JFLE9BQXBCLENBQTRCLEtBQUs3RCxTQUFMLENBQWU0RCxTQUFmLEVBQTBCM0QsT0FBMUIsQ0FBa0NDLFlBQTlELEtBQStFLENBQUMsQ0FBcEYsRUFBdUY7QUFDbkZZLDRCQUFRZ0QsS0FBUixDQUFjLGlEQUFpRCxLQUFLOUQsU0FBTCxDQUFlNEQsU0FBZixFQUEwQjNELE9BQTFCLENBQWtDQyxZQUFuRixHQUFrRywrQ0FBaEg7QUFDQSwyQkFBTyxLQUFQO0FBQ0g7O0FBRUR5RCxvQ0FBb0IxRSxJQUFwQixDQUF5QixLQUFLZSxTQUFMLENBQWU0RCxTQUFmLEVBQTBCM0QsT0FBMUIsQ0FBa0NDLFlBQTNEO0FBQ0g7O0FBRUQsaUJBQUt5QyxNQUFMO0FBQ0EsNEJBQU1vQixTQUFOLENBQWdCLEtBQUtqRyxNQUFyQjtBQUNBLGtDQUFZTyxJQUFaLENBQWlCLEtBQUtKLE9BQXRCO0FBQ0EsaUNBQVdJLElBQVgsQ0FBZ0IsS0FBS0osT0FBckI7O0FBRUEsaUJBQUsrRixXQUFMLEdBQW1CdkUsSUFBbkIsQ0FBd0IsWUFBTTtBQUMxQix1QkFBS3dFLGdCQUFMO0FBQ0gsYUFGRDtBQUlIOzs7Ozs7a0JBelBnQnBHLEkiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlbWl0dGVyIGZyb20gJy4vRUUnO1xuaW1wb3J0IFNpZGViYXIgZnJvbSAnLi9TaWRlYmFyJztcbmltcG9ydCBMYXVuY2hlciBmcm9tICcuL0xhdW5jaGVyJztcbmltcG9ydCBmZXRjaCBmcm9tICdpc29tb3JwaGljLWZldGNoJztcbmltcG9ydCBkcmFrZSBmcm9tICcuL0RyYWtlJztcbmltcG9ydCBpbWFnZUVkaXRvciBmcm9tICcuL0VkaXRvcnMvSW1hZ2VFZGl0b3InO1xuaW1wb3J0IGljb25FZGl0b3IgZnJvbSAnLi9FZGl0b3JzL0ljb25FZGl0b3InO1xuaW1wb3J0IENvbnRlbnRFbGVtZW50IGZyb20gJy4vQ29tcG9uZW50cy9TaWRlYmFyL0VsZW1lbnRzL0NvbnRlbnRFbGVtZW50JztcbmltcG9ydCBFbGVtZW50U2V0dGluZ3MgZnJvbSAnLi9Db21wb25lbnRzL1NpZGViYXIvRWxlbWVudHMvRWxlbWVudFNldHRpbmdzJztcbmltcG9ydCByZWdpc3RlclBsdWdpbnMgZnJvbSAnLi9UaW55TUNFL1JlZ2lzdGVyUGx1Z2lucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZyZWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICB0aGlzLmRyYWtlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25maWcucGFnZVNldHRpbmdzID0ge307XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKCdmcmVkJyk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmNvbmZpZy5mcmVkV3JhcHBlciA9IHRoaXMud3JhcHBlcjtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgfVxuICAgIFxuICAgIHJlbmRlckNvbXBvbmVudHMoKSB7XG4gICAgICAgIG5ldyBMYXVuY2hlcigodGhpcy5jb25maWcubGF1bmNoZXJQb3NpdGlvbiB8fCAnYm90dG9tX2xlZnQnKSk7XG4gICAgICAgIG5ldyBTaWRlYmFyKHRoaXMuY29uZmlnLCB0aGlzLndyYXBwZXIpO1xuICAgICAgICBuZXcgRWxlbWVudFNldHRpbmdzKCk7ICAgICAgICBcbiAgICB9XG5cbiAgICBnZXREYXRhRnJvbURyb3Bab25lKGRyb3Bab25lKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBkcm9wWm9uZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgZGF0YS5wdXNoKGNoaWxkLmZyZWRFbC5nZXRDb250ZW50KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZ2V0Q2xlYW5Ecm9wWm9uZUNvbnRlbnQoZHJvcFpvbmUpIHtcbiAgICAgICAgbGV0IGNsZWFuZWRDb250ZW50ID0gJyc7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgZHJvcFpvbmUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goY2hpbGQuZnJlZEVsLmNsZWFuUmVuZGVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4odmFsdWVzID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhbmVkQ29udGVudCArPSBlbC5pbm5lckhUTUw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGNsZWFuZWRDb250ZW50O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzYXZlKCkge1xuICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtbG9hZGluZycsICdTYXZpbmcgUGFnZScpO1xuICAgICAgICBjb25zdCBib2R5ID0ge307XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7fTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRyb3B6b25lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YVt0aGlzLmRyb3B6b25lc1tpXS5kYXRhc2V0LmZyZWREcm9wem9uZV0gPSB0aGlzLmdldERhdGFGcm9tRHJvcFpvbmUodGhpcy5kcm9wem9uZXNbaV0pO1xuXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRzID0gdGhpcy5kcm9wem9uZXNbaV0ucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZnJlZC10YXJnZXRdOm5vdChbZGF0YS1mcmVkLXRhcmdldD1cIlwiXSknKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5wYWdlU2V0dGluZ3MuaGFzT3duUHJvcGVydHkodGFyZ2V0LmRhdGFzZXQuZnJlZFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keVt0YXJnZXQuZGF0YXNldC5mcmVkVGFyZ2V0XSA9IHRhcmdldC5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmdldENsZWFuRHJvcFpvbmVDb250ZW50KHRoaXMuZHJvcHpvbmVzW2ldKS50aGVuKGNvbnRlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGJvZHlbdGhpcy5kcm9wem9uZXNbaV0uZGF0YXNldC5mcmVkRHJvcHpvbmVdID0gY29udGVudDsgICAgXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHkuaWQgPSB0aGlzLmNvbmZpZy5yZXNvdXJjZS5pZDtcbiAgICAgICAgYm9keS5kYXRhID0gZGF0YTtcbiAgICAgICAgYm9keS5wYWdlU2V0dGluZ3MgPSB0aGlzLmNvbmZpZy5wYWdlU2V0dGluZ3M7XG5cbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2JvZHk6ICcsIGJvZHkpO1xuXG4gICAgICAgICAgICBmZXRjaChgJHt0aGlzLmNvbmZpZy5hc3NldHNVcmx9ZW5kcG9pbnRzL2FqYXgucGhwP2FjdGlvbj1zYXZlLWNvbnRlbnRgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgICAgICAgICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSkudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24uaHJlZiA9IGpzb24udXJsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZnJlZC1sb2FkaW5nLWhpZGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2FkQ29udGVudCgpIHtcbiAgICAgICAgZW1pdHRlci5lbWl0KCdmcmVkLWxvYWRpbmcnLCAnUHJlcGFyaW5nIENvbnRlbnQnKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmZXRjaChgJHt0aGlzLmNvbmZpZy5hc3NldHNVcmx9ZW5kcG9pbnRzL2FqYXgucGhwP2FjdGlvbj1sb2FkLWNvbnRlbnQmaWQ9JHt0aGlzLmNvbmZpZy5yZXNvdXJjZS5pZH1gLCB7XG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ1xuICAgICAgICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0pLnRoZW4oanNvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCB6b25lcyA9IGpzb24uZGF0YS5kYXRhO1xuICAgICAgICAgICAgdGhpcy5jb25maWcucGFnZVNldHRpbmdzID0ganNvbi5kYXRhLnBhZ2VTZXR0aW5ncyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IGR6UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgem9uZU5hbWUgaW4gem9uZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoem9uZXMuaGFzT3duUHJvcGVydHkoem9uZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHpvbmVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWZyZWQtZHJvcHpvbmU9XCIke3pvbmVOYW1lfVwiXWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoem9uZUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lRWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lc1t6b25lTmFtZV0uZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLmNsYXNzTGlzdC5hZGQoJ2NodW5rJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuZGF0YXNldC5mcmVkRWxlbWVudElkID0gZWxlbWVudC53aWRnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuaW5uZXJIVE1MID0ganNvbi5kYXRhLmVsZW1lbnRzW2VsZW1lbnQud2lkZ2V0XS5odG1sO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLmVsZW1lbnRPcHRpb25zID0ganNvbi5kYXRhLmVsZW1lbnRzW2VsZW1lbnQud2lkZ2V0XS5vcHRpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBuZXcgQ29udGVudEVsZW1lbnQodGhpcy5jb25maWcsIGNodW5rLCB6b25lTmFtZSwgbnVsbCwgZWxlbWVudC52YWx1ZXMsIChlbGVtZW50LnNldHRpbmdzIHx8IHt9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjb250ZW50RWxlbWVudC5yZW5kZXIoKS50aGVuKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRDaGlsZHJlbihlbGVtZW50LmNoaWxkcmVuLCBjb250ZW50RWxlbWVudCwganNvbi5kYXRhLmVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZHpQcm9taXNlcy5wdXNoKFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKHdyYXBwZXJzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycy5mb3JFYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b25lRWwuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFByb21pc2UuYWxsKGR6UHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRyYWtlLnJlbG9hZENvbnRhaW5lcnMoKTtcbiAgICBcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtbG9hZGluZy1oaWRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbG9hZENoaWxkcmVuKHpvbmVzLCBwYXJlbnQsIGVsZW1lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHpvbmVOYW1lIGluIHpvbmVzKSB7XG4gICAgICAgICAgICBpZiAoem9uZXMuaGFzT3duUHJvcGVydHkoem9uZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgem9uZXNbem9uZU5hbWVdLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLmNsYXNzTGlzdC5hZGQoJ2NodW5rJyk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5kYXRhc2V0LmZyZWRFbGVtZW50SWQgPSBlbGVtZW50LndpZGdldDtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuaW5uZXJIVE1MID0gZWxlbWVudHNbZWxlbWVudC53aWRnZXRdLmh0bWw7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLmVsZW1lbnRPcHRpb25zID0gZWxlbWVudHNbZWxlbWVudC53aWRnZXRdLm9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IG5ldyBDb250ZW50RWxlbWVudCh0aGlzLmNvbmZpZywgY2h1bmssIHpvbmVOYW1lLCBwYXJlbnQsIGVsZW1lbnQudmFsdWVzLCAoZWxlbWVudC5zZXR0aW5ncyB8fCB7fSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudC5yZW5kZXIoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5hZGRFbGVtZW50VG9Ecm9wWm9uZSh6b25lTmFtZSwgY29udGVudEVsZW1lbnQpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkQ2hpbGRyZW4oZWxlbWVudC5jaGlsZHJlbiwgY29udGVudEVsZW1lbnQsIGVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGVtaXR0ZXIub24oJ2ZyZWQtc2F2ZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbWl0dGVyLm9uKCdmcmVkLXdyYXBwZXItaW5zZXJ0JywgZWwgPT4ge1xuICAgICAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW1pdHRlci5vbignZnJlZC1sb2FkaW5nJywgdGV4dCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkaW5nICE9PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgICAgIHRleHQgPSB0ZXh0IHx8ICcnO1xuXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcuY2xhc3NMaXN0LmFkZCgnZnJlZC0tbW9kYWwtYmcnKTtcblxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwiZnJlZC0tbW9kYWxcIiBhcmlhLWhpZGRlbj1cImZhbHNlXCI+PGRpdiBzdHlsZT1cImNvbG9yOndoaXRlO3RleHQtYWxpZ246Y2VudGVyO1wiPjxzcGFuIGNsYXNzPVwiZnJlZC0tbG9hZGluZ1wiPjwvc3Bhbj4gJHt0ZXh0fTwvZGl2PjwvZGl2PmA7XG5cbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmxvYWRpbmcpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbWl0dGVyLm9uKCdmcmVkLWxvYWRpbmctaGlkZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW1pdHRlci5vbignZnJlZC1wYWdlLXNldHRpbmctY2hhbmdlJywgKHNldHRpbmdOYW1lLCBzZXR0aW5nVmFsdWUsIHNvdXJjZUVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyb3B6b25lcy5mb3JFYWNoKGR6ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRzID0gZHoucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtZnJlZC10YXJnZXQ9XCIke3NldHRpbmdOYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gc291cmNlRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5mcmVkRWwuc2V0RWxWYWx1ZSh0YXJnZXQsIHNldHRpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW1pdHRlci5vbignZnJlZC11bmRvJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuZG8gbm90IHlldCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0hlbGxvIGZyb20gRnJlZCEnKTtcblxuICAgICAgICByZWdpc3RlclBsdWdpbnModGhpcyk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgdGhpcy5kcm9wem9uZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mcmVkLWRyb3B6b25lXTpub3QoW2RhdGEtZnJlZC1kcm9wem9uZT1cIlwiXSknKTtcbiAgICAgICAgbGV0IHJlZ2lzdGVyZWREcm9wem9uZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCB6b25lSW5kZXggPSAwOyB6b25lSW5kZXggPCB0aGlzLmRyb3B6b25lcy5sZW5ndGg7IHpvbmVJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAocmVnaXN0ZXJlZERyb3B6b25lcy5pbmRleE9mKHRoaXMuZHJvcHpvbmVzW3pvbmVJbmRleF0uZGF0YXNldC5mcmVkRHJvcHpvbmUpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGhlcmUgYXJlIHNldmVyYWwgZHJvcHpvbmVzIHdpdGggc2FtZSBuYW1lOiAnICsgdGhpcy5kcm9wem9uZXNbem9uZUluZGV4XS5kYXRhc2V0LmZyZWREcm9wem9uZSArICcuIFRoZSBuYW1lIG9mIGVhY2ggZHJvcHpvbmUgaGFzIHRvIGJlIHVuaXF1ZS4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZ2lzdGVyZWREcm9wem9uZXMucHVzaCh0aGlzLmRyb3B6b25lc1t6b25lSW5kZXhdLmRhdGFzZXQuZnJlZERyb3B6b25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIGRyYWtlLmluaXREcmFrZSh0aGlzLmNvbmZpZyk7XG4gICAgICAgIGltYWdlRWRpdG9yLmluaXQodGhpcy53cmFwcGVyKTtcbiAgICAgICAgaWNvbkVkaXRvci5pbml0KHRoaXMud3JhcHBlcik7XG5cbiAgICAgICAgdGhpcy5sb2FkQ29udGVudCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDb21wb25lbnRzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vX2J1aWxkL2Fzc2V0cy9qcy9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.emitter = undefined;\n\nvar _events = __webpack_require__(2);\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar emitter = exports.emitter = new _events2.default();\nexports.default = emitter;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0VFLmpzPzE5ZjQiXSwibmFtZXMiOlsiZW1pdHRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7QUFDTyxJQUFNQSw0QkFBVSxzQkFBaEI7a0JBQ1FBLE8iLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmV4cG9ydCBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuZXhwb3J0IGRlZmF1bHQgZW1pdHRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9fYnVpbGQvYXNzZXRzL2pzL0VFLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2V2ZW50cy9ldmVudHMuanM/N2M3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSCxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EE = __webpack_require__(1);\n\nvar _EE2 = _interopRequireDefault(_EE);\n\nvar _Pages = __webpack_require__(4);\n\nvar _Pages2 = _interopRequireDefault(_Pages);\n\nvar _Elements = __webpack_require__(9);\n\nvar _Elements2 = _interopRequireDefault(_Elements);\n\nvar _PageSettings = __webpack_require__(30);\n\nvar _PageSettings2 = _interopRequireDefault(_PageSettings);\n\nvar _promiseCancel = __webpack_require__(32);\n\nvar _promiseCancel2 = _interopRequireDefault(_promiseCancel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Sidebar = function () {\n    function Sidebar() {\n        var _this = this;\n\n        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var fredWrapper = arguments[1];\n\n        _classCallCheck(this, Sidebar);\n\n        this.lastRequest = null;\n        this.config = config || {};\n        this.components = [];\n        this.visible = false;\n        this.fredWrapper = fredWrapper;\n\n        this.hideSidebar = this.hideSidebar.bind(this);\n        this.globalHideSidebar = this.globalHideSidebar.bind(this);\n\n        _EE2.default.on('fred-sidebar-expand', function (cmp, title, data) {\n            cmp.loading();\n\n            _this.components.forEach(function (component) {\n                component.hide();\n            });\n\n            cmp.expand();\n\n            _this.lastRequest = (0, _promiseCancel2.default)(Promise.resolve(data));\n            _this.lastRequest.promise.then(function (content) {\n                _this.lastRequest = null;\n\n                cmp.setContent(content);\n\n                cmp.afterExpand();\n            }).catch(function (err) {\n                _this.lastRequest = null;\n\n                if (err.type === 'cancel') {\n                    return;\n                }\n\n                cmp.setContent('SOMETHING WRONG HAPPENED');\n            });\n        });\n\n        _EE2.default.on('fred-sidebar-collapse', function (cmp) {\n            if (_this.lastRequest !== null) {\n                _this.lastRequest.cancel();\n                _this.lastRequest = null;\n            }\n\n            _this.components.forEach(function (component) {\n                component.collapse();\n            });\n        });\n\n        _EE2.default.on('fred-sidebar-hide', function (silent) {\n            _this.hideSidebar(silent);\n        });\n\n        _EE2.default.on('fred-sidebar-show', function (silent) {\n            _this.showSidebar(silent);\n        });\n\n        _EE2.default.on('fred-sidebar-toggle', function () {\n            if (_this.wrapper.classList.contains('fred--hidden')) {\n                _EE2.default.emit('fred-sidebar-show');\n            } else {\n                _EE2.default.emit('fred-sidebar-hide');\n            }\n        });\n\n        this.render();\n    }\n\n    _createClass(Sidebar, [{\n        key: 'render',\n        value: function render() {\n            this.wrapper = document.createElement('div');\n            this.wrapper.classList.add('fred--sidebar', 'fred--hidden');\n            this.wrapper.setAttribute('aria-hidden', 'true');\n\n            this.wrapper.appendChild(this.buildCloseButton());\n            this.wrapper.appendChild(this.buildSidebarHeader());\n            this.wrapper.appendChild(this.buildSidebar());\n\n            _EE2.default.emit('fred-wrapper-insert', this.wrapper);\n\n            return this;\n        }\n    }, {\n        key: 'buildCloseButton',\n        value: function buildCloseButton() {\n            var button = document.createElement('button');\n            button.classList.add('fred--sidebar_close');\n            button.setAttribute('role', 'button');\n            button.innerHTML = '<i class=\"fred--angle-left\"></i><i class=\"fred--angle-left\"></i>';\n            button.addEventListener('click', function (e) {\n                e.preventDefault();\n\n                _EE2.default.emit('fred-sidebar-hide');\n            });\n\n            return button;\n        }\n    }, {\n        key: 'buildSidebarHeader',\n        value: function buildSidebarHeader() {\n            var header = document.createElement('div');\n            header.classList.add('fred--sidebar_title');\n\n            var logo = document.createElement('img');\n            logo.setAttribute('alt', 'MODX FRED');\n            logo.classList.add('fred--logo');\n            logo.src = (this.config.assetsUrl || '') + 'images/modx-revo-icon-48.svg';\n\n            var title = document.createElement('h1');\n            title.innerText = 'Fred';\n\n            header.appendChild(logo);\n            header.appendChild(title);\n\n            return header;\n        }\n    }, {\n        key: 'buildSidebar',\n        value: function buildSidebar() {\n            this.sidebar = document.createElement('dl');\n            this.sidebar.classList.add('fred--accordion');\n            this.sidebar.setAttribute('tabindex', '0');\n            this.sidebar.setAttribute('role', 'tablist');\n\n            this.components.push(new _Pages2.default(this.sidebar, this.config));\n            this.components.push(new _Elements2.default(this.sidebar, this.config));\n            this.components.push(new _PageSettings2.default(this.sidebar, this.config));\n\n            return this.sidebar;\n        }\n    }, {\n        key: 'hideSidebar',\n        value: function hideSidebar() {\n            var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (silent === false) {\n                this.visible = false;\n            }\n\n            this.wrapper.classList.add('fred--hidden');\n\n            window.removeEventListener('click', this.globalHideSidebar);\n        }\n    }, {\n        key: 'showSidebar',\n        value: function showSidebar() {\n            var _this2 = this;\n\n            var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (silent === true) {\n                if (this.visible === false) return;\n            }\n\n            this.visible = true;\n            this.wrapper.classList.remove('fred--hidden');\n            setTimeout(function () {\n                window.addEventListener('click', _this2.globalHideSidebar);\n            }, 50);\n        }\n    }, {\n        key: 'globalHideSidebar',\n        value: function globalHideSidebar(e) {\n            if (!this.fredWrapper.contains(e.target)) {\n                this.hideSidebar(false);\n            }\n        }\n    }]);\n\n    return Sidebar;\n}();\n\nexports.default = Sidebar;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL1NpZGViYXIuanM/OGRjYyJdLCJuYW1lcyI6WyJTaWRlYmFyIiwiY29uZmlnIiwiZnJlZFdyYXBwZXIiLCJsYXN0UmVxdWVzdCIsImNvbXBvbmVudHMiLCJ2aXNpYmxlIiwiaGlkZVNpZGViYXIiLCJiaW5kIiwiZ2xvYmFsSGlkZVNpZGViYXIiLCJvbiIsImNtcCIsInRpdGxlIiwiZGF0YSIsImxvYWRpbmciLCJmb3JFYWNoIiwiY29tcG9uZW50IiwiaGlkZSIsImV4cGFuZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicHJvbWlzZSIsInRoZW4iLCJzZXRDb250ZW50IiwiY29udGVudCIsImFmdGVyRXhwYW5kIiwiY2F0Y2giLCJlcnIiLCJ0eXBlIiwiY2FuY2VsIiwiY29sbGFwc2UiLCJzaWxlbnQiLCJzaG93U2lkZWJhciIsIndyYXBwZXIiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImVtaXQiLCJyZW5kZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhZGQiLCJzZXRBdHRyaWJ1dGUiLCJhcHBlbmRDaGlsZCIsImJ1aWxkQ2xvc2VCdXR0b24iLCJidWlsZFNpZGViYXJIZWFkZXIiLCJidWlsZFNpZGViYXIiLCJidXR0b24iLCJpbm5lckhUTUwiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInByZXZlbnREZWZhdWx0IiwiaGVhZGVyIiwibG9nbyIsInNyYyIsImFzc2V0c1VybCIsImlubmVyVGV4dCIsInNpZGViYXIiLCJwdXNoIiwid2luZG93IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZSIsInNldFRpbWVvdXQiLCJ0YXJnZXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7SUFFcUJBLE87QUFDakIsdUJBQXNDO0FBQUE7O0FBQUEsWUFBMUJDLE1BQTBCLHVFQUFqQixFQUFpQjtBQUFBLFlBQWJDLFdBQWE7O0FB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LGFBRkQsRUFFRyxFQUZIO0FBR0g7OzswQ0FFaUJ3QyxDLEVBQUc7QUFDakIsZ0JBQUksQ0FBQyxLQUFLOUMsV0FBTCxDQUFpQmdDLFFBQWpCLENBQTBCYyxFQUFFYSxNQUE1QixDQUFMLEVBQTBDO0FBQ3RDLHFCQUFLdkQsV0FBTCxDQUFpQixLQUFqQjtBQUNIO0FBQ0o7Ozs7OztrQkExSmdCTixPIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZW1pdHRlciBmcm9tICcuL0VFJztcbmltcG9ydCBQYWdlc0NvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudHMvU2lkZWJhci9QYWdlcyc7XG5pbXBvcnQgRWxlbWVudHNDb21wb25lbnQgZnJvbSAnLi9Db21wb25lbnRzL1NpZGViYXIvRWxlbWVudHMnO1xuaW1wb3J0IFBhZ2VTZXR0aW5nc0NvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudHMvU2lkZWJhci9QYWdlU2V0dGluZ3MnO1xuaW1wb3J0IHByb21pc2VDYW5jZWwgZnJvbSAncHJvbWlzZS1jYW5jZWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaWRlYmFyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSwgZnJlZFdyYXBwZXIpIHtcbiAgICAgICAgdGhpcy5sYXN0UmVxdWVzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJlZFdyYXBwZXIgPSBmcmVkV3JhcHBlcjtcblxuICAgICAgICB0aGlzLmhpZGVTaWRlYmFyID0gdGhpcy5oaWRlU2lkZWJhci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdsb2JhbEhpZGVTaWRlYmFyID0gdGhpcy5nbG9iYWxIaWRlU2lkZWJhci5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGVtaXR0ZXIub24oJ2ZyZWQtc2lkZWJhci1leHBhbmQnLCAoY21wLCB0aXRsZSwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgY21wLmxvYWRpbmcoKTtcblxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuaGlkZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNtcC5leHBhbmQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5sYXN0UmVxdWVzdCA9IHByb21pc2VDYW5jZWwoUHJvbWlzZS5yZXNvbHZlKGRhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlcXVlc3QucHJvbWlzZS50aGVuKGNvbnRlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNtcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNtcC5hZnRlckV4cGFuZCgpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIudHlwZSA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNtcC5zZXRDb250ZW50KCdTT01FVEhJTkcgV1JPTkcgSEFQUEVORUQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGVtaXR0ZXIub24oJ2ZyZWQtc2lkZWJhci1jb2xsYXBzZScsIGNtcCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0UmVxdWVzdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlcXVlc3QuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmNvbGxhcHNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICB9KTtcblxuICAgICAgICBlbWl0dGVyLm9uKCdmcmVkLXNpZGViYXItaGlkZScsIHNpbGVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGVTaWRlYmFyKHNpbGVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVtaXR0ZXIub24oJ2ZyZWQtc2lkZWJhci1zaG93Jywgc2lsZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2hvd1NpZGViYXIoc2lsZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBlbWl0dGVyLm9uKCdmcmVkLXNpZGViYXItdG9nZ2xlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMud3JhcHBlci5jbGFzc0xpc3QuY29udGFpbnMoJ2ZyZWQtLWhpZGRlbicpKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdmcmVkLXNpZGViYXItc2hvdycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtc2lkZWJhci1oaWRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCgnZnJlZC0tc2lkZWJhcicsICdmcmVkLS1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkQ2xvc2VCdXR0b24oKSk7XG4gICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkU2lkZWJhckhlYWRlcigpKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuYnVpbGRTaWRlYmFyKCkpO1xuXG4gICAgICAgIGVtaXR0ZXIuZW1pdCgnZnJlZC13cmFwcGVyLWluc2VydCcsIHRoaXMud3JhcHBlcik7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBidWlsZENsb3NlQnV0dG9uKCkge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLXNpZGViYXJfY2xvc2UnKTtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICc8aSBjbGFzcz1cImZyZWQtLWFuZ2xlLWxlZnRcIj48L2k+PGkgY2xhc3M9XCJmcmVkLS1hbmdsZS1sZWZ0XCI+PC9pPic7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtc2lkZWJhci1oaWRlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG5cbiAgICBidWlsZFNpZGViYXJIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBoZWFkZXIuY2xhc3NMaXN0LmFkZCgnZnJlZC0tc2lkZWJhcl90aXRsZScpO1xuXG4gICAgICAgIGNvbnN0IGxvZ28gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgbG9nby5zZXRBdHRyaWJ1dGUoJ2FsdCcsICdNT0RYIEZSRUQnKTtcbiAgICAgICAgbG9nby5jbGFzc0xpc3QuYWRkKCdmcmVkLS1sb2dvJyk7XG4gICAgICAgIGxvZ28uc3JjID0gYCR7dGhpcy5jb25maWcuYXNzZXRzVXJsIHx8ICcnfWltYWdlcy9tb2R4LXJldm8taWNvbi00OC5zdmdgO1xuXG4gICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcbiAgICAgICAgdGl0bGUuaW5uZXJUZXh0ID0gJ0ZyZWQnO1xuXG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChsb2dvKTtcbiAgICAgICAgaGVhZGVyLmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgfVxuXG4gICAgYnVpbGRTaWRlYmFyKCkge1xuICAgICAgICB0aGlzLnNpZGViYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkbCcpO1xuICAgICAgICB0aGlzLnNpZGViYXIuY2xhc3NMaXN0LmFkZCgnZnJlZC0tYWNjb3JkaW9uJyk7XG4gICAgICAgIHRoaXMuc2lkZWJhci5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgdGhpcy5zaWRlYmFyLnNldEF0dHJpYnV0ZSgncm9sZScsICd0YWJsaXN0Jyk7XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2gobmV3IFBhZ2VzQ29tcG9uZW50KHRoaXMuc2lkZWJhciwgdGhpcy5jb25maWcpKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2gobmV3IEVsZW1lbnRzQ29tcG9uZW50KHRoaXMuc2lkZWJhciwgdGhpcy5jb25maWcpKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2gobmV3IFBhZ2VTZXR0aW5nc0NvbXBvbmVudCh0aGlzLnNpZGViYXIsIHRoaXMuY29uZmlnKSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5zaWRlYmFyO1xuICAgIH1cblxuICAgIGhpZGVTaWRlYmFyKHNpbGVudCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzaWxlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLWhpZGRlbicpO1xuXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZ2xvYmFsSGlkZVNpZGViYXIpO1xuICAgIH1cblxuICAgIHNob3dTaWRlYmFyKHNpbGVudCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzaWxlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgaWYgKHRoaXMudmlzaWJsZSA9PT0gZmFsc2UpIHJldHVybjsgXG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnZnJlZC0taGlkZGVuJyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5nbG9iYWxIaWRlU2lkZWJhcik7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgXG4gICAgZ2xvYmFsSGlkZVNpZGViYXIoZSkge1xuICAgICAgICBpZiAoIXRoaXMuZnJlZFdyYXBwZXIuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVTaWRlYmFyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL19idWlsZC9hc3NldHMvanMvU2lkZWJhci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Sidebar2 = __webpack_require__(5);\n\nvar _Sidebar3 = _interopRequireDefault(_Sidebar2);\n\nvar _isomorphicFetch = __webpack_require__(6);\n\nvar _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);\n\nvar _choices = __webpack_require__(8);\n\nvar _choices2 = _interopRequireDefault(_choices);\n\nvar _EE = __webpack_require__(1);\n\nvar _EE2 = _interopRequireDefault(_EE);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Pages = function (_Sidebar) {\n    _inherits(Pages, _Sidebar);\n\n    function Pages() {\n        _classCallCheck(this, Pages);\n\n        return _possibleConstructorReturn(this, (Pages.__proto__ || Object.getPrototypeOf(Pages)).apply(this, arguments));\n    }\n\n    _createClass(Pages, [{\n        key: 'init',\n        value: function init() {\n            this.content = null;\n            this.parents = [{\n                id: 0,\n                value: '0',\n                label: 'No Parent'\n            }];\n        }\n    }, {\n        key: 'click',\n        value: function click() {\n            var _this2 = this;\n\n            if (this.content !== null) {\n                return this.buildPanel();\n            }\n\n            return (0, _isomorphicFetch2.default)(this.config.assetsUrl + 'endpoints/ajax.php?action=get-resources').then(function (response) {\n                return response.json();\n            }).then(function (response) {\n                _this2.content = response.data.resources;\n                return _this2.buildPanel();\n            });\n        }\n    }, {\n        key: 'buildPanel',\n        value: function buildPanel() {\n            var content = document.createElement('div');\n            content.classList.add('fred--pages');\n\n            var pageList = document.createElement('dl');\n            pageList.classList.add('fred--pages_list');\n\n            this.buildTree(this.content, pageList);\n\n            content.appendChild(pageList);\n\n            content.appendChild(this.buildCreatePage());\n\n            return content;\n        }\n    }, {\n        key: 'buildCreatePage',\n        value: function buildCreatePage() {\n            var _this3 = this;\n\n            var wrapper = document.createElement('div');\n\n            var form = document.createElement('form');\n            form.classList.add('fred--pages_create', 'fred--hidden');\n\n            var fieldset = document.createElement('fieldset');\n            var legend = document.createElement('legend');\n            legend.innerHTML = 'Create Page';\n\n            var parentLabel = document.createElement('label');\n            parentLabel.setAttribute('for', 'fred_create_page_parent');\n            parentLabel.classList.add('fred--label-choices');\n            parentLabel.innerHTML = 'Parent';\n\n            var parentInput = document.createElement('select');\n            parentInput.setAttribute('id', 'fred_create_page_parent');\n\n            var templateLabel = document.createElement('label');\n            templateLabel.setAttribute('for', 'fred_create_page_template');\n            templateLabel.classList.add('fred--label-choices');\n            templateLabel.innerHTML = 'Template';\n\n            var templateInput = document.createElement('select');\n            templateInput.setAttribute('id', 'fred_create_page_template');\n\n            var pagetitleLabel = document.createElement('label');\n            pagetitleLabel.setAttribute('for', 'fred_create_page_pagetitle');\n            pagetitleLabel.classList.add('fred--label-choices');\n            pagetitleLabel.innerHTML = 'Page Title';\n\n            var pagetitleInput = document.createElement('input');\n            pagetitleInput.setAttribute('id', 'fred_create_page_pagetitle');\n            pagetitleInput.setAttribute('type', 'text');\n\n            var createButton = document.createElement('button');\n            createButton.classList.add('fred--btn-panel', 'fred--btn-apply');\n            createButton.innerHTML = 'Create';\n            createButton.addEventListener('click', function (e) {\n                e.preventDefault();\n                _EE2.default.emit('fred-loading', 'Creating Page');\n\n                (0, _isomorphicFetch2.default)(_this3.config.assetsUrl + 'endpoints/ajax.php?action=create-resource', {\n                    method: \"post\",\n                    credentials: 'same-origin',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        parent: parentInput.value,\n                        template: templateInput.value,\n                        pagetitle: pagetitleInput.value\n                    })\n                }).then(function (response) {\n                    return response.json();\n                }).then(function (json) {\n                    location.href = json.url;\n                    _EE2.default.emit('fred-loading-hide');\n                });\n            });\n\n            fieldset.appendChild(legend);\n            fieldset.appendChild(parentLabel);\n            fieldset.appendChild(parentInput);\n            fieldset.appendChild(templateLabel);\n            fieldset.appendChild(templateInput);\n            fieldset.appendChild(pagetitleLabel);\n            fieldset.appendChild(pagetitleInput);\n            fieldset.appendChild(createButton);\n\n            form.appendChild(fieldset);\n\n            var button = document.createElement('button');\n            button.classList.add('fred--btn-sidebar');\n            button.innerHTML = 'Create Page';\n            button.addEventListener('click', function (e) {\n                e.preventDefault();\n                form.classList.toggle('fred--hidden');\n            });\n\n            wrapper.appendChild(button);\n            wrapper.appendChild(form);\n\n            new _choices2.default(parentInput, {\n                choices: this.parents,\n                shouldSort: false\n            });\n\n            var templateInputChoices = new _choices2.default(templateInput);\n            templateInputChoices.ajax(function (callback) {\n                (0, _isomorphicFetch2.default)(_this3.config.assetsUrl + 'endpoints/ajax.php?action=get-templates').then(function (response) {\n                    return response.json();\n                }).then(function (data) {\n                    if (data.data.templates[0]) {\n                        data.data.templates[0].selected = true;\n                    }\n                    callback(data.data.templates, 'value', 'name');\n                }).catch(function (error) {\n                    console.log(error);\n                });\n            });\n\n            window.test = templateInputChoices;\n\n            return wrapper;\n        }\n    }, {\n        key: 'buildTree',\n        value: function buildTree(pages, wrapper) {\n            var _this4 = this;\n\n            pages.forEach(function (page) {\n                _this4.parents.push({\n                    id: page.id,\n                    value: '' + page.id,\n                    label: page.pagetitle\n                });\n\n                var dt = document.createElement('dt');\n                dt.setAttribute('role', 'tab');\n                dt.setAttribute('tabindex', '0');\n                dt.innerHTML = page.pagetitle;\n\n                if (page.published !== true) {\n                    dt.classList.add('fred--pages_unpublished');\n                }\n\n                if (page.deleted === true) {\n                    dt.classList.add('fred--pages_deleted');\n                }\n\n                if (page.hidemenu === true) {\n                    dt.classList.add('fred--pages_hidden');\n                }\n\n                wrapper.append(dt);\n\n                if (page.isFred === true) {\n                    var dd = document.createElement('dd');\n                    dd.appendChild(_this4.createMenu(page));\n\n                    wrapper.append(dd);\n                } else {\n                    dt.classList.add('fred--pages_noedit');\n                }\n\n                if (page.children.length > 0) {\n                    var dl = document.createElement('dl');\n                    dl.classList.add('fred--pages_list', 'fred--hidden');\n                    dl.setAttribute('aria-disabled', 'true');\n\n                    _this4.buildTree(page.children, dl);\n\n                    var expander = document.createElement('button');\n                    expander.classList.add('fred--btn-list', 'fred--btn-list_expand');\n                    expander.addEventListener('click', function (e) {\n                        e.preventDefault();\n\n                        if (expander.classList.contains('fred--btn-list_close')) {\n                            expander.classList.remove('fred--btn-list_close');\n                            dl.classList.add('fred--hidden');\n                            dl.setAttribute('aria-disabled', 'true');\n\n                            return;\n                        }\n\n                        expander.classList.add('fred--btn-list_close');\n                        dl.classList.remove('fred--hidden');\n                        dl.setAttribute('aria-disabled', 'false');\n                    });\n\n                    dt.insertBefore(expander, dt.firstChild);\n\n                    wrapper.append(dl);\n                }\n            });\n        }\n    }, {\n        key: 'createMenu',\n        value: function createMenu(page) {\n            var menu = document.createElement('div');\n            menu.classList.add('fred--pages_menu');\n\n            var header = document.createElement('h3');\n            header.innerHTML = page.pagetitle;\n\n            var edit = document.createElement('button');\n            edit.innerHTML = 'Edit';\n            edit.addEventListener('click', function (e) {\n                e.preventDefault();\n                window.location.href = page.url;\n            });\n\n            var duplicate = document.createElement('button');\n            duplicate.innerHTML = 'Duplicate';\n\n            var publish = document.createElement('button');\n            if (page.published === true) {\n                publish.innerHTML = 'Unpublish';\n            } else {\n                publish.innerHTML = 'Publish';\n            }\n\n            var createChildPage = document.createElement('button');\n            createChildPage.innerHTML = 'Create Child Page';\n\n            var deletePage = document.createElement('button');\n            if (page.deleted === true) {\n                deletePage.innerHTML = 'Undelete';\n            } else {\n                deletePage.innerHTML = 'Delete';\n            }\n\n            menu.appendChild(header);\n            menu.appendChild(edit);\n            menu.appendChild(duplicate);\n            menu.appendChild(publish);\n            menu.appendChild(createChildPage);\n            menu.appendChild(deletePage);\n\n            return menu;\n        }\n    }]);\n\n    return Pages;\n}(_Sidebar3.default);\n\nPages.title = 'Pages';\nPages.expandable = true;\nexports.default = Pages;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0NvbXBvbmVudHMvU2lkZWJhci9QYWdlcy5qcz85ZTk0Il0sIm5hbWVzIjpbIlBhZ2VzIiwiY29udGVudCIsInBhcmVudHMiLCJpZCIsInZhbHVlIiwibGFiZWwiLCJidWlsZFBhbmVsIiwiY29uZmlnIiwiYXNzZXRzVXJsIiwidGhlbiIsInJlc3BvbnNlIiwianNvbiIsImRhdGEiLCJyZXNvdXJjZXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJwYWdlTGlzdCIsImJ1aWxkVHJlZSIsImFwcGVuZENoaWxkIiwiYnVpbGRDcmVhdGVQYWdlIiwid3JhcHBlciIsImZvcm0iLCJmaWVsZHNldCIsImxlZ2VuZCIsImlubmVySFRNTCIsInBhcmVudExhYmVsIiwic2V0QXR0cmlidXRlIiwicGFyZW50SW5wdXQiLCJ0ZW1wbGF0ZUxhYmVsIiwidGVtcGxhdGVJbnB1dCIsInBhZ2V0aXRsZUxhYmVsIiwicGFnZXRpdGxlSW5wdXQiLCJjcmVhdGVCdXR0b24iLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInByZXZlbnREZWZhdWx0IiwiZW1pdCIsIm1ldGhvZCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicGFyZW50IiwidGVtcGxhdGUiLCJwYWdldGl0bGUiLCJsb2NhdGlvbiIsImhyZWYiLCJ1cmwiLCJidXR0b24iLCJ0b2dnbGUiLCJjaG9pY2VzIiwic2hvdWxkU29ydCIsInRlbXBsYXRlSW5wdXRDaG9pY2VzIiwiYWpheCIsInRlbXBsYXRlcyIsInNlbGVjdGVkIiwiY2FsbGJhY2siLCJjYXRjaCIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsIndpbmRvdyIsInRlc3QiLCJwYWdlcyIsImZvckVhY2giLCJwdXNoIiwicGFnZSIsImR0IiwicHVibGlzaGVkIiwiZGVsZXRlZCIsImhpZGVtZW51IiwiYXBwZW5kIiwiaXNGcmVkIiwiZGQiLCJjcmVhdGVNZW51IiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJkbCIsImV4cGFuZGVyIiwiY29udGFpbnMiLCJyZW1vdmUiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwibWVudSIsImhlYWRlciIsImVkaXQiLCJkdXBsaWNhdGUiLCJwdWJsaXNoIiwiY3JlYXRlQ2hpbGRQYWdlIiwiZGVsZXRlUGFnZSIsInRpdGxlIiwiZXhwYW5kYWJsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRXFCQSxLOzs7Ozs7Ozs7OzsrQkFJVjtBQUNILGlCQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNBLGlCQUFLQyxPQUFMLEdBQWUsQ0FBQztBQUNaQyxvQkFBSSxDQURRO0FBRVpDLHVCQUFPLEdBRks7QUFHWkMsdUJBQU87QUFISyxhQUFELENBQWY7QUFLSDs7O2dDQUVPO0FBQUE7O0FBQ0osZ0JBQUksS0FBS0osT0FBTCxLQUFpQixJQUFyQixFQUEyQjtBQUN2Qix1QkFBTyxLQUFLSyxVQUFMLEVBQVA7QUFDSDs7QUFFRCxtQkFBTywrQkFBUyxLQUFLQyxNQUFMLENBQVlDLFNBQXJCLDhDQUNGQyxJQURFLENBQ0csb0JBQVk7QUFDZCx1QkFBT0MsU0FBU0MsSUFBVCxFQUFQO0FBQ0gsYUFIRSxFQUlGRixJQUpFLENBSUcsb0JBQVk7QUFDZCx1QkFBS1IsT0FBTCxHQUFlUyxTQUFTRSxJQUFULENBQWNDLFNBQTdCO0FBQ0EsdUJBQU8sT0FBS1AsVUFBTCxFQUFQO0FBQ0gsYUFQRSxDQUFQO0FBUUg7OztxQ0FFWTtBQUNULGdCQUFNTCxVQUFVYSxTQUFTQyxhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0FkLG9CQUFRZSxTQUFSLENBQWtCQyxHQUFsQixDQUFzQixhQUF0Qjs7QUFFQSxnQkFBTUMsV0FBV0osU0FBU0MsYUFBVCxDQUF1QixJQUF2QixDQUFqQjtBQUNBRyxxQkFBU0YsU0FBVCxDQUFtQkMsR0FBbkIsQ0FBdUIsa0JBQXZC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LFdBQXRCOztBQUVBLGdCQUFNZ0UsVUFBVTVFLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBaEI7QUFDQSxnQkFBSXNELEtBQUtFLFNBQUwsS0FBbUIsSUFBdkIsRUFBNkI7QUFDekJtQix3QkFBUWhFLFNBQVIsR0FBb0IsV0FBcEI7QUFDSCxhQUZELE1BRU87QUFDSGdFLHdCQUFRaEUsU0FBUixHQUFvQixTQUFwQjtBQUNIOztBQUVELGdCQUFNaUUsa0JBQWtCN0UsU0FBU0MsYUFBVCxDQUF1QixRQUF2QixDQUF4QjtBQUNBNEUsNEJBQWdCakUsU0FBaEIsR0FBNEIsbUJBQTVCOztBQUVBLGdCQUFNa0UsYUFBYTlFLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBbkI7QUFDQSxnQkFBSXNELEtBQUtHLE9BQUwsS0FBaUIsSUFBckIsRUFBMkI7QUFDdkJvQiwyQkFBV2xFLFNBQVgsR0FBdUIsVUFBdkI7QUFDSCxhQUZELE1BRU87QUFDSGtFLDJCQUFXbEUsU0FBWCxHQUF1QixRQUF2QjtBQUNIOztBQUVENEQsaUJBQUtsRSxXQUFMLENBQWlCbUUsTUFBakI7QUFDQUQsaUJBQUtsRSxXQUFMLENBQWlCb0UsSUFBakI7QUFDQUYsaUJBQUtsRSxXQUFMLENBQWlCcUUsU0FBakI7QUFDQUgsaUJBQUtsRSxXQUFMLENBQWlCc0UsT0FBakI7QUFDQUosaUJBQUtsRSxXQUFMLENBQWlCdUUsZUFBakI7QUFDQUwsaUJBQUtsRSxXQUFMLENBQWlCd0UsVUFBakI7O0FBRUEsbUJBQU9OLElBQVA7QUFDSDs7Ozs7O0FBM1FnQnRGLEssQ0FDVjZGLEssR0FBUSxPO0FBREU3RixLLENBRVY4RixVLEdBQWEsSTtrQkFGSDlGLEsiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTaWRlYmFyIGZyb20gJy4uL1NpZGViYXInO1xuaW1wb3J0IGZldGNoIGZyb20gJ2lzb21vcnBoaWMtZmV0Y2gnO1xuaW1wb3J0IENob2ljZXMgZnJvbSAnY2hvaWNlcy5qcyc7XG5pbXBvcnQgZW1pdHRlciBmcm9tIFwiLi4vLi4vRUVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZXMgZXh0ZW5kcyBTaWRlYmFyIHtcbiAgICBzdGF0aWMgdGl0bGUgPSAnUGFnZXMnO1xuICAgIHN0YXRpYyBleHBhbmRhYmxlID0gdHJ1ZTtcblxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyZW50cyA9IFt7XG4gICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgIHZhbHVlOiAnMCcsXG4gICAgICAgICAgICBsYWJlbDogJ05vIFBhcmVudCdcbiAgICAgICAgfV07XG4gICAgfVxuICAgIFxuICAgIGNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFBhbmVsKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5jb25maWcuYXNzZXRzVXJsfWVuZHBvaW50cy9hamF4LnBocD9hY3Rpb249Z2V0LXJlc291cmNlc2ApXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gcmVzcG9uc2UuZGF0YS5yZXNvdXJjZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRQYW5lbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGJ1aWxkUGFuZWwoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdmcmVkLS1wYWdlcycpO1xuXG4gICAgICAgIGNvbnN0IHBhZ2VMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGwnKTtcbiAgICAgICAgcGFnZUxpc3QuY2xhc3NMaXN0LmFkZCgnZnJlZC0tcGFnZXNfbGlzdCcpO1xuXG4gICAgICAgIHRoaXMuYnVpbGRUcmVlKHRoaXMuY29udGVudCwgcGFnZUxpc3QpO1xuXG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQocGFnZUxpc3QpO1xuXG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5idWlsZENyZWF0ZVBhZ2UoKSk7XG5cblxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgXG4gICAgYnVpbGRDcmVhdGVQYWdlKClcbiAgICB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBjb25zdCBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgICAgICBmb3JtLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLXBhZ2VzX2NyZWF0ZScsICdmcmVkLS1oaWRkZW4nKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGZpZWxkc2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmllbGRzZXQnKTtcbiAgICAgICAgY29uc3QgbGVnZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGVnZW5kJyk7XG4gICAgICAgIGxlZ2VuZC5pbm5lckhUTUwgPSAnQ3JlYXRlIFBhZ2UnO1xuXG4gICAgICAgIGNvbnN0IHBhcmVudExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgcGFyZW50TGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCAnZnJlZF9jcmVhdGVfcGFnZV9wYXJlbnQnKTtcbiAgICAgICAgcGFyZW50TGFiZWwuY2xhc3NMaXN0LmFkZCgnZnJlZC0tbGFiZWwtY2hvaWNlcycpO1xuICAgICAgICBwYXJlbnRMYWJlbC5pbm5lckhUTUwgPSAnUGFyZW50JztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhcmVudElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIHBhcmVudElucHV0LnNldEF0dHJpYnV0ZSgnaWQnLCAnZnJlZF9jcmVhdGVfcGFnZV9wYXJlbnQnKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICB0ZW1wbGF0ZUxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ2ZyZWRfY3JlYXRlX3BhZ2VfdGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGVMYWJlbC5jbGFzc0xpc3QuYWRkKCdmcmVkLS1sYWJlbC1jaG9pY2VzJyk7XG4gICAgICAgIHRlbXBsYXRlTGFiZWwuaW5uZXJIVE1MID0gJ1RlbXBsYXRlJztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgdGVtcGxhdGVJbnB1dC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2ZyZWRfY3JlYXRlX3BhZ2VfdGVtcGxhdGUnKTtcblxuICAgICAgICBjb25zdCBwYWdldGl0bGVMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHBhZ2V0aXRsZUxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ2ZyZWRfY3JlYXRlX3BhZ2VfcGFnZXRpdGxlJyk7XG4gICAgICAgIHBhZ2V0aXRsZUxhYmVsLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLWxhYmVsLWNob2ljZXMnKTtcbiAgICAgICAgcGFnZXRpdGxlTGFiZWwuaW5uZXJIVE1MID0gJ1BhZ2UgVGl0bGUnO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFnZXRpdGxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBwYWdldGl0bGVJbnB1dC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2ZyZWRfY3JlYXRlX3BhZ2VfcGFnZXRpdGxlJyk7XG4gICAgICAgIHBhZ2V0aXRsZUlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG5cbiAgICAgICAgY29uc3QgY3JlYXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGNyZWF0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdmcmVkLS1idG4tcGFuZWwnLCAnZnJlZC0tYnRuLWFwcGx5Jyk7XG4gICAgICAgIGNyZWF0ZUJ1dHRvbi5pbm5lckhUTUwgPSAnQ3JlYXRlJztcbiAgICAgICAgY3JlYXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtbG9hZGluZycsICdDcmVhdGluZyBQYWdlJyk7XG5cbiAgICAgICAgICAgIGZldGNoKGAke3RoaXMuY29uZmlnLmFzc2V0c1VybH1lbmRwb2ludHMvYWpheC5waHA/YWN0aW9uPWNyZWF0ZS1yZXNvdXJjZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHBhcmVudElucHV0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVJbnB1dC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZXRpdGxlOiBwYWdldGl0bGVJbnB1dC52YWx1ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pLnRoZW4oanNvbiA9PiB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24uaHJlZiA9IGpzb24udXJsO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZnJlZC1sb2FkaW5nLWhpZGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGxlZ2VuZCk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKHBhcmVudExhYmVsKTtcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQocGFyZW50SW5wdXQpO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZUxhYmVsKTtcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQodGVtcGxhdGVJbnB1dCk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKHBhZ2V0aXRsZUxhYmVsKTtcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQocGFnZXRpdGxlSW5wdXQpO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZChjcmVhdGVCdXR0b24pO1xuXG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoZmllbGRzZXQpO1xuXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnZnJlZC0tYnRuLXNpZGViYXInKTtcbiAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdDcmVhdGUgUGFnZSc7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZm9ybS5jbGFzc0xpc3QudG9nZ2xlKCdmcmVkLS1oaWRkZW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICAgICAgbmV3IENob2ljZXMocGFyZW50SW5wdXQsIHtcbiAgICAgICAgICAgIGNob2ljZXMgOiB0aGlzLnBhcmVudHMsXG4gICAgICAgICAgICBzaG91bGRTb3J0OiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZUlucHV0Q2hvaWNlcyA9IG5ldyBDaG9pY2VzKHRlbXBsYXRlSW5wdXQpO1xuICAgICAgICB0ZW1wbGF0ZUlucHV0Q2hvaWNlcy5hamF4KGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIGZldGNoKGAke3RoaXMuY29uZmlnLmFzc2V0c1VybH1lbmRwb2ludHMvYWpheC5waHA/YWN0aW9uPWdldC10ZW1wbGF0ZXNgKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmRhdGEudGVtcGxhdGVzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGEudGVtcGxhdGVzWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhLmRhdGEudGVtcGxhdGVzLCAndmFsdWUnLCAnbmFtZScpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHdpbmRvdy50ZXN0ID0gdGVtcGxhdGVJbnB1dENob2ljZXM7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgXG4gICAgYnVpbGRUcmVlKHBhZ2VzLCB3cmFwcGVyKSB7XG4gICAgICAgIHBhZ2VzLmZvckVhY2gocGFnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHBhZ2UuaWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICcnICsgcGFnZS5pZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogcGFnZS5wYWdldGl0bGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBkdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2R0Jyk7XG4gICAgICAgICAgICBkdC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGFiJyk7XG4gICAgICAgICAgICBkdC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgICAgIGR0LmlubmVySFRNTCA9IHBhZ2UucGFnZXRpdGxlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocGFnZS5wdWJsaXNoZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBkdC5jbGFzc0xpc3QuYWRkKCdmcmVkLS1wYWdlc191bnB1Ymxpc2hlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocGFnZS5kZWxldGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZHQuY2xhc3NMaXN0LmFkZCgnZnJlZC0tcGFnZXNfZGVsZXRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocGFnZS5oaWRlbWVudSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGR0LmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLXBhZ2VzX2hpZGRlbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZChkdCk7XG5cbiAgICAgICAgICAgIGlmIChwYWdlLmlzRnJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGQnKTtcbiAgICAgICAgICAgICAgICBkZC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZU1lbnUocGFnZSkpO1xuXG4gICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmQoZGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdC5jbGFzc0xpc3QuYWRkKCdmcmVkLS1wYWdlc19ub2VkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHBhZ2UuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGwnKTtcbiAgICAgICAgICAgICAgICBkbC5jbGFzc0xpc3QuYWRkKCdmcmVkLS1wYWdlc19saXN0JywgJ2ZyZWQtLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIGRsLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFRyZWUocGFnZS5jaGlsZHJlbiwgZGwpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5kZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICBleHBhbmRlci5jbGFzc0xpc3QuYWRkKCdmcmVkLS1idG4tbGlzdCcsICdmcmVkLS1idG4tbGlzdF9leHBhbmQnKTtcbiAgICAgICAgICAgICAgICBleHBhbmRlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwYW5kZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdmcmVkLS1idG4tbGlzdF9jbG9zZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlci5jbGFzc0xpc3QucmVtb3ZlKCdmcmVkLS1idG4tbGlzdF9jbG9zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGwuY2xhc3NMaXN0LmFkZCgnZnJlZC0taGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlci5jbGFzc0xpc3QuYWRkKCdmcmVkLS1idG4tbGlzdF9jbG9zZScpO1xuICAgICAgICAgICAgICAgICAgICBkbC5jbGFzc0xpc3QucmVtb3ZlKCdmcmVkLS1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgZGwuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGR0Lmluc2VydEJlZm9yZShleHBhbmRlciwgZHQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmQoZGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgY3JlYXRlTWVudShwYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWVudS5jbGFzc0xpc3QuYWRkKCdmcmVkLS1wYWdlc19tZW51Jyk7XG5cbiAgICAgICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICAgICAgaGVhZGVyLmlubmVySFRNTCA9IHBhZ2UucGFnZXRpdGxlO1xuXG4gICAgICAgIGNvbnN0IGVkaXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgZWRpdC5pbm5lckhUTUwgPSAnRWRpdCc7XG4gICAgICAgIGVkaXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcGFnZS51cmw7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZHVwbGljYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGR1cGxpY2F0ZS5pbm5lckhUTUwgPSAnRHVwbGljYXRlJztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgaWYgKHBhZ2UucHVibGlzaGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwdWJsaXNoLmlubmVySFRNTCA9ICdVbnB1Ymxpc2gnOyAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB1Ymxpc2guaW5uZXJIVE1MID0gJ1B1Ymxpc2gnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjcmVhdGVDaGlsZFBhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgY3JlYXRlQ2hpbGRQYWdlLmlubmVySFRNTCA9ICdDcmVhdGUgQ2hpbGQgUGFnZSc7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkZWxldGVQYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGlmIChwYWdlLmRlbGV0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZVBhZ2UuaW5uZXJIVE1MID0gJ1VuZGVsZXRlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZVBhZ2UuaW5uZXJIVE1MID0gJ0RlbGV0ZSc7ICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBtZW51LmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgICAgIG1lbnUuYXBwZW5kQ2hpbGQoZWRpdCk7XG4gICAgICAgIG1lbnUuYXBwZW5kQ2hpbGQoZHVwbGljYXRlKTtcbiAgICAgICAgbWVudS5hcHBlbmRDaGlsZChwdWJsaXNoKTtcbiAgICAgICAgbWVudS5hcHBlbmRDaGlsZChjcmVhdGVDaGlsZFBhZ2UpO1xuICAgICAgICBtZW51LmFwcGVuZENoaWxkKGRlbGV0ZVBhZ2UpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG1lbnU7XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL19idWlsZC9hc3NldHMvanMvQ29tcG9uZW50cy9TaWRlYmFyL1BhZ2VzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EE = __webpack_require__(1);\n\nvar _EE2 = _interopRequireDefault(_EE);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Sidebar = function () {\n    function Sidebar(sidebarWrapper) {\n        var _this = this;\n\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Sidebar);\n\n        this.sidebarWrapper = sidebarWrapper;\n        this.config = config || {};\n        this.titleEl = null;\n        this.contentEl = null;\n\n        var render = function render(text) {\n            var expandable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            _this.titleEl = document.createElement('dt');\n            _this.titleEl.setAttribute('role', 'tab');\n            _this.titleEl.setAttribute('tabindex', '0');\n            _this.titleEl.classList.add('fred--sidebar_' + _this.constructor.title.toLowerCase().replace(/ /g, '_'));\n\n            _this.titleEl.innerHTML = text + (expandable === true ? '<i class=\"fred--angle-right fred--accordion_toggle\"></i>' : '');\n\n            if (expandable === false) {\n                _this.titleEl.addEventListener('click', _this.click);\n            } else {\n                _this.titleEl.addEventListener('click', function () {\n                    if (_this.titleEl.classList.contains('active')) {\n                        _EE2.default.emit('fred-sidebar-collapse', _this);\n                    } else {\n                        _EE2.default.emit('fred-sidebar-expand', _this, text, _this.click());\n                    }\n                });\n            }\n\n            _this.contentEl = document.createElement('dd');\n\n            _this.sidebarWrapper.appendChild(_this.titleEl);\n            _this.sidebarWrapper.appendChild(_this.contentEl);\n        };\n\n        this.init();\n\n        render(this.constructor.title, this.constructor.expandable);\n    }\n\n    _createClass(Sidebar, [{\n        key: 'init',\n        value: function init() {}\n    }, {\n        key: 'click',\n        value: function click() {}\n    }, {\n        key: 'expand',\n        value: function expand() {\n            this.titleEl.classList.add('active');\n            this.titleEl.classList.remove('fred--hidden');\n        }\n    }, {\n        key: 'collapse',\n        value: function collapse() {\n            this.titleEl.classList.remove('active');\n            this.titleEl.classList.remove('fred--hidden');\n        }\n    }, {\n        key: 'hide',\n        value: function hide() {\n            this.titleEl.classList.remove('active');\n            this.titleEl.classList.add('fred--hidden');\n        }\n    }, {\n        key: 'setContent',\n        value: function setContent(content) {\n            if ((typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object' && content.outerHTML !== undefined) {\n                this.contentEl.innerHTML = '';\n                this.contentEl.appendChild(content);\n                return;\n            }\n\n            this.contentEl.innerHTML = content;\n        }\n    }, {\n        key: 'loading',\n        value: function loading() {\n            var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n            text = text || 'Retrieving ' + this.constructor.title;\n\n            var wrapper = document.createElement('div');\n            wrapper.classList.add('fred--loading_wrapper');\n            wrapper.innerHTML = '<span class=\"fred--loading\"></span> ' + text;\n\n            this.setContent(wrapper);\n        }\n    }, {\n        key: 'afterExpand',\n        value: function afterExpand() {}\n    }]);\n\n    return Sidebar;\n}();\n\nSidebar.title = 'TITLE NOT SET';\nSidebar.expandable = false;\nexports.default = Sidebar;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0NvbXBvbmVudHMvU2lkZWJhci5qcz80NGZmIl0sIm5hbWVzIjpbIlNpZGViYXIiLCJzaWRlYmFyV3JhcHBlciIsImNvbmZpZyIsInRpdGxlRWwiLCJjb250ZW50RWwiLCJyZW5kZXIiLCJ0ZXh0IiwiZXhwYW5kYWJsZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImNsYXNzTGlzdCIsImFkZCIsImNvbnN0cnVjdG9yIiwidGl0bGUiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJpbm5lckhUTUwiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xpY2siLCJjb250YWlucyIsImVtaXQiLCJhcHBlbmRDaGlsZCIsImluaXQiLCJyZW1vdmUiLCJjb250ZW50Iiwib3V0ZXJIVE1MIiwidW5kZWZpbmVkIiwid3JhcHBlciIsInNldENvbnRlbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7SUFFcUJBLE87QUFJakIscUJBQVlDLGNBQVosRUFBeUM7QUFBQTs7QUFBQSxZQUFiQyxNQUFhLHVFQUFKLEVBQUk7O0FBQUE7O0FBQ3JDLGFBQUtELGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0EsYUFBS0MsTUFBTCxHQUFjQSxVQUFVLEVBQXhCO0FBQ0EsYUFBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxhQUFLQyxTQUFMLEdBQWlCLElBQWpCOztBQUVBLFlBQU1DLFNBQVMsU0FBVEEsTUFBUyxDQUFDQyxJQUFELEVBQThCO0FBQUEsZ0JBQXZCQyxVQUF1Qix1RUFBVixLQUFVOztBQUN6QyxrQkFBS0osT0FBTCxHQUFlSyxTQUFTQyxhQUFULENBQXVCLElBQXZCLENBQWY7QUFDQSxrQkFBS04sT0FBTCxDQUFhTyxZQUFiLENBQTBCLE1BQTFCLEVBQWtDLEtBQWxDO0FBQ0Esa0JBQUtQLE9BQUwsQ0FBYU8sWUFBYixDQUEwQixVQUExQixFQUFzQyxHQUF0QztBQUNBLGtCQUFLUCxP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ImltcG9ydCBlbWl0dGVyIGZyb20gJy4uL0VFJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lkZWJhciB7XG4gICAgc3RhdGljIHRpdGxlID0gJ1RJVExFIE5PVCBTRVQnO1xuICAgIHN0YXRpYyBleHBhbmRhYmxlID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihzaWRlYmFyV3JhcHBlciwgY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5zaWRlYmFyV3JhcHBlciA9IHNpZGViYXJXcmFwcGVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdGhpcy50aXRsZUVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50RWwgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVuZGVyID0gKHRleHQsIGV4cGFuZGFibGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50aXRsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZHQnKTtcbiAgICAgICAgICAgIHRoaXMudGl0bGVFbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGFiJyk7XG4gICAgICAgICAgICB0aGlzLnRpdGxlRWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgICAgICB0aGlzLnRpdGxlRWwuY2xhc3NMaXN0LmFkZChgZnJlZC0tc2lkZWJhcl8ke3RoaXMuY29uc3RydWN0b3IudGl0bGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8gL2csICdfJyl9YCk7XG5cbiAgICAgICAgICAgIHRoaXMudGl0bGVFbC5pbm5lckhUTUwgPSB0ZXh0ICsgKChleHBhbmRhYmxlID09PSB0cnVlKSA/ICc8aSBjbGFzcz1cImZyZWQtLWFuZ2xlLXJpZ2h0IGZyZWQtLWFjY29yZGlvbl90b2dnbGVcIj48L2k+JyA6ICcnKTtcblxuICAgICAgICAgICAgaWYgKGV4cGFuZGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXRsZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbGljayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGl0bGVFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGl0bGVFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtc2lkZWJhci1jb2xsYXBzZScsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdmcmVkLXNpZGViYXItZXhwYW5kJywgdGhpcywgdGV4dCwgdGhpcy5jbGljaygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RkJyk7XG5cbiAgICAgICAgICAgIHRoaXMuc2lkZWJhcldyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy50aXRsZUVsKTtcbiAgICAgICAgICAgIHRoaXMuc2lkZWJhcldyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaW5pdCgpO1xuXG4gICAgICAgIHJlbmRlcih0aGlzLmNvbnN0cnVjdG9yLnRpdGxlLCB0aGlzLmNvbnN0cnVjdG9yLmV4cGFuZGFibGUpO1xuICAgIH1cblxuICAgIGluaXQoKSB7fVxuXG4gICAgY2xpY2soKSB7fVxuICAgIFxuICAgIGV4cGFuZCgpIHtcbiAgICAgICAgdGhpcy50aXRsZUVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLnRpdGxlRWwuY2xhc3NMaXN0LnJlbW92ZSgnZnJlZC0taGlkZGVuJyk7XG4gICAgfVxuICAgIFxuICAgIGNvbGxhcHNlKCkge1xuICAgICAgICB0aGlzLnRpdGxlRWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMudGl0bGVFbC5jbGFzc0xpc3QucmVtb3ZlKCdmcmVkLS1oaWRkZW4nKTtcbiAgICB9XG4gICAgXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy50aXRsZUVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLnRpdGxlRWwuY2xhc3NMaXN0LmFkZCgnZnJlZC0taGlkZGVuJyk7XG4gICAgfVxuICAgIFxuICAgIHNldENvbnRlbnQoY29udGVudCkge1xuICAgICAgICBpZiAoKHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0JykgJiYgKGNvbnRlbnQub3V0ZXJIVE1MICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH1cbiAgICBcbiAgICBsb2FkaW5nKHRleHQgPSAnJykge1xuICAgICAgICB0ZXh0ID0gdGV4dCB8fCBgUmV0cmlldmluZyAke3RoaXMuY29uc3RydWN0b3IudGl0bGV9YDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdmcmVkLS1sb2FkaW5nX3dyYXBwZXInKTtcbiAgICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSBgPHNwYW4gY2xhc3M9XCJmcmVkLS1sb2FkaW5nXCI+PC9zcGFuPiAke3RleHR9YDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0Q29udGVudCh3cmFwcGVyKTtcbiAgICB9XG5cbiAgICBhZnRlckV4cGFuZCgpIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9fYnVpbGQvYXNzZXRzL2pzL0NvbXBvbmVudHMvU2lkZWJhci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	eval("// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(7);\nmodule.exports = self.fetch.bind(self);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2lzb21vcnBoaWMtZmV0Y2gvZmV0Y2gtbnBtLWJyb3dzZXJpZnkuanM/NzcyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHRoZSB3aGF0d2ctZmV0Y2ggcG9seWZpbGwgaW5zdGFsbHMgdGhlIGZldGNoKCkgZnVuY3Rpb25cbi8vIG9uIHRoZSBnbG9iYWwgb2JqZWN0ICh3aW5kb3cgb3Igc2VsZilcbi8vXG4vLyBSZXR1cm4gdGhhdCBhcyB0aGUgZXhwb3J0IGZvciB1c2UgaW4gV2VicGFjaywgQnJvd3NlcmlmeSBldGMuXG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gc2VsZi5mZXRjaC5iaW5kKHNlbGYpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzb21vcnBoaWMtZmV0Y2gvZmV0Y2gtbnBtLWJyb3dzZXJpZnkuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	eval("(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qcz8xYzIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwwQkFBMEIsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXVxuXG4gICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgICAgfSwgdGhpcylcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IGl0ZW1zLnB1c2godmFsdWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDBcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/*! choices.js v3.0.4 | (c) 2018 Josh Johnson | https://github.com/jshjohnson/Choices#readme */ \n!function(e,t){ true?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.Choices=t():e.Choices=t()}(this,function(){return function(e){function t(n){if(i[n])return i[n].exports;var s=i[n]={exports:{},id:n,loaded:!1};return e[n].call(s.exports,s,s.exports,t),s.loaded=!0,s.exports}var i={};return t.m=e,t.c=i,t.p=\"/assets/scripts/dist/\",t(0)}([function(e,t,i){e.exports=i(1)},function(e,t,i){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}function s(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}function r(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}var a=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),c=i(2),l=n(c),h=i(3),u=n(h),d=i(4),f=n(d),p=i(31),v=i(32);i(33);var m=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"[data-choice]\",i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(r(this,e),(0,v.isType)(\"String\",t)){var n=document.querySelectorAll(t);if(n.length>1)for(var s=1;s<n.length;s++){var o=n[s];new e(o,i)}}var a={silent:!1,items:[],choices:[],renderChoiceLimit:-1,maxItemCount:-1,addItems:!0,removeItems:!0,removeItemButton:!1,editItems:!1,duplicateItems:!0,delimiter:\",\",paste:!0,searchEnabled:!0,searchChoices:!0,searchFloor:1,searchResultLimit:4,searchFields:[\"label\",\"value\"],position:\"auto\",resetScrollPosition:!0,regexFilter:null,shouldSort:!0,shouldSortItems:!1,sortFilter:v.sortByAlpha,placeholder:!0,placeholderValue:null,searchPlaceholderValue:null,prependValue:null,appendValue:null,renderSelectedChoices:\"auto\",loadingText:\"Loading...\",noResultsText:\"No results found\",noChoicesText:\"No choices to choose from\",itemSelectText:\"Press to select\",addItemText:function(e){return'Press Enter to add <b>\"'+(0,v.stripHTML)(e)+'\"</b>'},maxItemText:function(e){return\"Only \"+e+\" values can be added.\"},itemComparer:function(e,t){return e===t},uniqueItemText:\"Only unique values can be added.\",classNames:{containerOuter:\"choices\",containerInner:\"choices__inner\",input:\"choices__input\",inputCloned:\"choices__input--cloned\",list:\"choices__list\",listItems:\"choices__list--multiple\",listSingle:\"choices__list--single\",listDropdown:\"choices__list--dropdown\",item:\"choices__item\",itemSelectable:\"choices__item--selectable\",itemDisabled:\"choices__item--disabled\",itemChoice:\"choices__item--choice\",placeholder:\"choices__placeholder\",group:\"choices__group\",groupHeading:\"choices__heading\",button:\"choices__button\",activeState:\"is-active\",focusState:\"is-focused\",openState:\"is-open\",disabledState:\"is-disabled\",highlightedState:\"is-highlighted\",hiddenState:\"is-hidden\",flippedState:\"is-flipped\",loadingState:\"is-loading\",noResults:\"has-no-results\",noChoices:\"has-no-choices\"},fuseOptions:{include:\"score\"},callbackOnInit:null,callbackOnCreateTemplates:null};if(this.idNames={itemChoice:\"item-choice\"},this.config=(0,v.extend)(a,i),\"auto\"!==this.config.renderSelectedChoices&&\"always\"!==this.config.renderSelectedChoices&&(this.config.silent||console.warn(\"renderSelectedChoices: Possible values are 'auto' and 'always'. Falling back to 'auto'.\"),this.config.renderSelectedChoices=\"auto\"),this.store=new f.default(this.render),this.initialised=!1,this.currentState={},this.prevState={},this.currentValue=\"\",this.element=t,this.passedElement=(0,v.isType)(\"String\",t)?document.querySelector(t):t,!this.passedElement)return void(this.config.silent||console.error(\"Passed element not found\"));this.isTextElement=\"text\"===this.passedElement.type,this.isSelectOneElement=\"select-one\"===this.passedElement.type,this.isSelectMultipleElement=\"select-multiple\"===this.passedElement.type,this.isSelectElement=this.isSelectOneElement||this.isSelectMultipleElement,this.isValidElementType=this.isTextElement||this.isSelectElement,this.isIe11=!(!navigator.userAgent.match(/Trident/)||!navigator.userAgent.match(/rv[ :]11/)),this.isScrollingOnIe=!1,this.config.shouldSortItems===!0&&this.isSelectOneElement&&(this.config.silent||console.warn(\"shouldSortElements: Type of passed element is 'select-one', falling back to false.\")),this.highlightPosition=0,this.canSearch=this.config.searchEnabled,this.placeholder=!1,this.isSelectOneElement||(this.placeholder=!!this.config.placeholder&&(this.config.placeholderValue||this.passedElement.getAttribute(\"placeholder\"))),this.presetChoices=this.config.choices,this.presetItems=this.config.items,this.passedElement.value&&(this.presetItems=this.presetItems.concat(this.passedElement.value.split(this.config.delimiter))),this.baseId=(0,v.generateId)(this.passedElement,\"choices-\"),this.render=this.render.bind(this),this._onFocus=this._onFocus.bind(this),this._onBlur=this._onBlur.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._onKeyDown=this._onKeyDown.bind(this),this._onClick=this._onClick.bind(this),this._onTouchMove=this._onTouchMove.bind(this),this._onTouchEnd=this._onTouchEnd.bind(this),this._onMouseDown=this._onMouseDown.bind(this),this._onMouseOver=this._onMouseOver.bind(this),this._onPaste=this._onPaste.bind(this),this._onInput=this._onInput.bind(this),this.wasTap=!0;var c=\"classList\"in document.documentElement;c||this.config.silent||console.error(\"Choices: Your browser doesn't support Choices\");var l=(0,v.isElement)(this.passedElement)&&this.isValidElementType;if(l){if(\"active\"===this.passedElement.getAttribute(\"data-choice\"))return;this.init()}else this.config.silent||console.error(\"Incompatible input passed\")}return a(e,[{key:\"init\",value:function(){if(this.initialised!==!0){var e=this.config.callbackOnInit;this.initialised=!0,this._createTemplates(),this._createInput(),this.store.subscribe(this.render),this.render(),this._addEventListeners(),e&&(0,v.isType)(\"Function\",e)&&e.call(this)}}},{key:\"destroy\",value:function(){if(this.initialised!==!1){this._removeEventListeners(),this.passedElement.classList.remove(this.config.classNames.input,this.config.classNames.hiddenState),this.passedElement.removeAttribute(\"tabindex\");var e=this.passedElement.getAttribute(\"data-choice-orig-style\");Boolean(e)?(this.passedElement.removeAttribute(\"data-choice-orig-style\"),this.passedElement.setAttribute(\"style\",e)):this.passedElement.removeAttribute(\"style\"),this.passedElement.removeAttribute(\"aria-hidden\"),this.passedElement.removeAttribute(\"data-choice\"),this.passedElement.value=this.passedElement.value,this.containerOuter.parentNode.insertBefore(this.passedElement,this.containerOuter),this.containerOuter.parentNode.removeChild(this.containerOuter),this.clearStore(),this.config.templates=null,this.initialised=!1}}},{key:\"renderGroups\",value:function(e,t,i){var n=this,s=i||document.createDocumentFragment(),o=this.config.sortFilter;return this.config.shouldSort&&e.sort(o),e.forEach(function(e){var i=t.filter(function(t){return n.isSelectOneElement?t.groupId===e.id:t.groupId===e.id&&!t.selected});if(i.length>=1){var o=n._getTemplate(\"choiceGroup\",e);s.appendChild(o),n.renderChoices(i,s,!0)}}),s}},{key:\"renderChoices\",value:function(e,t){var i=this,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=t||document.createDocumentFragment(),r=this.config,a=r.renderSelectedChoices,c=r.searchResultLimit,l=r.renderChoiceLimit,h=this.isSearching?v.sortByScore:this.config.sortFilter,u=function(e){var t=\"auto\"!==a||(i.isSelectOneElement||!e.selected);if(t){var n=i._getTemplate(\"choice\",e);s.appendChild(n)}},d=e;\"auto\"!==a||this.isSelectOneElement||(d=e.filter(function(e){return!e.selected}));var f=d.reduce(function(e,t){return t.placeholder?e.placeholderChoices.push(t):e.normalChoices.push(t),e},{placeholderChoices:[],normalChoices:[]}),p=f.placeholderChoices,m=f.normalChoices;(this.config.shouldSort||this.isSearching)&&m.sort(h);var g=d.length,y=[].concat(o(p),o(m));this.isSearching?g=c:l>0&&!n&&(g=l);for(var b=0;b<g;b++)y[b]&&u(y[b]);return s}},{key:\"renderItems\",value:function(e){var t=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=i||document.createDocumentFragment();if(this.config.shouldSortItems&&!this.isSelectOneElement&&e.sort(this.config.sortFilter),this.isTextElement){var s=this.store.getItemsReducedToValues(e),o=s.join(this.config.delimiter);this.passedElement.setAttribute(\"value\",o),this.passedElement.value=o}else{var r=document.createDocumentFragment();e.forEach(function(e){var i=t._getTemplate(\"option\",e);r.appendChild(i)}),this.passedElement.innerHTML=\"\",this.passedElement.appendChild(r)}return e.forEach(function(e){var i=t._getTemplate(\"item\",e);n.appendChild(i)}),n}},{key:\"render\",value:function(){if(!this.store.isLoading()&&(this.currentState=this.store.getState(),this.currentState!==this.prevState)){if((this.currentState.choices!==this.prevState.choices||this.currentState.groups!==this.prevState.groups||this.currentState.items!==this.prevState.items)&&this.isSelectElement){var e=this.store.getGroupsFilteredByActive(),t=this.store.getChoicesFilteredByActive(),i=document.createDocumentFragment();this.choiceList.innerHTML=\"\",this.config.resetScrollPosition&&(this.choiceList.scrollTop=0),e.length>=1&&this.isSearching!==!0?i=this.renderGroups(e,t,i):t.length>=1&&(i=this.renderChoices(t,i));var n=this.store.getItemsFilteredByActive(),s=this._canAddItem(n,this.input.value);if(i.childNodes&&i.childNodes.length>0)s.response?(this.choiceList.appendChild(i),this._highlightChoice()):this.choiceList.appendChild(this._getTemplate(\"notice\",s.notice));else{var o=void 0,r=void 0;this.isSearching?(r=(0,v.isType)(\"Function\",this.config.noResultsText)?this.config.noResultsText():this.config.noResultsText,o=this._getTemplate(\"notice\",r,\"no-results\")):(r=(0,v.isType)(\"Function\",this.config.noChoicesText)?this.config.noChoicesText():this.config.noChoicesText,o=this._getTemplate(\"notice\",r,\"no-choices\")),this.choiceList.appendChild(o)}}if(this.currentState.items!==this.prevState.items){var a=this.store.getItemsFilteredByActive();if(this.itemList.innerHTML=\"\",a&&a){var c=this.renderItems(a);c.childNodes&&this.itemList.appendChild(c)}}this.prevState=this.currentState}}},{key:\"highlightItem\",value:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!e)return this;var i=e.id,n=e.groupId,s=n>=0?this.store.getGroupById(n):null;return this.store.dispatch((0,p.highlightItem)(i,!0)),t&&(s&&s.value?(0,v.triggerEvent)(this.passedElement,\"highlightItem\",{id:i,value:e.value,label:e.label,groupValue:s.value}):(0,v.triggerEvent)(this.passedElement,\"highlightItem\",{id:i,value:e.value,label:e.label})),this}},{key:\"unhighlightItem\",value:function(e){if(!e)return this;var t=e.id,i=e.groupId,n=i>=0?this.store.getGroupById(i):null;return this.store.dispatch((0,p.highlightItem)(t,!1)),n&&n.value?(0,v.triggerEvent)(this.passedElement,\"unhighlightItem\",{id:t,value:e.value,label:e.label,groupValue:n.value}):(0,v.triggerEvent)(this.passedElement,\"unhighlightItem\",{id:t,value:e.value,label:e.label}),this}},{key:\"highlightAll\",value:function(){var e=this,t=this.store.getItems();return t.forEach(function(t){e.highlightItem(t)}),this}},{key:\"unhighlightAll\",value:function(){var e=this,t=this.store.getItems();return t.forEach(function(t){e.unhighlightItem(t)}),this}},{key:\"removeItemsByValue\",value:function(e){var t=this;if(!e||!(0,v.isType)(\"String\",e))return this;var i=this.store.getItemsFilteredByActive();return i.forEach(function(i){i.value===e&&t._removeItem(i)}),this}},{key:\"removeActiveItems\",value:function(e){var t=this,i=this.store.getItemsFilteredByActive();return i.forEach(function(i){i.active&&e!==i.id&&t._removeItem(i)}),this}},{key:\"removeHighlightedItems\",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=this.store.getItemsFilteredByActive();return i.forEach(function(i){i.highlighted&&i.active&&(e._removeItem(i),t&&e._triggerChange(i.value))}),this}},{key:\"showDropdown\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=document.body,i=document.documentElement,n=Math.max(t.scrollHeight,t.offsetHeight,i.clientHeight,i.scrollHeight,i.offsetHeight);this.containerOuter.classList.add(this.config.classNames.openState),this.containerOuter.setAttribute(\"aria-expanded\",\"true\"),this.dropdown.classList.add(this.config.classNames.activeState),this.dropdown.setAttribute(\"aria-expanded\",\"true\");var s=this.dropdown.getBoundingClientRect(),o=Math.ceil(s.top+window.scrollY+this.dropdown.offsetHeight),r=!1;return\"auto\"===this.config.position?r=o>=n:\"top\"===this.config.position&&(r=!0),r&&this.containerOuter.classList.add(this.config.classNames.flippedState),e&&this.canSearch&&document.activeElement!==this.input&&this.input.focus(),(0,v.triggerEvent)(this.passedElement,\"showDropdown\",{}),this}},{key:\"hideDropdown\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=this.containerOuter.classList.contains(this.config.classNames.flippedState);return this.containerOuter.classList.remove(this.config.classNames.openState),this.containerOuter.setAttribute(\"aria-expanded\",\"false\"),this.dropdown.classList.remove(this.config.classNames.activeState),this.dropdown.setAttribute(\"aria-expanded\",\"false\"),t&&this.containerOuter.classList.remove(this.config.classNames.flippedState),e&&this.canSearch&&document.activeElement===this.input&&this.input.blur(),(0,v.triggerEvent)(this.passedElement,\"hideDropdown\",{}),this}},{key:\"toggleDropdown\",value:function(){var e=this.dropdown.classList.contains(this.config.classNames.activeState);return e?this.hideDropdown():this.showDropdown(!0),this}},{key:\"getValue\",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=this.store.getItemsFilteredByActive(),n=[];return i.forEach(function(i){e.isTextElement?n.push(t?i.value:i):i.active&&n.push(t?i.value:i)}),this.isSelectOneElement?n[0]:n}},{key:\"setValue\",value:function(e){var t=this;if(this.initialised===!0){var i=[].concat(o(e)),n=function(e){var i=(0,v.getType)(e);if(\"Object\"===i){if(!e.value)return;t.isTextElement?t._addItem(e.value,e.label,e.id,void 0,e.customProperties,e.placeholder):t._addChoice(e.value,e.label,!0,!1,-1,e.customProperties,e.placeholder)}else\"String\"===i&&(t.isTextElement?t._addItem(e):t._addChoice(e,e,!0,!1,-1,null))};i.length>1?i.forEach(function(e){n(e)}):n(i[0])}return this}},{key:\"setValueByChoice\",value:function(e){var t=this;if(!this.isTextElement){var i=this.store.getChoices(),n=(0,v.isType)(\"Array\",e)?e:[e];n.forEach(function(e){var n=i.find(function(i){return t.config.itemComparer(i.value,e)});n?n.selected?t.config.silent||console.warn(\"Attempting to select choice already selected\"):t._addItem(n.value,n.label,n.id,n.groupId,n.customProperties,n.placeholder,n.keyCode):t.config.silent||console.warn(\"Attempting to select choice that does not exist\")})}return this}},{key:\"setChoices\",value:function(e,t,i){var n=this,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(this.initialised===!0&&this.isSelectElement){if(!(0,v.isType)(\"Array\",e)||!t)return this;s&&this._clearChoices(),this._setLoading(!0),e&&e.length&&(this.containerOuter.classList.remove(this.config.classNames.loadingState),e.forEach(function(e){e.choices?n._addGroup(e,e.id||null,t,i):n._addChoice(e[t],e[i],e.selected,e.disabled,void 0,e.customProperties,e.placeholder)})),this._setLoading(!1)}return this}},{key:\"clearStore\",value:function(){return this.store.dispatch((0,p.clearAll)()),this}},{key:\"clearInput\",value:function(){return this.input.value&&(this.input.value=\"\"),this.isSelectOneElement||this._setInputWidth(),!this.isTextElement&&this.config.searchEnabled&&(this.isSearching=!1,this.store.dispatch((0,p.activateChoices)(!0))),this}},{key:\"enable\",value:function(){if(this.initialised){this.passedElement.disabled=!1;var e=this.containerOuter.classList.contains(this.config.classNames.disabledState);e&&(this._addEventListeners(),this.passedElement.removeAttribute(\"disabled\"),this.input.removeAttribute(\"disabled\"),this.containerOuter.classList.remove(this.config.classNames.disabledState),this.containerOuter.removeAttribute(\"aria-disabled\"),this.isSelectOneElement&&this.containerOuter.setAttribute(\"tabindex\",\"0\"))}return this}},{key:\"disable\",value:function(){if(this.initialised){this.passedElement.disabled=!0;var e=!this.containerOuter.classList.contains(this.config.classNames.disabledState);e&&(this._removeEventListeners(),this.passedElement.setAttribute(\"disabled\",\"\"),this.input.setAttribute(\"disabled\",\"\"),this.containerOuter.classList.add(this.config.classNames.disabledState),this.containerOuter.setAttribute(\"aria-disabled\",\"true\"),this.isSelectOneElement&&this.containerOuter.setAttribute(\"tabindex\",\"-1\"))}return this}},{key:\"ajax\",value:function(e){var t=this;return this.initialised===!0&&this.isSelectElement&&(requestAnimationFrame(function(){t._handleLoadingState(!0)}),e(this._ajaxCallback())),this}},{key:\"_triggerChange\",value:function(e){e&&(0,v.triggerEvent)(this.passedElement,\"change\",{value:e})}},{key:\"_handleButtonAction\",value:function(e,t){if(e&&t&&this.config.removeItems&&this.config.removeItemButton){var i=t.parentNode.getAttribute(\"data-id\"),n=e.find(function(e){return e.id===parseInt(i,10)});this._removeItem(n),this._triggerChange(n.value),this.isSelectOneElement&&this._selectPlaceholderChoice()}}},{key:\"_selectPlaceholderChoice\",value:function(){var e=this.store.getPlaceholderChoice();e&&(this._addItem(e.value,e.label,e.id,e.groupId,null,e.placeholder),this._triggerChange(e.value))}},{key:\"_handleItemAction\",value:function(e,t){var i=this,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(e&&t&&this.config.removeItems&&!this.isSelectOneElement){var s=t.getAttribute(\"data-id\");e.forEach(function(e){e.id!==parseInt(s,10)||e.highlighted?n||e.highlighted&&i.unhighlightItem(e):i.highlightItem(e)}),document.activeElement!==this.input&&this.input.focus()}}},{key:\"_handleChoiceAction\",value:function(e,t){if(e&&t){var i=t.getAttribute(\"data-id\"),n=this.store.getChoiceById(i),s=e[0]&&e[0].keyCode?e[0].keyCode:null,o=this.dropdown.classList.contains(this.config.classNames.activeState);if(n.keyCode=s,(0,v.triggerEvent)(this.passedElement,\"choice\",{choice:n}),n&&!n.selected&&!n.disabled){var r=this._canAddItem(e,n.value);r.response&&(this._addItem(n.value,n.label,n.id,n.groupId,n.customProperties,n.placeholder,n.keyCode),this._triggerChange(n.value))}this.clearInput(),o&&this.isSelectOneElement&&(this.hideDropdown(),this.containerOuter.focus())}}},{key:\"_handleBackspace\",value:function(e){if(this.config.removeItems&&e){var t=e[e.length-1],i=e.some(function(e){return e.highlighted});this.config.editItems&&!i&&t?(this.input.value=t.value,this._setInputWidth(),this._removeItem(t),this._triggerChange(t.value)):(i||this.highlightItem(t,!1),this.removeHighlightedItems(!0))}}},{key:\"_canAddItem\",value:function(e,t){var i=!0,n=(0,v.isType)(\"Function\",this.config.addItemText)?this.config.addItemText(t):this.config.addItemText;(this.isSelectMultipleElement||this.isTextElement)&&this.config.maxItemCount>0&&this.config.maxItemCount<=e.length&&(i=!1,n=(0,v.isType)(\"Function\",this.config.maxItemText)?this.config.maxItemText(this.config.maxItemCount):this.config.maxItemText),this.isTextElement&&this.config.addItems&&i&&this.config.regexFilter&&(i=this._regexFilter(t));var s=!e.some(function(e){return(0,v.isType)(\"String\",t)?e.value===t.trim():e.value===t});return s||this.config.duplicateItems||this.isSelectOneElement||!i||(i=!1,n=(0,v.isType)(\"Function\",this.config.uniqueItemText)?this.config.uniqueItemText(t):this.config.uniqueItemText),{response:i,notice:n}}},{key:\"_handleLoadingState\",value:function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=this.itemList.querySelector(\".\"+this.config.classNames.placeholder);e?(this.containerOuter.classList.add(this.config.classNames.loadingState),this.containerOuter.setAttribute(\"aria-busy\",\"true\"),this.isSelectOneElement?t?t.innerHTML=this.config.loadingText:(t=this._getTemplate(\"placeholder\",this.config.loadingText),this.itemList.appendChild(t)):this.input.placeholder=this.config.loadingText):(this.containerOuter.classList.remove(this.config.classNames.loadingState),this.isSelectOneElement?t.innerHTML=this.placeholder||\"\":this.input.placeholder=this.placeholder||\"\")}},{key:\"_ajaxCallback\",value:function(){var e=this;return function(t,i,n){if(t&&i){var s=(0,v.isType)(\"Object\",t)?[t]:t;s&&(0,v.isType)(\"Array\",s)&&s.length?(e._handleLoadingState(!1),e._setLoading(!0),s.forEach(function(t){if(t.choices){var s=t.id||null;e._addGroup(t,s,i,n)}else e._addChoice(t[i],t[n],t.selected,t.disabled,void 0,t.customProperties,t.placeholder)}),e._setLoading(!1),e.isSelectOneElement&&e._selectPlaceholderChoice()):e._handleLoadingState(!1),e.containerOuter.removeAttribute(\"aria-busy\")}}}},{key:\"_searchChoices\",value:function(e){var t=(0,v.isType)(\"String\",e)?e.trim():e,i=(0,v.isType)(\"String\",this.currentValue)?this.currentValue.trim():this.currentValue;if(t.length>=1&&t!==i+\" \"){var n=this.store.getSearchableChoices(),s=t,o=(0,v.isType)(\"Array\",this.config.searchFields)?this.config.searchFields:[this.config.searchFields],r=Object.assign(this.config.fuseOptions,{keys:o}),a=new l.default(n,r),c=a.search(s);return this.currentValue=t,this.highlightPosition=0,this.isSearching=!0,this.store.dispatch((0,p.filterChoices)(c)),c.length}return 0}},{key:\"_handleSearch\",value:function(e){if(e){var t=this.store.getChoices(),i=t.some(function(e){return!e.active});if(this.input===document.activeElement)if(e&&e.length>=this.config.searchFloor){var n=0;this.config.searchChoices&&(n=this._searchChoices(e)),(0,v.triggerEvent)(this.passedElement,\"search\",{value:e,resultCount:n})}else i&&(this.isSearching=!1,this.store.dispatch((0,p.activateChoices)(!0)))}}},{key:\"_addEventListeners\",value:function(){document.addEventListener(\"keyup\",this._onKeyUp),document.addEventListener(\"keydown\",this._onKeyDown),document.addEventListener(\"click\",this._onClick),document.addEventListener(\"touchmove\",this._onTouchMove),document.addEventListener(\"touchend\",this._onTouchEnd),document.addEventListener(\"mousedown\",this._onMouseDown),document.addEventListener(\"mouseover\",this._onMouseOver),this.isSelectOneElement&&(this.containerOuter.addEventListener(\"focus\",this._onFocus),this.containerOuter.addEventListener(\"blur\",this._onBlur)),this.input.addEventListener(\"input\",this._onInput),this.input.addEventListener(\"paste\",this._onPaste),this.input.addEventListener(\"focus\",this._onFocus),this.input.addEventListener(\"blur\",this._onBlur)}},{key:\"_removeEventListeners\",value:function(){document.removeEventListener(\"keyup\",this._onKeyUp),document.removeEventListener(\"keydown\",this._onKeyDown),document.removeEventListener(\"click\",this._onClick),document.removeEventListener(\"touchmove\",this._onTouchMove),document.removeEventListener(\"touchend\",this._onTouchEnd),document.removeEventListener(\"mousedown\",this._onMouseDown),document.removeEventListener(\"mouseover\",this._onMouseOver),this.isSelectOneElement&&(this.containerOuter.removeEventListener(\"focus\",this._onFocus),this.containerOuter.removeEventListener(\"blur\",this._onBlur)),this.input.removeEventListener(\"input\",this._onInput),this.input.removeEventListener(\"paste\",this._onPaste),this.input.removeEventListener(\"focus\",this._onFocus),this.input.removeEventListener(\"blur\",this._onBlur)}},{key:\"_setInputWidth\",value:function(){this.placeholder?this.input.value&&this.input.value.length>=this.placeholder.length/1.25&&(this.input.style.width=(0,v.getWidthOfInput)(this.input)):this.input.style.width=(0,v.getWidthOfInput)(this.input)}},{key:\"_onKeyDown\",value:function(e){var t,i=this;if(e.target===this.input||this.containerOuter.contains(e.target)){var n=e.target,o=this.store.getItemsFilteredByActive(),r=this.input===document.activeElement,a=this.dropdown.classList.contains(this.config.classNames.activeState),c=this.itemList&&this.itemList.children,l=String.fromCharCode(e.keyCode),h=46,u=8,d=13,f=65,p=27,m=38,g=40,y=33,b=34,E=e.ctrlKey||e.metaKey;this.isTextElement||!/[a-zA-Z0-9-_ ]/.test(l)||a||this.showDropdown(!0),this.canSearch=this.config.searchEnabled;var _=function(){E&&c&&(i.canSearch=!1,i.config.removeItems&&!i.input.value&&i.input===document.activeElement&&i.highlightAll())},S=function(){if(i.isTextElement&&n.value){var t=i.input.value,s=i._canAddItem(o,t);s.response&&(a&&i.hideDropdown(),i._addItem(t),i._triggerChange(t),i.clearInput())}if(n.hasAttribute(\"data-button\")&&(i._handleButtonAction(o,n),e.preventDefault()),a){e.preventDefault();var r=i.dropdown.querySelector(\".\"+i.config.classNames.highlightedState);r&&(o[0]&&(o[0].keyCode=d),i._handleChoiceAction(o,r))}else i.isSelectOneElement&&(a||(i.showDropdown(!0),e.preventDefault()))},I=function(){a&&(i.toggleDropdown(),i.containerOuter.focus())},w=function(){if(a||i.isSelectOneElement){a||i.showDropdown(!0),i.canSearch=!1;var t=e.keyCode===g||e.keyCode===b?1:-1,n=e.metaKey||e.keyCode===b||e.keyCode===y,s=void 0;if(n)s=t>0?Array.from(i.dropdown.querySelectorAll(\"[data-choice-selectable]\")).pop():i.dropdown.querySelector(\"[data-choice-selectable]\");else{var o=i.dropdown.querySelector(\".\"+i.config.classNames.highlightedState);s=o?(0,v.getAdjacentEl)(o,\"[data-choice-selectable]\",t):i.dropdown.querySelector(\"[data-choice-selectable]\")}s&&((0,v.isScrolledIntoView)(s,i.choiceList,t)||i._scrollToChoice(s,t),i._highlightChoice(s)),e.preventDefault()}},T=function(){!r||e.target.value||i.isSelectOneElement||(i._handleBackspace(o),e.preventDefault())},C=(t={},s(t,f,_),s(t,d,S),s(t,p,I),s(t,m,w),s(t,y,w),s(t,g,w),s(t,b,w),s(t,u,T),s(t,h,T),t);C[e.keyCode]&&C[e.keyCode]()}}},{key:\"_onKeyUp\",value:function(e){if(e.target===this.input){var t=this.input.value,i=this.store.getItemsFilteredByActive(),n=this._canAddItem(i,t);if(this.isTextElement){var s=this.dropdown.classList.contains(this.config.classNames.activeState);if(t){if(n.notice){var o=this._getTemplate(\"notice\",n.notice);this.dropdown.innerHTML=o.outerHTML}n.response===!0?s||this.showDropdown():!n.notice&&s&&this.hideDropdown()}else s&&this.hideDropdown()}else{var r=46,a=8;e.keyCode!==r&&e.keyCode!==a||e.target.value?this.canSearch&&n.response&&this._handleSearch(this.input.value):!this.isTextElement&&this.isSearching&&(this.isSearching=!1,this.store.dispatch((0,p.activateChoices)(!0)))}this.canSearch=this.config.searchEnabled}}},{key:\"_onInput\",value:function(){this.isSelectOneElement||this._setInputWidth()}},{key:\"_onTouchMove\",value:function(){this.wasTap===!0&&(this.wasTap=!1)}},{key:\"_onTouchEnd\",value:function(e){var t=e.target||e.touches[0].target,i=this.dropdown.classList.contains(this.config.classNames.activeState);this.wasTap===!0&&this.containerOuter.contains(t)&&(t!==this.containerOuter&&t!==this.containerInner||this.isSelectOneElement||(this.isTextElement?document.activeElement!==this.input&&this.input.focus():i||this.showDropdown(!0)),e.stopPropagation()),this.wasTap=!0}},{key:\"_onMouseDown\",value:function(e){var t=e.target;if(t===this.choiceList&&this.isIe11&&(this.isScrollingOnIe=!0),this.containerOuter.contains(t)&&t!==this.input){var i=void 0,n=this.store.getItemsFilteredByActive(),s=e.shiftKey;(i=(0,v.findAncestorByAttrName)(t,\"data-button\"))?this._handleButtonAction(n,i):(i=(0,v.findAncestorByAttrName)(t,\"data-item\"))?this._handleItemAction(n,i,s):(i=(0,v.findAncestorByAttrName)(t,\"data-choice\"))&&this._handleChoiceAction(n,i),e.preventDefault()}}},{key:\"_onClick\",value:function(e){var t=e.target,i=this.dropdown.classList.contains(this.config.classNames.activeState),n=this.store.getItemsFilteredByActive();if(this.containerOuter.contains(t))t.hasAttribute(\"data-button\")&&this._handleButtonAction(n,t),i?this.isSelectOneElement&&t!==this.input&&!this.dropdown.contains(t)&&this.hideDropdown(!0):this.isTextElement?document.activeElement!==this.input&&this.input.focus():this.canSearch?this.showDropdown(!0):(this.showDropdown(),this.containerOuter.focus());else{var s=n.some(function(e){return e.highlighted});s&&this.unhighlightAll(),this.containerOuter.classList.remove(this.config.classNames.focusState),i&&this.hideDropdown()}}},{key:\"_onMouseOver\",value:function(e){(e.target===this.dropdown||this.dropdown.contains(e.target))&&e.target.hasAttribute(\"data-choice\")&&this._highlightChoice(e.target)}},{key:\"_onPaste\",value:function(e){e.target!==this.input||this.config.paste||e.preventDefault()}},{key:\"_onFocus\",value:function(e){var t=this,i=e.target;if(this.containerOuter.contains(i)){var n=this.dropdown.classList.contains(this.config.classNames.activeState),s={text:function(){i===t.input&&t.containerOuter.classList.add(t.config.classNames.focusState)},\"select-one\":function(){t.containerOuter.classList.add(t.config.classNames.focusState),i===t.input&&(n||t.showDropdown())},\"select-multiple\":function(){i===t.input&&(t.containerOuter.classList.add(t.config.classNames.focusState),n||t.showDropdown(!0))}};s[this.passedElement.type]()}}},{key:\"_onBlur\",value:function(e){var t=this,i=e.target;if(this.containerOuter.contains(i)&&!this.isScrollingOnIe){var n=this.store.getItemsFilteredByActive(),s=this.dropdown.classList.contains(this.config.classNames.activeState),o=n.some(function(e){return e.highlighted}),r={text:function(){i===t.input&&(t.containerOuter.classList.remove(t.config.classNames.focusState),o&&t.unhighlightAll(),s&&t.hideDropdown())},\"select-one\":function(){t.containerOuter.classList.remove(t.config.classNames.focusState),i===t.containerOuter&&s&&!t.canSearch&&t.hideDropdown(),i===t.input&&s&&t.hideDropdown()},\"select-multiple\":function(){i===t.input&&(t.containerOuter.classList.remove(t.config.classNames.focusState),s&&t.hideDropdown(),o&&t.unhighlightAll())}};r[this.passedElement.type]()}else this.isScrollingOnIe=!1,this.input.focus()}},{key:\"_regexFilter\",value:function(e){if(!e)return!1;var t=this.config.regexFilter,i=new RegExp(t.source,\"i\");return i.test(e)}},{key:\"_scrollToChoice\",value:function(e,t){var i=this;if(e){var n=this.choiceList.offsetHeight,s=e.offsetHeight,o=e.offsetTop+s,r=this.choiceList.scrollTop+n,a=t>0?this.choiceList.scrollTop+o-r:e.offsetTop,c=function e(){var n=4,s=i.choiceList.scrollTop,o=!1,r=void 0,c=void 0;t>0?(r=(a-s)/n,c=r>1?r:1,i.choiceList.scrollTop=s+c,s<a&&(o=!0)):(r=(s-a)/n,c=r>1?r:1,i.choiceList.scrollTop=s-c,s>a&&(o=!0)),o&&requestAnimationFrame(function(i){e(i,a,t)})};requestAnimationFrame(function(e){c(e,a,t)})}}},{key:\"_highlightChoice\",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=Array.from(this.dropdown.querySelectorAll(\"[data-choice-selectable]\")),n=t;if(i&&i.length){var s=Array.from(this.dropdown.querySelectorAll(\".\"+this.config.classNames.highlightedState));s.forEach(function(t){t.classList.remove(e.config.classNames.highlightedState),t.setAttribute(\"aria-selected\",\"false\")}),n?this.highlightPosition=i.indexOf(n):(n=i.length>this.highlightPosition?i[this.highlightPosition]:i[i.length-1],n||(n=i[0])),n.classList.add(this.config.classNames.highlightedState),n.setAttribute(\"aria-selected\",\"true\"),this.containerOuter.setAttribute(\"aria-activedescendant\",n.id)}}},{key:\"_addItem\",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],r=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,a=(0,v.isType)(\"String\",e)?e.trim():e,c=r,l=this.store.getItems(),h=t||a,u=parseInt(i,10)||-1,d=n>=0?this.store.getGroupById(n):null,f=l?l.length+1:1;return this.config.prependValue&&(a=this.config.prependValue+a.toString()),this.config.appendValue&&(a+=this.config.appendValue.toString()),\nthis.store.dispatch((0,p.addItem)(a,h,f,u,n,s,o,c)),this.isSelectOneElement&&this.removeActiveItems(f),d&&d.value?(0,v.triggerEvent)(this.passedElement,\"addItem\",{id:f,value:a,label:h,groupValue:d.value,keyCode:c}):(0,v.triggerEvent)(this.passedElement,\"addItem\",{id:f,value:a,label:h,keyCode:c}),this}},{key:\"_removeItem\",value:function(e){if(!e||!(0,v.isType)(\"Object\",e))return this;var t=e.id,i=e.value,n=e.label,s=e.choiceId,o=e.groupId,r=o>=0?this.store.getGroupById(o):null;return this.store.dispatch((0,p.removeItem)(t,s)),r&&r.value?(0,v.triggerEvent)(this.passedElement,\"removeItem\",{id:t,value:i,label:n,groupValue:r.value}):(0,v.triggerEvent)(this.passedElement,\"removeItem\",{id:t,value:i,label:n}),this}},{key:\"_addChoice\",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:-1,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,r=arguments.length>6&&void 0!==arguments[6]&&arguments[6],a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;if(\"undefined\"!=typeof e&&null!==e){var c=this.store.getChoices(),l=t||e,h=c?c.length+1:1,u=this.baseId+\"-\"+this.idNames.itemChoice+\"-\"+h;this.store.dispatch((0,p.addChoice)(e,l,h,s,n,u,o,r,a)),i&&this._addItem(e,l,h,void 0,o,r,a)}}},{key:\"_clearChoices\",value:function(){this.store.dispatch((0,p.clearChoices)())}},{key:\"_addGroup\",value:function(e,t){var i=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:\"value\",s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:\"label\",o=(0,v.isType)(\"Object\",e)?e.choices:Array.from(e.getElementsByTagName(\"OPTION\")),r=t?t:Math.floor((new Date).valueOf()*Math.random()),a=!!e.disabled&&e.disabled;o?(this.store.dispatch((0,p.addGroup)(e.label,r,!0,a)),o.forEach(function(e){var t=e.disabled||e.parentNode&&e.parentNode.disabled;i._addChoice(e[n],(0,v.isType)(\"Object\",e)?e[s]:e.innerHTML,e.selected,t,r,e.customProperties,e.placeholder)})):this.store.dispatch((0,p.addGroup)(e.label,e.id,!1,e.disabled))}},{key:\"_getTemplate\",value:function(e){if(!e)return null;for(var t=this.config.templates,i=arguments.length,n=Array(i>1?i-1:0),s=1;s<i;s++)n[s-1]=arguments[s];return t[e].apply(t,n)}},{key:\"_createTemplates\",value:function(){var e=this,t=this.config.classNames,i={containerOuter:function(i){return(0,v.strToEl)('\\n          <div\\n            class=\"'+t.containerOuter+'\"\\n            '+(e.isSelectElement?e.config.searchEnabled?'role=\"combobox\" aria-autocomplete=\"list\"':'role=\"listbox\"':\"\")+'\\n            data-type=\"'+e.passedElement.type+'\"\\n            '+(e.isSelectOneElement?'tabindex=\"0\"':\"\")+'\\n            aria-haspopup=\"true\"\\n            aria-expanded=\"false\"\\n            dir=\"'+i+'\"\\n            >\\n          </div>\\n        ')},containerInner:function(){return(0,v.strToEl)('\\n          <div class=\"'+t.containerInner+'\"></div>\\n        ')},itemList:function(){var i,n=(0,u.default)(t.list,(i={},s(i,t.listSingle,e.isSelectOneElement),s(i,t.listItems,!e.isSelectOneElement),i));return(0,v.strToEl)('\\n          <div class=\"'+n+'\"></div>\\n        ')},placeholder:function(e){return(0,v.strToEl)('\\n          <div class=\"'+t.placeholder+'\">\\n            '+e+\"\\n          </div>\\n        \")},item:function(i){var n,o=(0,u.default)(t.item,(n={},s(n,t.highlightedState,i.highlighted),s(n,t.itemSelectable,!i.highlighted),s(n,t.placeholder,i.placeholder),n));if(e.config.removeItemButton){var r;return o=(0,u.default)(t.item,(r={},s(r,t.highlightedState,i.highlighted),s(r,t.itemSelectable,!i.disabled),s(r,t.placeholder,i.placeholder),r)),(0,v.strToEl)('\\n            <div\\n              class=\"'+o+'\"\\n              data-item\\n              data-id=\"'+i.id+'\"\\n              data-value=\"'+i.value+'\"\\n              data-deletable\\n              '+(i.active?'aria-selected=\"true\"':\"\")+\"\\n              \"+(i.disabled?'aria-disabled=\"true\"':\"\")+\"\\n              >\\n              \"+i.label+'<!--\\n           --><button\\n                type=\"button\"\\n                class=\"'+t.button+'\"\\n                data-button\\n                aria-label=\"Remove item: \\''+i.value+\"'\\\"\\n                >\\n                Remove item\\n              </button>\\n            </div>\\n          \")}return(0,v.strToEl)('\\n          <div\\n            class=\"'+o+'\"\\n            data-item\\n            data-id=\"'+i.id+'\"\\n            data-value=\"'+i.value+'\"\\n            '+(i.active?'aria-selected=\"true\"':\"\")+\"\\n            \"+(i.disabled?'aria-disabled=\"true\"':\"\")+\"\\n            >\\n            \"+i.label+\"\\n          </div>\\n        \")},choiceList:function(){return(0,v.strToEl)('\\n          <div\\n            class=\"'+t.list+'\"\\n            dir=\"ltr\"\\n            role=\"listbox\"\\n            '+(e.isSelectOneElement?\"\":'aria-multiselectable=\"true\"')+\"\\n            >\\n          </div>\\n        \")},choiceGroup:function(e){var i=(0,u.default)(t.group,s({},t.itemDisabled,e.disabled));return(0,v.strToEl)('\\n          <div\\n            class=\"'+i+'\"\\n            data-group\\n            data-id=\"'+e.id+'\"\\n            data-value=\"'+e.value+'\"\\n            role=\"group\"\\n            '+(e.disabled?'aria-disabled=\"true\"':\"\")+'\\n            >\\n            <div class=\"'+t.groupHeading+'\">'+e.value+\"</div>\\n          </div>\\n        \")},choice:function(i){var n,o=(0,u.default)(t.item,t.itemChoice,(n={},s(n,t.itemDisabled,i.disabled),s(n,t.itemSelectable,!i.disabled),s(n,t.placeholder,i.placeholder),n));return(0,v.strToEl)('\\n          <div\\n            class=\"'+o+'\"\\n            data-select-text=\"'+e.config.itemSelectText+'\"\\n            data-choice\\n            data-id=\"'+i.id+'\"\\n            data-value=\"'+i.value+'\"\\n            '+(i.disabled?'data-choice-disabled aria-disabled=\"true\"':\"data-choice-selectable\")+'\\n            id=\"'+i.elementId+'\"\\n            '+(i.groupId>0?'role=\"treeitem\"':'role=\"option\"')+\"\\n            >\\n            \"+i.label+\"\\n          </div>\\n        \")},input:function(){var e=(0,u.default)(t.input,t.inputCloned);return(0,v.strToEl)('\\n          <input\\n            type=\"text\"\\n            class=\"'+e+'\"\\n            autocomplete=\"off\"\\n            autocapitalize=\"off\"\\n            spellcheck=\"false\"\\n            role=\"textbox\"\\n            aria-autocomplete=\"list\"\\n            >\\n        ')},dropdown:function(){var e=(0,u.default)(t.list,t.listDropdown);return(0,v.strToEl)('\\n          <div\\n            class=\"'+e+'\"\\n            aria-expanded=\"false\"\\n            >\\n          </div>\\n        ')},notice:function(e){var i,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\",o=(0,u.default)(t.item,t.itemChoice,(i={},s(i,t.noResults,\"no-results\"===n),s(i,t.noChoices,\"no-choices\"===n),i));return(0,v.strToEl)('\\n          <div class=\"'+o+'\">\\n            '+e+\"\\n          </div>\\n        \")},option:function(e){return(0,v.strToEl)('\\n          <option value=\"'+e.value+'\" selected>'+e.label+\"</option>\\n        \")}},n=this.config.callbackOnCreateTemplates,o={};n&&(0,v.isType)(\"Function\",n)&&(o=n.call(this,v.strToEl)),this.config.templates=(0,v.extend)(i,o)}},{key:\"_setLoading\",value:function(e){this.store.dispatch((0,p.setIsLoading)(e))}},{key:\"_createInput\",value:function(){var e=this,t=this.passedElement.getAttribute(\"dir\")||\"ltr\",i=this._getTemplate(\"containerOuter\",t),n=this._getTemplate(\"containerInner\"),s=this._getTemplate(\"itemList\"),o=this._getTemplate(\"choiceList\"),r=this._getTemplate(\"input\"),a=this._getTemplate(\"dropdown\");this.containerOuter=i,this.containerInner=n,this.input=r,this.choiceList=o,this.itemList=s,this.dropdown=a,this.passedElement.classList.add(this.config.classNames.input,this.config.classNames.hiddenState),this.passedElement.tabIndex=\"-1\";var c=this.passedElement.getAttribute(\"style\");if(Boolean(c)&&this.passedElement.setAttribute(\"data-choice-orig-style\",c),this.passedElement.setAttribute(\"style\",\"display:none;\"),this.passedElement.setAttribute(\"aria-hidden\",\"true\"),this.passedElement.setAttribute(\"data-choice\",\"active\"),(0,v.wrap)(this.passedElement,n),(0,v.wrap)(n,i),this.isSelectOneElement?r.placeholder=this.config.searchPlaceholderValue||\"\":this.placeholder&&(r.placeholder=this.placeholder,r.style.width=(0,v.getWidthOfInput)(r)),this.config.addItems||this.disable(),i.appendChild(n),i.appendChild(a),n.appendChild(s),this.isTextElement||a.appendChild(o),this.isSelectMultipleElement||this.isTextElement?n.appendChild(r):this.canSearch&&a.insertBefore(r,a.firstChild),this.isSelectElement){var l=Array.from(this.passedElement.getElementsByTagName(\"OPTGROUP\"));if(this.highlightPosition=0,this.isSearching=!1,this._setLoading(!0),l&&l.length)l.forEach(function(t){e._addGroup(t,t.id||null)});else{var h=Array.from(this.passedElement.options),u=this.config.sortFilter,d=this.presetChoices;h.forEach(function(e){d.push({value:e.value,label:e.innerHTML,selected:e.selected,disabled:e.disabled||e.parentNode.disabled,placeholder:e.hasAttribute(\"placeholder\")})}),this.config.shouldSort&&d.sort(u);var f=d.some(function(e){return e.selected});d.forEach(function(t,i){if(e.isSelectOneElement){var n=f||!f&&i>0;e._addChoice(t.value,t.label,!n||t.selected,!!n&&t.disabled,void 0,t.customProperties,t.placeholder)}else e._addChoice(t.value,t.label,t.selected,t.disabled,void 0,t.customProperties,t.placeholder)})}this._setLoading(!1)}else this.isTextElement&&this.presetItems.forEach(function(t){var i=(0,v.getType)(t);if(\"Object\"===i){if(!t.value)return;e._addItem(t.value,t.label,t.id,void 0,t.customProperties,t.placeholder)}else\"String\"===i&&e._addItem(t)})}}]),e}();e.exports=m},function(e,t,i){!function(t){\"use strict\";function i(){console.log.apply(console,arguments)}function n(e,t){var i;this.list=e,this.options=t=t||{};for(i in a)a.hasOwnProperty(i)&&(\"boolean\"==typeof a[i]?this.options[i]=i in t?t[i]:a[i]:this.options[i]=t[i]||a[i])}function s(e,t,i){var n,r,a,c,l,h;if(t){if(a=t.indexOf(\".\"),a!==-1?(n=t.slice(0,a),r=t.slice(a+1)):n=t,c=e[n],null!==c&&void 0!==c)if(r||\"string\"!=typeof c&&\"number\"!=typeof c)if(o(c))for(l=0,h=c.length;l<h;l++)s(c[l],r,i);else r&&s(c,r,i);else i.push(c)}else i.push(e);return i}function o(e){return\"[object Array]\"===Object.prototype.toString.call(e)}function r(e,t){t=t||{},this.options=t,this.options.location=t.location||r.defaultOptions.location,this.options.distance=\"distance\"in t?t.distance:r.defaultOptions.distance,this.options.threshold=\"threshold\"in t?t.threshold:r.defaultOptions.threshold,this.options.maxPatternLength=t.maxPatternLength||r.defaultOptions.maxPatternLength,this.pattern=t.caseSensitive?e:e.toLowerCase(),this.patternLen=e.length,this.patternLen<=this.options.maxPatternLength&&(this.matchmask=1<<this.patternLen-1,this.patternAlphabet=this._calculatePatternAlphabet())}var a={id:null,caseSensitive:!1,include:[],shouldSort:!0,searchFn:r,sortFn:function(e,t){return e.score-t.score},getFn:s,keys:[],verbose:!1,tokenize:!1,matchAllTokens:!1,tokenSeparator:/ +/g,minMatchCharLength:1,findAllMatches:!1};n.VERSION=\"2.7.3\",n.prototype.set=function(e){return this.list=e,e},n.prototype.search=function(e){this.options.verbose&&i(\"\\nSearch term:\",e,\"\\n\"),this.pattern=e,this.results=[],this.resultMap={},this._keyMap=null,this._prepareSearchers(),this._startSearch(),this._computeScore(),this._sort();var t=this._format();return t},n.prototype._prepareSearchers=function(){var e=this.options,t=this.pattern,i=e.searchFn,n=t.split(e.tokenSeparator),s=0,o=n.length;if(this.options.tokenize)for(this.tokenSearchers=[];s<o;s++)this.tokenSearchers.push(new i(n[s],e));this.fullSeacher=new i(t,e)},n.prototype._startSearch=function(){var e,t,i,n,s=this.options,o=s.getFn,r=this.list,a=r.length,c=this.options.keys,l=c.length,h=null;if(\"string\"==typeof r[0])for(i=0;i<a;i++)this._analyze(\"\",r[i],i,i);else for(this._keyMap={},i=0;i<a;i++)for(h=r[i],n=0;n<l;n++){if(e=c[n],\"string\"!=typeof e){if(t=1-e.weight||1,this._keyMap[e.name]={weight:t},e.weight<=0||e.weight>1)throw new Error(\"Key weight has to be > 0 and <= 1\");e=e.name}else this._keyMap[e]={weight:1};this._analyze(e,o(h,e,[]),h,i)}},n.prototype._analyze=function(e,t,n,s){var r,a,c,l,h,u,d,f,p,v,m,g,y,b,E,_=this.options,S=!1;if(void 0!==t&&null!==t){a=[];var I=0;if(\"string\"==typeof t){if(r=t.split(_.tokenSeparator),_.verbose&&i(\"---------\\nKey:\",e),this.options.tokenize){for(b=0;b<this.tokenSearchers.length;b++){for(f=this.tokenSearchers[b],_.verbose&&i(\"Pattern:\",f.pattern),p=[],g=!1,E=0;E<r.length;E++){v=r[E],m=f.search(v);var w={};m.isMatch?(w[v]=m.score,S=!0,g=!0,a.push(m.score)):(w[v]=1,this.options.matchAllTokens||a.push(1)),p.push(w)}g&&I++,_.verbose&&i(\"Token scores:\",p)}for(l=a[0],u=a.length,b=1;b<u;b++)l+=a[b];l/=u,_.verbose&&i(\"Token score average:\",l)}d=this.fullSeacher.search(t),_.verbose&&i(\"Full text score:\",d.score),h=d.score,void 0!==l&&(h=(h+l)/2),_.verbose&&i(\"Score average:\",h),y=!this.options.tokenize||!this.options.matchAllTokens||I>=this.tokenSearchers.length,_.verbose&&i(\"Check Matches\",y),(S||d.isMatch)&&y&&(c=this.resultMap[s],c?c.output.push({key:e,score:h,matchedIndices:d.matchedIndices}):(this.resultMap[s]={item:n,output:[{key:e,score:h,matchedIndices:d.matchedIndices}]},this.results.push(this.resultMap[s])))}else if(o(t))for(b=0;b<t.length;b++)this._analyze(e,t[b],n,s)}},n.prototype._computeScore=function(){var e,t,n,s,o,r,a,c,l,h=this._keyMap,u=this.results;for(this.options.verbose&&i(\"\\n\\nComputing score:\\n\"),e=0;e<u.length;e++){for(n=0,s=u[e].output,o=s.length,c=1,t=0;t<o;t++)r=s[t].score,a=h?h[s[t].key].weight:1,l=r*a,1!==a?c=Math.min(c,l):(n+=l,s[t].nScore=l);1===c?u[e].score=n/o:u[e].score=c,this.options.verbose&&i(u[e])}},n.prototype._sort=function(){var e=this.options;e.shouldSort&&(e.verbose&&i(\"\\n\\nSorting....\"),this.results.sort(e.sortFn))},n.prototype._format=function(){var e,t,n,s,o=this.options,r=o.getFn,a=[],c=this.results,l=o.include;for(o.verbose&&i(\"\\n\\nOutput:\\n\\n\",c),n=o.id?function(e){c[e].item=r(c[e].item,o.id,[])[0]}:function(){},s=function(e){var t,i,n,s,o,r=c[e];if(l.length>0){if(t={item:r.item},l.indexOf(\"matches\")!==-1)for(n=r.output,t.matches=[],i=0;i<n.length;i++)s=n[i],o={indices:s.matchedIndices},s.key&&(o.key=s.key),t.matches.push(o);l.indexOf(\"score\")!==-1&&(t.score=c[e].score)}else t=r.item;return t},e=0,t=c.length;e<t;e++)n(e),a.push(s(e));return a},r.defaultOptions={location:0,distance:100,threshold:.6,maxPatternLength:32},r.prototype._calculatePatternAlphabet=function(){var e={},t=0;for(t=0;t<this.patternLen;t++)e[this.pattern.charAt(t)]=0;for(t=0;t<this.patternLen;t++)e[this.pattern.charAt(t)]|=1<<this.pattern.length-t-1;return e},r.prototype._bitapScore=function(e,t){var i=e/this.patternLen,n=Math.abs(this.options.location-t);return this.options.distance?i+n/this.options.distance:n?1:i},r.prototype.search=function(e){var t,i,n,s,o,r,a,c,l,h,u,d,f,p,v,m,g,y,b,E,_,S,I,w=this.options;if(e=w.caseSensitive?e:e.toLowerCase(),this.pattern===e)return{isMatch:!0,score:0,matchedIndices:[[0,e.length-1]]};if(this.patternLen>w.maxPatternLength){if(y=e.match(new RegExp(this.pattern.replace(w.tokenSeparator,\"|\"))),b=!!y)for(_=[],t=0,S=y.length;t<S;t++)I=y[t],_.push([e.indexOf(I),I.length-1]);return{isMatch:b,score:b?.5:1,matchedIndices:_}}for(s=w.findAllMatches,o=w.location,n=e.length,r=w.threshold,a=e.indexOf(this.pattern,o),E=[],t=0;t<n;t++)E[t]=0;for(a!=-1&&(r=Math.min(this._bitapScore(0,a),r),a=e.lastIndexOf(this.pattern,o+this.patternLen),a!=-1&&(r=Math.min(this._bitapScore(0,a),r))),a=-1,m=1,g=[],h=this.patternLen+n,t=0;t<this.patternLen;t++){for(c=0,l=h;c<l;)this._bitapScore(t,o+l)<=r?c=l:h=l,l=Math.floor((h-c)/2+c);for(h=l,u=Math.max(1,o-l+1),d=s?n:Math.min(o+l,n)+this.patternLen,f=Array(d+2),f[d+1]=(1<<t)-1,i=d;i>=u;i--)if(v=this.patternAlphabet[e.charAt(i-1)],v&&(E[i-1]=1),f[i]=(f[i+1]<<1|1)&v,0!==t&&(f[i]|=(p[i+1]|p[i])<<1|1|p[i+1]),f[i]&this.matchmask&&(m=this._bitapScore(t,i-1),m<=r)){if(r=m,a=i-1,g.push(a),a<=o)break;u=Math.max(1,2*o-a)}if(this._bitapScore(t+1,o)>r)break;p=f}return _=this._getMatchedIndices(E),{isMatch:a>=0,score:0===m?.001:m,matchedIndices:_}},r.prototype._getMatchedIndices=function(e){for(var t,i=[],n=-1,s=-1,o=0,r=e.length;o<r;o++)t=e[o],t&&n===-1?n=o:t||n===-1||(s=o-1,s-n+1>=this.options.minMatchCharLength&&i.push([n,s]),n=-1);return e[o-1]&&o-1-n+1>=this.options.minMatchCharLength&&i.push([n,o-1]),i},e.exports=n}(this)},function(e,t,i){var n,s;!function(){\"use strict\";function i(){for(var e=[],t=0;t<arguments.length;t++){var n=arguments[t];if(n){var s=typeof n;if(\"string\"===s||\"number\"===s)e.push(n);else if(Array.isArray(n))e.push(i.apply(null,n));else if(\"object\"===s)for(var r in n)o.call(n,r)&&n[r]&&e.push(r)}}return e.join(\" \")}var o={}.hasOwnProperty;\"undefined\"!=typeof e&&e.exports?e.exports=i:(n=[],s=function(){return i}.apply(t,n),!(void 0!==s&&(e.exports=s)))}()},function(e,t,i){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}function s(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}function o(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(t,\"__esModule\",{value:!0});var r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),a=i(5),c=i(26),l=n(c),h=function(){function e(){o(this,e),this.store=(0,a.createStore)(l.default,window.devToolsExtension?window.devToolsExtension():void 0)}return r(e,[{key:\"getState\",value:function(){return this.store.getState()}},{key:\"dispatch\",value:function(e){this.store.dispatch(e)}},{key:\"subscribe\",value:function(e){this.store.subscribe(e)}},{key:\"isLoading\",value:function(){var e=this.store.getState();return e.general.loading}},{key:\"getItems\",value:function(){var e=this.store.getState();return e.items}},{key:\"getItemsFilteredByActive\",value:function(){var e=this.getItems(),t=e.filter(function(e){return e.active===!0},[]);return t}},{key:\"getItemsReducedToValues\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.getItems(),t=e.reduce(function(e,t){return e.push(t.value),e},[]);return t}},{key:\"getChoices\",value:function(){var e=this.store.getState();return e.choices}},{key:\"getChoicesFilteredByActive\",value:function(){var e=this.getChoices(),t=e.filter(function(e){return e.active===!0});return t}},{key:\"getChoicesFilteredBySelectable\",value:function(){var e=this.getChoices(),t=e.filter(function(e){return e.disabled!==!0});return t}},{key:\"getSearchableChoices\",value:function(){var e=this.getChoicesFilteredBySelectable();return e.filter(function(e){return e.placeholder!==!0})}},{key:\"getChoiceById\",value:function(e){if(e){var t=this.getChoicesFilteredByActive(),i=t.find(function(t){return t.id===parseInt(e,10)});return i}return!1}},{key:\"getGroups\",value:function(){var e=this.store.getState();return e.groups}},{key:\"getGroupsFilteredByActive\",value:function(){var e=this.getGroups(),t=this.getChoices(),i=e.filter(function(e){var i=e.active===!0&&e.disabled===!1,n=t.some(function(e){return e.active===!0&&e.disabled===!1});return i&&n},[]);return i}},{key:\"getGroupById\",value:function(e){var t=this.getGroups(),i=t.find(function(t){return t.id===e});return i}},{key:\"getPlaceholderChoice\",value:function(){var e=this.getChoices(),t=[].concat(s(e)).reverse().find(function(e){return e.placeholder===!0});return t}}]),e}();t.default=h,e.exports=h},function(e,t,i){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0,t.compose=t.applyMiddleware=t.bindActionCreators=t.combineReducers=t.createStore=void 0;var s=i(6),o=n(s),r=i(21),a=n(r),c=i(23),l=n(c),h=i(24),u=n(h),d=i(25),f=n(d),p=i(22);n(p);t.createStore=o.default,t.combineReducers=a.default,t.bindActionCreators=l.default,t.applyMiddleware=u.default,t.compose=f.default},function(e,t,i){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}function s(e,t,i){function n(){g===m&&(g=m.slice())}function o(){return v}function a(e){if(\"function\"!=typeof e)throw new Error(\"Expected listener to be a function.\");var t=!0;return n(),g.push(e),function(){if(t){t=!1,n();var i=g.indexOf(e);g.splice(i,1)}}}function h(e){if(!(0,r.default)(e))throw new Error(\"Actions must be plain objects. Use custom middleware for async actions.\");if(\"undefined\"==typeof e.type)throw new Error('Actions may not have an undefined \"type\" property. Have you misspelled a constant?');if(y)throw new Error(\"Reducers may not dispatch actions.\");try{y=!0,v=p(v,e)}finally{y=!1}for(var t=m=g,i=0;i<t.length;i++){var n=t[i];n()}return e}function u(e){if(\"function\"!=typeof e)throw new Error(\"Expected the nextReducer to be a function.\");p=e,h({type:l.INIT})}function d(){var e,t=a;return e={subscribe:function(e){function i(){e.next&&e.next(o())}if(\"object\"!=typeof e)throw new TypeError(\"Expected the observer to be an object.\");i();var n=t(i);return{unsubscribe:n}}},e[c.default]=function(){return this},e}var f;if(\"function\"==typeof t&&\"undefined\"==typeof i&&(i=t,t=void 0),\"undefined\"!=typeof i){if(\"function\"!=typeof i)throw new Error(\"Expected the enhancer to be a function.\");return i(s)(e,t)}if(\"function\"!=typeof e)throw new Error(\"Expected the reducer to be a function.\");var p=e,v=t,m=[],g=m,y=!1;return h({type:l.INIT}),f={dispatch:h,subscribe:a,getState:o,replaceReducer:u},f[c.default]=d,f}t.__esModule=!0,t.ActionTypes=void 0,t.default=s;var o=i(7),r=n(o),a=i(17),c=n(a),l=t.ActionTypes={INIT:\"@@redux/INIT\"}},function(e,t,i){function n(e){if(!r(e)||s(e)!=a)return!1;var t=o(e);if(null===t)return!0;var i=u.call(t,\"constructor\")&&t.constructor;return\"function\"==typeof i&&i instanceof i&&h.call(i)==d}var s=i(8),o=i(14),r=i(16),a=\"[object Object]\",c=Function.prototype,l=Object.prototype,h=c.toString,u=l.hasOwnProperty,d=h.call(Object);e.exports=n},function(e,t,i){function n(e){return null==e?void 0===e?c:a:l&&l in Object(e)?o(e):r(e)}var s=i(9),o=i(12),r=i(13),a=\"[object Null]\",c=\"[object Undefined]\",l=s?s.toStringTag:void 0;e.exports=n},function(e,t,i){var n=i(10),s=n.Symbol;e.exports=s},function(e,t,i){var n=i(11),s=\"object\"==typeof self&&self&&self.Object===Object&&self,o=n||s||Function(\"return this\")();e.exports=o},function(e,t){(function(t){var i=\"object\"==typeof t&&t&&t.Object===Object&&t;e.exports=i}).call(t,function(){return this}())},function(e,t,i){function n(e){var t=r.call(e,c),i=e[c];try{e[c]=void 0;var n=!0}catch(e){}var s=a.call(e);return n&&(t?e[c]=i:delete e[c]),s}var s=i(9),o=Object.prototype,r=o.hasOwnProperty,a=o.toString,c=s?s.toStringTag:void 0;e.exports=n},function(e,t){function i(e){return s.call(e)}var n=Object.prototype,s=n.toString;e.exports=i},function(e,t,i){var n=i(15),s=n(Object.getPrototypeOf,Object);e.exports=s},function(e,t){function i(e,t){return function(i){return e(t(i))}}e.exports=i},function(e,t){function i(e){return null!=e&&\"object\"==typeof e}e.exports=i},function(e,t,i){e.exports=i(18)},function(e,t,i){(function(e,n){\"use strict\";function s(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,\"__esModule\",{value:!0});var o,r=i(20),a=s(r);o=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:\"undefined\"!=typeof e?e:n;var c=(0,a.default)(o);t.default=c}).call(t,function(){return this}(),i(19)(e))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children=[],e.webpackPolyfill=1),e}},function(e,t){\"use strict\";function i(e){var t,i=e.Symbol;return\"function\"==typeof i?i.observable?t=i.observable:(t=i(\"observable\"),i.observable=t):t=\"@@observable\",t}Object.defineProperty(t,\"__esModule\",{value:!0}),t.default=i},function(e,t,i){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}function s(e,t){var i=t&&t.type,n=i&&'\"'+i.toString()+'\"'||\"an action\";return\"Given action \"+n+', reducer \"'+e+'\" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.'}function o(e){Object.keys(e).forEach(function(t){var i=e[t],n=i(void 0,{type:a.ActionTypes.INIT});if(\"undefined\"==typeof n)throw new Error('Reducer \"'+t+\"\\\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.\");var s=\"@@redux/PROBE_UNKNOWN_ACTION_\"+Math.random().toString(36).substring(7).split(\"\").join(\".\");if(\"undefined\"==typeof i(void 0,{type:s}))throw new Error('Reducer \"'+t+'\" returned undefined when probed with a random type. '+(\"Don't try to handle \"+a.ActionTypes.INIT+' or other actions in \"redux/*\" ')+\"namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.\")})}function r(e){for(var t=Object.keys(e),i={},n=0;n<t.length;n++){var r=t[n];\"function\"==typeof e[r]&&(i[r]=e[r])}var a=Object.keys(i),c=void 0;try{o(i)}catch(e){c=e}return function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments[1];if(c)throw c;for(var n=!1,o={},r=0;r<a.length;r++){var l=a[r],h=i[l],u=e[l],d=h(u,t);if(\"undefined\"==typeof d){var f=s(l,t);throw new Error(f)}o[l]=d,n=n||d!==u}return n?o:e}}t.__esModule=!0,t.default=r;var a=i(6),c=i(7),l=(n(c),i(22));n(l)},function(e,t){\"use strict\";function i(e){\"undefined\"!=typeof console&&\"function\"==typeof console.error&&console.error(e);try{throw new Error(e)}catch(e){}}t.__esModule=!0,t.default=i},function(e,t){\"use strict\";function i(e,t){return function(){return t(e.apply(void 0,arguments))}}function n(e,t){if(\"function\"==typeof e)return i(e,t);if(\"object\"!=typeof e||null===e)throw new Error(\"bindActionCreators expected an object or a function, instead received \"+(null===e?\"null\":typeof e)+'. Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');for(var n=Object.keys(e),s={},o=0;o<n.length;o++){var r=n[o],a=e[r];\"function\"==typeof a&&(s[r]=i(a,t))}return s}t.__esModule=!0,t.default=n},function(e,t,i){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}function s(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];return function(e){return function(i,n,s){var r=e(i,n,s),c=r.dispatch,l=[],h={getState:r.getState,dispatch:function(e){return c(e)}};return l=t.map(function(e){return e(h)}),c=a.default.apply(void 0,l)(r.dispatch),o({},r,{dispatch:c})}}}t.__esModule=!0;var o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var i=arguments[t];for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(e[n]=i[n])}return e};t.default=s;var r=i(25),a=n(r)},function(e,t){\"use strict\";function i(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];return 0===t.length?function(e){return e}:1===t.length?t[0]:t.reduce(function(e,t){return function(){return e(t.apply(void 0,arguments))}})}t.__esModule=!0,t.default=i},function(e,t,i){\"use strict\";function n(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,\"__esModule\",{value:!0});var s=i(5),o=i(27),r=n(o),a=i(28),c=n(a),l=i(29),h=n(l),u=i(30),d=n(u),f=(0,s.combineReducers)({items:r.default,groups:c.default,choices:h.default,general:d.default}),p=function(e,t){var i=e;return\"CLEAR_ALL\"===t.type&&(i=void 0),f(i,t)};t.default=p},function(e,t){\"use strict\";function i(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}Object.defineProperty(t,\"__esModule\",{value:!0});var n=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments[1];switch(t.type){case\"ADD_ITEM\":var n=[].concat(i(e),[{id:t.id,choiceId:t.choiceId,groupId:t.groupId,value:t.value,label:t.label,active:!0,highlighted:!1,customProperties:t.customProperties,placeholder:t.placeholder||!1,keyCode:null}]);return n.map(function(e){return e.highlighted&&(e.highlighted=!1),e});case\"REMOVE_ITEM\":return e.map(function(e){return e.id===t.id&&(e.active=!1),e});case\"HIGHLIGHT_ITEM\":return e.map(function(e){return e.id===t.id&&(e.highlighted=t.highlighted),e});default:return e}};t.default=n},function(e,t){\"use strict\";function i(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}Object.defineProperty(t,\"__esModule\",{value:!0});var n=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments[1];switch(t.type){case\"ADD_GROUP\":return[].concat(i(e),[{id:t.id,value:t.value,active:t.active,disabled:t.disabled}]);case\"CLEAR_CHOICES\":return e.groups=[];default:return e}};t.default=n},function(e,t){\"use strict\";function i(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}Object.defineProperty(t,\"__esModule\",{value:!0});var n=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments[1];switch(t.type){case\"ADD_CHOICE\":return[].concat(i(e),[{id:t.id,elementId:t.elementId,groupId:t.groupId,value:t.value,label:t.label||t.value,disabled:t.disabled||!1,selected:!1,active:!0,score:9999,customProperties:t.customProperties,placeholder:t.placeholder||!1,keyCode:null}]);case\"ADD_ITEM\":var n=e;return t.activateOptions&&(n=e.map(function(e){return e.active=t.active,e})),t.choiceId>-1&&(n=e.map(function(e){return e.id===parseInt(t.choiceId,10)&&(e.selected=!0),e})),n;case\"REMOVE_ITEM\":return t.choiceId>-1?e.map(function(e){return e.id===parseInt(t.choiceId,10)&&(e.selected=!1),e}):e;case\"FILTER_CHOICES\":var s=t.results,o=e.map(function(e){return e.active=s.some(function(t){return t.item.id===e.id&&(e.score=t.score,!0)}),e});return o;case\"ACTIVATE_CHOICES\":return e.map(function(e){return e.active=t.active,e});case\"CLEAR_CHOICES\":return e.choices=[];default:return e}};t.default=n},function(e,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{loading:!1},t=arguments[1];switch(t.type){case\"LOADING\":return{loading:t.isLoading};default:return e}};t.default=i},function(e,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});t.addItem=function(e,t,i,n,s,o,r,a){return{type:\"ADD_ITEM\",value:e,label:t,id:i,choiceId:n,groupId:s,customProperties:o,placeholder:r,keyCode:a}},t.removeItem=function(e,t){return{type:\"REMOVE_ITEM\",id:e,choiceId:t}},t.highlightItem=function(e,t){return{type:\"HIGHLIGHT_ITEM\",id:e,highlighted:t}},t.addChoice=function(e,t,i,n,s,o,r,a,c){return{type:\"ADD_CHOICE\",value:e,label:t,id:i,groupId:n,disabled:s,elementId:o,customProperties:r,placeholder:a,keyCode:c}},t.filterChoices=function(e){return{type:\"FILTER_CHOICES\",results:e}},t.activateChoices=function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return{type:\"ACTIVATE_CHOICES\",active:e}},t.clearChoices=function(){return{type:\"CLEAR_CHOICES\"}},t.addGroup=function(e,t,i,n){return{type:\"ADD_GROUP\",value:e,id:t,active:i,disabled:n}},t.clearAll=function(){return{type:\"CLEAR_ALL\"}},t.setIsLoading=function(e){return{type:\"LOADING\",isLoading:e}}},function(e,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},n=(t.capitalise=function(e){return e.replace(/\\w\\S*/g,function(e){return e.charAt(0).toUpperCase()+e.substr(1).toLowerCase()})},t.generateChars=function(e){for(var t=\"\",i=0;i<e;i++){var n=c(0,36);t+=n.toString(36)}return t}),s=(t.generateId=function(e,t){var i=e.id||e.name&&e.name+\"-\"+n(2)||n(4);return i=i.replace(/(:|\\.|\\[|\\]|,)/g,\"\"),i=t+i},t.getType=function(e){return Object.prototype.toString.call(e).slice(8,-1);\n}),o=t.isType=function(e,t){var i=s(t);return void 0!==t&&null!==t&&i===e},r=(t.isNode=function(e){return\"object\"===(\"undefined\"==typeof Node?\"undefined\":i(Node))?e instanceof Node:e&&\"object\"===(\"undefined\"==typeof e?\"undefined\":i(e))&&\"number\"==typeof e.nodeType&&\"string\"==typeof e.nodeName},t.isElement=function(e){return\"object\"===(\"undefined\"==typeof HTMLElement?\"undefined\":i(HTMLElement))?e instanceof HTMLElement:e&&\"object\"===(\"undefined\"==typeof e?\"undefined\":i(e))&&null!==e&&1===e.nodeType&&\"string\"==typeof e.nodeName},t.extend=function e(){for(var t={},i=arguments.length,n=function(i){for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(o(\"Object\",i[n])?t[n]=e(!0,t[n],i[n]):t[n]=i[n])},s=0;s<i;s++){var r=arguments[s];o(\"Object\",r)&&n(r)}return t},t.whichTransitionEvent=function(){var e,t=document.createElement(\"fakeelement\"),i={transition:\"transitionend\",OTransition:\"oTransitionEnd\",MozTransition:\"transitionend\",WebkitTransition:\"webkitTransitionEnd\"};for(e in i)if(void 0!==t.style[e])return i[e]},t.whichAnimationEvent=function(){var e,t=document.createElement(\"fakeelement\"),i={animation:\"animationend\",OAnimation:\"oAnimationEnd\",MozAnimation:\"animationend\",WebkitAnimation:\"webkitAnimationEnd\"};for(e in i)if(void 0!==t.style[e])return i[e]}),a=(t.getParentsUntil=function(e,t,i){for(var n=[];e&&e!==document;e=e.parentNode){if(t){var s=t.charAt(0);if(\".\"===s&&e.classList.contains(t.substr(1)))break;if(\"#\"===s&&e.id===t.substr(1))break;if(\"[\"===s&&e.hasAttribute(t.substr(1,t.length-1)))break;if(e.tagName.toLowerCase()===t)break}if(i){var o=i.charAt(0);\".\"===o&&e.classList.contains(i.substr(1))&&n.push(e),\"#\"===o&&e.id===i.substr(1)&&n.push(e),\"[\"===o&&e.hasAttribute(i.substr(1,i.length-1))&&n.push(e),e.tagName.toLowerCase()===i&&n.push(e)}else n.push(e)}return 0===n.length?null:n},t.wrap=function(e,t){return t=t||document.createElement(\"div\"),e.nextSibling?e.parentNode.insertBefore(t,e.nextSibling):e.parentNode.appendChild(t),t.appendChild(e)},t.getSiblings=function(e){for(var t=[],i=e.parentNode.firstChild;i;i=i.nextSibling)1===i.nodeType&&i!==e&&t.push(i);return t},t.findAncestor=function(e,t){for(;(e=e.parentElement)&&!e.classList.contains(t););return e},t.findAncestorByAttrName=function(e,t){for(var i=e;i;){if(i.hasAttribute(t))return i;i=i.parentElement}return null},t.debounce=function(e,t,i){var n;return function(){var s=this,o=arguments,r=function(){n=null,i||e.apply(s,o)},a=i&&!n;clearTimeout(n),n=setTimeout(r,t),a&&e.apply(s,o)}},t.getElemDistance=function(e){var t=0;if(e.offsetParent)do t+=e.offsetTop,e=e.offsetParent;while(e);return t>=0?t:0},t.getElementOffset=function(e,t){var i=t;return i>1&&(i=1),i>0&&(i=0),Math.max(e.offsetHeight*i)},t.getAdjacentEl=function(e,t){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(e&&t){var n=e.parentNode.parentNode,s=Array.from(n.querySelectorAll(t)),o=s.indexOf(e),r=i>0?1:-1;return s[o+r]}},t.getScrollPosition=function(e){return\"bottom\"===e?Math.max((window.scrollY||window.pageYOffset)+(window.innerHeight||document.documentElement.clientHeight)):window.scrollY||window.pageYOffset},t.isInView=function(e,t,i){return this.getScrollPosition(t)>this.getElemDistance(e)+this.getElementOffset(e,i)},t.isScrolledIntoView=function(e,t){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(e){var n=void 0;return n=i>0?t.scrollTop+t.offsetHeight>=e.offsetTop+e.offsetHeight:e.offsetTop>=t.scrollTop}},t.stripHTML=function(e){return e.replace(/&/g,\"&amp;\").replace(/>/g,\"&rt;\").replace(/</g,\"&lt;\").replace(/\"/g,\"&quot;\")}),c=(t.addAnimation=function(e,t){var i=r(),n=function n(){e.classList.remove(t),e.removeEventListener(i,n,!1)};e.classList.add(t),e.addEventListener(i,n,!1)},t.getRandomNumber=function(e,t){return Math.floor(Math.random()*(t-e)+e)}),l=t.strToEl=function(){var e=document.createElement(\"div\");return function(t){var i=t.trim(),n=void 0;for(e.innerHTML=i,n=e.children[0];e.firstChild;)e.removeChild(e.firstChild);return n}}();t.getWidthOfInput=function(e){var t=e.value||e.placeholder,i=e.offsetWidth;if(t){var n=l(\"<span>\"+a(t)+\"</span>\");if(n.style.position=\"absolute\",n.style.padding=\"0\",n.style.top=\"-9999px\",n.style.left=\"-9999px\",n.style.width=\"auto\",n.style.whiteSpace=\"pre\",document.body.contains(e)&&window.getComputedStyle){var s=window.getComputedStyle(e);s&&(n.style.fontSize=s.fontSize,n.style.fontFamily=s.fontFamily,n.style.fontWeight=s.fontWeight,n.style.fontStyle=s.fontStyle,n.style.letterSpacing=s.letterSpacing,n.style.textTransform=s.textTransform,n.style.padding=s.padding)}document.body.appendChild(n),t&&n.offsetWidth!==e.offsetWidth&&(i=n.offsetWidth+4),document.body.removeChild(n)}return i+\"px\"},t.sortByAlpha=function(e,t){var i=(e.label||e.value).toLowerCase(),n=(t.label||t.value).toLowerCase();return i<n?-1:i>n?1:0},t.sortByScore=function(e,t){return e.score-t.score},t.triggerEvent=function(e,t){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=new CustomEvent(t,{detail:i,bubbles:!0,cancelable:!0});return e.dispatchEvent(n)}},function(e,t){\"use strict\";!function(){function e(e,t){t=t||{bubbles:!1,cancelable:!1,detail:void 0};var i=document.createEvent(\"CustomEvent\");return i.initCustomEvent(e,t.bubbles,t.cancelable,t.detail),i}Array.from||(Array.from=function(){var e=Object.prototype.toString,t=function(t){return\"function\"==typeof t||\"[object Function]\"===e.call(t)},i=function(e){var t=Number(e);return isNaN(t)?0:0!==t&&isFinite(t)?(t>0?1:-1)*Math.floor(Math.abs(t)):t},n=Math.pow(2,53)-1,s=function(e){var t=i(e);return Math.min(Math.max(t,0),n)};return function(e){var i=this,n=Object(e);if(null==e)throw new TypeError(\"Array.from requires an array-like object - not null or undefined\");var o,r=arguments.length>1?arguments[1]:void 0;if(\"undefined\"!=typeof r){if(!t(r))throw new TypeError(\"Array.from: when provided, the second argument must be a function\");arguments.length>2&&(o=arguments[2])}for(var a,c=s(n.length),l=t(i)?Object(new i(c)):new Array(c),h=0;h<c;)a=n[h],r?l[h]=\"undefined\"==typeof o?r(a,h):r.call(o,a,h):l[h]=a,h+=1;return l.length=c,l}}()),Array.prototype.find||(Array.prototype.find=function(e){if(null==this)throw new TypeError(\"Array.prototype.find called on null or undefined\");if(\"function\"!=typeof e)throw new TypeError(\"predicate must be a function\");for(var t,i=Object(this),n=i.length>>>0,s=arguments[1],o=0;o<n;o++)if(t=i[o],e.call(s,t,o,i))return t}),e.prototype=window.Event.prototype,window.CustomEvent=e}()}])});\n//# sourceMappingURL=choices.min.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nob2ljZXMuanMvYXNzZXRzL3NjcmlwdHMvZGlzdC9jaG9pY2VzLm1pbi5qcz84NmUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsZUFBZSx1SUFBbUwsaUJBQWlCLG1CQUFtQixjQUFjLDRCQUE0QixZQUFZLFVBQVUsaUJBQWlCLGdFQUFnRSxTQUFTLG9EQUFvRCxrQkFBa0IsZUFBZSxpQkFBaUIsYUFBYSxjQUFjLDBCQUEwQixXQUFXLGtCQUFrQix5Q0FBeUMsa0RBQWtELFdBQVcsY0FBYyxxQkFBcUIsOEJBQThCLFdBQVcsY0FBYyxTQUFTLHFCQUFxQixnQkFBZ0IsOEVBQThFLGlCQUFpQixnQkFBZ0IsWUFBWSxXQUFXLEtBQUssV0FBVywrR0FBK0csdUJBQXVCLHdDQUF3Qyw2REFBNkQsTUFBTSxpQkFBaUIsYUFBYSx5SUFBeUksdUNBQXVDLG1DQUFtQywwQkFBMEIsV0FBVyxLQUFLLFdBQVcsWUFBWSxPQUFPLDJwQkFBMnBCLDJEQUEyRCx5QkFBeUIsd0NBQXdDLDRCQUE0QixhQUFhLCtEQUErRCx5dkJBQXl2QixjQUFjLGdCQUFnQixxREFBcUQsaUJBQWlCLHlCQUF5Qiw4V0FBOFcsa0JBQWtCLDRNQUE0TSw4bERBQThsRCw2Q0FBNkMsc0ZBQXNGLG1FQUFtRSxNQUFNLG9FQUFvRSxZQUFZLG9FQUFvRSxhQUFhLDRCQUE0QiwwQkFBMEIsaUNBQWlDLHdMQUF3TCxFQUFFLCtCQUErQiwwQkFBMEIsaUxBQWlMLGdFQUFnRSw4Z0JBQThnQixFQUFFLHlDQUF5QywyRUFBMkUsK0RBQStELDJCQUEyQiwyRUFBMkUsRUFBRSxnQkFBZ0Isc0NBQXNDLDBDQUEwQyxLQUFLLEVBQUUsd0NBQXdDLHNRQUFzUSxzREFBc0QsTUFBTSxpQ0FBaUMsa0JBQWtCLEtBQUssNkRBQTZELGtCQUFrQixHQUFHLDZCQUE2Qiw0RUFBNEUsRUFBRSx1Q0FBdUMsMkNBQTJDLHNEQUFzRCxzQ0FBc0Msb0NBQW9DLFlBQVksSUFBSSxrQkFBa0IsVUFBVSxFQUFFLG9DQUFvQyxnSEFBZ0gsNkdBQTZHLDRFQUE0RSxzRUFBc0UsS0FBSyx3Q0FBd0Msc0JBQXNCLGlDQUFpQyxpQkFBaUIsb0VBQW9FLDZCQUE2QiwrQkFBK0IsaUJBQWlCLEtBQUssRUFBRSw4QkFBOEIsMEdBQTBHLGlMQUFpTCwySEFBMkgsbU1BQW1NLG1GQUFtRiw2S0FBNkssS0FBSyxzQkFBc0IscVdBQXFXLG1EQUFtRCw0Q0FBNEMsb0NBQW9DLDBCQUEwQiw0Q0FBNEMsbUNBQW1DLEVBQUUsc0NBQXNDLGlFQUFpRSxrQkFBa0IsOERBQThELDRIQUE0SCxvREFBb0QseURBQXlELGlDQUFpQyxTQUFTLEVBQUUsd0NBQXdDLGtCQUFrQiw4REFBOEQsMEhBQTBILG9EQUFvRCwyREFBMkQsaUNBQWlDLFFBQVEsRUFBRSxvQ0FBb0MsbUNBQW1DLDZCQUE2QixtQkFBbUIsUUFBUSxFQUFFLHNDQUFzQyxtQ0FBbUMsNkJBQTZCLHFCQUFxQixRQUFRLEVBQUUsMkNBQTJDLFdBQVcsNkNBQTZDLDRDQUE0Qyw2QkFBNkIsOEJBQThCLFFBQVEsRUFBRSwwQ0FBMEMsbURBQW1ELDZCQUE2QixxQ0FBcUMsUUFBUSxFQUFFLDhDQUE4Qyw2R0FBNkcsNkJBQTZCLHlFQUF5RSxRQUFRLEVBQUUsb0NBQW9DLGdNQUFnTSxnUEFBZ1AsOEdBQThHLDRSQUE0UixRQUFRLEVBQUUsb0NBQW9DLDRJQUE0SSw2Y0FBNmMsUUFBUSxFQUFFLHNDQUFzQywyRUFBMkUseURBQXlELEVBQUUsZ0NBQWdDLGtIQUFrSCw2QkFBNkIsa0VBQWtFLGtDQUFrQyxFQUFFLGlDQUFpQyxXQUFXLDBCQUEwQixvQ0FBb0MsdUJBQXVCLGlCQUFpQixtQkFBbUIsaUtBQWlLLG1GQUFtRixpQ0FBaUMsS0FBSyxVQUFVLGFBQWEsRUFBRSx5Q0FBeUMsV0FBVyx3QkFBd0IsOERBQThELHNCQUFzQix5QkFBeUIsd0NBQXdDLEVBQUUsa1FBQWtRLEVBQUUsYUFBYSxFQUFFLHVDQUF1QyxxRUFBcUUsZ0RBQWdELDRDQUE0QywySkFBMkosOEhBQThILHdCQUF3QixhQUFhLEVBQUUsa0NBQWtDLG1EQUFtRCxFQUFFLGtDQUFrQyx5TkFBeU4sRUFBRSw4QkFBOEIscUJBQXFCLCtCQUErQixtRkFBbUYsK1RBQStULGFBQWEsRUFBRSwrQkFBK0IscUJBQXFCLCtCQUErQixvRkFBb0Ysb1VBQW9VLGFBQWEsRUFBRSw2QkFBNkIsV0FBVyxzRkFBc0YsMEJBQTBCLGlDQUFpQyxFQUFFLHVDQUF1QyxtREFBbUQsUUFBUSxHQUFHLEVBQUUsOENBQThDLGdFQUFnRSxnRUFBZ0UsNkJBQTZCLEVBQUUsNEdBQTRHLEVBQUUsZ0RBQWdELHdDQUF3QyxvR0FBb0csRUFBRSw0Q0FBNEMscUVBQXFFLDREQUE0RCxnQ0FBZ0Msc0JBQXNCLCtGQUErRiw0REFBNEQsRUFBRSw4Q0FBOEMsU0FBUyw0S0FBNEssK0RBQStELFNBQVMsK0JBQStCLGtDQUFrQyxvSUFBb0ksa0dBQWtHLEVBQUUseUNBQXlDLCtCQUErQix5Q0FBeUMscUJBQXFCLEVBQUUsK0xBQStMLEVBQUUsc0NBQXNDLCtHQUErRyx1VkFBdVYsMEJBQTBCLDhEQUE4RCxFQUFFLDBMQUEwTCxzQkFBc0IsRUFBRSwyQ0FBMkMsdUlBQXVJLHlmQUF5ZixFQUFFLHFDQUFxQyxXQUFXLHVCQUF1QixTQUFTLHFDQUFxQyx3R0FBd0csY0FBYyxpQkFBaUIscUJBQXFCLDJGQUEyRixtSkFBbUosRUFBRSx1Q0FBdUMsZ0lBQWdJLDJCQUEyQiwwTEFBMEwsT0FBTyxxQ0FBcUMsNkhBQTZILFVBQVUsRUFBRSxzQ0FBc0MsTUFBTSxtREFBbUQsZ0JBQWdCLEVBQUUsZ0ZBQWdGLFFBQVEsc0dBQXNHLHNCQUFzQixFQUFFLCtFQUErRSxFQUFFLDBDQUEwQyxxdEJBQXF0QixFQUFFLDZDQUE2Qyw0dkJBQTR2QixFQUFFLHNDQUFzQywrTUFBK00sRUFBRSxtQ0FBbUMsYUFBYSxrRUFBa0UsZ1RBQWdULGlIQUFpSCxpQkFBaUIsZ0hBQWdILGNBQWMsNkJBQTZCLHlDQUF5QyxtRkFBbUYscUZBQXFGLG1CQUFtQix5RUFBeUUsdURBQXVELHdFQUF3RSxjQUFjLGlEQUFpRCxjQUFjLDRCQUE0QixxQ0FBcUMsMkZBQTJGLDBJQUEwSSxLQUFLLHlFQUF5RSw2R0FBNkcsa0hBQWtILGNBQWMscUZBQXFGLFFBQVEscUZBQXFGLCtCQUErQixFQUFFLGlDQUFpQywwQkFBMEIsdUZBQXVGLHVCQUF1QiwyRUFBMkUsTUFBTSxhQUFhLDJDQUEyQyxvQ0FBb0MseUVBQXlFLDRCQUE0QixLQUFLLGFBQWEsME5BQTBOLDJDQUEyQyxFQUFFLGdDQUFnQyxnREFBZ0QsRUFBRSxvQ0FBb0Msb0NBQW9DLEVBQUUsb0NBQW9DLDJHQUEyRywwUUFBMFEsRUFBRSxxQ0FBcUMsZUFBZSxnSEFBZ0gsa0VBQWtFLG9RQUFvUSxFQUFFLGlDQUFpQyw4SEFBOEgsK1ZBQStWLEtBQUsseUJBQXlCLHFCQUFxQixFQUFFLDBIQUEwSCxFQUFFLHFDQUFxQyxxSUFBcUksRUFBRSxpQ0FBaUMsOERBQThELEVBQUUsaUNBQWlDLHNCQUFzQixvQ0FBb0MsOEVBQThFLGdCQUFnQiw0RUFBNEUseUJBQXlCLGtHQUFrRyw4QkFBOEIsc0dBQXNHLCtCQUErQixFQUFFLGdDQUFnQyxzQkFBc0IsMkRBQTJELHdJQUF3SSxxQkFBcUIsS0FBSyxnQkFBZ0IsMkhBQTJILHlCQUF5QiwySkFBMkosOEJBQThCLDZIQUE2SCw2QkFBNkIsaURBQWlELEVBQUUscUNBQXFDLGVBQWUseURBQXlELGtCQUFrQixFQUFFLDBDQUEwQyxXQUFXLE1BQU0saUtBQWlLLHdEQUF3RCxtS0FBbUssU0FBUyxHQUFHLGtDQUFrQyxTQUFTLElBQUksRUFBRSx3Q0FBd0Msc0pBQXNKLGdCQUFnQiw4RkFBOEYsc0JBQXNCLGlHQUFpRyxpU0FBaVMsRUFBRSxpQ0FBaUMsc2dCQUFzZ0I7QUFDN3ArQixtS0FBbUssa0RBQWtELG1EQUFtRCwrQkFBK0IsUUFBUSxFQUFFLG9DQUFvQyw2Q0FBNkMsK0ZBQStGLGlIQUFpSCx3Q0FBd0Msc0RBQXNELHFCQUFxQixRQUFRLEVBQUUsbUNBQW1DLHdhQUF3YSxvQ0FBb0Msc0dBQXNHLCtGQUErRixFQUFFLHFDQUFxQywyQ0FBMkMsRUFBRSxvQ0FBb0MsK1NBQStTLDZFQUE2RSxzREFBc0QsNkdBQTZHLG9FQUFvRSxFQUFFLHFDQUFxQyxrQkFBa0IsMEVBQTBFLElBQUksd0JBQXdCLHdCQUF3QixFQUFFLHdDQUF3Qyx1Q0FBdUMsMkJBQTJCLGtjQUFrYywyQkFBMkIsc0ZBQXNGLHFCQUFxQixrQ0FBa0MsbUZBQW1GLHVFQUF1RSx5QkFBeUIsa0hBQWtILGtCQUFrQixrQ0FBa0MsaUhBQWlILDhCQUE4QixNQUFNLG1DQUFtQywrdUJBQSt1QixrVkFBa1YsdUJBQXVCLCtPQUErTyx5QkFBeUIsZ0NBQWdDLDZCQUE2Qiw2VkFBNlYsb0JBQW9CLCtDQUErQyx1R0FBdUcsd2VBQXdlLGtCQUFrQiwyQ0FBMkMsMlJBQTJSLHFCQUFxQiwyQ0FBMkMsaUpBQWlKLG9CQUFvQiwyR0FBMkcseUVBQXlFLHNHQUFzRyxvQkFBb0Isd0dBQXdHLDhDQUE4QyxtR0FBbUcsRUFBRSxvQ0FBb0MsNENBQTRDLEVBQUUsb0NBQW9DLHdRQUF3USw4T0FBOE8sK0NBQStDLGlJQUFpSSw2a0JBQTZrQixzRUFBc0UsdUdBQXVHLDBCQUEwQixFQUFFLEtBQUssMkZBQTJGLHNCQUFzQixRQUFRLHlJQUF5SSxFQUFFLG9DQUFvQyx5QkFBeUIsa0JBQWtCLEVBQUUsd0JBQXdCLHlCQUF5QixpQkFBaUIscUdBQXFHLGlHQUFpRyxFQUFFLHFCQUFxQiw4REFBOEQsdUJBQXVCLGlCQUFpQixtQkFBbUIseUVBQXlFLGdDQUFnQyxHQUFHLEtBQUssR0FBRyxZQUFZLGlCQUFpQixhQUFhLGFBQWEsYUFBYSxxQ0FBcUMsZ0JBQWdCLE1BQU0saUNBQWlDLHFIQUFxSCxrQkFBa0IsZ0JBQWdCLE1BQU0sbUtBQW1LLElBQUksZ0JBQWdCLGlCQUFpQixlQUFlLGVBQWUsU0FBUyxjQUFjLDJEQUEyRCxnQkFBZ0IsT0FBTyw0Z0JBQTRnQixPQUFPLGtGQUFrRix1QkFBdUIsdUhBQXVILDhDQUE4QyxxQkFBcUIsZ0NBQWdDLGlHQUFpRyxrR0FBa0cscUJBQXFCLFNBQVMsMENBQTBDLDBGQUEwRixvREFBb0QsSUFBSSw0Q0FBNEMsNEJBQTRCLHFDQUFxQyxrR0FBa0csaUNBQWlDLElBQUksK0JBQStCLHdCQUF3QixLQUFLLElBQUksbUJBQW1CLElBQUksS0FBSyw4QkFBOEIseUNBQXlDLFNBQVMsOEVBQThFLFNBQVMsc0JBQXNCLFVBQVUsZ0NBQWdDLHdDQUF3QyxzREFBc0QseUJBQXlCLEtBQUssUUFBUSx1QkFBdUIsd0ZBQXdGLFFBQVEsNkJBQTZCLEtBQUssOEVBQThFLFdBQVcsS0FBSyxxQkFBcUIsU0FBUyw2R0FBNkcsdUNBQXVDLDBCQUEwQixJQUFJLFlBQVksNENBQTRDLHdUQUF3VCw4Q0FBOEMsc0JBQXNCLGdCQUFnQiw4Q0FBOEMsRUFBRSx3Q0FBd0MscUJBQXFCLFdBQVcsK0JBQStCLHNDQUFzQyxvREFBb0QsMERBQTBELFdBQVcsS0FBSyx5Q0FBeUMsSUFBSSwyRkFBMkYsaUVBQWlFLDhCQUE4QixtQkFBbUIsNEVBQTRFLGdDQUFnQyxxRUFBcUUseURBQXlELGtDQUFrQyxhQUFhLGVBQWUscUJBQXFCLGVBQWUsTUFBTSxZQUFZLDJEQUEyRCxXQUFXLGNBQWMseUJBQXlCLHdDQUF3Qyw4Q0FBOEMsY0FBYyxTQUFTLGdCQUFnQixJQUFJLHNCQUFzQixTQUFTLG1CQUFtQix5REFBeUQsa0RBQWtELFFBQVEsS0FBSyxRQUFRLGtCQUFrQixnQ0FBZ0MsUUFBUSxrQkFBa0IsMERBQTBELFNBQVMsdUNBQXVDLDREQUE0RCw2REFBNkQsZ0NBQWdDLGlFQUFpRSwrREFBK0Qsb0RBQW9ELHVDQUF1QyxtR0FBbUcsSUFBSSw2Q0FBNkMsT0FBTyx5Q0FBeUMsa0dBQWtHLElBQUksV0FBVyxvTEFBb0wsa0JBQWtCLEtBQUssWUFBWSxJQUFJLDREQUE0RCxtR0FBbUcsS0FBSyxnTEFBZ0wsa0NBQWtDLG9CQUFvQixtQ0FBbUMsSUFBSSxxQ0FBcUMsa0RBQWtELDRDQUE0Qyx3Q0FBd0MsSUFBSSx1R0FBdUcsMkVBQTJFLGFBQWEsT0FBTyxpQkFBaUIsUUFBUSxZQUFZLGFBQWEsYUFBYSxpQkFBaUIsbUJBQW1CLEtBQUssbUJBQW1CLE1BQU0sZUFBZSx3Q0FBd0MsaURBQWlELGtFQUFrRSxtQkFBbUIsUUFBUSxnQkFBZ0IsZ0VBQWdFLFNBQVMsMENBQTBDLEdBQUcsaUJBQWlCLGFBQWEsY0FBYywwQkFBMEIsV0FBVyxjQUFjLHFCQUFxQiw4QkFBOEIsV0FBVyxjQUFjLFNBQVMscUJBQXFCLGdCQUFnQiw4RUFBOEUsc0NBQXNDLFNBQVMsRUFBRSxpQkFBaUIsZ0JBQWdCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLHVCQUF1Qix3Q0FBd0Msc0NBQXNDLGFBQWEsNkdBQTZHLGFBQWEsZ0NBQWdDLDhCQUE4QixFQUFFLGlDQUFpQyx3QkFBd0IsRUFBRSxrQ0FBa0MseUJBQXlCLEVBQUUsaUNBQWlDLDRCQUE0QiwwQkFBMEIsRUFBRSxnQ0FBZ0MsNEJBQTRCLGdCQUFnQixFQUFFLGdEQUFnRCw2Q0FBNkMscUJBQXFCLEtBQUssVUFBVSxFQUFFLCtDQUErQyxzR0FBc0cseUJBQXlCLEtBQUssVUFBVSxFQUFFLGtDQUFrQyw0QkFBNEIsa0JBQWtCLEVBQUUsa0RBQWtELCtDQUErQyxxQkFBcUIsRUFBRSxVQUFVLEVBQUUsc0RBQXNELCtDQUErQyx1QkFBdUIsRUFBRSxVQUFVLEVBQUUsNENBQTRDLDRDQUE0Qyw0QkFBNEIsMEJBQTBCLEdBQUcsRUFBRSxzQ0FBc0MsTUFBTSw2REFBNkQsNkJBQTZCLEVBQUUsU0FBUyxVQUFVLEVBQUUsaUNBQWlDLDRCQUE0QixpQkFBaUIsRUFBRSxpREFBaUQsa0VBQWtFLDBEQUEwRCxzQ0FBc0MsRUFBRSxZQUFZLEtBQUssVUFBVSxFQUFFLHFDQUFxQyw0Q0FBNEMsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLDRDQUE0QyxxRUFBcUUsMEJBQTBCLEVBQUUsVUFBVSxLQUFLLEdBQUcsd0JBQXdCLGlCQUFpQixhQUFhLGNBQWMsMEJBQTBCLFdBQVcsd0dBQXdHLHNGQUFzRixLQUFLLG1JQUFtSSxpQkFBaUIsYUFBYSxjQUFjLDBCQUEwQixXQUFXLGtCQUFrQixhQUFhLHFCQUFxQixhQUFhLFNBQVMsY0FBYywrRUFBK0UsU0FBUyxnQ0FBZ0MsTUFBTSxTQUFTLG1CQUFtQixnQkFBZ0IsY0FBYyxnSEFBZ0gsb0lBQW9JLDJEQUEyRCxJQUFJLGNBQWMsUUFBUSxLQUFLLGtCQUFrQixXQUFXLEtBQUssV0FBVyxJQUFJLFNBQVMsY0FBYyxzRkFBc0YsT0FBTyxZQUFZLEVBQUUsYUFBYSxVQUFVLFVBQVUsc0JBQXNCLGFBQWEsb0JBQW9CLG9GQUFvRixJQUFJLFdBQVcsT0FBTyxnQkFBZ0IseUJBQXlCLFlBQVksR0FBRyxNQUFNLHNGQUFzRixtRkFBbUYsaUJBQWlCLGtGQUFrRiwwQkFBMEIsVUFBVSxZQUFZLEtBQUssbURBQW1ELGtCQUFrQixpREFBaUQsa0RBQWtELHFCQUFxQixpQkFBaUIsY0FBYywyQkFBMkIsV0FBVyxxQkFBcUIsNkNBQTZDLHlEQUF5RCx3SUFBd0ksWUFBWSxpQkFBaUIsY0FBYywwREFBMEQsNkZBQTZGLFlBQVksaUJBQWlCLHVCQUF1QixZQUFZLGlCQUFpQix3R0FBd0csWUFBWSxlQUFlLGFBQWEsa0RBQWtELFlBQVksb0JBQW9CLFlBQVksSUFBSSxpQkFBaUIsY0FBYyx5QkFBeUIsSUFBSSxZQUFZLFNBQVMsVUFBVSxnQkFBZ0IsbUNBQW1DLHVGQUF1RixZQUFZLGVBQWUsY0FBYyxpQkFBaUIsb0NBQW9DLFlBQVksaUJBQWlCLDhDQUE4QyxZQUFZLGVBQWUsZ0JBQWdCLG1CQUFtQixnQkFBZ0IsWUFBWSxlQUFlLGNBQWMsbUNBQW1DLFlBQVksaUJBQWlCLGdCQUFnQixpQkFBaUIsZUFBZSxhQUFhLGNBQWMsMEJBQTBCLFdBQVcsc0NBQXNDLFNBQVMsRUFBRSxxQkFBcUIsNEZBQTRGLHVCQUF1QixZQUFZLG9CQUFvQixZQUFZLGFBQWEsZUFBZSxzQkFBc0IsbURBQW1ELGtEQUFrRCxlQUFlLGFBQWEsY0FBYyxpQkFBaUIsNkdBQTZHLHNDQUFzQyxTQUFTLGNBQWMsaUJBQWlCLGFBQWEsY0FBYywwQkFBMEIsV0FBVyxnQkFBZ0IsdURBQXVELHlOQUF5TixjQUFjLG1DQUFtQyx1QkFBdUIsd0JBQXdCLEVBQUUsd1VBQXdVLGtHQUFrRyxpQ0FBaUMsT0FBTyxzYkFBc2IsRUFBRSxjQUFjLDZCQUE2QixLQUFLLFdBQVcsS0FBSyxXQUFXLHFDQUFxQyw4QkFBOEIsSUFBSSxLQUFLLFNBQVMsSUFBSSxrQkFBa0IsK0RBQStELGdCQUFnQixhQUFhLGlCQUFpQixLQUFLLFdBQVcsS0FBSyxrQ0FBa0MsMEJBQTBCLGFBQWEsbUJBQW1CLGtCQUFrQixjQUFjLDRCQUE0QixpQ0FBaUMsS0FBSyxlQUFlLGFBQWEsY0FBYyxnRkFBZ0YsSUFBSSxtQkFBbUIsV0FBVyw0QkFBNEIsZUFBZSxhQUFhLGdCQUFnQixrQkFBa0IscUNBQXFDLGdCQUFnQixzQ0FBc0Msa1BBQWtQLDZCQUE2QixLQUFLLFdBQVcsS0FBSyxrQkFBa0Isb0NBQW9DLFNBQVMsNEJBQTRCLGlCQUFpQixhQUFhLGNBQWMsMEJBQTBCLFdBQVcsYUFBYSwwQ0FBMEMsSUFBSSxzQkFBc0IsbUJBQW1CLHVCQUF1QixvQ0FBb0MseUNBQXlDLGNBQWMsMkJBQTJCLFlBQVksOENBQThDLElBQUksV0FBVyxJQUFJLGdCQUFnQixpQ0FBaUMsWUFBWSxtQkFBbUIsS0FBSyxtQkFBbUIsc0VBQXNFLFVBQVUsWUFBWSxtQkFBbUIsZUFBZSxhQUFhLGFBQWEsMENBQTBDLElBQUksc0JBQXNCLGdDQUFnQyxTQUFTLDBDQUEwQyxrQkFBa0IscUNBQXFDLEVBQUUsNEJBQTRCLGlCQUFpQixhQUFhLGNBQWMsMEJBQTBCLFdBQVcsc0NBQXNDLFNBQVMsRUFBRSxnR0FBZ0cscUVBQXFFLGtCQUFrQixRQUFRLCtDQUErQyxZQUFZLGVBQWUsYUFBYSxjQUFjLHFCQUFxQiw4QkFBOEIsV0FBVyxjQUFjLFNBQVMscUJBQXFCLHNDQUFzQyxTQUFTLEVBQUUsaUJBQWlCLCtFQUErRSxlQUFlLHNDQUFzQyxrTEFBa0wsR0FBRyx5QkFBeUIsMkNBQTJDLEVBQUUsMkNBQTJDLG9DQUFvQyxFQUFFLDhDQUE4QyxvREFBb0QsRUFBRSxtQkFBbUIsWUFBWSxlQUFlLGFBQWEsY0FBYyxxQkFBcUIsOEJBQThCLFdBQVcsY0FBYyxTQUFTLHFCQUFxQixzQ0FBc0MsU0FBUyxFQUFFLGlCQUFpQiwrRUFBK0UsZUFBZSx1Q0FBdUMsMERBQTBELEdBQUcsdUNBQXVDLG1CQUFtQixZQUFZLGVBQWUsYUFBYSxjQUFjLHFCQUFxQiw4QkFBOEIsV0FBVyxjQUFjLFNBQVMscUJBQXFCLHNDQUFzQyxTQUFTLEVBQUUsaUJBQWlCLCtFQUErRSxlQUFlLHdDQUF3Qyw2TkFBNk4sR0FBRyx1QkFBdUIsK0NBQStDLDJCQUEyQix1Q0FBdUMseURBQXlELEtBQUsseURBQXlELHlEQUF5RCxJQUFJLHlEQUF5RCxtQ0FBbUMsOENBQThDLElBQUksRUFBRSxTQUFTLGdEQUFnRCwyQkFBMkIsRUFBRSx3Q0FBd0MsbUJBQW1CLFlBQVksZUFBZSxhQUFhLHNDQUFzQyxTQUFTLEVBQUUsaUJBQWlCLDhEQUE4RCxXQUFXLGdCQUFnQixlQUFlLHFCQUFxQixxQkFBcUIsbUJBQW1CLFlBQVksZUFBZSxhQUFhLHNDQUFzQyxTQUFTLEVBQUUsb0NBQW9DLE9BQU8sc0dBQXNHLDRCQUE0QixPQUFPLG9DQUFvQywrQkFBK0IsT0FBTywwQ0FBMEMseUNBQXlDLE9BQU8sb0hBQW9ILDZCQUE2QixPQUFPLGlDQUFpQyw4QkFBOEIsaUVBQWlFLE9BQU8sa0NBQWtDLDJCQUEyQixPQUFPLHNCQUFzQiw4QkFBOEIsT0FBTyxtREFBbUQsdUJBQXVCLE9BQU8sa0JBQWtCLDRCQUE0QixPQUFPLDZCQUE2QixlQUFlLGFBQWEsc0NBQXNDLFNBQVMsRUFBRSw4RUFBOEUsZ0JBQWdCLGFBQWEsb0dBQW9HLDZCQUE2QixzQ0FBc0MsMkRBQTJELEVBQUUsNkJBQTZCLGlCQUFpQixJQUFJLEtBQUssY0FBYyxrQkFBa0IsU0FBUyxnQ0FBZ0MsMENBQTBDLCtDQUErQyx1QkFBdUI7QUFDL3QrQixDQUFDLDJCQUEyQixXQUFXLG1DQUFtQyx5QkFBeUIsbU1BQW1NLHlCQUF5QixxTkFBcU4sdUJBQXVCLFlBQVksa0NBQWtDLDRHQUE0RyxLQUFLLElBQUksS0FBSyxtQkFBbUIsb0JBQW9CLFNBQVMsbUNBQW1DLGlEQUFpRCw4SEFBOEgsOENBQThDLGtDQUFrQyxpREFBaUQsc0hBQXNILDhDQUE4Qyx1Q0FBdUMsYUFBYSxnQkFBZ0IsZ0JBQWdCLE1BQU0sa0JBQWtCLG9EQUFvRCxxQ0FBcUMseURBQXlELHFDQUFxQyxNQUFNLGtCQUFrQiwrTEFBK0wsZUFBZSwyQkFBMkIsc0JBQXNCLGdKQUFnSiwyQkFBMkIsdUNBQXVDLEVBQUUsaURBQWlELFNBQVMsOEJBQThCLEtBQUssOENBQThDLEVBQUUsU0FBUyx3Q0FBd0MsWUFBWSxFQUFFLEVBQUUsOEJBQThCLGtCQUFrQixZQUFZLDRCQUE0QixNQUFNLGtCQUFrQixvQ0FBb0MsdUJBQXVCLFNBQVMsbURBQW1ELCtCQUErQixRQUFRLHFEQUFxRCxTQUFTLGdCQUFnQixrQ0FBa0MsUUFBUSx3REFBd0QsK0JBQStCLCtEQUErRCxTQUFTLDRGQUE0RixlQUFlLGlDQUFpQyxpS0FBaUssNEJBQTRCLG9GQUFvRixvQ0FBb0MsK0RBQStELE1BQU0sYUFBYSw4RkFBOEYseUJBQXlCLDRCQUE0QixxQkFBcUIscUJBQXFCLHVCQUF1QixHQUFHLGtDQUFrQyx5QkFBeUIscURBQXFELDhDQUE4QyxpQ0FBaUMseUNBQXlDLHlCQUF5QixvQ0FBb0MsbUJBQW1CLHdCQUF3QixrQ0FBa0MsYUFBYSw2QkFBNkIsVUFBVSxHQUFHLDhCQUE4Qiw2Q0FBNkMsTUFBTSxpQ0FBaUMsa01BQWtNLGlDQUFpQyxxT0FBcU8sZ0hBQWdILGNBQWMsNkJBQTZCLDBFQUEwRSxzQkFBc0IsNkJBQTZCLHVCQUF1Qiw4QkFBOEIsdUZBQXVGLGtDQUFrQyxFQUFFLDJCQUEyQixlQUFlLGFBQWEsWUFBWSxnQkFBZ0IsTUFBTSx3Q0FBd0MsMENBQTBDLDhEQUE4RCxtQ0FBbUMsOENBQThDLDREQUE0RCxlQUFlLGdCQUFnQiwwRUFBMEUsa0NBQWtDLFdBQVcsa0NBQWtDLG1CQUFtQix1QkFBdUIsbUdBQW1HLCtDQUErQywwQkFBMEIsa0dBQWtHLHFDQUFxQyxpRUFBaUUsSUFBSSxzRUFBc0UscUJBQXFCLDREQUE0RCxzRkFBc0YsNEVBQTRFLDJEQUEyRCxJQUFJLHVDQUF1QywwREFBMEQsR0FBRyxHQUFHO0FBQy96TSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIGNob2ljZXMuanMgdjMuMC40IHwgKGMpIDIwMTggSm9zaCBKb2huc29uIHwgaHR0cHM6Ly9naXRodWIuY29tL2pzaGpvaG5zb24vQ2hvaWNlcyNyZWFkbWUgKi8gXG4hZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLkNob2ljZXM9dCgpOmUuQ2hvaWNlcz10KCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXtpZihpW25dKXJldHVybiBpW25dLmV4cG9ydHM7dmFyIHM9aVtuXT17ZXhwb3J0czp7fSxpZDpuLGxvYWRlZDohMX07cmV0dXJuIGVbbl0uY2FsbChzLmV4cG9ydHMscyxzLmV4cG9ydHMsdCkscy5sb2FkZWQ9ITAscy5leHBvcnRzfXZhciBpPXt9O3JldHVybiB0Lm09ZSx0LmM9aSx0LnA9XCIvYXNzZXRzL3NjcmlwdHMvZGlzdC9cIix0KDApfShbZnVuY3Rpb24oZSx0LGkpe2UuZXhwb3J0cz1pKDEpfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gcyhlLHQsaSl7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1pLGV9ZnVuY3Rpb24gbyhlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxpPUFycmF5KGUubGVuZ3RoKTt0PGUubGVuZ3RoO3QrKylpW3RdPWVbdF07cmV0dXJuIGl9cmV0dXJuIEFycmF5LmZyb20oZSl9ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciBuPXRbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24odCxpLG4pe3JldHVybiBpJiZlKHQucHJvdG90eXBlLGkpLG4mJmUodCxuKSx0fX0oKSxjPWkoMiksbD1uKGMpLGg9aSgzKSx1PW4oaCksZD1pKDQpLGY9bihkKSxwPWkoMzEpLHY9aSgzMik7aSgzMyk7dmFyIG09ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOlwiW2RhdGEtY2hvaWNlXVwiLGk9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O2lmKHIodGhpcyxlKSwoMCx2LmlzVHlwZSkoXCJTdHJpbmdcIix0KSl7dmFyIG49ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KTtpZihuLmxlbmd0aD4xKWZvcih2YXIgcz0xO3M8bi5sZW5ndGg7cysrKXt2YXIgbz1uW3NdO25ldyBlKG8saSl9fXZhciBhPXtzaWxlbnQ6ITEsaXRlbXM6W10sY2hvaWNlczpbXSxyZW5kZXJDaG9pY2VMaW1pdDotMSxtYXhJdGVtQ291bnQ6LTEsYWRkSXRlbXM6ITAscmVtb3ZlSXRlbXM6ITAscmVtb3ZlSXRlbUJ1dHRvbjohMSxlZGl0SXRlbXM6ITEsZHVwbGljYXRlSXRlbXM6ITAsZGVsaW1pdGVyOlwiLFwiLHBhc3RlOiEwLHNlYXJjaEVuYWJsZWQ6ITAsc2VhcmNoQ2hvaWNlczohMCxzZWFyY2hGbG9vcjoxLHNlYXJjaFJlc3VsdExpbWl0OjQsc2VhcmNoRmllbGRzOltcImxhYmVsXCIsXCJ2YWx1ZVwiXSxwb3NpdGlvbjpcImF1dG9cIixyZXNldFNjcm9sbFBvc2l0aW9uOiEwLHJlZ2V4RmlsdGVyOm51bGwsc2hvdWxkU29ydDohMCxzaG91bGRTb3J0SXRlbXM6ITEsc29ydEZpbHRlcjp2LnNvcnRCeUFscGhhLHBsYWNlaG9sZGVyOiEwLHBsYWNlaG9sZGVyVmFsdWU6bnVsbCxzZWFyY2hQbGFjZWhvbGRlclZhbHVlOm51bGwscHJlcGVuZFZhbHVlOm51bGwsYXBwZW5kVmFsdWU6bnVsbCxyZW5kZXJTZWxlY3RlZENob2ljZXM6XCJhdXRvXCIsbG9hZGluZ1RleHQ6XCJMb2FkaW5nLi4uXCIsbm9SZXN1bHRzVGV4dDpcIk5vIHJlc3VsdHMgZm91bmRcIixub0Nob2ljZXNUZXh0OlwiTm8gY2hvaWNlcyB0byBjaG9vc2UgZnJvbVwiLGl0ZW1TZWxlY3RUZXh0OlwiUHJlc3MgdG8gc2VsZWN0XCIsYWRkSXRlbVRleHQ6ZnVuY3Rpb24oZSl7cmV0dXJuJ1ByZXNzIEVudGVyIHRvIGFkZCA8Yj5cIicrKDAsdi5zdHJpcEhUTUwpKGUpKydcIjwvYj4nfSxtYXhJdGVtVGV4dDpmdW5jdGlvbihlKXtyZXR1cm5cIk9ubHkgXCIrZStcIiB2YWx1ZXMgY2FuIGJlIGFkZGVkLlwifSxpdGVtQ29tcGFyZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT09PXR9LHVuaXF1ZUl0ZW1UZXh0OlwiT25seSB1bmlxdWUgdmFsdWVzIGNhbiBiZSBhZGRlZC5cIixjbGFzc05hbWVzOntjb250YWluZXJPdXRlcjpcImNob2ljZXNcIixjb250YWluZXJJbm5lcjpcImNob2ljZXNfX2lubmVyXCIsaW5wdXQ6XCJjaG9pY2VzX19pbnB1dFwiLGlucHV0Q2xvbmVkOlwiY2hvaWNlc19faW5wdXQtLWNsb25lZFwiLGxpc3Q6XCJjaG9pY2VzX19saXN0XCIsbGlzdEl0ZW1zOlwiY2hvaWNlc19fbGlzdC0tbXVsdGlwbGVcIixsaXN0U2luZ2xlOlwiY2hvaWNlc19fbGlzdC0tc2luZ2xlXCIsbGlzdERyb3Bkb3duOlwiY2hvaWNlc19fbGlzdC0tZHJvcGRvd25cIixpdGVtOlwiY2hvaWNlc19faXRlbVwiLGl0ZW1TZWxlY3RhYmxlOlwiY2hvaWNlc19faXRlbS0tc2VsZWN0YWJsZVwiLGl0ZW1EaXNhYmxlZDpcImNob2ljZXNfX2l0ZW0tLWRpc2FibGVkXCIsaXRlbUNob2ljZTpcImNob2ljZXNfX2l0ZW0tLWNob2ljZVwiLHBsYWNlaG9sZGVyOlwiY2hvaWNlc19fcGxhY2Vob2xkZXJcIixncm91cDpcImNob2ljZXNfX2dyb3VwXCIsZ3JvdXBIZWFkaW5nOlwiY2hvaWNlc19faGVhZGluZ1wiLGJ1dHRvbjpcImNob2ljZXNfX2J1dHRvblwiLGFjdGl2ZVN0YXRlOlwiaXMtYWN0aXZlXCIsZm9jdXNTdGF0ZTpcImlzLWZvY3VzZWRcIixvcGVuU3RhdGU6XCJpcy1vcGVuXCIsZGlzYWJsZWRTdGF0ZTpcImlzLWRpc2FibGVkXCIsaGlnaGxpZ2h0ZWRTdGF0ZTpcImlzLWhpZ2hsaWdodGVkXCIsaGlkZGVuU3RhdGU6XCJpcy1oaWRkZW5cIixmbGlwcGVkU3RhdGU6XCJpcy1mbGlwcGVkXCIsbG9hZGluZ1N0YXRlOlwiaXMtbG9hZGluZ1wiLG5vUmVzdWx0czpcImhhcy1uby1yZXN1bHRzXCIsbm9DaG9pY2VzOlwiaGFzLW5vLWNob2ljZXNcIn0sZnVzZU9wdGlvbnM6e2luY2x1ZGU6XCJzY29yZVwifSxjYWxsYmFja09uSW5pdDpudWxsLGNhbGxiYWNrT25DcmVhdGVUZW1wbGF0ZXM6bnVsbH07aWYodGhpcy5pZE5hbWVzPXtpdGVtQ2hvaWNlOlwiaXRlbS1jaG9pY2VcIn0sdGhpcy5jb25maWc9KDAsdi5leHRlbmQpKGEsaSksXCJhdXRvXCIhPT10aGlzLmNvbmZpZy5yZW5kZXJTZWxlY3RlZENob2ljZXMmJlwiYWx3YXlzXCIhPT10aGlzLmNvbmZpZy5yZW5kZXJTZWxlY3RlZENob2ljZXMmJih0aGlzLmNvbmZpZy5zaWxlbnR8fGNvbnNvbGUud2FybihcInJlbmRlclNlbGVjdGVkQ2hvaWNlczogUG9zc2libGUgdmFsdWVzIGFyZSAnYXV0bycgYW5kICdhbHdheXMnLiBGYWxsaW5nIGJhY2sgdG8gJ2F1dG8nLlwiKSx0aGlzLmNvbmZpZy5yZW5kZXJTZWxlY3RlZENob2ljZXM9XCJhdXRvXCIpLHRoaXMuc3RvcmU9bmV3IGYuZGVmYXVsdCh0aGlzLnJlbmRlciksdGhpcy5pbml0aWFsaXNlZD0hMSx0aGlzLmN1cnJlbnRTdGF0ZT17fSx0aGlzLnByZXZTdGF0ZT17fSx0aGlzLmN1cnJlbnRWYWx1ZT1cIlwiLHRoaXMuZWxlbWVudD10LHRoaXMucGFzc2VkRWxlbWVudD0oMCx2LmlzVHlwZSkoXCJTdHJpbmdcIix0KT9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpOnQsIXRoaXMucGFzc2VkRWxlbWVudClyZXR1cm4gdm9pZCh0aGlzLmNvbmZpZy5zaWxlbnR8fGNvbnNvbGUuZXJyb3IoXCJQYXNzZWQgZWxlbWVudCBub3QgZm91bmRcIikpO3RoaXMuaXNUZXh0RWxlbWVudD1cInRleHRcIj09PXRoaXMucGFzc2VkRWxlbWVudC50eXBlLHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50PVwic2VsZWN0LW9uZVwiPT09dGhpcy5wYXNzZWRFbGVtZW50LnR5cGUsdGhpcy5pc1NlbGVjdE11bHRpcGxlRWxlbWVudD1cInNlbGVjdC1tdWx0aXBsZVwiPT09dGhpcy5wYXNzZWRFbGVtZW50LnR5cGUsdGhpcy5pc1NlbGVjdEVsZW1lbnQ9dGhpcy5pc1NlbGVjdE9uZUVsZW1lbnR8fHRoaXMuaXNTZWxlY3RNdWx0aXBsZUVsZW1lbnQsdGhpcy5pc1ZhbGlkRWxlbWVudFR5cGU9dGhpcy5pc1RleHRFbGVtZW50fHx0aGlzLmlzU2VsZWN0RWxlbWVudCx0aGlzLmlzSWUxMT0hKCFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9UcmlkZW50Lyl8fCFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9ydlsgOl0xMS8pKSx0aGlzLmlzU2Nyb2xsaW5nT25JZT0hMSx0aGlzLmNvbmZpZy5zaG91bGRTb3J0SXRlbXM9PT0hMCYmdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQmJih0aGlzLmNvbmZpZy5zaWxlbnR8fGNvbnNvbGUud2FybihcInNob3VsZFNvcnRFbGVtZW50czogVHlwZSBvZiBwYXNzZWQgZWxlbWVudCBpcyAnc2VsZWN0LW9uZScsIGZhbGxpbmcgYmFjayB0byBmYWxzZS5cIikpLHRoaXMuaGlnaGxpZ2h0UG9zaXRpb249MCx0aGlzLmNhblNlYXJjaD10aGlzLmNvbmZpZy5zZWFyY2hFbmFibGVkLHRoaXMucGxhY2Vob2xkZXI9ITEsdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnR8fCh0aGlzLnBsYWNlaG9sZGVyPSEhdGhpcy5jb25maWcucGxhY2Vob2xkZXImJih0aGlzLmNvbmZpZy5wbGFjZWhvbGRlclZhbHVlfHx0aGlzLnBhc3NlZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikpKSx0aGlzLnByZXNldENob2ljZXM9dGhpcy5jb25maWcuY2hvaWNlcyx0aGlzLnByZXNldEl0ZW1zPXRoaXMuY29uZmlnLml0ZW1zLHRoaXMucGFzc2VkRWxlbWVudC52YWx1ZSYmKHRoaXMucHJlc2V0SXRlbXM9dGhpcy5wcmVzZXRJdGVtcy5jb25jYXQodGhpcy5wYXNzZWRFbGVtZW50LnZhbHVlLnNwbGl0KHRoaXMuY29uZmlnLmRlbGltaXRlcikpKSx0aGlzLmJhc2VJZD0oMCx2LmdlbmVyYXRlSWQpKHRoaXMucGFzc2VkRWxlbWVudCxcImNob2ljZXMtXCIpLHRoaXMucmVuZGVyPXRoaXMucmVuZGVyLmJpbmQodGhpcyksdGhpcy5fb25Gb2N1cz10aGlzLl9vbkZvY3VzLmJpbmQodGhpcyksdGhpcy5fb25CbHVyPXRoaXMuX29uQmx1ci5iaW5kKHRoaXMpLHRoaXMuX29uS2V5VXA9dGhpcy5fb25LZXlVcC5iaW5kKHRoaXMpLHRoaXMuX29uS2V5RG93bj10aGlzLl9vbktleURvd24uYmluZCh0aGlzKSx0aGlzLl9vbkNsaWNrPXRoaXMuX29uQ2xpY2suYmluZCh0aGlzKSx0aGlzLl9vblRvdWNoTW92ZT10aGlzLl9vblRvdWNoTW92ZS5iaW5kKHRoaXMpLHRoaXMuX29uVG91Y2hFbmQ9dGhpcy5fb25Ub3VjaEVuZC5iaW5kKHRoaXMpLHRoaXMuX29uTW91c2VEb3duPXRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyksdGhpcy5fb25Nb3VzZU92ZXI9dGhpcy5fb25Nb3VzZU92ZXIuYmluZCh0aGlzKSx0aGlzLl9vblBhc3RlPXRoaXMuX29uUGFzdGUuYmluZCh0aGlzKSx0aGlzLl9vbklucHV0PXRoaXMuX29uSW5wdXQuYmluZCh0aGlzKSx0aGlzLndhc1RhcD0hMDt2YXIgYz1cImNsYXNzTGlzdFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O2N8fHRoaXMuY29uZmlnLnNpbGVudHx8Y29uc29sZS5lcnJvcihcIkNob2ljZXM6IFlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgQ2hvaWNlc1wiKTt2YXIgbD0oMCx2LmlzRWxlbWVudCkodGhpcy5wYXNzZWRFbGVtZW50KSYmdGhpcy5pc1ZhbGlkRWxlbWVudFR5cGU7aWYobCl7aWYoXCJhY3RpdmVcIj09PXRoaXMucGFzc2VkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNob2ljZVwiKSlyZXR1cm47dGhpcy5pbml0KCl9ZWxzZSB0aGlzLmNvbmZpZy5zaWxlbnR8fGNvbnNvbGUuZXJyb3IoXCJJbmNvbXBhdGlibGUgaW5wdXQgcGFzc2VkXCIpfXJldHVybiBhKGUsW3trZXk6XCJpbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLmluaXRpYWxpc2VkIT09ITApe3ZhciBlPXRoaXMuY29uZmlnLmNhbGxiYWNrT25Jbml0O3RoaXMuaW5pdGlhbGlzZWQ9ITAsdGhpcy5fY3JlYXRlVGVtcGxhdGVzKCksdGhpcy5fY3JlYXRlSW5wdXQoKSx0aGlzLnN0b3JlLnN1YnNjcmliZSh0aGlzLnJlbmRlciksdGhpcy5yZW5kZXIoKSx0aGlzLl9hZGRFdmVudExpc3RlbmVycygpLGUmJigwLHYuaXNUeXBlKShcIkZ1bmN0aW9uXCIsZSkmJmUuY2FsbCh0aGlzKX19fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5pbml0aWFsaXNlZCE9PSExKXt0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpLHRoaXMucGFzc2VkRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuaW5wdXQsdGhpcy5jb25maWcuY2xhc3NOYW1lcy5oaWRkZW5TdGF0ZSksdGhpcy5wYXNzZWRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpO3ZhciBlPXRoaXMucGFzc2VkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNob2ljZS1vcmlnLXN0eWxlXCIpO0Jvb2xlYW4oZSk/KHRoaXMucGFzc2VkRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWNob2ljZS1vcmlnLXN0eWxlXCIpLHRoaXMucGFzc2VkRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLGUpKTp0aGlzLnBhc3NlZEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIiksdGhpcy5wYXNzZWRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLHRoaXMucGFzc2VkRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWNob2ljZVwiKSx0aGlzLnBhc3NlZEVsZW1lbnQudmFsdWU9dGhpcy5wYXNzZWRFbGVtZW50LnZhbHVlLHRoaXMuY29udGFpbmVyT3V0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5wYXNzZWRFbGVtZW50LHRoaXMuY29udGFpbmVyT3V0ZXIpLHRoaXMuY29udGFpbmVyT3V0ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lck91dGVyKSx0aGlzLmNsZWFyU3RvcmUoKSx0aGlzLmNvbmZpZy50ZW1wbGF0ZXM9bnVsbCx0aGlzLmluaXRpYWxpc2VkPSExfX19LHtrZXk6XCJyZW5kZXJHcm91cHNcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSl7dmFyIG49dGhpcyxzPWl8fGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxvPXRoaXMuY29uZmlnLnNvcnRGaWx0ZXI7cmV0dXJuIHRoaXMuY29uZmlnLnNob3VsZFNvcnQmJmUuc29ydChvKSxlLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIGk9dC5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIG4uaXNTZWxlY3RPbmVFbGVtZW50P3QuZ3JvdXBJZD09PWUuaWQ6dC5ncm91cElkPT09ZS5pZCYmIXQuc2VsZWN0ZWR9KTtpZihpLmxlbmd0aD49MSl7dmFyIG89bi5fZ2V0VGVtcGxhdGUoXCJjaG9pY2VHcm91cFwiLGUpO3MuYXBwZW5kQ2hpbGQobyksbi5yZW5kZXJDaG9pY2VzKGkscywhMCl9fSksc319LHtrZXk6XCJyZW5kZXJDaG9pY2VzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzLG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxzPXR8fGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxyPXRoaXMuY29uZmlnLGE9ci5yZW5kZXJTZWxlY3RlZENob2ljZXMsYz1yLnNlYXJjaFJlc3VsdExpbWl0LGw9ci5yZW5kZXJDaG9pY2VMaW1pdCxoPXRoaXMuaXNTZWFyY2hpbmc/di5zb3J0QnlTY29yZTp0aGlzLmNvbmZpZy5zb3J0RmlsdGVyLHU9ZnVuY3Rpb24oZSl7dmFyIHQ9XCJhdXRvXCIhPT1hfHwoaS5pc1NlbGVjdE9uZUVsZW1lbnR8fCFlLnNlbGVjdGVkKTtpZih0KXt2YXIgbj1pLl9nZXRUZW1wbGF0ZShcImNob2ljZVwiLGUpO3MuYXBwZW5kQ2hpbGQobil9fSxkPWU7XCJhdXRvXCIhPT1hfHx0aGlzLmlzU2VsZWN0T25lRWxlbWVudHx8KGQ9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIWUuc2VsZWN0ZWR9KSk7dmFyIGY9ZC5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5wbGFjZWhvbGRlcj9lLnBsYWNlaG9sZGVyQ2hvaWNlcy5wdXNoKHQpOmUubm9ybWFsQ2hvaWNlcy5wdXNoKHQpLGV9LHtwbGFjZWhvbGRlckNob2ljZXM6W10sbm9ybWFsQ2hvaWNlczpbXX0pLHA9Zi5wbGFjZWhvbGRlckNob2ljZXMsbT1mLm5vcm1hbENob2ljZXM7KHRoaXMuY29uZmlnLnNob3VsZFNvcnR8fHRoaXMuaXNTZWFyY2hpbmcpJiZtLnNvcnQoaCk7dmFyIGc9ZC5sZW5ndGgseT1bXS5jb25jYXQobyhwKSxvKG0pKTt0aGlzLmlzU2VhcmNoaW5nP2c9YzpsPjAmJiFuJiYoZz1sKTtmb3IodmFyIGI9MDtiPGc7YisrKXlbYl0mJnUoeVtiXSk7cmV0dXJuIHN9fSx7a2V5OlwicmVuZGVySXRlbXNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGk9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOm51bGwsbj1pfHxkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7aWYodGhpcy5jb25maWcuc2hvdWxkU29ydEl0ZW1zJiYhdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQmJmUuc29ydCh0aGlzLmNvbmZpZy5zb3J0RmlsdGVyKSx0aGlzLmlzVGV4dEVsZW1lbnQpe3ZhciBzPXRoaXMuc3RvcmUuZ2V0SXRlbXNSZWR1Y2VkVG9WYWx1ZXMoZSksbz1zLmpvaW4odGhpcy5jb25maWcuZGVsaW1pdGVyKTt0aGlzLnBhc3NlZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwidmFsdWVcIixvKSx0aGlzLnBhc3NlZEVsZW1lbnQudmFsdWU9b31lbHNle3ZhciByPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtlLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIGk9dC5fZ2V0VGVtcGxhdGUoXCJvcHRpb25cIixlKTtyLmFwcGVuZENoaWxkKGkpfSksdGhpcy5wYXNzZWRFbGVtZW50LmlubmVySFRNTD1cIlwiLHRoaXMucGFzc2VkRWxlbWVudC5hcHBlbmRDaGlsZChyKX1yZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBpPXQuX2dldFRlbXBsYXRlKFwiaXRlbVwiLGUpO24uYXBwZW5kQ2hpbGQoaSl9KSxufX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuc3RvcmUuaXNMb2FkaW5nKCkmJih0aGlzLmN1cnJlbnRTdGF0ZT10aGlzLnN0b3JlLmdldFN0YXRlKCksdGhpcy5jdXJyZW50U3RhdGUhPT10aGlzLnByZXZTdGF0ZSkpe2lmKCh0aGlzLmN1cnJlbnRTdGF0ZS5jaG9pY2VzIT09dGhpcy5wcmV2U3RhdGUuY2hvaWNlc3x8dGhpcy5jdXJyZW50U3RhdGUuZ3JvdXBzIT09dGhpcy5wcmV2U3RhdGUuZ3JvdXBzfHx0aGlzLmN1cnJlbnRTdGF0ZS5pdGVtcyE9PXRoaXMucHJldlN0YXRlLml0ZW1zKSYmdGhpcy5pc1NlbGVjdEVsZW1lbnQpe3ZhciBlPXRoaXMuc3RvcmUuZ2V0R3JvdXBzRmlsdGVyZWRCeUFjdGl2ZSgpLHQ9dGhpcy5zdG9yZS5nZXRDaG9pY2VzRmlsdGVyZWRCeUFjdGl2ZSgpLGk9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO3RoaXMuY2hvaWNlTGlzdC5pbm5lckhUTUw9XCJcIix0aGlzLmNvbmZpZy5yZXNldFNjcm9sbFBvc2l0aW9uJiYodGhpcy5jaG9pY2VMaXN0LnNjcm9sbFRvcD0wKSxlLmxlbmd0aD49MSYmdGhpcy5pc1NlYXJjaGluZyE9PSEwP2k9dGhpcy5yZW5kZXJHcm91cHMoZSx0LGkpOnQubGVuZ3RoPj0xJiYoaT10aGlzLnJlbmRlckNob2ljZXModCxpKSk7dmFyIG49dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKSxzPXRoaXMuX2NhbkFkZEl0ZW0obix0aGlzLmlucHV0LnZhbHVlKTtpZihpLmNoaWxkTm9kZXMmJmkuY2hpbGROb2Rlcy5sZW5ndGg+MClzLnJlc3BvbnNlPyh0aGlzLmNob2ljZUxpc3QuYXBwZW5kQ2hpbGQoaSksdGhpcy5faGlnaGxpZ2h0Q2hvaWNlKCkpOnRoaXMuY2hvaWNlTGlzdC5hcHBlbmRDaGlsZCh0aGlzLl9nZXRUZW1wbGF0ZShcIm5vdGljZVwiLHMubm90aWNlKSk7ZWxzZXt2YXIgbz12b2lkIDAscj12b2lkIDA7dGhpcy5pc1NlYXJjaGluZz8ocj0oMCx2LmlzVHlwZSkoXCJGdW5jdGlvblwiLHRoaXMuY29uZmlnLm5vUmVzdWx0c1RleHQpP3RoaXMuY29uZmlnLm5vUmVzdWx0c1RleHQoKTp0aGlzLmNvbmZpZy5ub1Jlc3VsdHNUZXh0LG89dGhpcy5fZ2V0VGVtcGxhdGUoXCJub3RpY2VcIixyLFwibm8tcmVzdWx0c1wiKSk6KHI9KDAsdi5pc1R5cGUpKFwiRnVuY3Rpb25cIix0aGlzLmNvbmZpZy5ub0Nob2ljZXNUZXh0KT90aGlzLmNvbmZpZy5ub0Nob2ljZXNUZXh0KCk6dGhpcy5jb25maWcubm9DaG9pY2VzVGV4dCxvPXRoaXMuX2dldFRlbXBsYXRlKFwibm90aWNlXCIscixcIm5vLWNob2ljZXNcIikpLHRoaXMuY2hvaWNlTGlzdC5hcHBlbmRDaGlsZChvKX19aWYodGhpcy5jdXJyZW50U3RhdGUuaXRlbXMhPT10aGlzLnByZXZTdGF0ZS5pdGVtcyl7dmFyIGE9dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKTtpZih0aGlzLml0ZW1MaXN0LmlubmVySFRNTD1cIlwiLGEmJmEpe3ZhciBjPXRoaXMucmVuZGVySXRlbXMoYSk7Yy5jaGlsZE5vZGVzJiZ0aGlzLml0ZW1MaXN0LmFwcGVuZENoaWxkKGMpfX10aGlzLnByZXZTdGF0ZT10aGlzLmN1cnJlbnRTdGF0ZX19fSx7a2V5OlwiaGlnaGxpZ2h0SXRlbVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07aWYoIWUpcmV0dXJuIHRoaXM7dmFyIGk9ZS5pZCxuPWUuZ3JvdXBJZCxzPW4+PTA/dGhpcy5zdG9yZS5nZXRHcm91cEJ5SWQobik6bnVsbDtyZXR1cm4gdGhpcy5zdG9yZS5kaXNwYXRjaCgoMCxwLmhpZ2hsaWdodEl0ZW0pKGksITApKSx0JiYocyYmcy52YWx1ZT8oMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwiaGlnaGxpZ2h0SXRlbVwiLHtpZDppLHZhbHVlOmUudmFsdWUsbGFiZWw6ZS5sYWJlbCxncm91cFZhbHVlOnMudmFsdWV9KTooMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwiaGlnaGxpZ2h0SXRlbVwiLHtpZDppLHZhbHVlOmUudmFsdWUsbGFiZWw6ZS5sYWJlbH0pKSx0aGlzfX0se2tleTpcInVuaGlnaGxpZ2h0SXRlbVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFlKXJldHVybiB0aGlzO3ZhciB0PWUuaWQsaT1lLmdyb3VwSWQsbj1pPj0wP3RoaXMuc3RvcmUuZ2V0R3JvdXBCeUlkKGkpOm51bGw7cmV0dXJuIHRoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5oaWdobGlnaHRJdGVtKSh0LCExKSksbiYmbi52YWx1ZT8oMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwidW5oaWdobGlnaHRJdGVtXCIse2lkOnQsdmFsdWU6ZS52YWx1ZSxsYWJlbDplLmxhYmVsLGdyb3VwVmFsdWU6bi52YWx1ZX0pOigwLHYudHJpZ2dlckV2ZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQsXCJ1bmhpZ2hsaWdodEl0ZW1cIix7aWQ6dCx2YWx1ZTplLnZhbHVlLGxhYmVsOmUubGFiZWx9KSx0aGlzfX0se2tleTpcImhpZ2hsaWdodEFsbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMuc3RvcmUuZ2V0SXRlbXMoKTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UuaGlnaGxpZ2h0SXRlbSh0KX0pLHRoaXN9fSx7a2V5OlwidW5oaWdobGlnaHRBbGxcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLnN0b3JlLmdldEl0ZW1zKCk7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtlLnVuaGlnaGxpZ2h0SXRlbSh0KX0pLHRoaXN9fSx7a2V5OlwicmVtb3ZlSXRlbXNCeVZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighZXx8ISgwLHYuaXNUeXBlKShcIlN0cmluZ1wiLGUpKXJldHVybiB0aGlzO3ZhciBpPXRoaXMuc3RvcmUuZ2V0SXRlbXNGaWx0ZXJlZEJ5QWN0aXZlKCk7cmV0dXJuIGkuZm9yRWFjaChmdW5jdGlvbihpKXtpLnZhbHVlPT09ZSYmdC5fcmVtb3ZlSXRlbShpKX0pLHRoaXN9fSx7a2V5OlwicmVtb3ZlQWN0aXZlSXRlbXNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGk9dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKTtyZXR1cm4gaS5mb3JFYWNoKGZ1bmN0aW9uKGkpe2kuYWN0aXZlJiZlIT09aS5pZCYmdC5fcmVtb3ZlSXRlbShpKX0pLHRoaXN9fSx7a2V5OlwicmVtb3ZlSGlnaGxpZ2h0ZWRJdGVtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0saT10aGlzLnN0b3JlLmdldEl0ZW1zRmlsdGVyZWRCeUFjdGl2ZSgpO3JldHVybiBpLmZvckVhY2goZnVuY3Rpb24oaSl7aS5oaWdobGlnaHRlZCYmaS5hY3RpdmUmJihlLl9yZW1vdmVJdGVtKGkpLHQmJmUuX3RyaWdnZXJDaGFuZ2UoaS52YWx1ZSkpfSksdGhpc319LHtrZXk6XCJzaG93RHJvcGRvd25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0sdD1kb2N1bWVudC5ib2R5LGk9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LG49TWF0aC5tYXgodC5zY3JvbGxIZWlnaHQsdC5vZmZzZXRIZWlnaHQsaS5jbGllbnRIZWlnaHQsaS5zY3JvbGxIZWlnaHQsaS5vZmZzZXRIZWlnaHQpO3RoaXMuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLm9wZW5TdGF0ZSksdGhpcy5jb250YWluZXJPdXRlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJ0cnVlXCIpLHRoaXMuZHJvcGRvd24uY2xhc3NMaXN0LmFkZCh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmFjdGl2ZVN0YXRlKSx0aGlzLmRyb3Bkb3duLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIixcInRydWVcIik7dmFyIHM9dGhpcy5kcm9wZG93bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxvPU1hdGguY2VpbChzLnRvcCt3aW5kb3cuc2Nyb2xsWSt0aGlzLmRyb3Bkb3duLm9mZnNldEhlaWdodCkscj0hMTtyZXR1cm5cImF1dG9cIj09PXRoaXMuY29uZmlnLnBvc2l0aW9uP3I9bz49bjpcInRvcFwiPT09dGhpcy5jb25maWcucG9zaXRpb24mJihyPSEwKSxyJiZ0aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb25maWcuY2xhc3NOYW1lcy5mbGlwcGVkU3RhdGUpLGUmJnRoaXMuY2FuU2VhcmNoJiZkb2N1bWVudC5hY3RpdmVFbGVtZW50IT09dGhpcy5pbnB1dCYmdGhpcy5pbnB1dC5mb2N1cygpLCgwLHYudHJpZ2dlckV2ZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQsXCJzaG93RHJvcGRvd25cIix7fSksdGhpc319LHtrZXk6XCJoaWRlRHJvcGRvd25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0sdD10aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmZsaXBwZWRTdGF0ZSk7cmV0dXJuIHRoaXMuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLm9wZW5TdGF0ZSksdGhpcy5jb250YWluZXJPdXRlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJmYWxzZVwiKSx0aGlzLmRyb3Bkb3duLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb25maWcuY2xhc3NOYW1lcy5hY3RpdmVTdGF0ZSksdGhpcy5kcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJmYWxzZVwiKSx0JiZ0aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb25maWcuY2xhc3NOYW1lcy5mbGlwcGVkU3RhdGUpLGUmJnRoaXMuY2FuU2VhcmNoJiZkb2N1bWVudC5hY3RpdmVFbGVtZW50PT09dGhpcy5pbnB1dCYmdGhpcy5pbnB1dC5ibHVyKCksKDAsdi50cmlnZ2VyRXZlbnQpKHRoaXMucGFzc2VkRWxlbWVudCxcImhpZGVEcm9wZG93blwiLHt9KSx0aGlzfX0se2tleTpcInRvZ2dsZURyb3Bkb3duXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmRyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmFjdGl2ZVN0YXRlKTtyZXR1cm4gZT90aGlzLmhpZGVEcm9wZG93bigpOnRoaXMuc2hvd0Ryb3Bkb3duKCEwKSx0aGlzfX0se2tleTpcImdldFZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXSxpPXRoaXMuc3RvcmUuZ2V0SXRlbXNGaWx0ZXJlZEJ5QWN0aXZlKCksbj1bXTtyZXR1cm4gaS5mb3JFYWNoKGZ1bmN0aW9uKGkpe2UuaXNUZXh0RWxlbWVudD9uLnB1c2godD9pLnZhbHVlOmkpOmkuYWN0aXZlJiZuLnB1c2godD9pLnZhbHVlOmkpfSksdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQ/blswXTpufX0se2tleTpcInNldFZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZih0aGlzLmluaXRpYWxpc2VkPT09ITApe3ZhciBpPVtdLmNvbmNhdChvKGUpKSxuPWZ1bmN0aW9uKGUpe3ZhciBpPSgwLHYuZ2V0VHlwZSkoZSk7aWYoXCJPYmplY3RcIj09PWkpe2lmKCFlLnZhbHVlKXJldHVybjt0LmlzVGV4dEVsZW1lbnQ/dC5fYWRkSXRlbShlLnZhbHVlLGUubGFiZWwsZS5pZCx2b2lkIDAsZS5jdXN0b21Qcm9wZXJ0aWVzLGUucGxhY2Vob2xkZXIpOnQuX2FkZENob2ljZShlLnZhbHVlLGUubGFiZWwsITAsITEsLTEsZS5jdXN0b21Qcm9wZXJ0aWVzLGUucGxhY2Vob2xkZXIpfWVsc2VcIlN0cmluZ1wiPT09aSYmKHQuaXNUZXh0RWxlbWVudD90Ll9hZGRJdGVtKGUpOnQuX2FkZENob2ljZShlLGUsITAsITEsLTEsbnVsbCkpfTtpLmxlbmd0aD4xP2kuZm9yRWFjaChmdW5jdGlvbihlKXtuKGUpfSk6bihpWzBdKX1yZXR1cm4gdGhpc319LHtrZXk6XCJzZXRWYWx1ZUJ5Q2hvaWNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighdGhpcy5pc1RleHRFbGVtZW50KXt2YXIgaT10aGlzLnN0b3JlLmdldENob2ljZXMoKSxuPSgwLHYuaXNUeXBlKShcIkFycmF5XCIsZSk/ZTpbZV07bi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPWkuZmluZChmdW5jdGlvbihpKXtyZXR1cm4gdC5jb25maWcuaXRlbUNvbXBhcmVyKGkudmFsdWUsZSl9KTtuP24uc2VsZWN0ZWQ/dC5jb25maWcuc2lsZW50fHxjb25zb2xlLndhcm4oXCJBdHRlbXB0aW5nIHRvIHNlbGVjdCBjaG9pY2UgYWxyZWFkeSBzZWxlY3RlZFwiKTp0Ll9hZGRJdGVtKG4udmFsdWUsbi5sYWJlbCxuLmlkLG4uZ3JvdXBJZCxuLmN1c3RvbVByb3BlcnRpZXMsbi5wbGFjZWhvbGRlcixuLmtleUNvZGUpOnQuY29uZmlnLnNpbGVudHx8Y29uc29sZS53YXJuKFwiQXR0ZW1wdGluZyB0byBzZWxlY3QgY2hvaWNlIHRoYXQgZG9lcyBub3QgZXhpc3RcIil9KX1yZXR1cm4gdGhpc319LHtrZXk6XCJzZXRDaG9pY2VzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LGkpe3ZhciBuPXRoaXMscz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdO2lmKHRoaXMuaW5pdGlhbGlzZWQ9PT0hMCYmdGhpcy5pc1NlbGVjdEVsZW1lbnQpe2lmKCEoMCx2LmlzVHlwZSkoXCJBcnJheVwiLGUpfHwhdClyZXR1cm4gdGhpcztzJiZ0aGlzLl9jbGVhckNob2ljZXMoKSx0aGlzLl9zZXRMb2FkaW5nKCEwKSxlJiZlLmxlbmd0aCYmKHRoaXMuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmxvYWRpbmdTdGF0ZSksZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuY2hvaWNlcz9uLl9hZGRHcm91cChlLGUuaWR8fG51bGwsdCxpKTpuLl9hZGRDaG9pY2UoZVt0XSxlW2ldLGUuc2VsZWN0ZWQsZS5kaXNhYmxlZCx2b2lkIDAsZS5jdXN0b21Qcm9wZXJ0aWVzLGUucGxhY2Vob2xkZXIpfSkpLHRoaXMuX3NldExvYWRpbmcoITEpfXJldHVybiB0aGlzfX0se2tleTpcImNsZWFyU3RvcmVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0b3JlLmRpc3BhdGNoKCgwLHAuY2xlYXJBbGwpKCkpLHRoaXN9fSx7a2V5OlwiY2xlYXJJbnB1dFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5wdXQudmFsdWUmJih0aGlzLmlucHV0LnZhbHVlPVwiXCIpLHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50fHx0aGlzLl9zZXRJbnB1dFdpZHRoKCksIXRoaXMuaXNUZXh0RWxlbWVudCYmdGhpcy5jb25maWcuc2VhcmNoRW5hYmxlZCYmKHRoaXMuaXNTZWFyY2hpbmc9ITEsdGhpcy5zdG9yZS5kaXNwYXRjaCgoMCxwLmFjdGl2YXRlQ2hvaWNlcykoITApKSksdGhpc319LHtrZXk6XCJlbmFibGVcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuaW5pdGlhbGlzZWQpe3RoaXMucGFzc2VkRWxlbWVudC5kaXNhYmxlZD0hMTt2YXIgZT10aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmRpc2FibGVkU3RhdGUpO2UmJih0aGlzLl9hZGRFdmVudExpc3RlbmVycygpLHRoaXMucGFzc2VkRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSx0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLHRoaXMuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmRpc2FibGVkU3RhdGUpLHRoaXMuY29udGFpbmVyT3V0ZXIucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiKSx0aGlzLmlzU2VsZWN0T25lRWxlbWVudCYmdGhpcy5jb250YWluZXJPdXRlci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFwiMFwiKSl9cmV0dXJuIHRoaXN9fSx7a2V5OlwiZGlzYWJsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5pbml0aWFsaXNlZCl7dGhpcy5wYXNzZWRFbGVtZW50LmRpc2FibGVkPSEwO3ZhciBlPSF0aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmRpc2FibGVkU3RhdGUpO2UmJih0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpLHRoaXMucGFzc2VkRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLFwiXCIpLHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIixcIlwiKSx0aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb25maWcuY2xhc3NOYW1lcy5kaXNhYmxlZFN0YXRlKSx0aGlzLmNvbnRhaW5lck91dGVyLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIiksdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQmJnRoaXMuY29udGFpbmVyT3V0ZXIuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcIi0xXCIpKX1yZXR1cm4gdGhpc319LHtrZXk6XCJhamF4XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGhpcy5pbml0aWFsaXNlZD09PSEwJiZ0aGlzLmlzU2VsZWN0RWxlbWVudCYmKHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe3QuX2hhbmRsZUxvYWRpbmdTdGF0ZSghMCl9KSxlKHRoaXMuX2FqYXhDYWxsYmFjaygpKSksdGhpc319LHtrZXk6XCJfdHJpZ2dlckNoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2UmJigwLHYudHJpZ2dlckV2ZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQsXCJjaGFuZ2VcIix7dmFsdWU6ZX0pfX0se2tleTpcIl9oYW5kbGVCdXR0b25BY3Rpb25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKGUmJnQmJnRoaXMuY29uZmlnLnJlbW92ZUl0ZW1zJiZ0aGlzLmNvbmZpZy5yZW1vdmVJdGVtQnV0dG9uKXt2YXIgaT10LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiKSxuPWUuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PXBhcnNlSW50KGksMTApfSk7dGhpcy5fcmVtb3ZlSXRlbShuKSx0aGlzLl90cmlnZ2VyQ2hhbmdlKG4udmFsdWUpLHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50JiZ0aGlzLl9zZWxlY3RQbGFjZWhvbGRlckNob2ljZSgpfX19LHtrZXk6XCJfc2VsZWN0UGxhY2Vob2xkZXJDaG9pY2VcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuc3RvcmUuZ2V0UGxhY2Vob2xkZXJDaG9pY2UoKTtlJiYodGhpcy5fYWRkSXRlbShlLnZhbHVlLGUubGFiZWwsZS5pZCxlLmdyb3VwSWQsbnVsbCxlLnBsYWNlaG9sZGVyKSx0aGlzLl90cmlnZ2VyQ2hhbmdlKGUudmFsdWUpKX19LHtrZXk6XCJfaGFuZGxlSXRlbUFjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07aWYoZSYmdCYmdGhpcy5jb25maWcucmVtb3ZlSXRlbXMmJiF0aGlzLmlzU2VsZWN0T25lRWxlbWVudCl7dmFyIHM9dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpO2UuZm9yRWFjaChmdW5jdGlvbihlKXtlLmlkIT09cGFyc2VJbnQocywxMCl8fGUuaGlnaGxpZ2h0ZWQ/bnx8ZS5oaWdobGlnaHRlZCYmaS51bmhpZ2hsaWdodEl0ZW0oZSk6aS5oaWdobGlnaHRJdGVtKGUpfSksZG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9PXRoaXMuaW5wdXQmJnRoaXMuaW5wdXQuZm9jdXMoKX19fSx7a2V5OlwiX2hhbmRsZUNob2ljZUFjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoZSYmdCl7dmFyIGk9dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpLG49dGhpcy5zdG9yZS5nZXRDaG9pY2VCeUlkKGkpLHM9ZVswXSYmZVswXS5rZXlDb2RlP2VbMF0ua2V5Q29kZTpudWxsLG89dGhpcy5kcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jb25maWcuY2xhc3NOYW1lcy5hY3RpdmVTdGF0ZSk7aWYobi5rZXlDb2RlPXMsKDAsdi50cmlnZ2VyRXZlbnQpKHRoaXMucGFzc2VkRWxlbWVudCxcImNob2ljZVwiLHtjaG9pY2U6bn0pLG4mJiFuLnNlbGVjdGVkJiYhbi5kaXNhYmxlZCl7dmFyIHI9dGhpcy5fY2FuQWRkSXRlbShlLG4udmFsdWUpO3IucmVzcG9uc2UmJih0aGlzLl9hZGRJdGVtKG4udmFsdWUsbi5sYWJlbCxuLmlkLG4uZ3JvdXBJZCxuLmN1c3RvbVByb3BlcnRpZXMsbi5wbGFjZWhvbGRlcixuLmtleUNvZGUpLHRoaXMuX3RyaWdnZXJDaGFuZ2Uobi52YWx1ZSkpfXRoaXMuY2xlYXJJbnB1dCgpLG8mJnRoaXMuaXNTZWxlY3RPbmVFbGVtZW50JiYodGhpcy5oaWRlRHJvcGRvd24oKSx0aGlzLmNvbnRhaW5lck91dGVyLmZvY3VzKCkpfX19LHtrZXk6XCJfaGFuZGxlQmFja3NwYWNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYodGhpcy5jb25maWcucmVtb3ZlSXRlbXMmJmUpe3ZhciB0PWVbZS5sZW5ndGgtMV0saT1lLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaGlnaGxpZ2h0ZWR9KTt0aGlzLmNvbmZpZy5lZGl0SXRlbXMmJiFpJiZ0Pyh0aGlzLmlucHV0LnZhbHVlPXQudmFsdWUsdGhpcy5fc2V0SW5wdXRXaWR0aCgpLHRoaXMuX3JlbW92ZUl0ZW0odCksdGhpcy5fdHJpZ2dlckNoYW5nZSh0LnZhbHVlKSk6KGl8fHRoaXMuaGlnaGxpZ2h0SXRlbSh0LCExKSx0aGlzLnJlbW92ZUhpZ2hsaWdodGVkSXRlbXMoITApKX19fSx7a2V5OlwiX2NhbkFkZEl0ZW1cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpPSEwLG49KDAsdi5pc1R5cGUpKFwiRnVuY3Rpb25cIix0aGlzLmNvbmZpZy5hZGRJdGVtVGV4dCk/dGhpcy5jb25maWcuYWRkSXRlbVRleHQodCk6dGhpcy5jb25maWcuYWRkSXRlbVRleHQ7KHRoaXMuaXNTZWxlY3RNdWx0aXBsZUVsZW1lbnR8fHRoaXMuaXNUZXh0RWxlbWVudCkmJnRoaXMuY29uZmlnLm1heEl0ZW1Db3VudD4wJiZ0aGlzLmNvbmZpZy5tYXhJdGVtQ291bnQ8PWUubGVuZ3RoJiYoaT0hMSxuPSgwLHYuaXNUeXBlKShcIkZ1bmN0aW9uXCIsdGhpcy5jb25maWcubWF4SXRlbVRleHQpP3RoaXMuY29uZmlnLm1heEl0ZW1UZXh0KHRoaXMuY29uZmlnLm1heEl0ZW1Db3VudCk6dGhpcy5jb25maWcubWF4SXRlbVRleHQpLHRoaXMuaXNUZXh0RWxlbWVudCYmdGhpcy5jb25maWcuYWRkSXRlbXMmJmkmJnRoaXMuY29uZmlnLnJlZ2V4RmlsdGVyJiYoaT10aGlzLl9yZWdleEZpbHRlcih0KSk7dmFyIHM9IWUuc29tZShmdW5jdGlvbihlKXtyZXR1cm4oMCx2LmlzVHlwZSkoXCJTdHJpbmdcIix0KT9lLnZhbHVlPT09dC50cmltKCk6ZS52YWx1ZT09PXR9KTtyZXR1cm4gc3x8dGhpcy5jb25maWcuZHVwbGljYXRlSXRlbXN8fHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50fHwhaXx8KGk9ITEsbj0oMCx2LmlzVHlwZSkoXCJGdW5jdGlvblwiLHRoaXMuY29uZmlnLnVuaXF1ZUl0ZW1UZXh0KT90aGlzLmNvbmZpZy51bmlxdWVJdGVtVGV4dCh0KTp0aGlzLmNvbmZpZy51bmlxdWVJdGVtVGV4dCkse3Jlc3BvbnNlOmksbm90aWNlOm59fX0se2tleTpcIl9oYW5kbGVMb2FkaW5nU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0pfHxhcmd1bWVudHNbMF0sdD10aGlzLml0ZW1MaXN0LnF1ZXJ5U2VsZWN0b3IoXCIuXCIrdGhpcy5jb25maWcuY2xhc3NOYW1lcy5wbGFjZWhvbGRlcik7ZT8odGhpcy5jb250YWluZXJPdXRlci5jbGFzc0xpc3QuYWRkKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMubG9hZGluZ1N0YXRlKSx0aGlzLmNvbnRhaW5lck91dGVyLnNldEF0dHJpYnV0ZShcImFyaWEtYnVzeVwiLFwidHJ1ZVwiKSx0aGlzLmlzU2VsZWN0T25lRWxlbWVudD90P3QuaW5uZXJIVE1MPXRoaXMuY29uZmlnLmxvYWRpbmdUZXh0Oih0PXRoaXMuX2dldFRlbXBsYXRlKFwicGxhY2Vob2xkZXJcIix0aGlzLmNvbmZpZy5sb2FkaW5nVGV4dCksdGhpcy5pdGVtTGlzdC5hcHBlbmRDaGlsZCh0KSk6dGhpcy5pbnB1dC5wbGFjZWhvbGRlcj10aGlzLmNvbmZpZy5sb2FkaW5nVGV4dCk6KHRoaXMuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmxvYWRpbmdTdGF0ZSksdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQ/dC5pbm5lckhUTUw9dGhpcy5wbGFjZWhvbGRlcnx8XCJcIjp0aGlzLmlucHV0LnBsYWNlaG9sZGVyPXRoaXMucGxhY2Vob2xkZXJ8fFwiXCIpfX0se2tleTpcIl9hamF4Q2FsbGJhY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHQsaSxuKXtpZih0JiZpKXt2YXIgcz0oMCx2LmlzVHlwZSkoXCJPYmplY3RcIix0KT9bdF06dDtzJiYoMCx2LmlzVHlwZSkoXCJBcnJheVwiLHMpJiZzLmxlbmd0aD8oZS5faGFuZGxlTG9hZGluZ1N0YXRlKCExKSxlLl9zZXRMb2FkaW5nKCEwKSxzLmZvckVhY2goZnVuY3Rpb24odCl7aWYodC5jaG9pY2VzKXt2YXIgcz10LmlkfHxudWxsO2UuX2FkZEdyb3VwKHQscyxpLG4pfWVsc2UgZS5fYWRkQ2hvaWNlKHRbaV0sdFtuXSx0LnNlbGVjdGVkLHQuZGlzYWJsZWQsdm9pZCAwLHQuY3VzdG9tUHJvcGVydGllcyx0LnBsYWNlaG9sZGVyKX0pLGUuX3NldExvYWRpbmcoITEpLGUuaXNTZWxlY3RPbmVFbGVtZW50JiZlLl9zZWxlY3RQbGFjZWhvbGRlckNob2ljZSgpKTplLl9oYW5kbGVMb2FkaW5nU3RhdGUoITEpLGUuY29udGFpbmVyT3V0ZXIucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1idXN5XCIpfX19fSx7a2V5OlwiX3NlYXJjaENob2ljZXNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0oMCx2LmlzVHlwZSkoXCJTdHJpbmdcIixlKT9lLnRyaW0oKTplLGk9KDAsdi5pc1R5cGUpKFwiU3RyaW5nXCIsdGhpcy5jdXJyZW50VmFsdWUpP3RoaXMuY3VycmVudFZhbHVlLnRyaW0oKTp0aGlzLmN1cnJlbnRWYWx1ZTtpZih0Lmxlbmd0aD49MSYmdCE9PWkrXCIgXCIpe3ZhciBuPXRoaXMuc3RvcmUuZ2V0U2VhcmNoYWJsZUNob2ljZXMoKSxzPXQsbz0oMCx2LmlzVHlwZSkoXCJBcnJheVwiLHRoaXMuY29uZmlnLnNlYXJjaEZpZWxkcyk/dGhpcy5jb25maWcuc2VhcmNoRmllbGRzOlt0aGlzLmNvbmZpZy5zZWFyY2hGaWVsZHNdLHI9T2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZy5mdXNlT3B0aW9ucyx7a2V5czpvfSksYT1uZXcgbC5kZWZhdWx0KG4sciksYz1hLnNlYXJjaChzKTtyZXR1cm4gdGhpcy5jdXJyZW50VmFsdWU9dCx0aGlzLmhpZ2hsaWdodFBvc2l0aW9uPTAsdGhpcy5pc1NlYXJjaGluZz0hMCx0aGlzLnN0b3JlLmRpc3BhdGNoKCgwLHAuZmlsdGVyQ2hvaWNlcykoYykpLGMubGVuZ3RofXJldHVybiAwfX0se2tleTpcIl9oYW5kbGVTZWFyY2hcIix2YWx1ZTpmdW5jdGlvbihlKXtpZihlKXt2YXIgdD10aGlzLnN0b3JlLmdldENob2ljZXMoKSxpPXQuc29tZShmdW5jdGlvbihlKXtyZXR1cm4hZS5hY3RpdmV9KTtpZih0aGlzLmlucHV0PT09ZG9jdW1lbnQuYWN0aXZlRWxlbWVudClpZihlJiZlLmxlbmd0aD49dGhpcy5jb25maWcuc2VhcmNoRmxvb3Ipe3ZhciBuPTA7dGhpcy5jb25maWcuc2VhcmNoQ2hvaWNlcyYmKG49dGhpcy5fc2VhcmNoQ2hvaWNlcyhlKSksKDAsdi50cmlnZ2VyRXZlbnQpKHRoaXMucGFzc2VkRWxlbWVudCxcInNlYXJjaFwiLHt2YWx1ZTplLHJlc3VsdENvdW50Om59KX1lbHNlIGkmJih0aGlzLmlzU2VhcmNoaW5nPSExLHRoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5hY3RpdmF0ZUNob2ljZXMpKCEwKSkpfX19LHtrZXk6XCJfYWRkRXZlbnRMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbigpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLHRoaXMuX29uS2V5VXApLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5fb25LZXlEb3duKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9vbkNsaWNrKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5fb25Ub3VjaE1vdmUpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMuX29uVG91Y2hFbmQpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLl9vbk1vdXNlRG93biksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLHRoaXMuX29uTW91c2VPdmVyKSx0aGlzLmlzU2VsZWN0T25lRWxlbWVudCYmKHRoaXMuY29udGFpbmVyT3V0ZXIuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5fb25Gb2N1cyksdGhpcy5jb250YWluZXJPdXRlci5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMuX29uQmx1cikpLHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsdGhpcy5fb25JbnB1dCksdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIix0aGlzLl9vblBhc3RlKSx0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuX29uRm9jdXMpLHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLl9vbkJsdXIpfX0se2tleTpcIl9yZW1vdmVFdmVudExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5fb25LZXlVcCksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLl9vbktleURvd24pLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX29uQ2xpY2spLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5fb25Ub3VjaEVuZCksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsdGhpcy5fb25Nb3VzZU92ZXIpLHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50JiYodGhpcy5jb250YWluZXJPdXRlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLl9vbkZvY3VzKSx0aGlzLmNvbnRhaW5lck91dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5fb25CbHVyKSksdGhpcy5pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIix0aGlzLl9vbklucHV0KSx0aGlzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLHRoaXMuX29uUGFzdGUpLHRoaXMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5fb25Gb2N1cyksdGhpcy5pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMuX29uQmx1cil9fSx7a2V5OlwiX3NldElucHV0V2lkdGhcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGxhY2Vob2xkZXI/dGhpcy5pbnB1dC52YWx1ZSYmdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGg+PXRoaXMucGxhY2Vob2xkZXIubGVuZ3RoLzEuMjUmJih0aGlzLmlucHV0LnN0eWxlLndpZHRoPSgwLHYuZ2V0V2lkdGhPZklucHV0KSh0aGlzLmlucHV0KSk6dGhpcy5pbnB1dC5zdHlsZS53aWR0aD0oMCx2LmdldFdpZHRoT2ZJbnB1dCkodGhpcy5pbnB1dCl9fSx7a2V5OlwiX29uS2V5RG93blwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0LGk9dGhpcztpZihlLnRhcmdldD09PXRoaXMuaW5wdXR8fHRoaXMuY29udGFpbmVyT3V0ZXIuY29udGFpbnMoZS50YXJnZXQpKXt2YXIgbj1lLnRhcmdldCxvPXRoaXMuc3RvcmUuZ2V0SXRlbXNGaWx0ZXJlZEJ5QWN0aXZlKCkscj10aGlzLmlucHV0PT09ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxhPXRoaXMuZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuYWN0aXZlU3RhdGUpLGM9dGhpcy5pdGVtTGlzdCYmdGhpcy5pdGVtTGlzdC5jaGlsZHJlbixsPVN0cmluZy5mcm9tQ2hhckNvZGUoZS5rZXlDb2RlKSxoPTQ2LHU9OCxkPTEzLGY9NjUscD0yNyxtPTM4LGc9NDAseT0zMyxiPTM0LEU9ZS5jdHJsS2V5fHxlLm1ldGFLZXk7dGhpcy5pc1RleHRFbGVtZW50fHwhL1thLXpBLVowLTktXyBdLy50ZXN0KGwpfHxhfHx0aGlzLnNob3dEcm9wZG93bighMCksdGhpcy5jYW5TZWFyY2g9dGhpcy5jb25maWcuc2VhcmNoRW5hYmxlZDt2YXIgXz1mdW5jdGlvbigpe0UmJmMmJihpLmNhblNlYXJjaD0hMSxpLmNvbmZpZy5yZW1vdmVJdGVtcyYmIWkuaW5wdXQudmFsdWUmJmkuaW5wdXQ9PT1kb2N1bWVudC5hY3RpdmVFbGVtZW50JiZpLmhpZ2hsaWdodEFsbCgpKX0sUz1mdW5jdGlvbigpe2lmKGkuaXNUZXh0RWxlbWVudCYmbi52YWx1ZSl7dmFyIHQ9aS5pbnB1dC52YWx1ZSxzPWkuX2NhbkFkZEl0ZW0obyx0KTtzLnJlc3BvbnNlJiYoYSYmaS5oaWRlRHJvcGRvd24oKSxpLl9hZGRJdGVtKHQpLGkuX3RyaWdnZXJDaGFuZ2UodCksaS5jbGVhcklucHV0KCkpfWlmKG4uaGFzQXR0cmlidXRlKFwiZGF0YS1idXR0b25cIikmJihpLl9oYW5kbGVCdXR0b25BY3Rpb24obyxuKSxlLnByZXZlbnREZWZhdWx0KCkpLGEpe2UucHJldmVudERlZmF1bHQoKTt2YXIgcj1pLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoXCIuXCIraS5jb25maWcuY2xhc3NOYW1lcy5oaWdobGlnaHRlZFN0YXRlKTtyJiYob1swXSYmKG9bMF0ua2V5Q29kZT1kKSxpLl9oYW5kbGVDaG9pY2VBY3Rpb24obyxyKSl9ZWxzZSBpLmlzU2VsZWN0T25lRWxlbWVudCYmKGF8fChpLnNob3dEcm9wZG93bighMCksZS5wcmV2ZW50RGVmYXVsdCgpKSl9LEk9ZnVuY3Rpb24oKXthJiYoaS50b2dnbGVEcm9wZG93bigpLGkuY29udGFpbmVyT3V0ZXIuZm9jdXMoKSl9LHc9ZnVuY3Rpb24oKXtpZihhfHxpLmlzU2VsZWN0T25lRWxlbWVudCl7YXx8aS5zaG93RHJvcGRvd24oITApLGkuY2FuU2VhcmNoPSExO3ZhciB0PWUua2V5Q29kZT09PWd8fGUua2V5Q29kZT09PWI/MTotMSxuPWUubWV0YUtleXx8ZS5rZXlDb2RlPT09Ynx8ZS5rZXlDb2RlPT09eSxzPXZvaWQgMDtpZihuKXM9dD4wP0FycmF5LmZyb20oaS5kcm9wZG93bi5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtY2hvaWNlLXNlbGVjdGFibGVdXCIpKS5wb3AoKTppLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1jaG9pY2Utc2VsZWN0YWJsZV1cIik7ZWxzZXt2YXIgbz1pLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoXCIuXCIraS5jb25maWcuY2xhc3NOYW1lcy5oaWdobGlnaHRlZFN0YXRlKTtzPW8/KDAsdi5nZXRBZGphY2VudEVsKShvLFwiW2RhdGEtY2hvaWNlLXNlbGVjdGFibGVdXCIsdCk6aS5kcm9wZG93bi5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtY2hvaWNlLXNlbGVjdGFibGVdXCIpfXMmJigoMCx2LmlzU2Nyb2xsZWRJbnRvVmlldykocyxpLmNob2ljZUxpc3QsdCl8fGkuX3Njcm9sbFRvQ2hvaWNlKHMsdCksaS5faGlnaGxpZ2h0Q2hvaWNlKHMpKSxlLnByZXZlbnREZWZhdWx0KCl9fSxUPWZ1bmN0aW9uKCl7IXJ8fGUudGFyZ2V0LnZhbHVlfHxpLmlzU2VsZWN0T25lRWxlbWVudHx8KGkuX2hhbmRsZUJhY2tzcGFjZShvKSxlLnByZXZlbnREZWZhdWx0KCkpfSxDPSh0PXt9LHModCxmLF8pLHModCxkLFMpLHModCxwLEkpLHModCxtLHcpLHModCx5LHcpLHModCxnLHcpLHModCxiLHcpLHModCx1LFQpLHModCxoLFQpLHQpO0NbZS5rZXlDb2RlXSYmQ1tlLmtleUNvZGVdKCl9fX0se2tleTpcIl9vbktleVVwXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoZS50YXJnZXQ9PT10aGlzLmlucHV0KXt2YXIgdD10aGlzLmlucHV0LnZhbHVlLGk9dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKSxuPXRoaXMuX2NhbkFkZEl0ZW0oaSx0KTtpZih0aGlzLmlzVGV4dEVsZW1lbnQpe3ZhciBzPXRoaXMuZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuYWN0aXZlU3RhdGUpO2lmKHQpe2lmKG4ubm90aWNlKXt2YXIgbz10aGlzLl9nZXRUZW1wbGF0ZShcIm5vdGljZVwiLG4ubm90aWNlKTt0aGlzLmRyb3Bkb3duLmlubmVySFRNTD1vLm91dGVySFRNTH1uLnJlc3BvbnNlPT09ITA/c3x8dGhpcy5zaG93RHJvcGRvd24oKTohbi5ub3RpY2UmJnMmJnRoaXMuaGlkZURyb3Bkb3duKCl9ZWxzZSBzJiZ0aGlzLmhpZGVEcm9wZG93bigpfWVsc2V7dmFyIHI9NDYsYT04O2Uua2V5Q29kZSE9PXImJmUua2V5Q29kZSE9PWF8fGUudGFyZ2V0LnZhbHVlP3RoaXMuY2FuU2VhcmNoJiZuLnJlc3BvbnNlJiZ0aGlzLl9oYW5kbGVTZWFyY2godGhpcy5pbnB1dC52YWx1ZSk6IXRoaXMuaXNUZXh0RWxlbWVudCYmdGhpcy5pc1NlYXJjaGluZyYmKHRoaXMuaXNTZWFyY2hpbmc9ITEsdGhpcy5zdG9yZS5kaXNwYXRjaCgoMCxwLmFjdGl2YXRlQ2hvaWNlcykoITApKSl9dGhpcy5jYW5TZWFyY2g9dGhpcy5jb25maWcuc2VhcmNoRW5hYmxlZH19fSx7a2V5OlwiX29uSW5wdXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaXNTZWxlY3RPbmVFbGVtZW50fHx0aGlzLl9zZXRJbnB1dFdpZHRoKCl9fSx7a2V5OlwiX29uVG91Y2hNb3ZlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLndhc1RhcD09PSEwJiYodGhpcy53YXNUYXA9ITEpfX0se2tleTpcIl9vblRvdWNoRW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50YXJnZXR8fGUudG91Y2hlc1swXS50YXJnZXQsaT10aGlzLmRyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmFjdGl2ZVN0YXRlKTt0aGlzLndhc1RhcD09PSEwJiZ0aGlzLmNvbnRhaW5lck91dGVyLmNvbnRhaW5zKHQpJiYodCE9PXRoaXMuY29udGFpbmVyT3V0ZXImJnQhPT10aGlzLmNvbnRhaW5lcklubmVyfHx0aGlzLmlzU2VsZWN0T25lRWxlbWVudHx8KHRoaXMuaXNUZXh0RWxlbWVudD9kb2N1bWVudC5hY3RpdmVFbGVtZW50IT09dGhpcy5pbnB1dCYmdGhpcy5pbnB1dC5mb2N1cygpOml8fHRoaXMuc2hvd0Ryb3Bkb3duKCEwKSksZS5zdG9wUHJvcGFnYXRpb24oKSksdGhpcy53YXNUYXA9ITB9fSx7a2V5OlwiX29uTW91c2VEb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50YXJnZXQ7aWYodD09PXRoaXMuY2hvaWNlTGlzdCYmdGhpcy5pc0llMTEmJih0aGlzLmlzU2Nyb2xsaW5nT25JZT0hMCksdGhpcy5jb250YWluZXJPdXRlci5jb250YWlucyh0KSYmdCE9PXRoaXMuaW5wdXQpe3ZhciBpPXZvaWQgMCxuPXRoaXMuc3RvcmUuZ2V0SXRlbXNGaWx0ZXJlZEJ5QWN0aXZlKCkscz1lLnNoaWZ0S2V5OyhpPSgwLHYuZmluZEFuY2VzdG9yQnlBdHRyTmFtZSkodCxcImRhdGEtYnV0dG9uXCIpKT90aGlzLl9oYW5kbGVCdXR0b25BY3Rpb24obixpKTooaT0oMCx2LmZpbmRBbmNlc3RvckJ5QXR0ck5hbWUpKHQsXCJkYXRhLWl0ZW1cIikpP3RoaXMuX2hhbmRsZUl0ZW1BY3Rpb24obixpLHMpOihpPSgwLHYuZmluZEFuY2VzdG9yQnlBdHRyTmFtZSkodCxcImRhdGEtY2hvaWNlXCIpKSYmdGhpcy5faGFuZGxlQ2hvaWNlQWN0aW9uKG4saSksZS5wcmV2ZW50RGVmYXVsdCgpfX19LHtrZXk6XCJfb25DbGlja1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudGFyZ2V0LGk9dGhpcy5kcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jb25maWcuY2xhc3NOYW1lcy5hY3RpdmVTdGF0ZSksbj10aGlzLnN0b3JlLmdldEl0ZW1zRmlsdGVyZWRCeUFjdGl2ZSgpO2lmKHRoaXMuY29udGFpbmVyT3V0ZXIuY29udGFpbnModCkpdC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWJ1dHRvblwiKSYmdGhpcy5faGFuZGxlQnV0dG9uQWN0aW9uKG4sdCksaT90aGlzLmlzU2VsZWN0T25lRWxlbWVudCYmdCE9PXRoaXMuaW5wdXQmJiF0aGlzLmRyb3Bkb3duLmNvbnRhaW5zKHQpJiZ0aGlzLmhpZGVEcm9wZG93bighMCk6dGhpcy5pc1RleHRFbGVtZW50P2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPT10aGlzLmlucHV0JiZ0aGlzLmlucHV0LmZvY3VzKCk6dGhpcy5jYW5TZWFyY2g/dGhpcy5zaG93RHJvcGRvd24oITApOih0aGlzLnNob3dEcm9wZG93bigpLHRoaXMuY29udGFpbmVyT3V0ZXIuZm9jdXMoKSk7ZWxzZXt2YXIgcz1uLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaGlnaGxpZ2h0ZWR9KTtzJiZ0aGlzLnVuaGlnaGxpZ2h0QWxsKCksdGhpcy5jb250YWluZXJPdXRlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuZm9jdXNTdGF0ZSksaSYmdGhpcy5oaWRlRHJvcGRvd24oKX19fSx7a2V5OlwiX29uTW91c2VPdmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7KGUudGFyZ2V0PT09dGhpcy5kcm9wZG93bnx8dGhpcy5kcm9wZG93bi5jb250YWlucyhlLnRhcmdldCkpJiZlLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWNob2ljZVwiKSYmdGhpcy5faGlnaGxpZ2h0Q2hvaWNlKGUudGFyZ2V0KX19LHtrZXk6XCJfb25QYXN0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2UudGFyZ2V0IT09dGhpcy5pbnB1dHx8dGhpcy5jb25maWcucGFzdGV8fGUucHJldmVudERlZmF1bHQoKX19LHtrZXk6XCJfb25Gb2N1c1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsaT1lLnRhcmdldDtpZih0aGlzLmNvbnRhaW5lck91dGVyLmNvbnRhaW5zKGkpKXt2YXIgbj10aGlzLmRyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmFjdGl2ZVN0YXRlKSxzPXt0ZXh0OmZ1bmN0aW9uKCl7aT09PXQuaW5wdXQmJnQuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LmFkZCh0LmNvbmZpZy5jbGFzc05hbWVzLmZvY3VzU3RhdGUpfSxcInNlbGVjdC1vbmVcIjpmdW5jdGlvbigpe3QuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LmFkZCh0LmNvbmZpZy5jbGFzc05hbWVzLmZvY3VzU3RhdGUpLGk9PT10LmlucHV0JiYobnx8dC5zaG93RHJvcGRvd24oKSl9LFwic2VsZWN0LW11bHRpcGxlXCI6ZnVuY3Rpb24oKXtpPT09dC5pbnB1dCYmKHQuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LmFkZCh0LmNvbmZpZy5jbGFzc05hbWVzLmZvY3VzU3RhdGUpLG58fHQuc2hvd0Ryb3Bkb3duKCEwKSl9fTtzW3RoaXMucGFzc2VkRWxlbWVudC50eXBlXSgpfX19LHtrZXk6XCJfb25CbHVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxpPWUudGFyZ2V0O2lmKHRoaXMuY29udGFpbmVyT3V0ZXIuY29udGFpbnMoaSkmJiF0aGlzLmlzU2Nyb2xsaW5nT25JZSl7dmFyIG49dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKSxzPXRoaXMuZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuYWN0aXZlU3RhdGUpLG89bi5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBlLmhpZ2hsaWdodGVkfSkscj17dGV4dDpmdW5jdGlvbigpe2k9PT10LmlucHV0JiYodC5jb250YWluZXJPdXRlci5jbGFzc0xpc3QucmVtb3ZlKHQuY29uZmlnLmNsYXNzTmFtZXMuZm9jdXNTdGF0ZSksbyYmdC51bmhpZ2hsaWdodEFsbCgpLHMmJnQuaGlkZURyb3Bkb3duKCkpfSxcInNlbGVjdC1vbmVcIjpmdW5jdGlvbigpe3QuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LnJlbW92ZSh0LmNvbmZpZy5jbGFzc05hbWVzLmZvY3VzU3RhdGUpLGk9PT10LmNvbnRhaW5lck91dGVyJiZzJiYhdC5jYW5TZWFyY2gmJnQuaGlkZURyb3Bkb3duKCksaT09PXQuaW5wdXQmJnMmJnQuaGlkZURyb3Bkb3duKCl9LFwic2VsZWN0LW11bHRpcGxlXCI6ZnVuY3Rpb24oKXtpPT09dC5pbnB1dCYmKHQuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LnJlbW92ZSh0LmNvbmZpZy5jbGFzc05hbWVzLmZvY3VzU3RhdGUpLHMmJnQuaGlkZURyb3Bkb3duKCksbyYmdC51bmhpZ2hsaWdodEFsbCgpKX19O3JbdGhpcy5wYXNzZWRFbGVtZW50LnR5cGVdKCl9ZWxzZSB0aGlzLmlzU2Nyb2xsaW5nT25JZT0hMSx0aGlzLmlucHV0LmZvY3VzKCl9fSx7a2V5OlwiX3JlZ2V4RmlsdGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuITE7dmFyIHQ9dGhpcy5jb25maWcucmVnZXhGaWx0ZXIsaT1uZXcgUmVnRXhwKHQuc291cmNlLFwiaVwiKTtyZXR1cm4gaS50ZXN0KGUpfX0se2tleTpcIl9zY3JvbGxUb0Nob2ljZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9dGhpcztpZihlKXt2YXIgbj10aGlzLmNob2ljZUxpc3Qub2Zmc2V0SGVpZ2h0LHM9ZS5vZmZzZXRIZWlnaHQsbz1lLm9mZnNldFRvcCtzLHI9dGhpcy5jaG9pY2VMaXN0LnNjcm9sbFRvcCtuLGE9dD4wP3RoaXMuY2hvaWNlTGlzdC5zY3JvbGxUb3Arby1yOmUub2Zmc2V0VG9wLGM9ZnVuY3Rpb24gZSgpe3ZhciBuPTQscz1pLmNob2ljZUxpc3Quc2Nyb2xsVG9wLG89ITEscj12b2lkIDAsYz12b2lkIDA7dD4wPyhyPShhLXMpL24sYz1yPjE/cjoxLGkuY2hvaWNlTGlzdC5zY3JvbGxUb3A9cytjLHM8YSYmKG89ITApKToocj0ocy1hKS9uLGM9cj4xP3I6MSxpLmNob2ljZUxpc3Quc2Nyb2xsVG9wPXMtYyxzPmEmJihvPSEwKSksbyYmcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKGkpe2UoaSxhLHQpfSl9O3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbihlKXtjKGUsYSx0KX0pfX19LHtrZXk6XCJfaGlnaGxpZ2h0Q2hvaWNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOm51bGwsaT1BcnJheS5mcm9tKHRoaXMuZHJvcGRvd24ucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWNob2ljZS1zZWxlY3RhYmxlXVwiKSksbj10O2lmKGkmJmkubGVuZ3RoKXt2YXIgcz1BcnJheS5mcm9tKHRoaXMuZHJvcGRvd24ucXVlcnlTZWxlY3RvckFsbChcIi5cIit0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmhpZ2hsaWdodGVkU3RhdGUpKTtzLmZvckVhY2goZnVuY3Rpb24odCl7dC5jbGFzc0xpc3QucmVtb3ZlKGUuY29uZmlnLmNsYXNzTmFtZXMuaGlnaGxpZ2h0ZWRTdGF0ZSksdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsXCJmYWxzZVwiKX0pLG4/dGhpcy5oaWdobGlnaHRQb3NpdGlvbj1pLmluZGV4T2Yobik6KG49aS5sZW5ndGg+dGhpcy5oaWdobGlnaHRQb3NpdGlvbj9pW3RoaXMuaGlnaGxpZ2h0UG9zaXRpb25dOmlbaS5sZW5ndGgtMV0sbnx8KG49aVswXSkpLG4uY2xhc3NMaXN0LmFkZCh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmhpZ2hsaWdodGVkU3RhdGUpLG4uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLFwidHJ1ZVwiKSx0aGlzLmNvbnRhaW5lck91dGVyLnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLG4uaWQpfX19LHtrZXk6XCJfYWRkSXRlbVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpudWxsLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOi0xLG49YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOi0xLHM9YXJndW1lbnRzLmxlbmd0aD40JiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOm51bGwsbz1hcmd1bWVudHMubGVuZ3RoPjUmJnZvaWQgMCE9PWFyZ3VtZW50c1s1XSYmYXJndW1lbnRzWzVdLHI9YXJndW1lbnRzLmxlbmd0aD42JiZ2b2lkIDAhPT1hcmd1bWVudHNbNl0/YXJndW1lbnRzWzZdOm51bGwsYT0oMCx2LmlzVHlwZSkoXCJTdHJpbmdcIixlKT9lLnRyaW0oKTplLGM9cixsPXRoaXMuc3RvcmUuZ2V0SXRlbXMoKSxoPXR8fGEsdT1wYXJzZUludChpLDEwKXx8LTEsZD1uPj0wP3RoaXMuc3RvcmUuZ2V0R3JvdXBCeUlkKG4pOm51bGwsZj1sP2wubGVuZ3RoKzE6MTtyZXR1cm4gdGhpcy5jb25maWcucHJlcGVuZFZhbHVlJiYoYT10aGlzLmNvbmZpZy5wcmVwZW5kVmFsdWUrYS50b1N0cmluZygpKSx0aGlzLmNvbmZpZy5hcHBlbmRWYWx1ZSYmKGErPXRoaXMuY29uZmlnLmFwcGVuZFZhbHVlLnRvU3RyaW5nKCkpLFxudGhpcy5zdG9yZS5kaXNwYXRjaCgoMCxwLmFkZEl0ZW0pKGEsaCxmLHUsbixzLG8sYykpLHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50JiZ0aGlzLnJlbW92ZUFjdGl2ZUl0ZW1zKGYpLGQmJmQudmFsdWU/KDAsdi50cmlnZ2VyRXZlbnQpKHRoaXMucGFzc2VkRWxlbWVudCxcImFkZEl0ZW1cIix7aWQ6Zix2YWx1ZTphLGxhYmVsOmgsZ3JvdXBWYWx1ZTpkLnZhbHVlLGtleUNvZGU6Y30pOigwLHYudHJpZ2dlckV2ZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQsXCJhZGRJdGVtXCIse2lkOmYsdmFsdWU6YSxsYWJlbDpoLGtleUNvZGU6Y30pLHRoaXN9fSx7a2V5OlwiX3JlbW92ZUl0ZW1cIix2YWx1ZTpmdW5jdGlvbihlKXtpZighZXx8ISgwLHYuaXNUeXBlKShcIk9iamVjdFwiLGUpKXJldHVybiB0aGlzO3ZhciB0PWUuaWQsaT1lLnZhbHVlLG49ZS5sYWJlbCxzPWUuY2hvaWNlSWQsbz1lLmdyb3VwSWQscj1vPj0wP3RoaXMuc3RvcmUuZ2V0R3JvdXBCeUlkKG8pOm51bGw7cmV0dXJuIHRoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5yZW1vdmVJdGVtKSh0LHMpKSxyJiZyLnZhbHVlPygwLHYudHJpZ2dlckV2ZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQsXCJyZW1vdmVJdGVtXCIse2lkOnQsdmFsdWU6aSxsYWJlbDpuLGdyb3VwVmFsdWU6ci52YWx1ZX0pOigwLHYudHJpZ2dlckV2ZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQsXCJyZW1vdmVJdGVtXCIse2lkOnQsdmFsdWU6aSxsYWJlbDpufSksdGhpc319LHtrZXk6XCJfYWRkQ2hvaWNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOm51bGwsaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLG49YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10mJmFyZ3VtZW50c1szXSxzPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTotMSxvPWFyZ3VtZW50cy5sZW5ndGg+NSYmdm9pZCAwIT09YXJndW1lbnRzWzVdP2FyZ3VtZW50c1s1XTpudWxsLHI9YXJndW1lbnRzLmxlbmd0aD42JiZ2b2lkIDAhPT1hcmd1bWVudHNbNl0mJmFyZ3VtZW50c1s2XSxhPWFyZ3VtZW50cy5sZW5ndGg+NyYmdm9pZCAwIT09YXJndW1lbnRzWzddP2FyZ3VtZW50c1s3XTpudWxsO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl7dmFyIGM9dGhpcy5zdG9yZS5nZXRDaG9pY2VzKCksbD10fHxlLGg9Yz9jLmxlbmd0aCsxOjEsdT10aGlzLmJhc2VJZCtcIi1cIit0aGlzLmlkTmFtZXMuaXRlbUNob2ljZStcIi1cIitoO3RoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5hZGRDaG9pY2UpKGUsbCxoLHMsbix1LG8scixhKSksaSYmdGhpcy5fYWRkSXRlbShlLGwsaCx2b2lkIDAsbyxyLGEpfX19LHtrZXk6XCJfY2xlYXJDaG9pY2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnN0b3JlLmRpc3BhdGNoKCgwLHAuY2xlYXJDaG9pY2VzKSgpKX19LHtrZXk6XCJfYWRkR3JvdXBcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpPXRoaXMsbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06XCJ2YWx1ZVwiLHM9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOlwibGFiZWxcIixvPSgwLHYuaXNUeXBlKShcIk9iamVjdFwiLGUpP2UuY2hvaWNlczpBcnJheS5mcm9tKGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJPUFRJT05cIikpLHI9dD90Ok1hdGguZmxvb3IoKG5ldyBEYXRlKS52YWx1ZU9mKCkqTWF0aC5yYW5kb20oKSksYT0hIWUuZGlzYWJsZWQmJmUuZGlzYWJsZWQ7bz8odGhpcy5zdG9yZS5kaXNwYXRjaCgoMCxwLmFkZEdyb3VwKShlLmxhYmVsLHIsITAsYSkpLG8uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lLmRpc2FibGVkfHxlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5kaXNhYmxlZDtpLl9hZGRDaG9pY2UoZVtuXSwoMCx2LmlzVHlwZSkoXCJPYmplY3RcIixlKT9lW3NdOmUuaW5uZXJIVE1MLGUuc2VsZWN0ZWQsdCxyLGUuY3VzdG9tUHJvcGVydGllcyxlLnBsYWNlaG9sZGVyKX0pKTp0aGlzLnN0b3JlLmRpc3BhdGNoKCgwLHAuYWRkR3JvdXApKGUubGFiZWwsZS5pZCwhMSxlLmRpc2FibGVkKSl9fSx7a2V5OlwiX2dldFRlbXBsYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuIG51bGw7Zm9yKHZhciB0PXRoaXMuY29uZmlnLnRlbXBsYXRlcyxpPWFyZ3VtZW50cy5sZW5ndGgsbj1BcnJheShpPjE/aS0xOjApLHM9MTtzPGk7cysrKW5bcy0xXT1hcmd1bWVudHNbc107cmV0dXJuIHRbZV0uYXBwbHkodCxuKX19LHtrZXk6XCJfY3JlYXRlVGVtcGxhdGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9dGhpcy5jb25maWcuY2xhc3NOYW1lcyxpPXtjb250YWluZXJPdXRlcjpmdW5jdGlvbihpKXtyZXR1cm4oMCx2LnN0clRvRWwpKCdcXG4gICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgIGNsYXNzPVwiJyt0LmNvbnRhaW5lck91dGVyKydcIlxcbiAgICAgICAgICAgICcrKGUuaXNTZWxlY3RFbGVtZW50P2UuY29uZmlnLnNlYXJjaEVuYWJsZWQ/J3JvbGU9XCJjb21ib2JveFwiIGFyaWEtYXV0b2NvbXBsZXRlPVwibGlzdFwiJzoncm9sZT1cImxpc3Rib3hcIic6XCJcIikrJ1xcbiAgICAgICAgICAgIGRhdGEtdHlwZT1cIicrZS5wYXNzZWRFbGVtZW50LnR5cGUrJ1wiXFxuICAgICAgICAgICAgJysoZS5pc1NlbGVjdE9uZUVsZW1lbnQ/J3RhYmluZGV4PVwiMFwiJzpcIlwiKSsnXFxuICAgICAgICAgICAgYXJpYS1oYXNwb3B1cD1cInRydWVcIlxcbiAgICAgICAgICAgIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiXFxuICAgICAgICAgICAgZGlyPVwiJytpKydcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAnKX0sY29udGFpbmVySW5uZXI6ZnVuY3Rpb24oKXtyZXR1cm4oMCx2LnN0clRvRWwpKCdcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIicrdC5jb250YWluZXJJbm5lcisnXCI+PC9kaXY+XFxuICAgICAgICAnKX0saXRlbUxpc3Q6ZnVuY3Rpb24oKXt2YXIgaSxuPSgwLHUuZGVmYXVsdCkodC5saXN0LChpPXt9LHMoaSx0Lmxpc3RTaW5nbGUsZS5pc1NlbGVjdE9uZUVsZW1lbnQpLHMoaSx0Lmxpc3RJdGVtcywhZS5pc1NlbGVjdE9uZUVsZW1lbnQpLGkpKTtyZXR1cm4oMCx2LnN0clRvRWwpKCdcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIicrbisnXCI+PC9kaXY+XFxuICAgICAgICAnKX0scGxhY2Vob2xkZXI6ZnVuY3Rpb24oZSl7cmV0dXJuKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCInK3QucGxhY2Vob2xkZXIrJ1wiPlxcbiAgICAgICAgICAgICcrZStcIlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiKX0saXRlbTpmdW5jdGlvbihpKXt2YXIgbixvPSgwLHUuZGVmYXVsdCkodC5pdGVtLChuPXt9LHMobix0LmhpZ2hsaWdodGVkU3RhdGUsaS5oaWdobGlnaHRlZCkscyhuLHQuaXRlbVNlbGVjdGFibGUsIWkuaGlnaGxpZ2h0ZWQpLHMobix0LnBsYWNlaG9sZGVyLGkucGxhY2Vob2xkZXIpLG4pKTtpZihlLmNvbmZpZy5yZW1vdmVJdGVtQnV0dG9uKXt2YXIgcjtyZXR1cm4gbz0oMCx1LmRlZmF1bHQpKHQuaXRlbSwocj17fSxzKHIsdC5oaWdobGlnaHRlZFN0YXRlLGkuaGlnaGxpZ2h0ZWQpLHMocix0Lml0ZW1TZWxlY3RhYmxlLCFpLmRpc2FibGVkKSxzKHIsdC5wbGFjZWhvbGRlcixpLnBsYWNlaG9sZGVyKSxyKSksKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XCInK28rJ1wiXFxuICAgICAgICAgICAgICBkYXRhLWl0ZW1cXG4gICAgICAgICAgICAgIGRhdGEtaWQ9XCInK2kuaWQrJ1wiXFxuICAgICAgICAgICAgICBkYXRhLXZhbHVlPVwiJytpLnZhbHVlKydcIlxcbiAgICAgICAgICAgICAgZGF0YS1kZWxldGFibGVcXG4gICAgICAgICAgICAgICcrKGkuYWN0aXZlPydhcmlhLXNlbGVjdGVkPVwidHJ1ZVwiJzpcIlwiKStcIlxcbiAgICAgICAgICAgICAgXCIrKGkuZGlzYWJsZWQ/J2FyaWEtZGlzYWJsZWQ9XCJ0cnVlXCInOlwiXCIpK1wiXFxuICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICBcIitpLmxhYmVsKyc8IS0tXFxuICAgICAgICAgICAtLT48YnV0dG9uXFxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cIicrdC5idXR0b24rJ1wiXFxuICAgICAgICAgICAgICAgIGRhdGEtYnV0dG9uXFxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJSZW1vdmUgaXRlbTogXFwnJytpLnZhbHVlK1wiJ1xcXCJcXG4gICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICBSZW1vdmUgaXRlbVxcbiAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIFwiKX1yZXR1cm4oMCx2LnN0clRvRWwpKCdcXG4gICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgIGNsYXNzPVwiJytvKydcIlxcbiAgICAgICAgICAgIGRhdGEtaXRlbVxcbiAgICAgICAgICAgIGRhdGEtaWQ9XCInK2kuaWQrJ1wiXFxuICAgICAgICAgICAgZGF0YS12YWx1ZT1cIicraS52YWx1ZSsnXCJcXG4gICAgICAgICAgICAnKyhpLmFjdGl2ZT8nYXJpYS1zZWxlY3RlZD1cInRydWVcIic6XCJcIikrXCJcXG4gICAgICAgICAgICBcIisoaS5kaXNhYmxlZD8nYXJpYS1kaXNhYmxlZD1cInRydWVcIic6XCJcIikrXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgXCIraS5sYWJlbCtcIlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiKX0sY2hvaWNlTGlzdDpmdW5jdGlvbigpe3JldHVybigwLHYuc3RyVG9FbCkoJ1xcbiAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgY2xhc3M9XCInK3QubGlzdCsnXCJcXG4gICAgICAgICAgICBkaXI9XCJsdHJcIlxcbiAgICAgICAgICAgIHJvbGU9XCJsaXN0Ym94XCJcXG4gICAgICAgICAgICAnKyhlLmlzU2VsZWN0T25lRWxlbWVudD9cIlwiOidhcmlhLW11bHRpc2VsZWN0YWJsZT1cInRydWVcIicpK1wiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiKX0sY2hvaWNlR3JvdXA6ZnVuY3Rpb24oZSl7dmFyIGk9KDAsdS5kZWZhdWx0KSh0Lmdyb3VwLHMoe30sdC5pdGVtRGlzYWJsZWQsZS5kaXNhYmxlZCkpO3JldHVybigwLHYuc3RyVG9FbCkoJ1xcbiAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgY2xhc3M9XCInK2krJ1wiXFxuICAgICAgICAgICAgZGF0YS1ncm91cFxcbiAgICAgICAgICAgIGRhdGEtaWQ9XCInK2UuaWQrJ1wiXFxuICAgICAgICAgICAgZGF0YS12YWx1ZT1cIicrZS52YWx1ZSsnXCJcXG4gICAgICAgICAgICByb2xlPVwiZ3JvdXBcIlxcbiAgICAgICAgICAgICcrKGUuZGlzYWJsZWQ/J2FyaWEtZGlzYWJsZWQ9XCJ0cnVlXCInOlwiXCIpKydcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIicrdC5ncm91cEhlYWRpbmcrJ1wiPicrZS52YWx1ZStcIjwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiKX0sY2hvaWNlOmZ1bmN0aW9uKGkpe3ZhciBuLG89KDAsdS5kZWZhdWx0KSh0Lml0ZW0sdC5pdGVtQ2hvaWNlLChuPXt9LHMobix0Lml0ZW1EaXNhYmxlZCxpLmRpc2FibGVkKSxzKG4sdC5pdGVtU2VsZWN0YWJsZSwhaS5kaXNhYmxlZCkscyhuLHQucGxhY2Vob2xkZXIsaS5wbGFjZWhvbGRlciksbikpO3JldHVybigwLHYuc3RyVG9FbCkoJ1xcbiAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgY2xhc3M9XCInK28rJ1wiXFxuICAgICAgICAgICAgZGF0YS1zZWxlY3QtdGV4dD1cIicrZS5jb25maWcuaXRlbVNlbGVjdFRleHQrJ1wiXFxuICAgICAgICAgICAgZGF0YS1jaG9pY2VcXG4gICAgICAgICAgICBkYXRhLWlkPVwiJytpLmlkKydcIlxcbiAgICAgICAgICAgIGRhdGEtdmFsdWU9XCInK2kudmFsdWUrJ1wiXFxuICAgICAgICAgICAgJysoaS5kaXNhYmxlZD8nZGF0YS1jaG9pY2UtZGlzYWJsZWQgYXJpYS1kaXNhYmxlZD1cInRydWVcIic6XCJkYXRhLWNob2ljZS1zZWxlY3RhYmxlXCIpKydcXG4gICAgICAgICAgICBpZD1cIicraS5lbGVtZW50SWQrJ1wiXFxuICAgICAgICAgICAgJysoaS5ncm91cElkPjA/J3JvbGU9XCJ0cmVlaXRlbVwiJzoncm9sZT1cIm9wdGlvblwiJykrXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgXCIraS5sYWJlbCtcIlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiKX0saW5wdXQ6ZnVuY3Rpb24oKXt2YXIgZT0oMCx1LmRlZmF1bHQpKHQuaW5wdXQsdC5pbnB1dENsb25lZCk7cmV0dXJuKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcXG4gICAgICAgICAgICBjbGFzcz1cIicrZSsnXCJcXG4gICAgICAgICAgICBhdXRvY29tcGxldGU9XCJvZmZcIlxcbiAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplPVwib2ZmXCJcXG4gICAgICAgICAgICBzcGVsbGNoZWNrPVwiZmFsc2VcIlxcbiAgICAgICAgICAgIHJvbGU9XCJ0ZXh0Ym94XCJcXG4gICAgICAgICAgICBhcmlhLWF1dG9jb21wbGV0ZT1cImxpc3RcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICcpfSxkcm9wZG93bjpmdW5jdGlvbigpe3ZhciBlPSgwLHUuZGVmYXVsdCkodC5saXN0LHQubGlzdERyb3Bkb3duKTtyZXR1cm4oMCx2LnN0clRvRWwpKCdcXG4gICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgIGNsYXNzPVwiJytlKydcIlxcbiAgICAgICAgICAgIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICcpfSxub3RpY2U6ZnVuY3Rpb24oZSl7dmFyIGksbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJcIixvPSgwLHUuZGVmYXVsdCkodC5pdGVtLHQuaXRlbUNob2ljZSwoaT17fSxzKGksdC5ub1Jlc3VsdHMsXCJuby1yZXN1bHRzXCI9PT1uKSxzKGksdC5ub0Nob2ljZXMsXCJuby1jaG9pY2VzXCI9PT1uKSxpKSk7cmV0dXJuKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCInK28rJ1wiPlxcbiAgICAgICAgICAgICcrZStcIlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiKX0sb3B0aW9uOmZ1bmN0aW9uKGUpe3JldHVybigwLHYuc3RyVG9FbCkoJ1xcbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiJytlLnZhbHVlKydcIiBzZWxlY3RlZD4nK2UubGFiZWwrXCI8L29wdGlvbj5cXG4gICAgICAgIFwiKX19LG49dGhpcy5jb25maWcuY2FsbGJhY2tPbkNyZWF0ZVRlbXBsYXRlcyxvPXt9O24mJigwLHYuaXNUeXBlKShcIkZ1bmN0aW9uXCIsbikmJihvPW4uY2FsbCh0aGlzLHYuc3RyVG9FbCkpLHRoaXMuY29uZmlnLnRlbXBsYXRlcz0oMCx2LmV4dGVuZCkoaSxvKX19LHtrZXk6XCJfc2V0TG9hZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5zZXRJc0xvYWRpbmcpKGUpKX19LHtrZXk6XCJfY3JlYXRlSW5wdXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLnBhc3NlZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGlyXCIpfHxcImx0clwiLGk9dGhpcy5fZ2V0VGVtcGxhdGUoXCJjb250YWluZXJPdXRlclwiLHQpLG49dGhpcy5fZ2V0VGVtcGxhdGUoXCJjb250YWluZXJJbm5lclwiKSxzPXRoaXMuX2dldFRlbXBsYXRlKFwiaXRlbUxpc3RcIiksbz10aGlzLl9nZXRUZW1wbGF0ZShcImNob2ljZUxpc3RcIikscj10aGlzLl9nZXRUZW1wbGF0ZShcImlucHV0XCIpLGE9dGhpcy5fZ2V0VGVtcGxhdGUoXCJkcm9wZG93blwiKTt0aGlzLmNvbnRhaW5lck91dGVyPWksdGhpcy5jb250YWluZXJJbm5lcj1uLHRoaXMuaW5wdXQ9cix0aGlzLmNob2ljZUxpc3Q9byx0aGlzLml0ZW1MaXN0PXMsdGhpcy5kcm9wZG93bj1hLHRoaXMucGFzc2VkRWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuaW5wdXQsdGhpcy5jb25maWcuY2xhc3NOYW1lcy5oaWRkZW5TdGF0ZSksdGhpcy5wYXNzZWRFbGVtZW50LnRhYkluZGV4PVwiLTFcIjt2YXIgYz10aGlzLnBhc3NlZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7aWYoQm9vbGVhbihjKSYmdGhpcy5wYXNzZWRFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtY2hvaWNlLW9yaWctc3R5bGVcIixjKSx0aGlzLnBhc3NlZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcImRpc3BsYXk6bm9uZTtcIiksdGhpcy5wYXNzZWRFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpLHRoaXMucGFzc2VkRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNob2ljZVwiLFwiYWN0aXZlXCIpLCgwLHYud3JhcCkodGhpcy5wYXNzZWRFbGVtZW50LG4pLCgwLHYud3JhcCkobixpKSx0aGlzLmlzU2VsZWN0T25lRWxlbWVudD9yLnBsYWNlaG9sZGVyPXRoaXMuY29uZmlnLnNlYXJjaFBsYWNlaG9sZGVyVmFsdWV8fFwiXCI6dGhpcy5wbGFjZWhvbGRlciYmKHIucGxhY2Vob2xkZXI9dGhpcy5wbGFjZWhvbGRlcixyLnN0eWxlLndpZHRoPSgwLHYuZ2V0V2lkdGhPZklucHV0KShyKSksdGhpcy5jb25maWcuYWRkSXRlbXN8fHRoaXMuZGlzYWJsZSgpLGkuYXBwZW5kQ2hpbGQobiksaS5hcHBlbmRDaGlsZChhKSxuLmFwcGVuZENoaWxkKHMpLHRoaXMuaXNUZXh0RWxlbWVudHx8YS5hcHBlbmRDaGlsZChvKSx0aGlzLmlzU2VsZWN0TXVsdGlwbGVFbGVtZW50fHx0aGlzLmlzVGV4dEVsZW1lbnQ/bi5hcHBlbmRDaGlsZChyKTp0aGlzLmNhblNlYXJjaCYmYS5pbnNlcnRCZWZvcmUocixhLmZpcnN0Q2hpbGQpLHRoaXMuaXNTZWxlY3RFbGVtZW50KXt2YXIgbD1BcnJheS5mcm9tKHRoaXMucGFzc2VkRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIk9QVEdST1VQXCIpKTtpZih0aGlzLmhpZ2hsaWdodFBvc2l0aW9uPTAsdGhpcy5pc1NlYXJjaGluZz0hMSx0aGlzLl9zZXRMb2FkaW5nKCEwKSxsJiZsLmxlbmd0aClsLmZvckVhY2goZnVuY3Rpb24odCl7ZS5fYWRkR3JvdXAodCx0LmlkfHxudWxsKX0pO2Vsc2V7dmFyIGg9QXJyYXkuZnJvbSh0aGlzLnBhc3NlZEVsZW1lbnQub3B0aW9ucyksdT10aGlzLmNvbmZpZy5zb3J0RmlsdGVyLGQ9dGhpcy5wcmVzZXRDaG9pY2VzO2guZm9yRWFjaChmdW5jdGlvbihlKXtkLnB1c2goe3ZhbHVlOmUudmFsdWUsbGFiZWw6ZS5pbm5lckhUTUwsc2VsZWN0ZWQ6ZS5zZWxlY3RlZCxkaXNhYmxlZDplLmRpc2FibGVkfHxlLnBhcmVudE5vZGUuZGlzYWJsZWQscGxhY2Vob2xkZXI6ZS5oYXNBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKX0pfSksdGhpcy5jb25maWcuc2hvdWxkU29ydCYmZC5zb3J0KHUpO3ZhciBmPWQuc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZS5zZWxlY3RlZH0pO2QuZm9yRWFjaChmdW5jdGlvbih0LGkpe2lmKGUuaXNTZWxlY3RPbmVFbGVtZW50KXt2YXIgbj1mfHwhZiYmaT4wO2UuX2FkZENob2ljZSh0LnZhbHVlLHQubGFiZWwsIW58fHQuc2VsZWN0ZWQsISFuJiZ0LmRpc2FibGVkLHZvaWQgMCx0LmN1c3RvbVByb3BlcnRpZXMsdC5wbGFjZWhvbGRlcil9ZWxzZSBlLl9hZGRDaG9pY2UodC52YWx1ZSx0LmxhYmVsLHQuc2VsZWN0ZWQsdC5kaXNhYmxlZCx2b2lkIDAsdC5jdXN0b21Qcm9wZXJ0aWVzLHQucGxhY2Vob2xkZXIpfSl9dGhpcy5fc2V0TG9hZGluZyghMSl9ZWxzZSB0aGlzLmlzVGV4dEVsZW1lbnQmJnRoaXMucHJlc2V0SXRlbXMuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgaT0oMCx2LmdldFR5cGUpKHQpO2lmKFwiT2JqZWN0XCI9PT1pKXtpZighdC52YWx1ZSlyZXR1cm47ZS5fYWRkSXRlbSh0LnZhbHVlLHQubGFiZWwsdC5pZCx2b2lkIDAsdC5jdXN0b21Qcm9wZXJ0aWVzLHQucGxhY2Vob2xkZXIpfWVsc2VcIlN0cmluZ1wiPT09aSYmZS5fYWRkSXRlbSh0KX0pfX1dKSxlfSgpO2UuZXhwb3J0cz1tfSxmdW5jdGlvbihlLHQsaSl7IWZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoKXtjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLGFyZ3VtZW50cyl9ZnVuY3Rpb24gbihlLHQpe3ZhciBpO3RoaXMubGlzdD1lLHRoaXMub3B0aW9ucz10PXR8fHt9O2ZvcihpIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShpKSYmKFwiYm9vbGVhblwiPT10eXBlb2YgYVtpXT90aGlzLm9wdGlvbnNbaV09aSBpbiB0P3RbaV06YVtpXTp0aGlzLm9wdGlvbnNbaV09dFtpXXx8YVtpXSl9ZnVuY3Rpb24gcyhlLHQsaSl7dmFyIG4scixhLGMsbCxoO2lmKHQpe2lmKGE9dC5pbmRleE9mKFwiLlwiKSxhIT09LTE/KG49dC5zbGljZSgwLGEpLHI9dC5zbGljZShhKzEpKTpuPXQsYz1lW25dLG51bGwhPT1jJiZ2b2lkIDAhPT1jKWlmKHJ8fFwic3RyaW5nXCIhPXR5cGVvZiBjJiZcIm51bWJlclwiIT10eXBlb2YgYylpZihvKGMpKWZvcihsPTAsaD1jLmxlbmd0aDtsPGg7bCsrKXMoY1tsXSxyLGkpO2Vsc2UgciYmcyhjLHIsaSk7ZWxzZSBpLnB1c2goYyl9ZWxzZSBpLnB1c2goZSk7cmV0dXJuIGl9ZnVuY3Rpb24gbyhlKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9ZnVuY3Rpb24gcihlLHQpe3Q9dHx8e30sdGhpcy5vcHRpb25zPXQsdGhpcy5vcHRpb25zLmxvY2F0aW9uPXQubG9jYXRpb258fHIuZGVmYXVsdE9wdGlvbnMubG9jYXRpb24sdGhpcy5vcHRpb25zLmRpc3RhbmNlPVwiZGlzdGFuY2VcImluIHQ/dC5kaXN0YW5jZTpyLmRlZmF1bHRPcHRpb25zLmRpc3RhbmNlLHRoaXMub3B0aW9ucy50aHJlc2hvbGQ9XCJ0aHJlc2hvbGRcImluIHQ/dC50aHJlc2hvbGQ6ci5kZWZhdWx0T3B0aW9ucy50aHJlc2hvbGQsdGhpcy5vcHRpb25zLm1heFBhdHRlcm5MZW5ndGg9dC5tYXhQYXR0ZXJuTGVuZ3RofHxyLmRlZmF1bHRPcHRpb25zLm1heFBhdHRlcm5MZW5ndGgsdGhpcy5wYXR0ZXJuPXQuY2FzZVNlbnNpdGl2ZT9lOmUudG9Mb3dlckNhc2UoKSx0aGlzLnBhdHRlcm5MZW49ZS5sZW5ndGgsdGhpcy5wYXR0ZXJuTGVuPD10aGlzLm9wdGlvbnMubWF4UGF0dGVybkxlbmd0aCYmKHRoaXMubWF0Y2htYXNrPTE8PHRoaXMucGF0dGVybkxlbi0xLHRoaXMucGF0dGVybkFscGhhYmV0PXRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5BbHBoYWJldCgpKX12YXIgYT17aWQ6bnVsbCxjYXNlU2Vuc2l0aXZlOiExLGluY2x1ZGU6W10sc2hvdWxkU29ydDohMCxzZWFyY2hGbjpyLHNvcnRGbjpmdW5jdGlvbihlLHQpe3JldHVybiBlLnNjb3JlLXQuc2NvcmV9LGdldEZuOnMsa2V5czpbXSx2ZXJib3NlOiExLHRva2VuaXplOiExLG1hdGNoQWxsVG9rZW5zOiExLHRva2VuU2VwYXJhdG9yOi8gKy9nLG1pbk1hdGNoQ2hhckxlbmd0aDoxLGZpbmRBbGxNYXRjaGVzOiExfTtuLlZFUlNJT049XCIyLjcuM1wiLG4ucHJvdG90eXBlLnNldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5saXN0PWUsZX0sbi5wcm90b3R5cGUuc2VhcmNoPWZ1bmN0aW9uKGUpe3RoaXMub3B0aW9ucy52ZXJib3NlJiZpKFwiXFxuU2VhcmNoIHRlcm06XCIsZSxcIlxcblwiKSx0aGlzLnBhdHRlcm49ZSx0aGlzLnJlc3VsdHM9W10sdGhpcy5yZXN1bHRNYXA9e30sdGhpcy5fa2V5TWFwPW51bGwsdGhpcy5fcHJlcGFyZVNlYXJjaGVycygpLHRoaXMuX3N0YXJ0U2VhcmNoKCksdGhpcy5fY29tcHV0ZVNjb3JlKCksdGhpcy5fc29ydCgpO3ZhciB0PXRoaXMuX2Zvcm1hdCgpO3JldHVybiB0fSxuLnByb3RvdHlwZS5fcHJlcGFyZVNlYXJjaGVycz1mdW5jdGlvbigpe3ZhciBlPXRoaXMub3B0aW9ucyx0PXRoaXMucGF0dGVybixpPWUuc2VhcmNoRm4sbj10LnNwbGl0KGUudG9rZW5TZXBhcmF0b3IpLHM9MCxvPW4ubGVuZ3RoO2lmKHRoaXMub3B0aW9ucy50b2tlbml6ZSlmb3IodGhpcy50b2tlblNlYXJjaGVycz1bXTtzPG87cysrKXRoaXMudG9rZW5TZWFyY2hlcnMucHVzaChuZXcgaShuW3NdLGUpKTt0aGlzLmZ1bGxTZWFjaGVyPW5ldyBpKHQsZSl9LG4ucHJvdG90eXBlLl9zdGFydFNlYXJjaD1mdW5jdGlvbigpe3ZhciBlLHQsaSxuLHM9dGhpcy5vcHRpb25zLG89cy5nZXRGbixyPXRoaXMubGlzdCxhPXIubGVuZ3RoLGM9dGhpcy5vcHRpb25zLmtleXMsbD1jLmxlbmd0aCxoPW51bGw7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHJbMF0pZm9yKGk9MDtpPGE7aSsrKXRoaXMuX2FuYWx5emUoXCJcIixyW2ldLGksaSk7ZWxzZSBmb3IodGhpcy5fa2V5TWFwPXt9LGk9MDtpPGE7aSsrKWZvcihoPXJbaV0sbj0wO248bDtuKyspe2lmKGU9Y1tuXSxcInN0cmluZ1wiIT10eXBlb2YgZSl7aWYodD0xLWUud2VpZ2h0fHwxLHRoaXMuX2tleU1hcFtlLm5hbWVdPXt3ZWlnaHQ6dH0sZS53ZWlnaHQ8PTB8fGUud2VpZ2h0PjEpdGhyb3cgbmV3IEVycm9yKFwiS2V5IHdlaWdodCBoYXMgdG8gYmUgPiAwIGFuZCA8PSAxXCIpO2U9ZS5uYW1lfWVsc2UgdGhpcy5fa2V5TWFwW2VdPXt3ZWlnaHQ6MX07dGhpcy5fYW5hbHl6ZShlLG8oaCxlLFtdKSxoLGkpfX0sbi5wcm90b3R5cGUuX2FuYWx5emU9ZnVuY3Rpb24oZSx0LG4scyl7dmFyIHIsYSxjLGwsaCx1LGQsZixwLHYsbSxnLHksYixFLF89dGhpcy5vcHRpb25zLFM9ITE7aWYodm9pZCAwIT09dCYmbnVsbCE9PXQpe2E9W107dmFyIEk9MDtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7aWYocj10LnNwbGl0KF8udG9rZW5TZXBhcmF0b3IpLF8udmVyYm9zZSYmaShcIi0tLS0tLS0tLVxcbktleTpcIixlKSx0aGlzLm9wdGlvbnMudG9rZW5pemUpe2ZvcihiPTA7Yjx0aGlzLnRva2VuU2VhcmNoZXJzLmxlbmd0aDtiKyspe2ZvcihmPXRoaXMudG9rZW5TZWFyY2hlcnNbYl0sXy52ZXJib3NlJiZpKFwiUGF0dGVybjpcIixmLnBhdHRlcm4pLHA9W10sZz0hMSxFPTA7RTxyLmxlbmd0aDtFKyspe3Y9cltFXSxtPWYuc2VhcmNoKHYpO3ZhciB3PXt9O20uaXNNYXRjaD8od1t2XT1tLnNjb3JlLFM9ITAsZz0hMCxhLnB1c2gobS5zY29yZSkpOih3W3ZdPTEsdGhpcy5vcHRpb25zLm1hdGNoQWxsVG9rZW5zfHxhLnB1c2goMSkpLHAucHVzaCh3KX1nJiZJKyssXy52ZXJib3NlJiZpKFwiVG9rZW4gc2NvcmVzOlwiLHApfWZvcihsPWFbMF0sdT1hLmxlbmd0aCxiPTE7Yjx1O2IrKylsKz1hW2JdO2wvPXUsXy52ZXJib3NlJiZpKFwiVG9rZW4gc2NvcmUgYXZlcmFnZTpcIixsKX1kPXRoaXMuZnVsbFNlYWNoZXIuc2VhcmNoKHQpLF8udmVyYm9zZSYmaShcIkZ1bGwgdGV4dCBzY29yZTpcIixkLnNjb3JlKSxoPWQuc2NvcmUsdm9pZCAwIT09bCYmKGg9KGgrbCkvMiksXy52ZXJib3NlJiZpKFwiU2NvcmUgYXZlcmFnZTpcIixoKSx5PSF0aGlzLm9wdGlvbnMudG9rZW5pemV8fCF0aGlzLm9wdGlvbnMubWF0Y2hBbGxUb2tlbnN8fEk+PXRoaXMudG9rZW5TZWFyY2hlcnMubGVuZ3RoLF8udmVyYm9zZSYmaShcIkNoZWNrIE1hdGNoZXNcIix5KSwoU3x8ZC5pc01hdGNoKSYmeSYmKGM9dGhpcy5yZXN1bHRNYXBbc10sYz9jLm91dHB1dC5wdXNoKHtrZXk6ZSxzY29yZTpoLG1hdGNoZWRJbmRpY2VzOmQubWF0Y2hlZEluZGljZXN9KToodGhpcy5yZXN1bHRNYXBbc109e2l0ZW06bixvdXRwdXQ6W3trZXk6ZSxzY29yZTpoLG1hdGNoZWRJbmRpY2VzOmQubWF0Y2hlZEluZGljZXN9XX0sdGhpcy5yZXN1bHRzLnB1c2godGhpcy5yZXN1bHRNYXBbc10pKSl9ZWxzZSBpZihvKHQpKWZvcihiPTA7Yjx0Lmxlbmd0aDtiKyspdGhpcy5fYW5hbHl6ZShlLHRbYl0sbixzKX19LG4ucHJvdG90eXBlLl9jb21wdXRlU2NvcmU9ZnVuY3Rpb24oKXt2YXIgZSx0LG4scyxvLHIsYSxjLGwsaD10aGlzLl9rZXlNYXAsdT10aGlzLnJlc3VsdHM7Zm9yKHRoaXMub3B0aW9ucy52ZXJib3NlJiZpKFwiXFxuXFxuQ29tcHV0aW5nIHNjb3JlOlxcblwiKSxlPTA7ZTx1Lmxlbmd0aDtlKyspe2ZvcihuPTAscz11W2VdLm91dHB1dCxvPXMubGVuZ3RoLGM9MSx0PTA7dDxvO3QrKylyPXNbdF0uc2NvcmUsYT1oP2hbc1t0XS5rZXldLndlaWdodDoxLGw9ciphLDEhPT1hP2M9TWF0aC5taW4oYyxsKToobis9bCxzW3RdLm5TY29yZT1sKTsxPT09Yz91W2VdLnNjb3JlPW4vbzp1W2VdLnNjb3JlPWMsdGhpcy5vcHRpb25zLnZlcmJvc2UmJmkodVtlXSl9fSxuLnByb3RvdHlwZS5fc29ydD1mdW5jdGlvbigpe3ZhciBlPXRoaXMub3B0aW9ucztlLnNob3VsZFNvcnQmJihlLnZlcmJvc2UmJmkoXCJcXG5cXG5Tb3J0aW5nLi4uLlwiKSx0aGlzLnJlc3VsdHMuc29ydChlLnNvcnRGbikpfSxuLnByb3RvdHlwZS5fZm9ybWF0PWZ1bmN0aW9uKCl7dmFyIGUsdCxuLHMsbz10aGlzLm9wdGlvbnMscj1vLmdldEZuLGE9W10sYz10aGlzLnJlc3VsdHMsbD1vLmluY2x1ZGU7Zm9yKG8udmVyYm9zZSYmaShcIlxcblxcbk91dHB1dDpcXG5cXG5cIixjKSxuPW8uaWQ/ZnVuY3Rpb24oZSl7Y1tlXS5pdGVtPXIoY1tlXS5pdGVtLG8uaWQsW10pWzBdfTpmdW5jdGlvbigpe30scz1mdW5jdGlvbihlKXt2YXIgdCxpLG4scyxvLHI9Y1tlXTtpZihsLmxlbmd0aD4wKXtpZih0PXtpdGVtOnIuaXRlbX0sbC5pbmRleE9mKFwibWF0Y2hlc1wiKSE9PS0xKWZvcihuPXIub3V0cHV0LHQubWF0Y2hlcz1bXSxpPTA7aTxuLmxlbmd0aDtpKyspcz1uW2ldLG89e2luZGljZXM6cy5tYXRjaGVkSW5kaWNlc30scy5rZXkmJihvLmtleT1zLmtleSksdC5tYXRjaGVzLnB1c2gobyk7bC5pbmRleE9mKFwic2NvcmVcIikhPT0tMSYmKHQuc2NvcmU9Y1tlXS5zY29yZSl9ZWxzZSB0PXIuaXRlbTtyZXR1cm4gdH0sZT0wLHQ9Yy5sZW5ndGg7ZTx0O2UrKyluKGUpLGEucHVzaChzKGUpKTtyZXR1cm4gYX0sci5kZWZhdWx0T3B0aW9ucz17bG9jYXRpb246MCxkaXN0YW5jZToxMDAsdGhyZXNob2xkOi42LG1heFBhdHRlcm5MZW5ndGg6MzJ9LHIucHJvdG90eXBlLl9jYWxjdWxhdGVQYXR0ZXJuQWxwaGFiZXQ9ZnVuY3Rpb24oKXt2YXIgZT17fSx0PTA7Zm9yKHQ9MDt0PHRoaXMucGF0dGVybkxlbjt0KyspZVt0aGlzLnBhdHRlcm4uY2hhckF0KHQpXT0wO2Zvcih0PTA7dDx0aGlzLnBhdHRlcm5MZW47dCsrKWVbdGhpcy5wYXR0ZXJuLmNoYXJBdCh0KV18PTE8PHRoaXMucGF0dGVybi5sZW5ndGgtdC0xO3JldHVybiBlfSxyLnByb3RvdHlwZS5fYml0YXBTY29yZT1mdW5jdGlvbihlLHQpe3ZhciBpPWUvdGhpcy5wYXR0ZXJuTGVuLG49TWF0aC5hYnModGhpcy5vcHRpb25zLmxvY2F0aW9uLXQpO3JldHVybiB0aGlzLm9wdGlvbnMuZGlzdGFuY2U/aStuL3RoaXMub3B0aW9ucy5kaXN0YW5jZTpuPzE6aX0sci5wcm90b3R5cGUuc2VhcmNoPWZ1bmN0aW9uKGUpe3ZhciB0LGksbixzLG8scixhLGMsbCxoLHUsZCxmLHAsdixtLGcseSxiLEUsXyxTLEksdz10aGlzLm9wdGlvbnM7aWYoZT13LmNhc2VTZW5zaXRpdmU/ZTplLnRvTG93ZXJDYXNlKCksdGhpcy5wYXR0ZXJuPT09ZSlyZXR1cm57aXNNYXRjaDohMCxzY29yZTowLG1hdGNoZWRJbmRpY2VzOltbMCxlLmxlbmd0aC0xXV19O2lmKHRoaXMucGF0dGVybkxlbj53Lm1heFBhdHRlcm5MZW5ndGgpe2lmKHk9ZS5tYXRjaChuZXcgUmVnRXhwKHRoaXMucGF0dGVybi5yZXBsYWNlKHcudG9rZW5TZXBhcmF0b3IsXCJ8XCIpKSksYj0hIXkpZm9yKF89W10sdD0wLFM9eS5sZW5ndGg7dDxTO3QrKylJPXlbdF0sXy5wdXNoKFtlLmluZGV4T2YoSSksSS5sZW5ndGgtMV0pO3JldHVybntpc01hdGNoOmIsc2NvcmU6Yj8uNToxLG1hdGNoZWRJbmRpY2VzOl99fWZvcihzPXcuZmluZEFsbE1hdGNoZXMsbz13LmxvY2F0aW9uLG49ZS5sZW5ndGgscj13LnRocmVzaG9sZCxhPWUuaW5kZXhPZih0aGlzLnBhdHRlcm4sbyksRT1bXSx0PTA7dDxuO3QrKylFW3RdPTA7Zm9yKGEhPS0xJiYocj1NYXRoLm1pbih0aGlzLl9iaXRhcFNjb3JlKDAsYSksciksYT1lLmxhc3RJbmRleE9mKHRoaXMucGF0dGVybixvK3RoaXMucGF0dGVybkxlbiksYSE9LTEmJihyPU1hdGgubWluKHRoaXMuX2JpdGFwU2NvcmUoMCxhKSxyKSkpLGE9LTEsbT0xLGc9W10saD10aGlzLnBhdHRlcm5MZW4rbix0PTA7dDx0aGlzLnBhdHRlcm5MZW47dCsrKXtmb3IoYz0wLGw9aDtjPGw7KXRoaXMuX2JpdGFwU2NvcmUodCxvK2wpPD1yP2M9bDpoPWwsbD1NYXRoLmZsb29yKChoLWMpLzIrYyk7Zm9yKGg9bCx1PU1hdGgubWF4KDEsby1sKzEpLGQ9cz9uOk1hdGgubWluKG8rbCxuKSt0aGlzLnBhdHRlcm5MZW4sZj1BcnJheShkKzIpLGZbZCsxXT0oMTw8dCktMSxpPWQ7aT49dTtpLS0paWYodj10aGlzLnBhdHRlcm5BbHBoYWJldFtlLmNoYXJBdChpLTEpXSx2JiYoRVtpLTFdPTEpLGZbaV09KGZbaSsxXTw8MXwxKSZ2LDAhPT10JiYoZltpXXw9KHBbaSsxXXxwW2ldKTw8MXwxfHBbaSsxXSksZltpXSZ0aGlzLm1hdGNobWFzayYmKG09dGhpcy5fYml0YXBTY29yZSh0LGktMSksbTw9cikpe2lmKHI9bSxhPWktMSxnLnB1c2goYSksYTw9bylicmVhazt1PU1hdGgubWF4KDEsMipvLWEpfWlmKHRoaXMuX2JpdGFwU2NvcmUodCsxLG8pPnIpYnJlYWs7cD1mfXJldHVybiBfPXRoaXMuX2dldE1hdGNoZWRJbmRpY2VzKEUpLHtpc01hdGNoOmE+PTAsc2NvcmU6MD09PW0/LjAwMTptLG1hdGNoZWRJbmRpY2VzOl99fSxyLnByb3RvdHlwZS5fZ2V0TWF0Y2hlZEluZGljZXM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LGk9W10sbj0tMSxzPS0xLG89MCxyPWUubGVuZ3RoO288cjtvKyspdD1lW29dLHQmJm49PT0tMT9uPW86dHx8bj09PS0xfHwocz1vLTEscy1uKzE+PXRoaXMub3B0aW9ucy5taW5NYXRjaENoYXJMZW5ndGgmJmkucHVzaChbbixzXSksbj0tMSk7cmV0dXJuIGVbby0xXSYmby0xLW4rMT49dGhpcy5vcHRpb25zLm1pbk1hdGNoQ2hhckxlbmd0aCYmaS5wdXNoKFtuLG8tMV0pLGl9LGUuZXhwb3J0cz1ufSh0aGlzKX0sZnVuY3Rpb24oZSx0LGkpe3ZhciBuLHM7IWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSgpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIG49YXJndW1lbnRzW3RdO2lmKG4pe3ZhciBzPXR5cGVvZiBuO2lmKFwic3RyaW5nXCI9PT1zfHxcIm51bWJlclwiPT09cyllLnB1c2gobik7ZWxzZSBpZihBcnJheS5pc0FycmF5KG4pKWUucHVzaChpLmFwcGx5KG51bGwsbikpO2Vsc2UgaWYoXCJvYmplY3RcIj09PXMpZm9yKHZhciByIGluIG4pby5jYWxsKG4scikmJm5bcl0mJmUucHVzaChyKX19cmV0dXJuIGUuam9pbihcIiBcIil9dmFyIG89e30uaGFzT3duUHJvcGVydHk7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9aToobj1bXSxzPWZ1bmN0aW9uKCl7cmV0dXJuIGl9LmFwcGx5KHQsbiksISh2b2lkIDAhPT1zJiYoZS5leHBvcnRzPXMpKSl9KCl9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBzKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2Zvcih2YXIgdD0wLGk9QXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKWlbdF09ZVt0XTtyZXR1cm4gaX1yZXR1cm4gQXJyYXkuZnJvbShlKX1mdW5jdGlvbiBvKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyl7dmFyIG49dFtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbih0LGksbil7cmV0dXJuIGkmJmUodC5wcm90b3R5cGUsaSksbiYmZSh0LG4pLHR9fSgpLGE9aSg1KSxjPWkoMjYpLGw9bihjKSxoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe28odGhpcyxlKSx0aGlzLnN0b3JlPSgwLGEuY3JlYXRlU3RvcmUpKGwuZGVmYXVsdCx3aW5kb3cuZGV2VG9vbHNFeHRlbnNpb24/d2luZG93LmRldlRvb2xzRXh0ZW5zaW9uKCk6dm9pZCAwKX1yZXR1cm4gcihlLFt7a2V5OlwiZ2V0U3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCl9fSx7a2V5OlwiZGlzcGF0Y2hcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnN0b3JlLmRpc3BhdGNoKGUpfX0se2tleTpcInN1YnNjcmliZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc3RvcmUuc3Vic2NyaWJlKGUpfX0se2tleTpcImlzTG9hZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdG9yZS5nZXRTdGF0ZSgpO3JldHVybiBlLmdlbmVyYWwubG9hZGluZ319LHtrZXk6XCJnZXRJdGVtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdG9yZS5nZXRTdGF0ZSgpO3JldHVybiBlLml0ZW1zfX0se2tleTpcImdldEl0ZW1zRmlsdGVyZWRCeUFjdGl2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5nZXRJdGVtcygpLHQ9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYWN0aXZlPT09ITB9LFtdKTtyZXR1cm4gdH19LHtrZXk6XCJnZXRJdGVtc1JlZHVjZWRUb1ZhbHVlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnRoaXMuZ2V0SXRlbXMoKSx0PWUucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUucHVzaCh0LnZhbHVlKSxlfSxbXSk7cmV0dXJuIHR9fSx7a2V5OlwiZ2V0Q2hvaWNlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdG9yZS5nZXRTdGF0ZSgpO3JldHVybiBlLmNob2ljZXN9fSx7a2V5OlwiZ2V0Q2hvaWNlc0ZpbHRlcmVkQnlBY3RpdmVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0Q2hvaWNlcygpLHQ9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYWN0aXZlPT09ITB9KTtyZXR1cm4gdH19LHtrZXk6XCJnZXRDaG9pY2VzRmlsdGVyZWRCeVNlbGVjdGFibGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0Q2hvaWNlcygpLHQ9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzYWJsZWQhPT0hMH0pO3JldHVybiB0fX0se2tleTpcImdldFNlYXJjaGFibGVDaG9pY2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldENob2ljZXNGaWx0ZXJlZEJ5U2VsZWN0YWJsZSgpO3JldHVybiBlLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS5wbGFjZWhvbGRlciE9PSEwfSl9fSx7a2V5OlwiZ2V0Q2hvaWNlQnlJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUpe3ZhciB0PXRoaXMuZ2V0Q2hvaWNlc0ZpbHRlcmVkQnlBY3RpdmUoKSxpPXQuZmluZChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZD09PXBhcnNlSW50KGUsMTApfSk7cmV0dXJuIGl9cmV0dXJuITF9fSx7a2V5OlwiZ2V0R3JvdXBzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnN0b3JlLmdldFN0YXRlKCk7cmV0dXJuIGUuZ3JvdXBzfX0se2tleTpcImdldEdyb3Vwc0ZpbHRlcmVkQnlBY3RpdmVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0R3JvdXBzKCksdD10aGlzLmdldENob2ljZXMoKSxpPWUuZmlsdGVyKGZ1bmN0aW9uKGUpe3ZhciBpPWUuYWN0aXZlPT09ITAmJmUuZGlzYWJsZWQ9PT0hMSxuPXQuc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZS5hY3RpdmU9PT0hMCYmZS5kaXNhYmxlZD09PSExfSk7cmV0dXJuIGkmJm59LFtdKTtyZXR1cm4gaX19LHtrZXk6XCJnZXRHcm91cEJ5SWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldEdyb3VwcygpLGk9dC5maW5kKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkPT09ZX0pO3JldHVybiBpfX0se2tleTpcImdldFBsYWNlaG9sZGVyQ2hvaWNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldENob2ljZXMoKSx0PVtdLmNvbmNhdChzKGUpKS5yZXZlcnNlKCkuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gZS5wbGFjZWhvbGRlcj09PSEwfSk7cmV0dXJuIHR9fV0pLGV9KCk7dC5kZWZhdWx0PWgsZS5leHBvcnRzPWh9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX10Ll9fZXNNb2R1bGU9ITAsdC5jb21wb3NlPXQuYXBwbHlNaWRkbGV3YXJlPXQuYmluZEFjdGlvbkNyZWF0b3JzPXQuY29tYmluZVJlZHVjZXJzPXQuY3JlYXRlU3RvcmU9dm9pZCAwO3ZhciBzPWkoNiksbz1uKHMpLHI9aSgyMSksYT1uKHIpLGM9aSgyMyksbD1uKGMpLGg9aSgyNCksdT1uKGgpLGQ9aSgyNSksZj1uKGQpLHA9aSgyMik7bihwKTt0LmNyZWF0ZVN0b3JlPW8uZGVmYXVsdCx0LmNvbWJpbmVSZWR1Y2Vycz1hLmRlZmF1bHQsdC5iaW5kQWN0aW9uQ3JlYXRvcnM9bC5kZWZhdWx0LHQuYXBwbHlNaWRkbGV3YXJlPXUuZGVmYXVsdCx0LmNvbXBvc2U9Zi5kZWZhdWx0fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gcyhlLHQsaSl7ZnVuY3Rpb24gbigpe2c9PT1tJiYoZz1tLnNsaWNlKCkpfWZ1bmN0aW9uIG8oKXtyZXR1cm4gdn1mdW5jdGlvbiBhKGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi5cIik7dmFyIHQ9ITA7cmV0dXJuIG4oKSxnLnB1c2goZSksZnVuY3Rpb24oKXtpZih0KXt0PSExLG4oKTt2YXIgaT1nLmluZGV4T2YoZSk7Zy5zcGxpY2UoaSwxKX19fWZ1bmN0aW9uIGgoZSl7aWYoISgwLHIuZGVmYXVsdCkoZSkpdGhyb3cgbmV3IEVycm9yKFwiQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuIFVzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy5cIik7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGUudHlwZSl0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO2lmKHkpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLlwiKTt0cnl7eT0hMCx2PXAodixlKX1maW5hbGx5e3k9ITF9Zm9yKHZhciB0PW09ZyxpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciBuPXRbaV07bigpfXJldHVybiBlfWZ1bmN0aW9uIHUoZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi5cIik7cD1lLGgoe3R5cGU6bC5JTklUfSl9ZnVuY3Rpb24gZCgpe3ZhciBlLHQ9YTtyZXR1cm4gZT17c3Vic2NyaWJlOmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGkoKXtlLm5leHQmJmUubmV4dChvKCkpfWlmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LlwiKTtpKCk7dmFyIG49dChpKTtyZXR1cm57dW5zdWJzY3JpYmU6bn19fSxlW2MuZGVmYXVsdF09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sZX12YXIgZjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgaSYmKGk9dCx0PXZvaWQgMCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGkpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uXCIpO3JldHVybiBpKHMpKGUsdCl9aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLlwiKTt2YXIgcD1lLHY9dCxtPVtdLGc9bSx5PSExO3JldHVybiBoKHt0eXBlOmwuSU5JVH0pLGY9e2Rpc3BhdGNoOmgsc3Vic2NyaWJlOmEsZ2V0U3RhdGU6byxyZXBsYWNlUmVkdWNlcjp1fSxmW2MuZGVmYXVsdF09ZCxmfXQuX19lc01vZHVsZT0hMCx0LkFjdGlvblR5cGVzPXZvaWQgMCx0LmRlZmF1bHQ9czt2YXIgbz1pKDcpLHI9bihvKSxhPWkoMTcpLGM9bihhKSxsPXQuQWN0aW9uVHlwZXM9e0lOSVQ6XCJAQHJlZHV4L0lOSVRcIn19LGZ1bmN0aW9uKGUsdCxpKXtmdW5jdGlvbiBuKGUpe2lmKCFyKGUpfHxzKGUpIT1hKXJldHVybiExO3ZhciB0PW8oZSk7aWYobnVsbD09PXQpcmV0dXJuITA7dmFyIGk9dS5jYWxsKHQsXCJjb25zdHJ1Y3RvclwiKSYmdC5jb25zdHJ1Y3RvcjtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBpJiZpIGluc3RhbmNlb2YgaSYmaC5jYWxsKGkpPT1kfXZhciBzPWkoOCksbz1pKDE0KSxyPWkoMTYpLGE9XCJbb2JqZWN0IE9iamVjdF1cIixjPUZ1bmN0aW9uLnByb3RvdHlwZSxsPU9iamVjdC5wcm90b3R5cGUsaD1jLnRvU3RyaW5nLHU9bC5oYXNPd25Qcm9wZXJ0eSxkPWguY2FsbChPYmplY3QpO2UuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQsaSl7ZnVuY3Rpb24gbihlKXtyZXR1cm4gbnVsbD09ZT92b2lkIDA9PT1lP2M6YTpsJiZsIGluIE9iamVjdChlKT9vKGUpOnIoZSl9dmFyIHM9aSg5KSxvPWkoMTIpLHI9aSgxMyksYT1cIltvYmplY3QgTnVsbF1cIixjPVwiW29iamVjdCBVbmRlZmluZWRdXCIsbD1zP3MudG9TdHJpbmdUYWc6dm9pZCAwO2UuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQsaSl7dmFyIG49aSgxMCkscz1uLlN5bWJvbDtlLmV4cG9ydHM9c30sZnVuY3Rpb24oZSx0LGkpe3ZhciBuPWkoMTEpLHM9XCJvYmplY3RcIj09dHlwZW9mIHNlbGYmJnNlbGYmJnNlbGYuT2JqZWN0PT09T2JqZWN0JiZzZWxmLG89bnx8c3x8RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO2UuZXhwb3J0cz1vfSxmdW5jdGlvbihlLHQpeyhmdW5jdGlvbih0KXt2YXIgaT1cIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmdC5PYmplY3Q9PT1PYmplY3QmJnQ7ZS5leHBvcnRzPWl9KS5jYWxsKHQsZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKSl9LGZ1bmN0aW9uKGUsdCxpKXtmdW5jdGlvbiBuKGUpe3ZhciB0PXIuY2FsbChlLGMpLGk9ZVtjXTt0cnl7ZVtjXT12b2lkIDA7dmFyIG49ITB9Y2F0Y2goZSl7fXZhciBzPWEuY2FsbChlKTtyZXR1cm4gbiYmKHQ/ZVtjXT1pOmRlbGV0ZSBlW2NdKSxzfXZhciBzPWkoOSksbz1PYmplY3QucHJvdG90eXBlLHI9by5oYXNPd25Qcm9wZXJ0eSxhPW8udG9TdHJpbmcsYz1zP3MudG9TdHJpbmdUYWc6dm9pZCAwO2UuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIGkoZSl7cmV0dXJuIHMuY2FsbChlKX12YXIgbj1PYmplY3QucHJvdG90eXBlLHM9bi50b1N0cmluZztlLmV4cG9ydHM9aX0sZnVuY3Rpb24oZSx0LGkpe3ZhciBuPWkoMTUpLHM9bihPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KTtlLmV4cG9ydHM9c30sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBpKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiBlKHQoaSkpfX1lLmV4cG9ydHM9aX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBpKGUpe3JldHVybiBudWxsIT1lJiZcIm9iamVjdFwiPT10eXBlb2YgZX1lLmV4cG9ydHM9aX0sZnVuY3Rpb24oZSx0LGkpe2UuZXhwb3J0cz1pKDE4KX0sZnVuY3Rpb24oZSx0LGkpeyhmdW5jdGlvbihlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHMoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvLHI9aSgyMCksYT1zKHIpO289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZT9lOm47dmFyIGM9KDAsYS5kZWZhdWx0KShvKTt0LmRlZmF1bHQ9Y30pLmNhbGwodCxmdW5jdGlvbigpe3JldHVybiB0aGlzfSgpLGkoMTkpKGUpKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUud2VicGFja1BvbHlmaWxsfHwoZS5kZXByZWNhdGU9ZnVuY3Rpb24oKXt9LGUucGF0aHM9W10sZS5jaGlsZHJlbj1bXSxlLndlYnBhY2tQb2x5ZmlsbD0xKSxlfX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3ZhciB0LGk9ZS5TeW1ib2w7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgaT9pLm9ic2VydmFibGU/dD1pLm9ic2VydmFibGU6KHQ9aShcIm9ic2VydmFibGVcIiksaS5vYnNlcnZhYmxlPXQpOnQ9XCJAQG9ic2VydmFibGVcIix0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1pfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gcyhlLHQpe3ZhciBpPXQmJnQudHlwZSxuPWkmJidcIicraS50b1N0cmluZygpKydcIid8fFwiYW4gYWN0aW9uXCI7cmV0dXJuXCJHaXZlbiBhY3Rpb24gXCIrbisnLCByZWR1Y2VyIFwiJytlKydcIiByZXR1cm5lZCB1bmRlZmluZWQuIFRvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gSWYgeW91IHdhbnQgdGhpcyByZWR1Y2VyIHRvIGhvbGQgbm8gdmFsdWUsIHlvdSBjYW4gcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuJ31mdW5jdGlvbiBvKGUpe09iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGk9ZVt0XSxuPWkodm9pZCAwLHt0eXBlOmEuQWN0aW9uVHlwZXMuSU5JVH0pO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicrdCtcIlxcXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5cIik7dmFyIHM9XCJAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OX1wiK01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdChcIlwiKS5qb2luKFwiLlwiKTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgaSh2b2lkIDAse3R5cGU6c30pKXRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicrdCsnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJysoXCJEb24ndCB0cnkgdG8gaGFuZGxlIFwiK2EuQWN0aW9uVHlwZXMuSU5JVCsnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykrXCJuYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuXCIpfSl9ZnVuY3Rpb24gcihlKXtmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksaT17fSxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07XCJmdW5jdGlvblwiPT10eXBlb2YgZVtyXSYmKGlbcl09ZVtyXSl9dmFyIGE9T2JqZWN0LmtleXMoaSksYz12b2lkIDA7dHJ5e28oaSl9Y2F0Y2goZSl7Yz1lfXJldHVybiBmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PWFyZ3VtZW50c1sxXTtpZihjKXRocm93IGM7Zm9yKHZhciBuPSExLG89e30scj0wO3I8YS5sZW5ndGg7cisrKXt2YXIgbD1hW3JdLGg9aVtsXSx1PWVbbF0sZD1oKHUsdCk7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGQpe3ZhciBmPXMobCx0KTt0aHJvdyBuZXcgRXJyb3IoZil9b1tsXT1kLG49bnx8ZCE9PXV9cmV0dXJuIG4/bzplfX10Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXI7dmFyIGE9aSg2KSxjPWkoNyksbD0obihjKSxpKDIyKSk7bihsKX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBjb25zb2xlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjb25zb2xlLmVycm9yJiZjb25zb2xlLmVycm9yKGUpO3RyeXt0aHJvdyBuZXcgRXJyb3IoZSl9Y2F0Y2goZSl7fX10Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PWl9LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KGUuYXBwbHkodm9pZCAwLGFyZ3VtZW50cykpfX1mdW5jdGlvbiBuKGUsdCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSlyZXR1cm4gaShlLHQpO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgXCIrKG51bGw9PT1lP1wibnVsbFwiOnR5cGVvZiBlKSsnLiBEaWQgeW91IHdyaXRlIFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cIiBpbnN0ZWFkIG9mIFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiPycpO2Zvcih2YXIgbj1PYmplY3Qua2V5cyhlKSxzPXt9LG89MDtvPG4ubGVuZ3RoO28rKyl7dmFyIHI9bltvXSxhPWVbcl07XCJmdW5jdGlvblwiPT10eXBlb2YgYSYmKHNbcl09aShhLHQpKX1yZXR1cm4gc310Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PW59LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBzKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1BcnJheShlKSxpPTA7aTxlO2krKyl0W2ldPWFyZ3VtZW50c1tpXTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKGksbixzKXt2YXIgcj1lKGksbixzKSxjPXIuZGlzcGF0Y2gsbD1bXSxoPXtnZXRTdGF0ZTpyLmdldFN0YXRlLGRpc3BhdGNoOmZ1bmN0aW9uKGUpe3JldHVybiBjKGUpfX07cmV0dXJuIGw9dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUoaCl9KSxjPWEuZGVmYXVsdC5hcHBseSh2b2lkIDAsbCkoci5kaXNwYXRjaCksbyh7fSxyLHtkaXNwYXRjaDpjfSl9fX10Ll9fZXNNb2R1bGU9ITA7dmFyIG89T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIGk9YXJndW1lbnRzW3RdO2Zvcih2YXIgbiBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLG4pJiYoZVtuXT1pW25dKX1yZXR1cm4gZX07dC5kZWZhdWx0PXM7dmFyIHI9aSgyNSksYT1uKHIpfSxmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PUFycmF5KGUpLGk9MDtpPGU7aSsrKXRbaV09YXJndW1lbnRzW2ldO3JldHVybiAwPT09dC5sZW5ndGg/ZnVuY3Rpb24oZSl7cmV0dXJuIGV9OjE9PT10Lmxlbmd0aD90WzBdOnQucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUodC5hcHBseSh2b2lkIDAsYXJndW1lbnRzKSl9fSl9dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD1pfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9aSg1KSxvPWkoMjcpLHI9bihvKSxhPWkoMjgpLGM9bihhKSxsPWkoMjkpLGg9bihsKSx1PWkoMzApLGQ9bih1KSxmPSgwLHMuY29tYmluZVJlZHVjZXJzKSh7aXRlbXM6ci5kZWZhdWx0LGdyb3VwczpjLmRlZmF1bHQsY2hvaWNlczpoLmRlZmF1bHQsZ2VuZXJhbDpkLmRlZmF1bHR9KSxwPWZ1bmN0aW9uKGUsdCl7dmFyIGk9ZTtyZXR1cm5cIkNMRUFSX0FMTFwiPT09dC50eXBlJiYoaT12b2lkIDApLGYoaSx0KX07dC5kZWZhdWx0PXB9LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxpPUFycmF5KGUubGVuZ3RoKTt0PGUubGVuZ3RoO3QrKylpW3RdPWVbdF07cmV0dXJuIGl9cmV0dXJuIEFycmF5LmZyb20oZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06W10sdD1hcmd1bWVudHNbMV07c3dpdGNoKHQudHlwZSl7Y2FzZVwiQUREX0lURU1cIjp2YXIgbj1bXS5jb25jYXQoaShlKSxbe2lkOnQuaWQsY2hvaWNlSWQ6dC5jaG9pY2VJZCxncm91cElkOnQuZ3JvdXBJZCx2YWx1ZTp0LnZhbHVlLGxhYmVsOnQubGFiZWwsYWN0aXZlOiEwLGhpZ2hsaWdodGVkOiExLGN1c3RvbVByb3BlcnRpZXM6dC5jdXN0b21Qcm9wZXJ0aWVzLHBsYWNlaG9sZGVyOnQucGxhY2Vob2xkZXJ8fCExLGtleUNvZGU6bnVsbH1dKTtyZXR1cm4gbi5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaGlnaGxpZ2h0ZWQmJihlLmhpZ2hsaWdodGVkPSExKSxlfSk7Y2FzZVwiUkVNT1ZFX0lURU1cIjpyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT10LmlkJiYoZS5hY3RpdmU9ITEpLGV9KTtjYXNlXCJISUdITElHSFRfSVRFTVwiOnJldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PXQuaWQmJihlLmhpZ2hsaWdodGVkPXQuaGlnaGxpZ2h0ZWQpLGV9KTtkZWZhdWx0OnJldHVybiBlfX07dC5kZWZhdWx0PW59LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxpPUFycmF5KGUubGVuZ3RoKTt0PGUubGVuZ3RoO3QrKylpW3RdPWVbdF07cmV0dXJuIGl9cmV0dXJuIEFycmF5LmZyb20oZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06W10sdD1hcmd1bWVudHNbMV07c3dpdGNoKHQudHlwZSl7Y2FzZVwiQUREX0dST1VQXCI6cmV0dXJuW10uY29uY2F0KGkoZSksW3tpZDp0LmlkLHZhbHVlOnQudmFsdWUsYWN0aXZlOnQuYWN0aXZlLGRpc2FibGVkOnQuZGlzYWJsZWR9XSk7Y2FzZVwiQ0xFQVJfQ0hPSUNFU1wiOnJldHVybiBlLmdyb3Vwcz1bXTtkZWZhdWx0OnJldHVybiBlfX07dC5kZWZhdWx0PW59LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxpPUFycmF5KGUubGVuZ3RoKTt0PGUubGVuZ3RoO3QrKylpW3RdPWVbdF07cmV0dXJuIGl9cmV0dXJuIEFycmF5LmZyb20oZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06W10sdD1hcmd1bWVudHNbMV07c3dpdGNoKHQudHlwZSl7Y2FzZVwiQUREX0NIT0lDRVwiOnJldHVybltdLmNvbmNhdChpKGUpLFt7aWQ6dC5pZCxlbGVtZW50SWQ6dC5lbGVtZW50SWQsZ3JvdXBJZDp0Lmdyb3VwSWQsdmFsdWU6dC52YWx1ZSxsYWJlbDp0LmxhYmVsfHx0LnZhbHVlLGRpc2FibGVkOnQuZGlzYWJsZWR8fCExLHNlbGVjdGVkOiExLGFjdGl2ZTohMCxzY29yZTo5OTk5LGN1c3RvbVByb3BlcnRpZXM6dC5jdXN0b21Qcm9wZXJ0aWVzLHBsYWNlaG9sZGVyOnQucGxhY2Vob2xkZXJ8fCExLGtleUNvZGU6bnVsbH1dKTtjYXNlXCJBRERfSVRFTVwiOnZhciBuPWU7cmV0dXJuIHQuYWN0aXZhdGVPcHRpb25zJiYobj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5hY3RpdmU9dC5hY3RpdmUsZX0pKSx0LmNob2ljZUlkPi0xJiYobj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PXBhcnNlSW50KHQuY2hvaWNlSWQsMTApJiYoZS5zZWxlY3RlZD0hMCksZX0pKSxuO2Nhc2VcIlJFTU9WRV9JVEVNXCI6cmV0dXJuIHQuY2hvaWNlSWQ+LTE/ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT1wYXJzZUludCh0LmNob2ljZUlkLDEwKSYmKGUuc2VsZWN0ZWQ9ITEpLGV9KTplO2Nhc2VcIkZJTFRFUl9DSE9JQ0VTXCI6dmFyIHM9dC5yZXN1bHRzLG89ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYWN0aXZlPXMuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdC5pdGVtLmlkPT09ZS5pZCYmKGUuc2NvcmU9dC5zY29yZSwhMCl9KSxlfSk7cmV0dXJuIG87Y2FzZVwiQUNUSVZBVEVfQ0hPSUNFU1wiOnJldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5hY3RpdmU9dC5hY3RpdmUsZX0pO2Nhc2VcIkNMRUFSX0NIT0lDRVNcIjpyZXR1cm4gZS5jaG9pY2VzPVtdO2RlZmF1bHQ6cmV0dXJuIGV9fTt0LmRlZmF1bHQ9bn0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7bG9hZGluZzohMX0sdD1hcmd1bWVudHNbMV07c3dpdGNoKHQudHlwZSl7Y2FzZVwiTE9BRElOR1wiOnJldHVybntsb2FkaW5nOnQuaXNMb2FkaW5nfTtkZWZhdWx0OnJldHVybiBlfX07dC5kZWZhdWx0PWl9LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dC5hZGRJdGVtPWZ1bmN0aW9uKGUsdCxpLG4scyxvLHIsYSl7cmV0dXJue3R5cGU6XCJBRERfSVRFTVwiLHZhbHVlOmUsbGFiZWw6dCxpZDppLGNob2ljZUlkOm4sZ3JvdXBJZDpzLGN1c3RvbVByb3BlcnRpZXM6byxwbGFjZWhvbGRlcjpyLGtleUNvZGU6YX19LHQucmVtb3ZlSXRlbT1mdW5jdGlvbihlLHQpe3JldHVybnt0eXBlOlwiUkVNT1ZFX0lURU1cIixpZDplLGNob2ljZUlkOnR9fSx0LmhpZ2hsaWdodEl0ZW09ZnVuY3Rpb24oZSx0KXtyZXR1cm57dHlwZTpcIkhJR0hMSUdIVF9JVEVNXCIsaWQ6ZSxoaWdobGlnaHRlZDp0fX0sdC5hZGRDaG9pY2U9ZnVuY3Rpb24oZSx0LGksbixzLG8scixhLGMpe3JldHVybnt0eXBlOlwiQUREX0NIT0lDRVwiLHZhbHVlOmUsbGFiZWw6dCxpZDppLGdyb3VwSWQ6bixkaXNhYmxlZDpzLGVsZW1lbnRJZDpvLGN1c3RvbVByb3BlcnRpZXM6cixwbGFjZWhvbGRlcjphLGtleUNvZGU6Y319LHQuZmlsdGVyQ2hvaWNlcz1mdW5jdGlvbihlKXtyZXR1cm57dHlwZTpcIkZJTFRFUl9DSE9JQ0VTXCIscmVzdWx0czplfX0sdC5hY3RpdmF0ZUNob2ljZXM9ZnVuY3Rpb24oKXt2YXIgZT0hKGFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdKXx8YXJndW1lbnRzWzBdO3JldHVybnt0eXBlOlwiQUNUSVZBVEVfQ0hPSUNFU1wiLGFjdGl2ZTplfX0sdC5jbGVhckNob2ljZXM9ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcIkNMRUFSX0NIT0lDRVNcIn19LHQuYWRkR3JvdXA9ZnVuY3Rpb24oZSx0LGksbil7cmV0dXJue3R5cGU6XCJBRERfR1JPVVBcIix2YWx1ZTplLGlkOnQsYWN0aXZlOmksZGlzYWJsZWQ6bn19LHQuY2xlYXJBbGw9ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcIkNMRUFSX0FMTFwifX0sdC5zZXRJc0xvYWRpbmc9ZnVuY3Rpb24oZSl7cmV0dXJue3R5cGU6XCJMT0FESU5HXCIsaXNMb2FkaW5nOmV9fX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSxuPSh0LmNhcGl0YWxpc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvXFx3XFxTKi9nLGZ1bmN0aW9uKGUpe3JldHVybiBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCl9KX0sdC5nZW5lcmF0ZUNoYXJzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1cIlwiLGk9MDtpPGU7aSsrKXt2YXIgbj1jKDAsMzYpO3QrPW4udG9TdHJpbmcoMzYpfXJldHVybiB0fSkscz0odC5nZW5lcmF0ZUlkPWZ1bmN0aW9uKGUsdCl7dmFyIGk9ZS5pZHx8ZS5uYW1lJiZlLm5hbWUrXCItXCIrbigyKXx8big0KTtyZXR1cm4gaT1pLnJlcGxhY2UoLyg6fFxcLnxcXFt8XFxdfCwpL2csXCJcIiksaT10K2l9LHQuZ2V0VHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO1xufSksbz10LmlzVHlwZT1mdW5jdGlvbihlLHQpe3ZhciBpPXModCk7cmV0dXJuIHZvaWQgMCE9PXQmJm51bGwhPT10JiZpPT09ZX0scj0odC5pc05vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09PShcInVuZGVmaW5lZFwiPT10eXBlb2YgTm9kZT9cInVuZGVmaW5lZFwiOmkoTm9kZSkpP2UgaW5zdGFuY2VvZiBOb2RlOmUmJlwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGU/XCJ1bmRlZmluZWRcIjppKGUpKSYmXCJudW1iZXJcIj09dHlwZW9mIGUubm9kZVR5cGUmJlwic3RyaW5nXCI9PXR5cGVvZiBlLm5vZGVOYW1lfSx0LmlzRWxlbWVudD1mdW5jdGlvbihlKXtyZXR1cm5cIm9iamVjdFwiPT09KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBIVE1MRWxlbWVudD9cInVuZGVmaW5lZFwiOmkoSFRNTEVsZW1lbnQpKT9lIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ6ZSYmXCJvYmplY3RcIj09PShcInVuZGVmaW5lZFwiPT10eXBlb2YgZT9cInVuZGVmaW5lZFwiOmkoZSkpJiZudWxsIT09ZSYmMT09PWUubm9kZVR5cGUmJlwic3RyaW5nXCI9PXR5cGVvZiBlLm5vZGVOYW1lfSx0LmV4dGVuZD1mdW5jdGlvbiBlKCl7Zm9yKHZhciB0PXt9LGk9YXJndW1lbnRzLmxlbmd0aCxuPWZ1bmN0aW9uKGkpe2Zvcih2YXIgbiBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLG4pJiYobyhcIk9iamVjdFwiLGlbbl0pP3Rbbl09ZSghMCx0W25dLGlbbl0pOnRbbl09aVtuXSl9LHM9MDtzPGk7cysrKXt2YXIgcj1hcmd1bWVudHNbc107byhcIk9iamVjdFwiLHIpJiZuKHIpfXJldHVybiB0fSx0LndoaWNoVHJhbnNpdGlvbkV2ZW50PWZ1bmN0aW9uKCl7dmFyIGUsdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmFrZWVsZW1lbnRcIiksaT17dHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIixPVHJhbnNpdGlvbjpcIm9UcmFuc2l0aW9uRW5kXCIsTW96VHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIixXZWJraXRUcmFuc2l0aW9uOlwid2Via2l0VHJhbnNpdGlvbkVuZFwifTtmb3IoZSBpbiBpKWlmKHZvaWQgMCE9PXQuc3R5bGVbZV0pcmV0dXJuIGlbZV19LHQud2hpY2hBbmltYXRpb25FdmVudD1mdW5jdGlvbigpe3ZhciBlLHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZha2VlbGVtZW50XCIpLGk9e2FuaW1hdGlvbjpcImFuaW1hdGlvbmVuZFwiLE9BbmltYXRpb246XCJvQW5pbWF0aW9uRW5kXCIsTW96QW5pbWF0aW9uOlwiYW5pbWF0aW9uZW5kXCIsV2Via2l0QW5pbWF0aW9uOlwid2Via2l0QW5pbWF0aW9uRW5kXCJ9O2ZvcihlIGluIGkpaWYodm9pZCAwIT09dC5zdHlsZVtlXSlyZXR1cm4gaVtlXX0pLGE9KHQuZ2V0UGFyZW50c1VudGlsPWZ1bmN0aW9uKGUsdCxpKXtmb3IodmFyIG49W107ZSYmZSE9PWRvY3VtZW50O2U9ZS5wYXJlbnROb2RlKXtpZih0KXt2YXIgcz10LmNoYXJBdCgwKTtpZihcIi5cIj09PXMmJmUuY2xhc3NMaXN0LmNvbnRhaW5zKHQuc3Vic3RyKDEpKSlicmVhaztpZihcIiNcIj09PXMmJmUuaWQ9PT10LnN1YnN0cigxKSlicmVhaztpZihcIltcIj09PXMmJmUuaGFzQXR0cmlidXRlKHQuc3Vic3RyKDEsdC5sZW5ndGgtMSkpKWJyZWFrO2lmKGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT09dClicmVha31pZihpKXt2YXIgbz1pLmNoYXJBdCgwKTtcIi5cIj09PW8mJmUuY2xhc3NMaXN0LmNvbnRhaW5zKGkuc3Vic3RyKDEpKSYmbi5wdXNoKGUpLFwiI1wiPT09byYmZS5pZD09PWkuc3Vic3RyKDEpJiZuLnB1c2goZSksXCJbXCI9PT1vJiZlLmhhc0F0dHJpYnV0ZShpLnN1YnN0cigxLGkubGVuZ3RoLTEpKSYmbi5wdXNoKGUpLGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT09aSYmbi5wdXNoKGUpfWVsc2Ugbi5wdXNoKGUpfXJldHVybiAwPT09bi5sZW5ndGg/bnVsbDpufSx0LndyYXA9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD10fHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGUubmV4dFNpYmxpbmc/ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpOmUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0KSx0LmFwcGVuZENoaWxkKGUpfSx0LmdldFNpYmxpbmdzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxpPWUucGFyZW50Tm9kZS5maXJzdENoaWxkO2k7aT1pLm5leHRTaWJsaW5nKTE9PT1pLm5vZGVUeXBlJiZpIT09ZSYmdC5wdXNoKGkpO3JldHVybiB0fSx0LmZpbmRBbmNlc3Rvcj1mdW5jdGlvbihlLHQpe2Zvcig7KGU9ZS5wYXJlbnRFbGVtZW50KSYmIWUuY2xhc3NMaXN0LmNvbnRhaW5zKHQpOyk7cmV0dXJuIGV9LHQuZmluZEFuY2VzdG9yQnlBdHRyTmFtZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgaT1lO2k7KXtpZihpLmhhc0F0dHJpYnV0ZSh0KSlyZXR1cm4gaTtpPWkucGFyZW50RWxlbWVudH1yZXR1cm4gbnVsbH0sdC5kZWJvdW5jZT1mdW5jdGlvbihlLHQsaSl7dmFyIG47cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHM9dGhpcyxvPWFyZ3VtZW50cyxyPWZ1bmN0aW9uKCl7bj1udWxsLGl8fGUuYXBwbHkocyxvKX0sYT1pJiYhbjtjbGVhclRpbWVvdXQobiksbj1zZXRUaW1lb3V0KHIsdCksYSYmZS5hcHBseShzLG8pfX0sdC5nZXRFbGVtRGlzdGFuY2U9ZnVuY3Rpb24oZSl7dmFyIHQ9MDtpZihlLm9mZnNldFBhcmVudClkbyB0Kz1lLm9mZnNldFRvcCxlPWUub2Zmc2V0UGFyZW50O3doaWxlKGUpO3JldHVybiB0Pj0wP3Q6MH0sdC5nZXRFbGVtZW50T2Zmc2V0PWZ1bmN0aW9uKGUsdCl7dmFyIGk9dDtyZXR1cm4gaT4xJiYoaT0xKSxpPjAmJihpPTApLE1hdGgubWF4KGUub2Zmc2V0SGVpZ2h0KmkpfSx0LmdldEFkamFjZW50RWw9ZnVuY3Rpb24oZSx0KXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06MTtpZihlJiZ0KXt2YXIgbj1lLnBhcmVudE5vZGUucGFyZW50Tm9kZSxzPUFycmF5LmZyb20obi5xdWVyeVNlbGVjdG9yQWxsKHQpKSxvPXMuaW5kZXhPZihlKSxyPWk+MD8xOi0xO3JldHVybiBzW28rcl19fSx0LmdldFNjcm9sbFBvc2l0aW9uPWZ1bmN0aW9uKGUpe3JldHVyblwiYm90dG9tXCI9PT1lP01hdGgubWF4KCh3aW5kb3cuc2Nyb2xsWXx8d2luZG93LnBhZ2VZT2Zmc2V0KSsod2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSk6d2luZG93LnNjcm9sbFl8fHdpbmRvdy5wYWdlWU9mZnNldH0sdC5pc0luVmlldz1mdW5jdGlvbihlLHQsaSl7cmV0dXJuIHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb24odCk+dGhpcy5nZXRFbGVtRGlzdGFuY2UoZSkrdGhpcy5nZXRFbGVtZW50T2Zmc2V0KGUsaSl9LHQuaXNTY3JvbGxlZEludG9WaWV3PWZ1bmN0aW9uKGUsdCl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOjE7aWYoZSl7dmFyIG49dm9pZCAwO3JldHVybiBuPWk+MD90LnNjcm9sbFRvcCt0Lm9mZnNldEhlaWdodD49ZS5vZmZzZXRUb3ArZS5vZmZzZXRIZWlnaHQ6ZS5vZmZzZXRUb3A+PXQuc2Nyb2xsVG9wfX0sdC5zdHJpcEhUTUw9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvJi9nLFwiJmFtcDtcIikucmVwbGFjZSgvPi9nLFwiJnJ0O1wiKS5yZXBsYWNlKC88L2csXCImbHQ7XCIpLnJlcGxhY2UoL1wiL2csXCImcXVvdDtcIil9KSxjPSh0LmFkZEFuaW1hdGlvbj1mdW5jdGlvbihlLHQpe3ZhciBpPXIoKSxuPWZ1bmN0aW9uIG4oKXtlLmNsYXNzTGlzdC5yZW1vdmUodCksZS5yZW1vdmVFdmVudExpc3RlbmVyKGksbiwhMSl9O2UuY2xhc3NMaXN0LmFkZCh0KSxlLmFkZEV2ZW50TGlzdGVuZXIoaSxuLCExKX0sdC5nZXRSYW5kb21OdW1iZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKih0LWUpK2UpfSksbD10LnN0clRvRWw9ZnVuY3Rpb24oKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3JldHVybiBmdW5jdGlvbih0KXt2YXIgaT10LnRyaW0oKSxuPXZvaWQgMDtmb3IoZS5pbm5lckhUTUw9aSxuPWUuY2hpbGRyZW5bMF07ZS5maXJzdENoaWxkOyllLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7cmV0dXJuIG59fSgpO3QuZ2V0V2lkdGhPZklucHV0PWZ1bmN0aW9uKGUpe3ZhciB0PWUudmFsdWV8fGUucGxhY2Vob2xkZXIsaT1lLm9mZnNldFdpZHRoO2lmKHQpe3ZhciBuPWwoXCI8c3Bhbj5cIithKHQpK1wiPC9zcGFuPlwiKTtpZihuLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixuLnN0eWxlLnBhZGRpbmc9XCIwXCIsbi5zdHlsZS50b3A9XCItOTk5OXB4XCIsbi5zdHlsZS5sZWZ0PVwiLTk5OTlweFwiLG4uc3R5bGUud2lkdGg9XCJhdXRvXCIsbi5zdHlsZS53aGl0ZVNwYWNlPVwicHJlXCIsZG9jdW1lbnQuYm9keS5jb250YWlucyhlKSYmd2luZG93LmdldENvbXB1dGVkU3R5bGUpe3ZhciBzPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpO3MmJihuLnN0eWxlLmZvbnRTaXplPXMuZm9udFNpemUsbi5zdHlsZS5mb250RmFtaWx5PXMuZm9udEZhbWlseSxuLnN0eWxlLmZvbnRXZWlnaHQ9cy5mb250V2VpZ2h0LG4uc3R5bGUuZm9udFN0eWxlPXMuZm9udFN0eWxlLG4uc3R5bGUubGV0dGVyU3BhY2luZz1zLmxldHRlclNwYWNpbmcsbi5zdHlsZS50ZXh0VHJhbnNmb3JtPXMudGV4dFRyYW5zZm9ybSxuLnN0eWxlLnBhZGRpbmc9cy5wYWRkaW5nKX1kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG4pLHQmJm4ub2Zmc2V0V2lkdGghPT1lLm9mZnNldFdpZHRoJiYoaT1uLm9mZnNldFdpZHRoKzQpLGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobil9cmV0dXJuIGkrXCJweFwifSx0LnNvcnRCeUFscGhhPWZ1bmN0aW9uKGUsdCl7dmFyIGk9KGUubGFiZWx8fGUudmFsdWUpLnRvTG93ZXJDYXNlKCksbj0odC5sYWJlbHx8dC52YWx1ZSkudG9Mb3dlckNhc2UoKTtyZXR1cm4gaTxuPy0xOmk+bj8xOjB9LHQuc29ydEJ5U2NvcmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5zY29yZS10LnNjb3JlfSx0LnRyaWdnZXJFdmVudD1mdW5jdGlvbihlLHQpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLG49bmV3IEN1c3RvbUV2ZW50KHQse2RldGFpbDppLGJ1YmJsZXM6ITAsY2FuY2VsYWJsZTohMH0pO3JldHVybiBlLmRpc3BhdGNoRXZlbnQobil9fSxmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiOyFmdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0PXR8fHtidWJibGVzOiExLGNhbmNlbGFibGU6ITEsZGV0YWlsOnZvaWQgMH07dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtyZXR1cm4gaS5pbml0Q3VzdG9tRXZlbnQoZSx0LmJ1YmJsZXMsdC5jYW5jZWxhYmxlLHQuZGV0YWlsKSxpfUFycmF5LmZyb218fChBcnJheS5mcm9tPWZ1bmN0aW9uKCl7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyx0PWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHR8fFwiW29iamVjdCBGdW5jdGlvbl1cIj09PWUuY2FsbCh0KX0saT1mdW5jdGlvbihlKXt2YXIgdD1OdW1iZXIoZSk7cmV0dXJuIGlzTmFOKHQpPzA6MCE9PXQmJmlzRmluaXRlKHQpPyh0PjA/MTotMSkqTWF0aC5mbG9vcihNYXRoLmFicyh0KSk6dH0sbj1NYXRoLnBvdygyLDUzKS0xLHM9ZnVuY3Rpb24oZSl7dmFyIHQ9aShlKTtyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodCwwKSxuKX07cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBpPXRoaXMsbj1PYmplY3QoZSk7aWYobnVsbD09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXkuZnJvbSByZXF1aXJlcyBhbiBhcnJheS1saWtlIG9iamVjdCAtIG5vdCBudWxsIG9yIHVuZGVmaW5lZFwiKTt2YXIgbyxyPWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiByKXtpZighdChyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXkuZnJvbTogd2hlbiBwcm92aWRlZCwgdGhlIHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7YXJndW1lbnRzLmxlbmd0aD4yJiYobz1hcmd1bWVudHNbMl0pfWZvcih2YXIgYSxjPXMobi5sZW5ndGgpLGw9dChpKT9PYmplY3QobmV3IGkoYykpOm5ldyBBcnJheShjKSxoPTA7aDxjOylhPW5baF0scj9sW2hdPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBvP3IoYSxoKTpyLmNhbGwobyxhLGgpOmxbaF09YSxoKz0xO3JldHVybiBsLmxlbmd0aD1jLGx9fSgpKSxBcnJheS5wcm90b3R5cGUuZmluZHx8KEFycmF5LnByb3RvdHlwZS5maW5kPWZ1bmN0aW9uKGUpe2lmKG51bGw9PXRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5LnByb3RvdHlwZS5maW5kIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZFwiKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO2Zvcih2YXIgdCxpPU9iamVjdCh0aGlzKSxuPWkubGVuZ3RoPj4+MCxzPWFyZ3VtZW50c1sxXSxvPTA7bzxuO28rKylpZih0PWlbb10sZS5jYWxsKHMsdCxvLGkpKXJldHVybiB0fSksZS5wcm90b3R5cGU9d2luZG93LkV2ZW50LnByb3RvdHlwZSx3aW5kb3cuQ3VzdG9tRXZlbnQ9ZX0oKX1dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hvaWNlcy5taW4uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nob2ljZXMuanMvYXNzZXRzL3NjcmlwdHMvZGlzdC9jaG9pY2VzLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Sidebar2 = __webpack_require__(5);\n\nvar _Sidebar3 = _interopRequireDefault(_Sidebar2);\n\nvar _Drake = __webpack_require__(10);\n\nvar _Drake2 = _interopRequireDefault(_Drake);\n\nvar _isomorphicFetch = __webpack_require__(6);\n\nvar _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Elements = function (_Sidebar) {\n    _inherits(Elements, _Sidebar);\n\n    function Elements() {\n        _classCallCheck(this, Elements);\n\n        return _possibleConstructorReturn(this, (Elements.__proto__ || Object.getPrototypeOf(Elements)).apply(this, arguments));\n    }\n\n    _createClass(Elements, [{\n        key: 'init',\n        value: function init() {\n            this.content = null;\n        }\n    }, {\n        key: 'click',\n        value: function click() {\n            var _this2 = this;\n\n            if (this.content !== null) {\n                return this.content;\n            }\n\n            return (0, _isomorphicFetch2.default)(this.config.assetsUrl + 'endpoints/ajax.php?action=get-elements').then(function (response) {\n                return response.json();\n            }).then(function (response) {\n                var content = document.createElement('dl');\n\n                response.data.elements.forEach(function (category) {\n                    var dt = document.createElement('dt');\n                    dt.setAttribute('role', 'tab');\n                    dt.setAttribute('tabindex', '1');\n                    dt.innerHTML = category.category;\n\n                    var dd = document.createElement('dd');\n\n                    var categoryEl = document.createElement('div');\n                    categoryEl.classList.add('fred--thumbs', 'source', 'blueprints-source');\n\n                    category.elements.forEach(function (element) {\n                        categoryEl.appendChild(Elements.elementWrapper(element.id, element.title, element.description, element.image, element.content, element.options || {}));\n                    });\n\n                    dd.appendChild(categoryEl);\n\n                    content.appendChild(dt);\n                    content.appendChild(dd);\n                });\n\n                _this2.content = content;\n\n                return _this2.content;\n            });\n        }\n    }, {\n        key: 'afterExpand',\n        value: function afterExpand() {\n            _Drake2.default.reloadContainers();\n        }\n    }], [{\n        key: 'elementWrapper',\n        value: function elementWrapper(id, title, description, image, content, options) {\n            var figure = document.createElement('figure');\n            figure.classList.add('fred--thumb');\n\n            var div = document.createElement('div');\n            var img = document.createElement('img');\n            img.src = image;\n            img.alt = title;\n\n            div.appendChild(img);\n\n            var figCaption = document.createElement('figcaption');\n            figCaption.innerHTML = '<strong>' + title + '</strong><em>' + description + '</em>';\n\n            var chunk = document.createElement('div');\n            chunk.classList.add('chunk');\n            chunk.dataset.fredElementId = id;\n            chunk.setAttribute('hidden', 'hidden');\n            chunk.innerHTML = content;\n            chunk.elementOptions = options;\n\n            figure.appendChild(div);\n            figure.appendChild(figCaption);\n            figure.appendChild(chunk);\n\n            return figure;\n        }\n    }]);\n\n    return Elements;\n}(_Sidebar3.default);\n\nElements.title = 'Elements';\nElements.expandable = true;\nexports.default = Elements;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0NvbXBvbmVudHMvU2lkZWJhci9FbGVtZW50cy5qcz9mYWUyIl0sIm5hbWVzIjpbIkVsZW1lbnRzIiwiY29udGVudCIsImNvbmZpZyIsImFzc2V0c1VybCIsInRoZW4iLCJyZXNwb25zZSIsImpzb24iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJkYXRhIiwiZWxlbWVudHMiLCJmb3JFYWNoIiwiZHQiLCJzZXRBdHRyaWJ1dGUiLCJpbm5lckhUTUwiLCJjYXRlZ29yeSIsImRkIiwiY2F0ZWdvcnlFbCIsImNsYXNzTGlzdCIsImFkZCIsImFwcGVuZENoaWxkIiwiZWxlbWVudFdyYXBwZXIiLCJlbGVtZW50IiwiaWQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiaW1hZ2UiLCJvcHRpb25zIiwicmVsb2FkQ29udGFpbmVycyIsImZpZ3VyZSIsImRpdiIsImltZyIsInNyYyIsImFsdCIsImZpZ0NhcHRpb24iLCJjaHVuayIsImRhdGFzZXQiLCJmcmVkRWxlbWVudElkIiwiZWxlbWVudE9wdGlvbnMiLCJleHBhbmRhYmxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRXFCQSxROzs7Ozs7Ozs7OzsrQkFJVjtBQUNILGlCQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNIOzs7Z0NBRU87QUFBQTs7QUFDSixnQkFBSSxLQUFLQSxPQUFMLEtBQWlCLElBQXJCLEVBQTJCO0FBQ3ZCLHVCQUFPLEtBQUtBLE9BQVo7QUFDSDs7QUFFRCxtQkFBTywrQkFBUyxLQUFLQyxNQUFMLENBQVlDLFNBQXJCLDZDQUNGQyxJQURFLENBQ0csb0JBQVk7QUFDZCx1QkFBT0MsU0FBU0MsSUFBVCxFQUFQO0FBQ0gsYUFIRSxFQUlGRixJQUpFLENBSUcsb0JBQVk7QUFDZCxvQkFBTUgsVUFBVU0sU0FBU0MsYUFBVCxDQUF1QixJQUF2QixDQUFoQjs7QUFHQUgseUJBQVNJLElBQVQsQ0FBY0MsUUFBZCxDQUF1QkMsT0FBdkIsQ0FBK0Isb0JBQVk7QUFDdkMsd0JBQU1DLEtBQUtMLFNBQVNDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBWDtBQUNBSSx1QkFBR0MsWUFBSCxDQUFnQixNQUFoQixFQUF3QixLQUF4QjtBQUNBRCx1QkFBR0MsWUFBSCxDQUFnQixVQUFoQixFQUE0QixHQUE1QjtBQUNBRCx1QkFBR0UsU0FBSCxHQUFlQyxTQUFTQSxRQUF4Qjs7QUFFQSx3QkFBTUMsS0FBS1QsU0FBU0MsYUFBVCxDQUF1QixJQUF2QixDQUFYOztBQUVBLHdCQUFNUyxhQUFhVixTQUFTQyxhQUFULENBQXVCLEtBQXZCLENBQW5CO0FBQ0FTLCtCQUFXQyxTQUFYLENBQXFCQyxHQUFyQixDQUF5QixjQUF6QixFQUF5QyxRQUF6QyxFQUFtRCxtQkFBbkQ7O0FBRUFKLDZCQUFTTCxRQUFULENBQWtCQyxPQUFsQixDQUEwQixtQkFBVztBQUNqQ00sbUNBQVdHLFdBQVgsQ0FBdUJwQixTQUFTcUIsY0FBVCxDQUF3QkMsUUFBUUMsRUFBaEMsRUFBb0NELFFBQVFFLEtBQTVDLEVBQW1ERixRQUFRRyxXQUEzRCxFQUF3RUgsUUFBUUksS0FBaEYsRUFBdUZKLFFBQVFyQixPQUEvRixFQUF3R3FCLFFBQVFLLE9BQVIsSUFBbUIsRUFBM0gsQ0FBdkI7QUFDSCxxQkFGRDs7QUFJQVgsdUJBQUdJLFdBQUgsQ0FBZUgsVUFBZjs7QUFFQWhCLDRCQUFRbUIsV0FBUixDQUFvQlIsRUFBcEI7QUFDQVgsNEJBQVFtQixXQUFSLENBQW9CSixFQUFwQjtBQUNILGlCQW5CRDs7QUFxQkEsdUJBQUtmLE9BQUwsR0FBZUEsT0FBZjs7QUFFQSx1QkFBTyxPQUFLQSxPQUFaO0FBQ0gsYUFoQ0UsQ0FBUDtBQWlDSDs7O3NDQThCYTtBQUNWLDRCQUFNMkIsZ0JBQU47QUFDSDs7O3VDQTlCcUJMLEUsRUFBSUMsSyxFQUFPQyxXLEVBQWFDLEssRUFBT3pCLE8sRUFBUzBCLE8sRUFBUztBQUNuRSxnQkFBTUUsU0FBU3RCLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBcUIsbUJBQU9YLFNBQVAsQ0FBaUJDLEdBQWpCLENBQXFCLGFBQXJCOztBQUVBLGdCQUFNVyxNQUFNdkIsU0FBU0MsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0EsZ0JBQU11QixNQUFNeEIsU0FBU0MsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0F1QixnQkFBSUMsR0FBSixHQUFVTixLQUFWO0FBQ0FLLGdCQUFJRSxHQUFKLEdBQVVULEtBQVY7O0FBRUFNLGdCQUFJVixXQUFKLENBQWdCVyxHQUFoQjs7QUFFQSxnQkFBTUcsYUFBYTNCLFNBQVNDLGFBQVQsQ0FBdUIsWUFBdkIsQ0FBbkI7QUFDQTBCLHVCQUFXcEIsU0FBWCxnQkFBa0NVLEtBQWxDLHFCQUF1REMsV0FBdkQ7O0FBRUEsZ0JBQU1VLFFBQVE1QixTQUFTQyxhQUFULENBQXVCLEtBQXZCLENBQWQ7QUFDQTJCLGtCQUFNakIsU0FBTixDQUFnQkMsR0FBaEIsQ0FBb0IsT0FBcEI7QUFDQWdCLGtCQUFNQyxPQUFOLENBQWNDLGFBQWQsR0FBOEJkLEVBQTlCO0FBQ0FZLGtCQUFNdEIsWUFBTixDQUFtQixRQUFuQixFQUE2QixRQUE3QjtBQUNBc0Isa0JBQU1yQixTQUFOLEdBQWtCYixPQUFsQjtBQUNBa0Msa0JBQU1HLGNBQU4sR0FBdUJYLE9BQXZCOztBQUVBRSxtQkFBT1QsV0FBUCxDQUFtQlUsR0FBbkI7QUFDQUQsbUJBQU9ULFdBQVAsQ0FBbUJjLFVBQW5CO0FBQ0FMLG1CQUFPVCxXQUFQLENBQW1CZSxLQUFuQjs7QUFFQSxtQkFBT04sTUFBUDtBQUNIOzs7Ozs7QUExRWdCN0IsUSxDQUNWd0IsSyxHQUFRLFU7QUFERXhCLFEsQ0FFVnVDLFUsR0FBYSxJO2tCQUZIdkMsUSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNpZGViYXIgZnJvbSAnLi4vU2lkZWJhcic7XG5pbXBvcnQgZHJha2UgZnJvbSAnLi4vLi4vRHJha2UnO1xuaW1wb3J0IGZldGNoIGZyb20gJ2lzb21vcnBoaWMtZmV0Y2gnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50cyBleHRlbmRzIFNpZGViYXIge1xuICAgIHN0YXRpYyB0aXRsZSA9ICdFbGVtZW50cyc7XG4gICAgc3RhdGljIGV4cGFuZGFibGUgPSB0cnVlO1xuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmZXRjaChgJHt0aGlzLmNvbmZpZy5hc3NldHNVcmx9ZW5kcG9pbnRzL2FqYXgucGhwP2FjdGlvbj1nZXQtZWxlbWVudHNgKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkbCcpO1xuICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS5lbGVtZW50cy5mb3JFYWNoKGNhdGVnb3J5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkdCcpO1xuICAgICAgICAgICAgICAgICAgICBkdC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGFiJyk7XG4gICAgICAgICAgICAgICAgICAgIGR0LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMScpO1xuICAgICAgICAgICAgICAgICAgICBkdC5pbm5lckhUTUwgPSBjYXRlZ29yeS5jYXRlZ29yeTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGQnKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlFbC5jbGFzc0xpc3QuYWRkKCdmcmVkLS10aHVtYnMnLCAnc291cmNlJywgJ2JsdWVwcmludHMtc291cmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeS5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlFbC5hcHBlbmRDaGlsZChFbGVtZW50cy5lbGVtZW50V3JhcHBlcihlbGVtZW50LmlkLCBlbGVtZW50LnRpdGxlLCBlbGVtZW50LmRlc2NyaXB0aW9uLCBlbGVtZW50LmltYWdlLCBlbGVtZW50LmNvbnRlbnQsIGVsZW1lbnQub3B0aW9ucyB8fCB7fSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBkZC5hcHBlbmRDaGlsZChjYXRlZ29yeUVsKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGR0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChkZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBlbGVtZW50V3JhcHBlcihpZCwgdGl0bGUsIGRlc2NyaXB0aW9uLCBpbWFnZSwgY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmaWd1cmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWd1cmUnKTtcbiAgICAgICAgZmlndXJlLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLXRodW1iJyk7XG5cbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpbWcuc3JjID0gaW1hZ2U7XG4gICAgICAgIGltZy5hbHQgPSB0aXRsZTtcblxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoaW1nKTtcblxuICAgICAgICBjb25zdCBmaWdDYXB0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmlnY2FwdGlvbicpO1xuICAgICAgICBmaWdDYXB0aW9uLmlubmVySFRNTCA9IGA8c3Ryb25nPiR7dGl0bGV9PC9zdHJvbmc+PGVtPiR7ZGVzY3JpcHRpb259PC9lbT5gO1xuXG4gICAgICAgIGNvbnN0IGNodW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNodW5rLmNsYXNzTGlzdC5hZGQoJ2NodW5rJyk7XG4gICAgICAgIGNodW5rLmRhdGFzZXQuZnJlZEVsZW1lbnRJZCA9IGlkO1xuICAgICAgICBjaHVuay5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICAgICAgY2h1bmsuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgY2h1bmsuZWxlbWVudE9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIGZpZ3VyZS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBmaWd1cmUuYXBwZW5kQ2hpbGQoZmlnQ2FwdGlvbik7XG4gICAgICAgIGZpZ3VyZS5hcHBlbmRDaGlsZChjaHVuayk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmlndXJlO1xuICAgIH1cblxuICAgIGFmdGVyRXhwYW5kKCkge1xuICAgICAgICBkcmFrZS5yZWxvYWRDb250YWluZXJzKCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vX2J1aWxkL2Fzc2V0cy9qcy9Db21wb25lbnRzL1NpZGViYXIvRWxlbWVudHMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EE = __webpack_require__(1);\n\nvar _EE2 = _interopRequireDefault(_EE);\n\nvar _dragula = __webpack_require__(11);\n\nvar _dragula2 = _interopRequireDefault(_dragula);\n\nvar _ContentElement = __webpack_require__(23);\n\nvar _ContentElement2 = _interopRequireDefault(_ContentElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Drake = function () {\n    function Drake() {\n        _classCallCheck(this, Drake);\n\n        this.drake = null;\n\n        this.topScroll = null;\n        this.bottomScroll = null;\n        this.scrollSpeed = null;\n        this.lastPosition = null;\n\n        this.scrollHandler = this.scrollHandler.bind(this);\n    }\n\n    _createClass(Drake, [{\n        key: 'initDrake',\n        value: function initDrake(config) {\n            var _this = this;\n\n            this.config = config;\n\n            var containers = [].concat(_toConsumableArray(document.querySelectorAll('[data-fred-dropzone]:not([data-fred-dropzone=\"\"])')));\n            containers.unshift.apply(containers, _toConsumableArray(document.querySelectorAll('.source')));\n\n            var contains = function contains(a, b) {\n                return a.contains ? a != b && a.contains(b) : !!(a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_CONTAINED_BY);\n            };\n\n            try {\n                this.drake = (0, _dragula2.default)(containers, {\n                    copy: function copy(el, source) {\n                        return source.classList.contains('source');\n                    },\n                    accepts: function accepts(el, target) {\n                        if (!contains(el, target) === false) {\n                            return false;\n                        }\n\n                        return !target.classList.contains('source');\n                    },\n                    moves: function moves(el, source, handle, sibling) {\n                        if (source.dataset.fredDropzone !== undefined && source.dataset.fredDropzone !== '') {\n                            return handle.classList.contains('handle');\n                        }\n\n                        return true;\n                    }\n                });\n            } catch (err) {}\n\n            this.drake.on('cloned', function (clone, original, type) {\n                if (type === 'copy') {\n                    clone.lastChild.elementOptions = original.lastChild.elementOptions;\n                }\n            });\n\n            this.drake.on('drop', function (el, target, source, sibling) {\n                //emitter.emit('fred-dragula-drop', el, target, source, sibling);\n\n                if (source.classList.contains('blueprints-source') && el.parentNode) {\n                    var parent = target.fredEl || null;\n                    var contentElement = new _ContentElement2.default(_this.config, el.lastChild, target.dataset.fredDropzone, parent);\n                    contentElement.render().then(function () {\n                        if (parent) {\n                            if (sibling === null) {\n                                parent.dzs[target.dataset.fredDropzone].children.push(contentElement.wrapper);\n                            } else {\n                                parent.dzs[target.dataset.fredDropzone].children.splice(parent.dzs[target.dataset.fredDropzone].children.indexOf(sibling), 0, contentElement.wrapper);\n                            }\n                        }\n\n                        el.parentNode.replaceChild(contentElement.wrapper, el);\n                    });\n                } else {\n                    if (target && el.fredEl) {\n                        if (el.fredEl.parent) {\n                            el.fredEl.parent.dzs[source.dataset.fredDropzone].children.splice(el.fredEl.parent.dzs[source.dataset.fredDropzone].children.indexOf(el), 1);\n                        }\n\n                        var _parent = target.fredEl || null;\n                        if (_parent) {\n                            if (sibling === null) {\n                                _parent.dzs[target.dataset.fredDropzone].children.push(el);\n                            } else {\n                                _parent.dzs[target.dataset.fredDropzone].children.splice(_parent.dzs[target.dataset.fredDropzone].children.indexOf(sibling), 0, el);\n                            }\n                        }\n                        el.fredEl.parent = _parent;\n                        el.fredEl.dzName = target.dataset.fredDropzone;\n                    }\n                }\n\n                _this.reloadContainers();\n            });\n\n            this.drake.on('drag', function (el, source) {\n                _this.registerScroller();\n\n                var dropZones = document.querySelectorAll('[data-fred-dropzone]');\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = dropZones[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var zone = _step.value;\n\n                        zone.classList.add('fred--dropzone_highlight');\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                _EE2.default.emit('fred-sidebar-hide', true);\n            });\n\n            this.drake.on('dragend', function (el) {\n                _this.removeScroller();\n\n                var dropZones = document.querySelectorAll('[data-fred-dropzone]');\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = dropZones[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var zone = _step2.value;\n\n                        zone.classList.remove('fred--dropzone_highlight');\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n\n                _EE2.default.emit('fred-sidebar-show', true);\n            });\n        }\n    }, {\n        key: 'cancelScroll',\n        value: function cancelScroll(type) {\n            if (this[type + 'Scroll']) {\n                clearInterval(this[type + 'Scroll']);\n                this[type + 'Scroll'] = null;\n                this.scrollSpeed = null;\n                this.lastPosition = null;\n            }\n        }\n    }, {\n        key: 'scrollWindow',\n        value: function scrollWindow(e, type, breakpoints) {\n            var _this2 = this;\n\n            var start = false;\n            var speed = null;\n\n            breakpoints.forEach(function (breakpoint) {\n                if (type === 'top') {\n                    var currentBreakpoint = e.y > window.innerHeight - breakpoint.offset;\n                    start = start || currentBreakpoint;\n\n                    if (currentBreakpoint) {\n                        speed = breakpoint.speed;\n                    }\n                } else {\n                    var _currentBreakpoint = e.y < breakpoint.offset;\n                    start = start || _currentBreakpoint;\n\n                    if (_currentBreakpoint) {\n                        speed = -1 * breakpoint.speed;\n                    }\n                }\n            });\n\n            if (start) {\n                if (this[type + 'Scroll'] && speed !== this.scrollSpeed) {\n                    clearInterval(this[type + 'Scroll']);\n                    this[type + 'Scroll'] = null;\n                }\n\n                if (this[type + 'Scroll'] === null) {\n                    this.lastPosition = window.innerHeight + window.scrollY;\n\n                    this[type + 'Scroll'] = setInterval(function () {\n                        _this2.scrollSpeed = speed;\n                        window.scrollBy(0, speed);\n                        var newPosition = window.innerHeight + window.scrollY;\n\n                        if (_this2.lastPosition === newPosition) {\n                            _this2.cancelScroll(type);\n                        }\n\n                        _this2.lastPosition = newPosition;\n                    }, 5);\n                }\n            } else {\n                this.cancelScroll(type);\n            }\n        }\n    }, {\n        key: 'scrollHandler',\n        value: function scrollHandler(e) {\n            this.scrollWindow(e, 'top', [{ offset: 60, speed: 2 }, { offset: 30, speed: 8 }]);\n            this.scrollWindow(e, 'bottom', [{ offset: 60, speed: 2 }, { offset: 30, speed: 8 }]);\n        }\n    }, {\n        key: 'registerScroller',\n        value: function registerScroller() {\n            this.topScroll = null;\n            this.bottomScroll = null;\n            this.scrollSpeed = null;\n            this.lastPosition = null;\n\n            document.addEventListener('mousemove', this.scrollHandler);\n        }\n    }, {\n        key: 'removeScroller',\n        value: function removeScroller() {\n            document.removeEventListener('mousemove', this.scrollHandler);\n        }\n    }, {\n        key: 'reloadContainers',\n        value: function reloadContainers() {\n            var initContainer = document.querySelectorAll('[data-fred-dropzone]:not([data-fred-dropzone=\"\"])');\n            var containers = [].concat(_toConsumableArray(initContainer));\n\n            for (var i = 0; i < initContainer.length; i++) {\n                containers.push.apply(containers, _toConsumableArray(initContainer[i].querySelectorAll('[data-fred-dropzone]:not([data-fred-dropzone=\"\"])')));\n            }\n\n            containers.unshift.apply(containers, _toConsumableArray(document.querySelectorAll('.source')));\n\n            this.drake.containers = containers;\n        }\n    }]);\n\n    return Drake;\n}();\n\nvar drake = new Drake();\n\nexports.default = drake;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0RyYWtlLmpzP2IwNTgiXSwibmFtZXMiOlsiRHJha2UiLCJkcmFrZSIsInRvcFNjcm9sbCIsImJvdHRvbVNjcm9sbCIsInNjcm9sbFNwZWVkIiwibGFzdFBvc2l0aW9uIiwic2Nyb2xsSGFuZGxlciIsImJpbmQiLCJjb25maWciLCJjb250YWluZXJzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwidW5zaGlmdCIsImNvbnRhaW5zIiwiYSIsImIiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIk5vZGUiLCJET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkiLCJjb3B5IiwiZWwiLCJzb3VyY2UiLCJjbGFzc0xpc3QiLCJhY2NlcHRzIiwidGFyZ2V0IiwibW92ZXMiLCJoYW5kbGUiLCJzaWJsaW5nIiwiZGF0YXNldCIsImZyZWREcm9wem9uZSIsInVuZGVmaW5lZCIsImVyciIsIm9uIiwiY2xvbmUiLCJvcmlnaW5hbCIsInR5cGUiLCJsYXN0Q2hpbGQiLCJlbGVtZW50T3B0aW9ucyIsInBhcmVudE5vZGUiLCJwYXJlbnQiLCJmcmVkRWwiLCJjb250ZW50RWxlbWVudCIsInJlbmRlciIsInRoZW4iLCJkenMiLCJjaGlsZHJlbiIsInB1c2giLCJ3cmFwcGVyIiwic3BsaWNlIiwiaW5kZXhPZiIsInJlcGxhY2VDaGlsZCIsImR6TmFtZSIsInJlbG9hZENvbnRhaW5lcnMiLCJyZWdpc3RlclNjcm9sbGVyIiwiZHJvcFpvbmVzIiwiem9uZSIsImFkZCIsImVtaXQiLCJyZW1vdmVTY3JvbGxlciIsInJlbW92ZSIsImNsZWFySW50ZXJ2YWwiLCJlIiwiYnJlYWtwb2ludHMiLCJzdGFydCIsInNwZWVkIiwiZm9yRWFjaCIsImN1cnJlbnRCcmVha3BvaW50IiwieSIsIndpbmRvdyIsImlubmVySGVpZ2h0IiwiYnJlYWtwb2ludCIsIm9mZnNldCIsInNjcm9sbFkiLCJzZXRJbnRlcnZhbCIsInNjcm9sbEJ5IiwibmV3UG9zaXRpb24iLCJjYW5jZWxTY3JvbGwiLCJzY3JvbGxXaW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImluaXRDb250YWluZXIiLCJpIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OztJQUVNQSxLO0FBQ0YscUJBQWM7QUFBQTs7QUFDVixhQUFLQyxLQUFMLEdBQWEsSUFBYjs7QUFFQSxhQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsYUFBS0MsWUFBTCxHQUFvQixJQUFwQjtBQUNBLGFBQUtDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxhQUFLQyxZQUFMLEdBQW9CLElBQXBCOztBQUVBLGFBQUtDLGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxDQUFtQkMsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBckI7QUFDSDs7OztrQ0FFU0MsTSxFQUFRO0FBQUE7O0FBQ2QsaUJBQUtBLE1BQUwsR0FBY0EsTUFBZDs7QUFFQSxnQkFBTUMsMENBQWlCQyxTQUFTQyxnQkFBVCxDQUEwQixtREFBMUIsQ0FBakIsRUFBTjtBQUNBRix1QkFBV0csT0FBWCxzQ0FBdUJGLFNBQVNDLGdCQUFULENBQTBCLFNBQTFCLENBQXZCOztBQUVBLGdCQUFNRSxXQUFXLFNBQVhBLFFBQVcsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLEVBQVU7QUFDdkIsdUJBQU9ELEVBQUVELFFBQUYsR0FBYUMsS0FBS0MsQ0FBTCxJQUFVRCxFQUFFRCxRQUFGLENBQVdFLENBQVgsQ0FBdkIsR0FBdUMsQ0FBQyxFQUFFRCxFQUFFRSx1QkFBRixDQUEwQkQsQ0FBMUIsSUFBK0JFLEtBQUtDLDhCQUF0QyxDQUEvQztBQUNILGFBRkQ7O0FBSUEsZ0JBQUk7QUFDQSxxQkFBS2pCLEtBQUwsR0FBYSx1QkFBUVEsVUFBUixFQUFvQjtBQUM3QlUsMEJBQU0sY0FBVUMsRUFBVixFQUFjQyxNQUFkLEVBQXNCO0FBQ3hCLCtCQUFPQSxPQUFPQyxTQUFQLENBQWlC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LEdBQXdCQSxVQUF4QjtBQUNIOzs7Ozs7QUFHTCxJQUFNUixRQUFRLElBQUlELEtBQUosRUFBZDs7a0JBRWVDLEsiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZW1pdHRlciBmcm9tICcuL0VFJztcbmltcG9ydCBkcmFndWxhIGZyb20gJ2RyYWd1bGEnO1xuaW1wb3J0IENvbnRlbnRFbGVtZW50IGZyb20gJy4vQ29tcG9uZW50cy9TaWRlYmFyL0VsZW1lbnRzL0NvbnRlbnRFbGVtZW50JztcblxuY2xhc3MgRHJha2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRyYWtlID0gbnVsbDtcblxuICAgICAgICB0aGlzLnRvcFNjcm9sbCA9IG51bGw7XG4gICAgICAgIHRoaXMuYm90dG9tU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXIgPSB0aGlzLnNjcm9sbEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbml0RHJha2UoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZnJlZC1kcm9wem9uZV06bm90KFtkYXRhLWZyZWQtZHJvcHpvbmU9XCJcIl0pJyldO1xuICAgICAgICBjb250YWluZXJzLnVuc2hpZnQoLi4uKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zb3VyY2UnKSkpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5zID0gKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhLmNvbnRhaW5zID8gYSAhPSBiICYmIGEuY29udGFpbnMoYikgOiAhIShhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRyYWtlID0gZHJhZ3VsYShjb250YWluZXJzLCB7XG4gICAgICAgICAgICAgICAgY29weTogZnVuY3Rpb24gKGVsLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5jbGFzc0xpc3QuY29udGFpbnMoJ3NvdXJjZScpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWNjZXB0czogZnVuY3Rpb24gKGVsLCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWlucyhlbCwgdGFyZ2V0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc291cmNlJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb3ZlczogZnVuY3Rpb24gKGVsLCBzb3VyY2UsIGhhbmRsZSwgc2libGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHNvdXJjZS5kYXRhc2V0LmZyZWREcm9wem9uZSAhPT0gdW5kZWZpbmVkKSAmJiAoc291cmNlLmRhdGFzZXQuZnJlZERyb3B6b25lICE9PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdoYW5kbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJha2Uub24oJ2Nsb25lZCcsIChjbG9uZSwgb3JpZ2luYWwsIHR5cGUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnY29weScpIHtcbiAgICAgICAgICAgICAgICBjbG9uZS5sYXN0Q2hpbGQuZWxlbWVudE9wdGlvbnMgPSBvcmlnaW5hbC5sYXN0Q2hpbGQuZWxlbWVudE9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZHJha2Uub24oJ2Ryb3AnLCAoZWwsIHRhcmdldCwgc291cmNlLCBzaWJsaW5nKSA9PiB7XG4gICAgICAgICAgICAvL2VtaXR0ZXIuZW1pdCgnZnJlZC1kcmFndWxhLWRyb3AnLCBlbCwgdGFyZ2V0LCBzb3VyY2UsIHNpYmxpbmcpO1xuXG4gICAgICAgICAgICBpZiAoc291cmNlLmNsYXNzTGlzdC5jb250YWlucygnYmx1ZXByaW50cy1zb3VyY2UnKSAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGFyZ2V0LmZyZWRFbCB8fCBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gbmV3IENvbnRlbnRFbGVtZW50KHRoaXMuY29uZmlnLCBlbC5sYXN0Q2hpbGQsIHRhcmdldC5kYXRhc2V0LmZyZWREcm9wem9uZSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudC5yZW5kZXIoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZHpzW3RhcmdldC5kYXRhc2V0LmZyZWREcm9wem9uZV0uY2hpbGRyZW4ucHVzaChjb250ZW50RWxlbWVudC53cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmR6c1t0YXJnZXQuZGF0YXNldC5mcmVkRHJvcHpvbmVdLmNoaWxkcmVuLnNwbGljZShwYXJlbnQuZHpzW3RhcmdldC5kYXRhc2V0LmZyZWREcm9wem9uZV0uY2hpbGRyZW4uaW5kZXhPZihzaWJsaW5nKSwgMCwgY29udGVudEVsZW1lbnQud3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNvbnRlbnRFbGVtZW50LndyYXBwZXIsIGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiBlbC5mcmVkRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmZyZWRFbC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmZyZWRFbC5wYXJlbnQuZHpzW3NvdXJjZS5kYXRhc2V0LmZyZWREcm9wem9uZV0uY2hpbGRyZW4uc3BsaWNlKGVsLmZyZWRFbC5wYXJlbnQuZHpzW3NvdXJjZS5kYXRhc2V0LmZyZWREcm9wem9uZV0uY2hpbGRyZW4uaW5kZXhPZihlbCksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGFyZ2V0LmZyZWRFbCB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5kenNbdGFyZ2V0LmRhdGFzZXQuZnJlZERyb3B6b25lXS5jaGlsZHJlbi5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmR6c1t0YXJnZXQuZGF0YXNldC5mcmVkRHJvcHpvbmVdLmNoaWxkcmVuLnNwbGljZShwYXJlbnQuZHpzW3RhcmdldC5kYXRhc2V0LmZyZWREcm9wem9uZV0uY2hpbGRyZW4uaW5kZXhPZihzaWJsaW5nKSwgMCwgZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsLmZyZWRFbC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsLmZyZWRFbC5kek5hbWUgPSB0YXJnZXQuZGF0YXNldC5mcmVkRHJvcHpvbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlbG9hZENvbnRhaW5lcnMoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kcmFrZS5vbignZHJhZycsIChlbCwgc291cmNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyU2Nyb2xsZXIoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZHJvcFpvbmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZnJlZC1kcm9wem9uZV0nKTtcbiAgICAgICAgICAgIGZvciAobGV0IHpvbmUgb2YgZHJvcFpvbmVzKSB7XG4gICAgICAgICAgICAgICAgem9uZS5jbGFzc0xpc3QuYWRkKCdmcmVkLS1kcm9wem9uZV9oaWdobGlnaHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdmcmVkLXNpZGViYXItaGlkZScsIHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmRyYWtlLm9uKCdkcmFnZW5kJywgZWwgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTY3JvbGxlcigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBkcm9wWm9uZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mcmVkLWRyb3B6b25lXScpO1xuICAgICAgICAgICAgZm9yIChsZXQgem9uZSBvZiBkcm9wWm9uZXMpIHtcbiAgICAgICAgICAgICAgICB6b25lLmNsYXNzTGlzdC5yZW1vdmUoJ2ZyZWQtLWRyb3B6b25lX2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtc2lkZWJhci1zaG93JywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgfTtcbiAgICBcbiAgICBjYW5jZWxTY3JvbGwodHlwZSkge1xuICAgICAgICBpZiAodGhpc1t0eXBlICsgJ1Njcm9sbCddKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXNbdHlwZSArICdTY3JvbGwnXSk7XG4gICAgICAgICAgICB0aGlzW3R5cGUgKyAnU2Nyb2xsJ10gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2Nyb2xsV2luZG93KGUsIHR5cGUsIGJyZWFrcG9pbnRzKSB7XG4gICAgICAgIGxldCBzdGFydCA9IGZhbHNlO1xuICAgICAgICBsZXQgc3BlZWQgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgYnJlYWtwb2ludHMuZm9yRWFjaChicmVha3BvaW50ID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCcmVha3BvaW50ID0gZS55ID4gKHdpbmRvdy5pbm5lckhlaWdodCAtIGJyZWFrcG9pbnQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IGN1cnJlbnRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QnJlYWtwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBzcGVlZCA9IGJyZWFrcG9pbnQuc3BlZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJyZWFrcG9pbnQgPSBlLnkgPCBicmVha3BvaW50Lm9mZnNldDtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IGN1cnJlbnRCcmVha3BvaW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCcmVha3BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWVkID0gLTEgKiBicmVha3BvaW50LnNwZWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW3R5cGUgKyAnU2Nyb2xsJ10gJiYgKHNwZWVkICE9PSB0aGlzLnNjcm9sbFNwZWVkKSkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpc1t0eXBlICsgJ1Njcm9sbCddKTtcbiAgICAgICAgICAgICAgICB0aGlzW3R5cGUgKyAnU2Nyb2xsJ10gPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpc1t0eXBlICsgJ1Njcm9sbCddID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSB3aW5kb3cuaW5uZXJIZWlnaHQgKyB3aW5kb3cuc2Nyb2xsWTtcblxuICAgICAgICAgICAgICAgIHRoaXNbdHlwZSArICdTY3JvbGwnXSA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgc3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHdpbmRvdy5pbm5lckhlaWdodCArIHdpbmRvdy5zY3JvbGxZO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubGFzdFBvc2l0aW9uID09PSBuZXdQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxTY3JvbGwodHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH0sIDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxTY3JvbGwodHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2Nyb2xsSGFuZGxlcihlKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsV2luZG93KGUsICd0b3AnLCBbe29mZnNldDogNjAsIHNwZWVkOiAyfSx7b2Zmc2V0OjMwLCBzcGVlZDogOH1dKTtcbiAgICAgICAgdGhpcy5zY3JvbGxXaW5kb3coZSwgJ2JvdHRvbScsIFt7b2Zmc2V0OiA2MCwgc3BlZWQ6IDJ9LHtvZmZzZXQ6MzAsIHNwZWVkOiA4fV0pO1xuICAgIH1cbiAgICBcbiAgICByZWdpc3RlclNjcm9sbGVyKCkge1xuICAgICAgICB0aGlzLnRvcFNjcm9sbCA9IG51bGw7XG4gICAgICAgIHRoaXMuYm90dG9tU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gbnVsbDtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuICAgIH1cbiAgICBcbiAgICByZW1vdmVTY3JvbGxlcigpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgICB9XG5cbiAgICByZWxvYWRDb250YWluZXJzKCkge1xuICAgICAgICBjb25zdCBpbml0Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZnJlZC1kcm9wem9uZV06bm90KFtkYXRhLWZyZWQtZHJvcHpvbmU9XCJcIl0pJyk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBbLi4uaW5pdENvbnRhaW5lcl07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0Q29udGFpbmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb250YWluZXJzLnB1c2goLi4uKGluaXRDb250YWluZXJbaV0ucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZnJlZC1kcm9wem9uZV06bm90KFtkYXRhLWZyZWQtZHJvcHpvbmU9XCJcIl0pJykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lcnMudW5zaGlmdCguLi4oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNvdXJjZScpKSk7XG5cbiAgICAgICAgdGhpcy5kcmFrZS5jb250YWluZXJzID0gY29udGFpbmVycztcbiAgICB9XG59XG5cbmNvbnN0IGRyYWtlID0gbmV3IERyYWtlKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGRyYWtlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL19idWlsZC9hc3NldHMvanMvRHJha2UuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nvar emitter = __webpack_require__(12);\nvar crossvent = __webpack_require__(19);\nvar classes = __webpack_require__(22);\nvar doc = document;\nvar documentElement = doc.documentElement;\n\nfunction dragula (initialContainers, options) {\n  var len = arguments.length;\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n  var _mirror; // mirror image\n  var _source; // source container\n  var _item; // item being dragged\n  var _offsetX; // reference x\n  var _offsetY; // reference y\n  var _moveX; // reference move x\n  var _moveY; // reference move y\n  var _initialSibling; // reference sibling when grabbed\n  var _currentSibling; // reference sibling now\n  var _copy; // item used for copying\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n  var _lastDropTarget = null; // last container item was over\n  var _grabbed; // holds mousedown context until first mousemove\n\n  var o = options || {};\n  if (o.moves === void 0) { o.moves = always; }\n  if (o.accepts === void 0) { o.accepts = always; }\n  if (o.invalid === void 0) { o.invalid = invalidTarget; }\n  if (o.containers === void 0) { o.containers = initialContainers || []; }\n  if (o.isContainer === void 0) { o.isContainer = never; }\n  if (o.copy === void 0) { o.copy = false; }\n  if (o.copySortSource === void 0) { o.copySortSource = false; }\n  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\n  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\n  if (o.direction === void 0) { o.direction = 'vertical'; }\n  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }\n  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }\n\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n\n  events();\n\n  return drake;\n\n  function isContainer (el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n\n  function events (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n\n  function eventualMovements (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n\n  function movements (remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n\n  function destroy () {\n    events(true);\n    release({});\n  }\n\n  function preventGrabbed (e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  function grab (e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n    var item = e.target;\n    var context = canStart(item);\n    if (!context) {\n      return;\n    }\n    _grabbed = context;\n    eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved (e) {\n    if (!_grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n    // truthy check fixes #239, equality fixes #207\n    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {\n      return;\n    }\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e);\n      var clientY = getCoord('clientY', e);\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n\n  function canStart (item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n    var handle = item;\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    var source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (o.invalid(item, handle)) {\n      return;\n    }\n\n    var movable = o.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n\n    return {\n      item: item,\n      source: source\n    };\n  }\n\n  function canMove (item) {\n    return !!canStart(item);\n  }\n\n  function manualStart (item) {\n    var context = canStart(item);\n    if (context) {\n      start(context);\n    }\n  }\n\n  function start (context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n\n  function invalidTarget () {\n    return false;\n  }\n\n  function end () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n\n  function ungrab () {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n\n  function release (e) {\n    ungrab();\n\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n\n  function drop (item, target) {\n    var parent = getParent(item);\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n    if (isInitialPlacement(target)) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function remove () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n\n  function cancel (revert) {\n    if (!drake.dragging) {\n      return;\n    }\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function cleanup () {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n    drake.dragging = false;\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n\n  function isInitialPlacement (target, s) {\n    var sibling;\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n    return target === _source && sibling === _initialSibling;\n  }\n\n  function findDropTarget (elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n    return target;\n\n    function accepted () {\n      var droppable = isContainer(target);\n      if (droppable === false) {\n        return false;\n      }\n\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n\n  function drag (e) {\n    if (!_mirror) {\n      return;\n    }\n    e.preventDefault();\n\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n    var parent = getParent(item);\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (\n      (reference === null && changed) ||\n      reference !== item &&\n      reference !== nextEl(item)\n    ) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }\n    function over () { if (changed) { moved('over'); } }\n    function out () { if (_lastDropTarget) { moved('out'); } }\n  }\n\n  function spillOver (el) {\n    classes.rm(el, 'gu-hide');\n  }\n\n  function spillOut (el) {\n    if (drake.dragging) { classes.add(el, 'gu-hide'); }\n  }\n\n  function renderMirrorImage () {\n    if (_mirror) {\n      return;\n    }\n    var rect = _item.getBoundingClientRect();\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n\n  function removeMirrorImage () {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n\n  function getImmediateChild (dropTarget, target) {\n    var immediate = target;\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n    if (immediate === documentElement) {\n      return null;\n    }\n    return immediate;\n  }\n\n  function getReference (dropTarget, target, x, y) {\n    var horizontal = o.direction === 'horizontal';\n    var reference = target !== dropTarget ? inside() : outside();\n    return reference;\n\n    function outside () { // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\n        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\n      }\n      return null;\n    }\n\n    function inside () { // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    function resolve (after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n\n  function isCopy (item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\n\nfunction touchy (el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\n\nfunction whichMouseButton (e) {\n  if (e.touches !== void 0) { return e.touches.length; }\n  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== void 0) { return e.buttons; }\n  var button = e.button;\n  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n  }\n}\n\nfunction getOffset (el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\n\nfunction getScroll (scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\n\nfunction getElementBehindPoint (point, x, y) {\n  var p = point || {};\n  var state = p.className;\n  var el;\n  p.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  p.className = state;\n  return el;\n}\n\nfunction never () { return false; }\nfunction always () { return true; }\nfunction getRectWidth (rect) { return rect.width || (rect.right - rect.left); }\nfunction getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }\nfunction getParent (el) { return el.parentNode === doc ? null : el.parentNode; }\nfunction isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }\nfunction isEditable (el) {\n  if (!el) { return false; } // no parents were editable\n  if (el.contentEditable === 'false') { return false; } // stop the lookup\n  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl (el) {\n  return el.nextElementSibling || manually();\n  function manually () {\n    var sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n}\n\nfunction getEventHost (e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\n\nfunction getCoord (coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX', // IE8\n    pageY: 'clientY' // IE8\n  };\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n  return host[coord];\n}\n\nmodule.exports = dragula;\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2RyYWd1bGEvZHJhZ3VsYS5qcz8xYTUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZO0FBQ1osZUFBZTtBQUNmLGVBQWU7QUFDZixhQUFhO0FBQ2IsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFDN0IsZUFBZTs7QUFFZjtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0MsNkJBQTZCLG9CQUFvQjtBQUNqRCw2QkFBNkIsMkJBQTJCO0FBQ3hELGdDQUFnQyx3Q0FBd0M7QUFDeEUsaUNBQWlDLHVCQUF1QjtBQUN4RCwwQkFBMEIsZ0JBQWdCO0FBQzFDLG9DQUFvQywwQkFBMEI7QUFDOUQsbUNBQW1DLHlCQUF5QjtBQUM1RCxtQ0FBbUMseUJBQXlCO0FBQzVELCtCQUErQiwwQkFBMEI7QUFDekQsOENBQThDLG1DQUFtQztBQUNqRixxQ0FBcUMsOEJBQThCOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsT0FBTztBQUNQLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBlbWl0dGVyID0gcmVxdWlyZSgnY29udHJhL2VtaXR0ZXInKTtcbnZhciBjcm9zc3ZlbnQgPSByZXF1aXJlKCdjcm9zc3ZlbnQnKTtcbnZhciBjbGFzc2VzID0gcmVxdWlyZSgnLi9jbGFzc2VzJyk7XG52YXIgZG9jID0gZG9jdW1lbnQ7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuZnVuY3Rpb24gZHJhZ3VsYSAoaW5pdGlhbENvbnRhaW5lcnMsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDEgJiYgQXJyYXkuaXNBcnJheShpbml0aWFsQ29udGFpbmVycykgPT09IGZhbHNlKSB7XG4gICAgb3B0aW9ucyA9IGluaXRpYWxDb250YWluZXJzO1xuICAgIGluaXRpYWxDb250YWluZXJzID0gW107XG4gIH1cbiAgdmFyIF9taXJyb3I7IC8vIG1pcnJvciBpbWFnZVxuICB2YXIgX3NvdXJjZTsgLy8gc291cmNlIGNvbnRhaW5lclxuICB2YXIgX2l0ZW07IC8vIGl0ZW0gYmVpbmcgZHJhZ2dlZFxuICB2YXIgX29mZnNldFg7IC8vIHJlZmVyZW5jZSB4XG4gIHZhciBfb2Zmc2V0WTsgLy8gcmVmZXJlbmNlIHlcbiAgdmFyIF9tb3ZlWDsgLy8gcmVmZXJlbmNlIG1vdmUgeFxuICB2YXIgX21vdmVZOyAvLyByZWZlcmVuY2UgbW92ZSB5XG4gIHZhciBfaW5pdGlhbFNpYmxpbmc7IC8vIHJlZmVyZW5jZSBzaWJsaW5nIHdoZW4gZ3JhYmJlZFxuICB2YXIgX2N1cnJlbnRTaWJsaW5nOyAvLyByZWZlcmVuY2Ugc2libGluZyBub3dcbiAgdmFyIF9jb3B5OyAvLyBpdGVtIHVzZWQgZm9yIGNvcHlpbmdcbiAgdmFyIF9yZW5kZXJUaW1lcjsgLy8gdGltZXIgZm9yIHNldFRpbWVvdXQgcmVuZGVyTWlycm9ySW1hZ2VcbiAgdmFyIF9sYXN0RHJvcFRhcmdldCA9IG51bGw7IC8vIGxhc3QgY29udGFpbmVyIGl0ZW0gd2FzIG92ZXJcbiAgdmFyIF9ncmFiYmVkOyAvLyBob2xkcyBtb3VzZWRvd24gY29udGV4dCB1bnRpbCBmaXJzdCBtb3VzZW1vdmVcblxuICB2YXIgbyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvLm1vdmVzID09PSB2b2lkIDApIHsgby5tb3ZlcyA9IGFsd2F5czsgfVxuICBpZiAoby5hY2NlcHRzID09PSB2b2lkIDApIHsgby5hY2NlcHRzID0gYWx3YXlzOyB9XG4gIGlmIChvLmludmFsaWQgPT09IHZvaWQgMCkgeyBvLmludmFsaWQgPSBpbnZhbGlkVGFyZ2V0OyB9XG4gIGlmIChvLmNvbnRhaW5lcnMgPT09IHZvaWQgMCkgeyBvLmNvbnRhaW5lcnMgPSBpbml0aWFsQ29udGFpbmVycyB8fCBbXTsgfVxuICBpZiAoby5pc0NvbnRhaW5lciA9PT0gdm9pZCAwKSB7IG8uaXNDb250YWluZXIgPSBuZXZlcjsgfVxuICBpZiAoby5jb3B5ID09PSB2b2lkIDApIHsgby5jb3B5ID0gZmFsc2U7IH1cbiAgaWYgKG8uY29weVNvcnRTb3VyY2UgPT09IHZvaWQgMCkgeyBvLmNvcHlTb3J0U291cmNlID0gZmFsc2U7IH1cbiAgaWYgKG8ucmV2ZXJ0T25TcGlsbCA9PT0gdm9pZCAwKSB7IG8ucmV2ZXJ0T25TcGlsbCA9IGZhbHNlOyB9XG4gIGlmIChvLnJlbW92ZU9uU3BpbGwgPT09IHZvaWQgMCkgeyBvLnJlbW92ZU9uU3BpbGwgPSBmYWxzZTsgfVxuICBpZiAoby5kaXJlY3Rpb24gPT09IHZvaWQgMCkgeyBvLmRpcmVjdGlvbiA9ICd2ZXJ0aWNhbCc7IH1cbiAgaWYgKG8uaWdub3JlSW5wdXRUZXh0U2VsZWN0aW9uID09PSB2b2lkIDApIHsgby5pZ25vcmVJbnB1dFRleHRTZWxlY3Rpb24gPSB0cnVlOyB9XG4gIGlmIChvLm1pcnJvckNvbnRhaW5lciA9PT0gdm9pZCAwKSB7IG8ubWlycm9yQ29udGFpbmVyID0gZG9jLmJvZHk7IH1cblxuICB2YXIgZHJha2UgPSBlbWl0dGVyKHtcbiAgICBjb250YWluZXJzOiBvLmNvbnRhaW5lcnMsXG4gICAgc3RhcnQ6IG1hbnVhbFN0YXJ0LFxuICAgIGVuZDogZW5kLFxuICAgIGNhbmNlbDogY2FuY2VsLFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgY2FuTW92ZTogY2FuTW92ZSxcbiAgICBkcmFnZ2luZzogZmFsc2VcbiAgfSk7XG5cbiAgaWYgKG8ucmVtb3ZlT25TcGlsbCA9PT0gdHJ1ZSkge1xuICAgIGRyYWtlLm9uKCdvdmVyJywgc3BpbGxPdmVyKS5vbignb3V0Jywgc3BpbGxPdXQpO1xuICB9XG5cbiAgZXZlbnRzKCk7XG5cbiAgcmV0dXJuIGRyYWtlO1xuXG4gIGZ1bmN0aW9uIGlzQ29udGFpbmVyIChlbCkge1xuICAgIHJldHVybiBkcmFrZS5jb250YWluZXJzLmluZGV4T2YoZWwpICE9PSAtMSB8fCBvLmlzQ29udGFpbmVyKGVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2ZW50cyAocmVtb3ZlKSB7XG4gICAgdmFyIG9wID0gcmVtb3ZlID8gJ3JlbW92ZScgOiAnYWRkJztcbiAgICB0b3VjaHkoZG9jdW1lbnRFbGVtZW50LCBvcCwgJ21vdXNlZG93bicsIGdyYWIpO1xuICAgIHRvdWNoeShkb2N1bWVudEVsZW1lbnQsIG9wLCAnbW91c2V1cCcsIHJlbGVhc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXZlbnR1YWxNb3ZlbWVudHMgKHJlbW92ZSkge1xuICAgIHZhciBvcCA9IHJlbW92ZSA/ICdyZW1vdmUnIDogJ2FkZCc7XG4gICAgdG91Y2h5KGRvY3VtZW50RWxlbWVudCwgb3AsICdtb3VzZW1vdmUnLCBzdGFydEJlY2F1c2VNb3VzZU1vdmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVtZW50cyAocmVtb3ZlKSB7XG4gICAgdmFyIG9wID0gcmVtb3ZlID8gJ3JlbW92ZScgOiAnYWRkJztcbiAgICBjcm9zc3ZlbnRbb3BdKGRvY3VtZW50RWxlbWVudCwgJ3NlbGVjdHN0YXJ0JywgcHJldmVudEdyYWJiZWQpOyAvLyBJRThcbiAgICBjcm9zc3ZlbnRbb3BdKGRvY3VtZW50RWxlbWVudCwgJ2NsaWNrJywgcHJldmVudEdyYWJiZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gICAgZXZlbnRzKHRydWUpO1xuICAgIHJlbGVhc2Uoe30pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJldmVudEdyYWJiZWQgKGUpIHtcbiAgICBpZiAoX2dyYWJiZWQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBncmFiIChlKSB7XG4gICAgX21vdmVYID0gZS5jbGllbnRYO1xuICAgIF9tb3ZlWSA9IGUuY2xpZW50WTtcblxuICAgIHZhciBpZ25vcmUgPSB3aGljaE1vdXNlQnV0dG9uKGUpICE9PSAxIHx8IGUubWV0YUtleSB8fCBlLmN0cmxLZXk7XG4gICAgaWYgKGlnbm9yZSkge1xuICAgICAgcmV0dXJuOyAvLyB3ZSBvbmx5IGNhcmUgYWJvdXQgaG9uZXN0LXRvLWdvZCBsZWZ0IGNsaWNrcyBhbmQgdG91Y2ggZXZlbnRzXG4gICAgfVxuICAgIHZhciBpdGVtID0gZS50YXJnZXQ7XG4gICAgdmFyIGNvbnRleHQgPSBjYW5TdGFydChpdGVtKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2dyYWJiZWQgPSBjb250ZXh0O1xuICAgIGV2ZW50dWFsTW92ZW1lbnRzKCk7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgIGlmIChpc0lucHV0KGl0ZW0pKSB7IC8vIHNlZSBhbHNvOiBodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvZHJhZ3VsYS9pc3N1ZXMvMjA4XG4gICAgICAgIGl0ZW0uZm9jdXMoKTsgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL2JldmFjcXVhL2RyYWd1bGEvaXNzdWVzLzE3NlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvZHJhZ3VsYS9pc3N1ZXMvMTU1XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRCZWNhdXNlTW91c2VNb3ZlZCAoZSkge1xuICAgIGlmICghX2dyYWJiZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdoaWNoTW91c2VCdXR0b24oZSkgPT09IDApIHtcbiAgICAgIHJlbGVhc2Uoe30pO1xuICAgICAgcmV0dXJuOyAvLyB3aGVuIHRleHQgaXMgc2VsZWN0ZWQgb24gYW4gaW5wdXQgYW5kIHRoZW4gZHJhZ2dlZCwgbW91c2V1cCBkb2Vzbid0IGZpcmUuIHRoaXMgaXMgb3VyIG9ubHkgaG9wZVxuICAgIH1cbiAgICAvLyB0cnV0aHkgY2hlY2sgZml4ZXMgIzIzOSwgZXF1YWxpdHkgZml4ZXMgIzIwN1xuICAgIGlmIChlLmNsaWVudFggIT09IHZvaWQgMCAmJiBlLmNsaWVudFggPT09IF9tb3ZlWCAmJiBlLmNsaWVudFkgIT09IHZvaWQgMCAmJiBlLmNsaWVudFkgPT09IF9tb3ZlWSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoby5pZ25vcmVJbnB1dFRleHRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBjbGllbnRYID0gZ2V0Q29vcmQoJ2NsaWVudFgnLCBlKTtcbiAgICAgIHZhciBjbGllbnRZID0gZ2V0Q29vcmQoJ2NsaWVudFknLCBlKTtcbiAgICAgIHZhciBlbGVtZW50QmVoaW5kQ3Vyc29yID0gZG9jLmVsZW1lbnRGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICBpZiAoaXNJbnB1dChlbGVtZW50QmVoaW5kQ3Vyc29yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdyYWJiZWQgPSBfZ3JhYmJlZDsgLy8gY2FsbCB0byBlbmQoKSB1bnNldHMgX2dyYWJiZWRcbiAgICBldmVudHVhbE1vdmVtZW50cyh0cnVlKTtcbiAgICBtb3ZlbWVudHMoKTtcbiAgICBlbmQoKTtcbiAgICBzdGFydChncmFiYmVkKTtcblxuICAgIHZhciBvZmZzZXQgPSBnZXRPZmZzZXQoX2l0ZW0pO1xuICAgIF9vZmZzZXRYID0gZ2V0Q29vcmQoJ3BhZ2VYJywgZSkgLSBvZmZzZXQubGVmdDtcbiAgICBfb2Zmc2V0WSA9IGdldENvb3JkKCdwYWdlWScsIGUpIC0gb2Zmc2V0LnRvcDtcblxuICAgIGNsYXNzZXMuYWRkKF9jb3B5IHx8IF9pdGVtLCAnZ3UtdHJhbnNpdCcpO1xuICAgIHJlbmRlck1pcnJvckltYWdlKCk7XG4gICAgZHJhZyhlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhblN0YXJ0IChpdGVtKSB7XG4gICAgaWYgKGRyYWtlLmRyYWdnaW5nICYmIF9taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQ29udGFpbmVyKGl0ZW0pKSB7XG4gICAgICByZXR1cm47IC8vIGRvbid0IGRyYWcgY29udGFpbmVyIGl0c2VsZlxuICAgIH1cbiAgICB2YXIgaGFuZGxlID0gaXRlbTtcbiAgICB3aGlsZSAoZ2V0UGFyZW50KGl0ZW0pICYmIGlzQ29udGFpbmVyKGdldFBhcmVudChpdGVtKSkgPT09IGZhbHNlKSB7XG4gICAgICBpZiAoby5pbnZhbGlkKGl0ZW0sIGhhbmRsZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaXRlbSA9IGdldFBhcmVudChpdGVtKTsgLy8gZHJhZyB0YXJnZXQgc2hvdWxkIGJlIGEgdG9wIGVsZW1lbnRcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBnZXRQYXJlbnQoaXRlbSk7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8uaW52YWxpZChpdGVtLCBoYW5kbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1vdmFibGUgPSBvLm1vdmVzKGl0ZW0sIHNvdXJjZSwgaGFuZGxlLCBuZXh0RWwoaXRlbSkpO1xuICAgIGlmICghbW92YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpdGVtOiBpdGVtLFxuICAgICAgc291cmNlOiBzb3VyY2VcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuTW92ZSAoaXRlbSkge1xuICAgIHJldHVybiAhIWNhblN0YXJ0KGl0ZW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFudWFsU3RhcnQgKGl0ZW0pIHtcbiAgICB2YXIgY29udGV4dCA9IGNhblN0YXJ0KGl0ZW0pO1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICBzdGFydChjb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydCAoY29udGV4dCkge1xuICAgIGlmIChpc0NvcHkoY29udGV4dC5pdGVtLCBjb250ZXh0LnNvdXJjZSkpIHtcbiAgICAgIF9jb3B5ID0gY29udGV4dC5pdGVtLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGRyYWtlLmVtaXQoJ2Nsb25lZCcsIF9jb3B5LCBjb250ZXh0Lml0ZW0sICdjb3B5Jyk7XG4gICAgfVxuXG4gICAgX3NvdXJjZSA9IGNvbnRleHQuc291cmNlO1xuICAgIF9pdGVtID0gY29udGV4dC5pdGVtO1xuICAgIF9pbml0aWFsU2libGluZyA9IF9jdXJyZW50U2libGluZyA9IG5leHRFbChjb250ZXh0Lml0ZW0pO1xuXG4gICAgZHJha2UuZHJhZ2dpbmcgPSB0cnVlO1xuICAgIGRyYWtlLmVtaXQoJ2RyYWcnLCBfaXRlbSwgX3NvdXJjZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkVGFyZ2V0ICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmQgKCkge1xuICAgIGlmICghZHJha2UuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0ZW0gPSBfY29weSB8fCBfaXRlbTtcbiAgICBkcm9wKGl0ZW0sIGdldFBhcmVudChpdGVtKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1bmdyYWIgKCkge1xuICAgIF9ncmFiYmVkID0gZmFsc2U7XG4gICAgZXZlbnR1YWxNb3ZlbWVudHModHJ1ZSk7XG4gICAgbW92ZW1lbnRzKHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVsZWFzZSAoZSkge1xuICAgIHVuZ3JhYigpO1xuXG4gICAgaWYgKCFkcmFrZS5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXRlbSA9IF9jb3B5IHx8IF9pdGVtO1xuICAgIHZhciBjbGllbnRYID0gZ2V0Q29vcmQoJ2NsaWVudFgnLCBlKTtcbiAgICB2YXIgY2xpZW50WSA9IGdldENvb3JkKCdjbGllbnRZJywgZSk7XG4gICAgdmFyIGVsZW1lbnRCZWhpbmRDdXJzb3IgPSBnZXRFbGVtZW50QmVoaW5kUG9pbnQoX21pcnJvciwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgdmFyIGRyb3BUYXJnZXQgPSBmaW5kRHJvcFRhcmdldChlbGVtZW50QmVoaW5kQ3Vyc29yLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICBpZiAoZHJvcFRhcmdldCAmJiAoKF9jb3B5ICYmIG8uY29weVNvcnRTb3VyY2UpIHx8ICghX2NvcHkgfHwgZHJvcFRhcmdldCAhPT0gX3NvdXJjZSkpKSB7XG4gICAgICBkcm9wKGl0ZW0sIGRyb3BUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoby5yZW1vdmVPblNwaWxsKSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJvcCAoaXRlbSwgdGFyZ2V0KSB7XG4gICAgdmFyIHBhcmVudCA9IGdldFBhcmVudChpdGVtKTtcbiAgICBpZiAoX2NvcHkgJiYgby5jb3B5U29ydFNvdXJjZSAmJiB0YXJnZXQgPT09IF9zb3VyY2UpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChfaXRlbSk7XG4gICAgfVxuICAgIGlmIChpc0luaXRpYWxQbGFjZW1lbnQodGFyZ2V0KSkge1xuICAgICAgZHJha2UuZW1pdCgnY2FuY2VsJywgaXRlbSwgX3NvdXJjZSwgX3NvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYWtlLmVtaXQoJ2Ryb3AnLCBpdGVtLCB0YXJnZXQsIF9zb3VyY2UsIF9jdXJyZW50U2libGluZyk7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgaWYgKCFkcmFrZS5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXRlbSA9IF9jb3B5IHx8IF9pdGVtO1xuICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQoaXRlbSk7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGl0ZW0pO1xuICAgIH1cbiAgICBkcmFrZS5lbWl0KF9jb3B5ID8gJ2NhbmNlbCcgOiAncmVtb3ZlJywgaXRlbSwgcGFyZW50LCBfc291cmNlKTtcbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwgKHJldmVydCkge1xuICAgIGlmICghZHJha2UuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldmVydHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IHJldmVydCA6IG8ucmV2ZXJ0T25TcGlsbDtcbiAgICB2YXIgaXRlbSA9IF9jb3B5IHx8IF9pdGVtO1xuICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQoaXRlbSk7XG4gICAgdmFyIGluaXRpYWwgPSBpc0luaXRpYWxQbGFjZW1lbnQocGFyZW50KTtcbiAgICBpZiAoaW5pdGlhbCA9PT0gZmFsc2UgJiYgcmV2ZXJ0cykge1xuICAgICAgaWYgKF9jb3B5KSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX2NvcHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc291cmNlLmluc2VydEJlZm9yZShpdGVtLCBfaW5pdGlhbFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5pdGlhbCB8fCByZXZlcnRzKSB7XG4gICAgICBkcmFrZS5lbWl0KCdjYW5jZWwnLCBpdGVtLCBfc291cmNlLCBfc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJha2UuZW1pdCgnZHJvcCcsIGl0ZW0sIHBhcmVudCwgX3NvdXJjZSwgX2N1cnJlbnRTaWJsaW5nKTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgdmFyIGl0ZW0gPSBfY29weSB8fCBfaXRlbTtcbiAgICB1bmdyYWIoKTtcbiAgICByZW1vdmVNaXJyb3JJbWFnZSgpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjbGFzc2VzLnJtKGl0ZW0sICdndS10cmFuc2l0Jyk7XG4gICAgfVxuICAgIGlmIChfcmVuZGVyVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChfcmVuZGVyVGltZXIpO1xuICAgIH1cbiAgICBkcmFrZS5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIGlmIChfbGFzdERyb3BUYXJnZXQpIHtcbiAgICAgIGRyYWtlLmVtaXQoJ291dCcsIGl0ZW0sIF9sYXN0RHJvcFRhcmdldCwgX3NvdXJjZSk7XG4gICAgfVxuICAgIGRyYWtlLmVtaXQoJ2RyYWdlbmQnLCBpdGVtKTtcbiAgICBfc291cmNlID0gX2l0ZW0gPSBfY29weSA9IF9pbml0aWFsU2libGluZyA9IF9jdXJyZW50U2libGluZyA9IF9yZW5kZXJUaW1lciA9IF9sYXN0RHJvcFRhcmdldCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBpc0luaXRpYWxQbGFjZW1lbnQgKHRhcmdldCwgcykge1xuICAgIHZhciBzaWJsaW5nO1xuICAgIGlmIChzICE9PSB2b2lkIDApIHtcbiAgICAgIHNpYmxpbmcgPSBzO1xuICAgIH0gZWxzZSBpZiAoX21pcnJvcikge1xuICAgICAgc2libGluZyA9IF9jdXJyZW50U2libGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgc2libGluZyA9IG5leHRFbChfY29weSB8fCBfaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQgPT09IF9zb3VyY2UgJiYgc2libGluZyA9PT0gX2luaXRpYWxTaWJsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZERyb3BUYXJnZXQgKGVsZW1lbnRCZWhpbmRDdXJzb3IsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZWxlbWVudEJlaGluZEN1cnNvcjtcbiAgICB3aGlsZSAodGFyZ2V0ICYmICFhY2NlcHRlZCgpKSB7XG4gICAgICB0YXJnZXQgPSBnZXRQYXJlbnQodGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcblxuICAgIGZ1bmN0aW9uIGFjY2VwdGVkICgpIHtcbiAgICAgIHZhciBkcm9wcGFibGUgPSBpc0NvbnRhaW5lcih0YXJnZXQpO1xuICAgICAgaWYgKGRyb3BwYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1tZWRpYXRlID0gZ2V0SW1tZWRpYXRlQ2hpbGQodGFyZ2V0LCBlbGVtZW50QmVoaW5kQ3Vyc29yKTtcbiAgICAgIHZhciByZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2UodGFyZ2V0LCBpbW1lZGlhdGUsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgdmFyIGluaXRpYWwgPSBpc0luaXRpYWxQbGFjZW1lbnQodGFyZ2V0LCByZWZlcmVuY2UpO1xuICAgICAgaWYgKGluaXRpYWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBkcm9wIGl0IHJpZ2h0IGJhY2sgd2hlcmUgaXQgd2FzXG4gICAgICB9XG4gICAgICByZXR1cm4gby5hY2NlcHRzKF9pdGVtLCB0YXJnZXQsIF9zb3VyY2UsIHJlZmVyZW5jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhZyAoZSkge1xuICAgIGlmICghX21pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgY2xpZW50WCA9IGdldENvb3JkKCdjbGllbnRYJywgZSk7XG4gICAgdmFyIGNsaWVudFkgPSBnZXRDb29yZCgnY2xpZW50WScsIGUpO1xuICAgIHZhciB4ID0gY2xpZW50WCAtIF9vZmZzZXRYO1xuICAgIHZhciB5ID0gY2xpZW50WSAtIF9vZmZzZXRZO1xuXG4gICAgX21pcnJvci5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgX21pcnJvci5zdHlsZS50b3AgPSB5ICsgJ3B4JztcblxuICAgIHZhciBpdGVtID0gX2NvcHkgfHwgX2l0ZW07XG4gICAgdmFyIGVsZW1lbnRCZWhpbmRDdXJzb3IgPSBnZXRFbGVtZW50QmVoaW5kUG9pbnQoX21pcnJvciwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgdmFyIGRyb3BUYXJnZXQgPSBmaW5kRHJvcFRhcmdldChlbGVtZW50QmVoaW5kQ3Vyc29yLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICB2YXIgY2hhbmdlZCA9IGRyb3BUYXJnZXQgIT09IG51bGwgJiYgZHJvcFRhcmdldCAhPT0gX2xhc3REcm9wVGFyZ2V0O1xuICAgIGlmIChjaGFuZ2VkIHx8IGRyb3BUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgIG91dCgpO1xuICAgICAgX2xhc3REcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcbiAgICAgIG92ZXIoKTtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IGdldFBhcmVudChpdGVtKTtcbiAgICBpZiAoZHJvcFRhcmdldCA9PT0gX3NvdXJjZSAmJiBfY29weSAmJiAhby5jb3B5U29ydFNvdXJjZSkge1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaXRlbSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWZlcmVuY2U7XG4gICAgdmFyIGltbWVkaWF0ZSA9IGdldEltbWVkaWF0ZUNoaWxkKGRyb3BUYXJnZXQsIGVsZW1lbnRCZWhpbmRDdXJzb3IpO1xuICAgIGlmIChpbW1lZGlhdGUgIT09IG51bGwpIHtcbiAgICAgIHJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZShkcm9wVGFyZ2V0LCBpbW1lZGlhdGUsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIH0gZWxzZSBpZiAoby5yZXZlcnRPblNwaWxsID09PSB0cnVlICYmICFfY29weSkge1xuICAgICAgcmVmZXJlbmNlID0gX2luaXRpYWxTaWJsaW5nO1xuICAgICAgZHJvcFRhcmdldCA9IF9zb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfY29weSAmJiBwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGl0ZW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAocmVmZXJlbmNlID09PSBudWxsICYmIGNoYW5nZWQpIHx8XG4gICAgICByZWZlcmVuY2UgIT09IGl0ZW0gJiZcbiAgICAgIHJlZmVyZW5jZSAhPT0gbmV4dEVsKGl0ZW0pXG4gICAgKSB7XG4gICAgICBfY3VycmVudFNpYmxpbmcgPSByZWZlcmVuY2U7XG4gICAgICBkcm9wVGFyZ2V0Lmluc2VydEJlZm9yZShpdGVtLCByZWZlcmVuY2UpO1xuICAgICAgZHJha2UuZW1pdCgnc2hhZG93JywgaXRlbSwgZHJvcFRhcmdldCwgX3NvdXJjZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVkICh0eXBlKSB7IGRyYWtlLmVtaXQodHlwZSwgaXRlbSwgX2xhc3REcm9wVGFyZ2V0LCBfc291cmNlKTsgfVxuICAgIGZ1bmN0aW9uIG92ZXIgKCkgeyBpZiAoY2hhbmdlZCkgeyBtb3ZlZCgnb3ZlcicpOyB9IH1cbiAgICBmdW5jdGlvbiBvdXQgKCkgeyBpZiAoX2xhc3REcm9wVGFyZ2V0KSB7IG1vdmVkKCdvdXQnKTsgfSB9XG4gIH1cblxuICBmdW5jdGlvbiBzcGlsbE92ZXIgKGVsKSB7XG4gICAgY2xhc3Nlcy5ybShlbCwgJ2d1LWhpZGUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwaWxsT3V0IChlbCkge1xuICAgIGlmIChkcmFrZS5kcmFnZ2luZykgeyBjbGFzc2VzLmFkZChlbCwgJ2d1LWhpZGUnKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyTWlycm9ySW1hZ2UgKCkge1xuICAgIGlmIChfbWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWN0ID0gX2l0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgX21pcnJvciA9IF9pdGVtLmNsb25lTm9kZSh0cnVlKTtcbiAgICBfbWlycm9yLnN0eWxlLndpZHRoID0gZ2V0UmVjdFdpZHRoKHJlY3QpICsgJ3B4JztcbiAgICBfbWlycm9yLnN0eWxlLmhlaWdodCA9IGdldFJlY3RIZWlnaHQocmVjdCkgKyAncHgnO1xuICAgIGNsYXNzZXMucm0oX21pcnJvciwgJ2d1LXRyYW5zaXQnKTtcbiAgICBjbGFzc2VzLmFkZChfbWlycm9yLCAnZ3UtbWlycm9yJyk7XG4gICAgby5taXJyb3JDb250YWluZXIuYXBwZW5kQ2hpbGQoX21pcnJvcik7XG4gICAgdG91Y2h5KGRvY3VtZW50RWxlbWVudCwgJ2FkZCcsICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICBjbGFzc2VzLmFkZChvLm1pcnJvckNvbnRhaW5lciwgJ2d1LXVuc2VsZWN0YWJsZScpO1xuICAgIGRyYWtlLmVtaXQoJ2Nsb25lZCcsIF9taXJyb3IsIF9pdGVtLCAnbWlycm9yJyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVNaXJyb3JJbWFnZSAoKSB7XG4gICAgaWYgKF9taXJyb3IpIHtcbiAgICAgIGNsYXNzZXMucm0oby5taXJyb3JDb250YWluZXIsICdndS11bnNlbGVjdGFibGUnKTtcbiAgICAgIHRvdWNoeShkb2N1bWVudEVsZW1lbnQsICdyZW1vdmUnLCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgICBnZXRQYXJlbnQoX21pcnJvcikucmVtb3ZlQ2hpbGQoX21pcnJvcik7XG4gICAgICBfbWlycm9yID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbW1lZGlhdGVDaGlsZCAoZHJvcFRhcmdldCwgdGFyZ2V0KSB7XG4gICAgdmFyIGltbWVkaWF0ZSA9IHRhcmdldDtcbiAgICB3aGlsZSAoaW1tZWRpYXRlICE9PSBkcm9wVGFyZ2V0ICYmIGdldFBhcmVudChpbW1lZGlhdGUpICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICBpbW1lZGlhdGUgPSBnZXRQYXJlbnQoaW1tZWRpYXRlKTtcbiAgICB9XG4gICAgaWYgKGltbWVkaWF0ZSA9PT0gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGltbWVkaWF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJlZmVyZW5jZSAoZHJvcFRhcmdldCwgdGFyZ2V0LCB4LCB5KSB7XG4gICAgdmFyIGhvcml6b250YWwgPSBvLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgIHZhciByZWZlcmVuY2UgPSB0YXJnZXQgIT09IGRyb3BUYXJnZXQgPyBpbnNpZGUoKSA6IG91dHNpZGUoKTtcbiAgICByZXR1cm4gcmVmZXJlbmNlO1xuXG4gICAgZnVuY3Rpb24gb3V0c2lkZSAoKSB7IC8vIHNsb3dlciwgYnV0IGFibGUgdG8gZmlndXJlIG91dCBhbnkgcG9zaXRpb25cbiAgICAgIHZhciBsZW4gPSBkcm9wVGFyZ2V0LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGVsO1xuICAgICAgdmFyIHJlY3Q7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwgPSBkcm9wVGFyZ2V0LmNoaWxkcmVuW2ldO1xuICAgICAgICByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChob3Jpem9udGFsICYmIChyZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMikgPiB4KSB7IHJldHVybiBlbDsgfVxuICAgICAgICBpZiAoIWhvcml6b250YWwgJiYgKHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLyAyKSA+IHkpIHsgcmV0dXJuIGVsOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNpZGUgKCkgeyAvLyBmYXN0ZXIsIGJ1dCBvbmx5IGF2YWlsYWJsZSBpZiBkcm9wcGVkIGluc2lkZSBhIGNoaWxkIGVsZW1lbnRcbiAgICAgIHZhciByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoeCA+IHJlY3QubGVmdCArIGdldFJlY3RXaWR0aChyZWN0KSAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmUoeSA+IHJlY3QudG9wICsgZ2V0UmVjdEhlaWdodChyZWN0KSAvIDIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmUgKGFmdGVyKSB7XG4gICAgICByZXR1cm4gYWZ0ZXIgPyBuZXh0RWwodGFyZ2V0KSA6IHRhcmdldDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0NvcHkgKGl0ZW0sIGNvbnRhaW5lcikge1xuICAgIHJldHVybiB0eXBlb2Ygby5jb3B5ID09PSAnYm9vbGVhbicgPyBvLmNvcHkgOiBvLmNvcHkoaXRlbSwgY29udGFpbmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b3VjaHkgKGVsLCBvcCwgdHlwZSwgZm4pIHtcbiAgdmFyIHRvdWNoID0ge1xuICAgIG1vdXNldXA6ICd0b3VjaGVuZCcsXG4gICAgbW91c2Vkb3duOiAndG91Y2hzdGFydCcsXG4gICAgbW91c2Vtb3ZlOiAndG91Y2htb3ZlJ1xuICB9O1xuICB2YXIgcG9pbnRlcnMgPSB7XG4gICAgbW91c2V1cDogJ3BvaW50ZXJ1cCcsXG4gICAgbW91c2Vkb3duOiAncG9pbnRlcmRvd24nLFxuICAgIG1vdXNlbW92ZTogJ3BvaW50ZXJtb3ZlJ1xuICB9O1xuICB2YXIgbWljcm9zb2Z0ID0ge1xuICAgIG1vdXNldXA6ICdNU1BvaW50ZXJVcCcsXG4gICAgbW91c2Vkb3duOiAnTVNQb2ludGVyRG93bicsXG4gICAgbW91c2Vtb3ZlOiAnTVNQb2ludGVyTW92ZSdcbiAgfTtcbiAgaWYgKGdsb2JhbC5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQpIHtcbiAgICBjcm9zc3ZlbnRbb3BdKGVsLCBwb2ludGVyc1t0eXBlXSwgZm4pO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuICAgIGNyb3NzdmVudFtvcF0oZWwsIG1pY3Jvc29mdFt0eXBlXSwgZm4pO1xuICB9IGVsc2Uge1xuICAgIGNyb3NzdmVudFtvcF0oZWwsIHRvdWNoW3R5cGVdLCBmbik7XG4gICAgY3Jvc3N2ZW50W29wXShlbCwgdHlwZSwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdoaWNoTW91c2VCdXR0b24gKGUpIHtcbiAgaWYgKGUudG91Y2hlcyAhPT0gdm9pZCAwKSB7IHJldHVybiBlLnRvdWNoZXMubGVuZ3RoOyB9XG4gIGlmIChlLndoaWNoICE9PSB2b2lkIDAgJiYgZS53aGljaCAhPT0gMCkgeyByZXR1cm4gZS53aGljaDsgfSAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JldmFjcXVhL2RyYWd1bGEvaXNzdWVzLzI2MVxuICBpZiAoZS5idXR0b25zICE9PSB2b2lkIDApIHsgcmV0dXJuIGUuYnV0dG9uczsgfVxuICB2YXIgYnV0dG9uID0gZS5idXR0b247XG4gIGlmIChidXR0b24gIT09IHZvaWQgMCkgeyAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi85OWU4ZmYxYmFhN2FlMzQxZTk0YmI4OWMzZTg0NTcwYzdjM2FkOWVhL3NyYy9ldmVudC5qcyNMNTczLUw1NzVcbiAgICByZXR1cm4gYnV0dG9uICYgMSA/IDEgOiBidXR0b24gJiAyID8gMyA6IChidXR0b24gJiA0ID8gMiA6IDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldCAoZWwpIHtcbiAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiByZWN0LmxlZnQgKyBnZXRTY3JvbGwoJ3Njcm9sbExlZnQnLCAncGFnZVhPZmZzZXQnKSxcbiAgICB0b3A6IHJlY3QudG9wICsgZ2V0U2Nyb2xsKCdzY3JvbGxUb3AnLCAncGFnZVlPZmZzZXQnKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGwgKHNjcm9sbFByb3AsIG9mZnNldFByb3ApIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxbb2Zmc2V0UHJvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbFtvZmZzZXRQcm9wXTtcbiAgfVxuICBpZiAoZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnRbc2Nyb2xsUHJvcF07XG4gIH1cbiAgcmV0dXJuIGRvYy5ib2R5W3Njcm9sbFByb3BdO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50QmVoaW5kUG9pbnQgKHBvaW50LCB4LCB5KSB7XG4gIHZhciBwID0gcG9pbnQgfHwge307XG4gIHZhciBzdGF0ZSA9IHAuY2xhc3NOYW1lO1xuICB2YXIgZWw7XG4gIHAuY2xhc3NOYW1lICs9ICcgZ3UtaGlkZSc7XG4gIGVsID0gZG9jLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gIHAuY2xhc3NOYW1lID0gc3RhdGU7XG4gIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gbmV2ZXIgKCkgeyByZXR1cm4gZmFsc2U7IH1cbmZ1bmN0aW9uIGFsd2F5cyAoKSB7IHJldHVybiB0cnVlOyB9XG5mdW5jdGlvbiBnZXRSZWN0V2lkdGggKHJlY3QpIHsgcmV0dXJuIHJlY3Qud2lkdGggfHwgKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpOyB9XG5mdW5jdGlvbiBnZXRSZWN0SGVpZ2h0IChyZWN0KSB7IHJldHVybiByZWN0LmhlaWdodCB8fCAocmVjdC5ib3R0b20gLSByZWN0LnRvcCk7IH1cbmZ1bmN0aW9uIGdldFBhcmVudCAoZWwpIHsgcmV0dXJuIGVsLnBhcmVudE5vZGUgPT09IGRvYyA/IG51bGwgOiBlbC5wYXJlbnROb2RlOyB9XG5mdW5jdGlvbiBpc0lucHV0IChlbCkgeyByZXR1cm4gZWwudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnIHx8IGVsLnRhZ05hbWUgPT09ICdTRUxFQ1QnIHx8IGlzRWRpdGFibGUoZWwpOyB9XG5mdW5jdGlvbiBpc0VkaXRhYmxlIChlbCkge1xuICBpZiAoIWVsKSB7IHJldHVybiBmYWxzZTsgfSAvLyBubyBwYXJlbnRzIHdlcmUgZWRpdGFibGVcbiAgaWYgKGVsLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ2ZhbHNlJykgeyByZXR1cm4gZmFsc2U7IH0gLy8gc3RvcCB0aGUgbG9va3VwXG4gIGlmIChlbC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykgeyByZXR1cm4gdHJ1ZTsgfSAvLyBmb3VuZCBhIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50IGluIHRoZSBjaGFpblxuICByZXR1cm4gaXNFZGl0YWJsZShnZXRQYXJlbnQoZWwpKTsgLy8gY29udGVudEVkaXRhYmxlIGlzIHNldCB0byAnaW5oZXJpdCdcbn1cblxuZnVuY3Rpb24gbmV4dEVsIChlbCkge1xuICByZXR1cm4gZWwubmV4dEVsZW1lbnRTaWJsaW5nIHx8IG1hbnVhbGx5KCk7XG4gIGZ1bmN0aW9uIG1hbnVhbGx5ICgpIHtcbiAgICB2YXIgc2libGluZyA9IGVsO1xuICAgIGRvIHtcbiAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgIH0gd2hpbGUgKHNpYmxpbmcgJiYgc2libGluZy5ub2RlVHlwZSAhPT0gMSk7XG4gICAgcmV0dXJuIHNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRIb3N0IChlKSB7XG4gIC8vIG9uIHRvdWNoZW5kIGV2ZW50LCB3ZSBoYXZlIHRvIHVzZSBgZS5jaGFuZ2VkVG91Y2hlc2BcbiAgLy8gc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzE5MjU2My90b3VjaGVuZC1ldmVudC1wcm9wZXJ0aWVzXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvZHJhZ3VsYS9pc3N1ZXMvMzRcbiAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXTtcbiAgfVxuICBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBnZXRDb29yZCAoY29vcmQsIGUpIHtcbiAgdmFyIGhvc3QgPSBnZXRFdmVudEhvc3QoZSk7XG4gIHZhciBtaXNzTWFwID0ge1xuICAgIHBhZ2VYOiAnY2xpZW50WCcsIC8vIElFOFxuICAgIHBhZ2VZOiAnY2xpZW50WScgLy8gSUU4XG4gIH07XG4gIGlmIChjb29yZCBpbiBtaXNzTWFwICYmICEoY29vcmQgaW4gaG9zdCkgJiYgbWlzc01hcFtjb29yZF0gaW4gaG9zdCkge1xuICAgIGNvb3JkID0gbWlzc01hcFtjb29yZF07XG4gIH1cbiAgcmV0dXJuIGhvc3RbY29vcmRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYWd1bGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZHJhZ3VsYS9kcmFndWxhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar atoa = __webpack_require__(13);\nvar debounce = __webpack_require__(14);\n\nmodule.exports = function emitter (thing, options) {\n  var opts = options || {};\n  var evt = {};\n  if (thing === undefined) { thing = {}; }\n  thing.on = function (type, fn) {\n    if (!evt[type]) {\n      evt[type] = [fn];\n    } else {\n      evt[type].push(fn);\n    }\n    return thing;\n  };\n  thing.once = function (type, fn) {\n    fn._once = true; // thing.off(fn) still works!\n    thing.on(type, fn);\n    return thing;\n  };\n  thing.off = function (type, fn) {\n    var c = arguments.length;\n    if (c === 1) {\n      delete evt[type];\n    } else if (c === 0) {\n      evt = {};\n    } else {\n      var et = evt[type];\n      if (!et) { return thing; }\n      et.splice(et.indexOf(fn), 1);\n    }\n    return thing;\n  };\n  thing.emit = function () {\n    var args = atoa(arguments);\n    return thing.emitterSnapshot(args.shift()).apply(this, args);\n  };\n  thing.emitterSnapshot = function (type) {\n    var et = (evt[type] || []).slice(0);\n    return function () {\n      var args = atoa(arguments);\n      var ctx = this || thing;\n      if (type === 'error' && opts.throws !== false && !et.length) { throw args.length === 1 ? args[0] : args; }\n      et.forEach(function emitter (listen) {\n        if (opts.async) { debounce(listen, args, ctx); } else { listen.apply(ctx, args); }\n        if (listen._once) { thing.off(type, listen); }\n      });\n      return thing;\n    };\n  };\n  return thing;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvbnRyYS9lbWl0dGVyLmpzP2I0MjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDBDQUEwQztBQUM5RztBQUNBLHlCQUF5Qiw2QkFBNkIsRUFBRSxPQUFPLHlCQUF5QjtBQUN4RiwyQkFBMkIseUJBQXlCO0FBQ3BELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXRvYSA9IHJlcXVpcmUoJ2F0b2EnKTtcbnZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJy4vZGVib3VuY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbWl0dGVyICh0aGluZywgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBldnQgPSB7fTtcbiAgaWYgKHRoaW5nID09PSB1bmRlZmluZWQpIHsgdGhpbmcgPSB7fTsgfVxuICB0aGluZy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgIGlmICghZXZ0W3R5cGVdKSB7XG4gICAgICBldnRbdHlwZV0gPSBbZm5dO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnRbdHlwZV0ucHVzaChmbik7XG4gICAgfVxuICAgIHJldHVybiB0aGluZztcbiAgfTtcbiAgdGhpbmcub25jZSA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgIGZuLl9vbmNlID0gdHJ1ZTsgLy8gdGhpbmcub2ZmKGZuKSBzdGlsbCB3b3JrcyFcbiAgICB0aGluZy5vbih0eXBlLCBmbik7XG4gICAgcmV0dXJuIHRoaW5nO1xuICB9O1xuICB0aGluZy5vZmYgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGMgPT09IDEpIHtcbiAgICAgIGRlbGV0ZSBldnRbdHlwZV07XG4gICAgfSBlbHNlIGlmIChjID09PSAwKSB7XG4gICAgICBldnQgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV0ID0gZXZ0W3R5cGVdO1xuICAgICAgaWYgKCFldCkgeyByZXR1cm4gdGhpbmc7IH1cbiAgICAgIGV0LnNwbGljZShldC5pbmRleE9mKGZuKSwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGluZztcbiAgfTtcbiAgdGhpbmcuZW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGF0b2EoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpbmcuZW1pdHRlclNuYXBzaG90KGFyZ3Muc2hpZnQoKSkuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG4gIHRoaW5nLmVtaXR0ZXJTbmFwc2hvdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGV0ID0gKGV2dFt0eXBlXSB8fCBbXSkuc2xpY2UoMCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXRvYShhcmd1bWVudHMpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMgfHwgdGhpbmc7XG4gICAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJyAmJiBvcHRzLnRocm93cyAhPT0gZmFsc2UgJiYgIWV0Lmxlbmd0aCkgeyB0aHJvdyBhcmdzLmxlbmd0aCA9PT0gMSA/IGFyZ3NbMF0gOiBhcmdzOyB9XG4gICAgICBldC5mb3JFYWNoKGZ1bmN0aW9uIGVtaXR0ZXIgKGxpc3Rlbikge1xuICAgICAgICBpZiAob3B0cy5hc3luYykgeyBkZWJvdW5jZShsaXN0ZW4sIGFyZ3MsIGN0eCk7IH0gZWxzZSB7IGxpc3Rlbi5hcHBseShjdHgsIGFyZ3MpOyB9XG4gICAgICAgIGlmIChsaXN0ZW4uX29uY2UpIHsgdGhpbmcub2ZmKHR5cGUsIGxpc3Rlbik7IH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaW5nO1xuICAgIH07XG4gIH07XG4gIHJldHVybiB0aGluZztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29udHJhL2VtaXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	eval("module.exports = function atoa (a, n) { return Array.prototype.slice.call(a, n); }\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2F0b2EvYXRvYS5qcz81MzJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHVDQUF1Qyx5Q0FBeUMiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF0b2EgKGEsIG4pIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIG4pOyB9XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXRvYS9hdG9hLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar ticky = __webpack_require__(15);\n\nmodule.exports = function debounce (fn, args, ctx) {\n  if (!fn) { return; }\n  ticky(function run () {\n    fn.apply(ctx || null, args || []);\n  });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvbnRyYS9kZWJvdW5jZS5qcz9hZWMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB0aWNreSA9IHJlcXVpcmUoJ3RpY2t5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVib3VuY2UgKGZuLCBhcmdzLCBjdHgpIHtcbiAgaWYgKCFmbikgeyByZXR1cm47IH1cbiAgdGlja3koZnVuY3Rpb24gcnVuICgpIHtcbiAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgYXJncyB8fCBbXSk7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb250cmEvZGVib3VuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {var si = typeof setImmediate === 'function', tick;\nif (si) {\n  tick = function (fn) { setImmediate(fn); };\n} else {\n  tick = function (fn) { setTimeout(fn, 0); };\n}\n\nmodule.exports = tick;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpY2t5L3RpY2t5LWJyb3dzZXIuanM/MDFmZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQyxDQUFDO0FBQ0Qsd0JBQXdCLG1CQUFtQjtBQUMzQzs7QUFFQSxzQiIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzaSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicsIHRpY2s7XG5pZiAoc2kpIHtcbiAgdGljayA9IGZ1bmN0aW9uIChmbikgeyBzZXRJbW1lZGlhdGUoZm4pOyB9O1xufSBlbHNlIHtcbiAgdGljayA9IGZ1bmN0aW9uIChmbikgeyBzZXRUaW1lb3V0KGZuLCAwKTsgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aWNrO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90aWNreS90aWNreS1icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(17);\n// On some exotic environments, it's not clear which object `setimmeidate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWlkYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(18)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/NGE4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nvar customEvent = __webpack_require__(20);\nvar eventmap = __webpack_require__(21);\nvar doc = global.document;\nvar addEvent = addEventEasy;\nvar removeEvent = removeEventEasy;\nvar hardCache = [];\n\nif (!global.addEventListener) {\n  addEvent = addEventHard;\n  removeEvent = removeEventHard;\n}\n\nmodule.exports = {\n  add: addEvent,\n  remove: removeEvent,\n  fabricate: fabricateEvent\n};\n\nfunction addEventEasy (el, type, fn, capturing) {\n  return el.addEventListener(type, fn, capturing);\n}\n\nfunction addEventHard (el, type, fn) {\n  return el.attachEvent('on' + type, wrap(el, type, fn));\n}\n\nfunction removeEventEasy (el, type, fn, capturing) {\n  return el.removeEventListener(type, fn, capturing);\n}\n\nfunction removeEventHard (el, type, fn) {\n  var listener = unwrap(el, type, fn);\n  if (listener) {\n    return el.detachEvent('on' + type, listener);\n  }\n}\n\nfunction fabricateEvent (el, type, model) {\n  var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();\n  if (el.dispatchEvent) {\n    el.dispatchEvent(e);\n  } else {\n    el.fireEvent('on' + type, e);\n  }\n  function makeClassicEvent () {\n    var e;\n    if (doc.createEvent) {\n      e = doc.createEvent('Event');\n      e.initEvent(type, true, true);\n    } else if (doc.createEventObject) {\n      e = doc.createEventObject();\n    }\n    return e;\n  }\n  function makeCustomEvent () {\n    return new customEvent(type, { detail: model });\n  }\n}\n\nfunction wrapperFactory (el, type, fn) {\n  return function wrapper (originalEvent) {\n    var e = originalEvent || global.event;\n    e.target = e.target || e.srcElement;\n    e.preventDefault = e.preventDefault || function preventDefault () { e.returnValue = false; };\n    e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; };\n    e.which = e.which || e.keyCode;\n    fn.call(el, e);\n  };\n}\n\nfunction wrap (el, type, fn) {\n  var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);\n  hardCache.push({\n    wrapper: wrapper,\n    element: el,\n    type: type,\n    fn: fn\n  });\n  return wrapper;\n}\n\nfunction unwrap (el, type, fn) {\n  var i = find(el, type, fn);\n  if (i) {\n    var wrapper = hardCache[i].wrapper;\n    hardCache.splice(i, 1); // free up a tad of memory\n    return wrapper;\n  }\n}\n\nfunction find (el, type, fn) {\n  var i, item;\n  for (i = 0; i < hardCache.length; i++) {\n    item = hardCache[i];\n    if (item.element === el && item.type === type && item.fn === fn) {\n      return i;\n    }\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nyb3NzdmVudC9zcmMvY3Jvc3N2ZW50LmpzPzUzNzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsdUJBQXVCO0FBQzlGLDBFQUEwRSx1QkFBdUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGN1c3RvbUV2ZW50ID0gcmVxdWlyZSgnY3VzdG9tLWV2ZW50Jyk7XG52YXIgZXZlbnRtYXAgPSByZXF1aXJlKCcuL2V2ZW50bWFwJyk7XG52YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xudmFyIGFkZEV2ZW50ID0gYWRkRXZlbnRFYXN5O1xudmFyIHJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnRFYXN5O1xudmFyIGhhcmRDYWNoZSA9IFtdO1xuXG5pZiAoIWdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gIGFkZEV2ZW50ID0gYWRkRXZlbnRIYXJkO1xuICByZW1vdmVFdmVudCA9IHJlbW92ZUV2ZW50SGFyZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZDogYWRkRXZlbnQsXG4gIHJlbW92ZTogcmVtb3ZlRXZlbnQsXG4gIGZhYnJpY2F0ZTogZmFicmljYXRlRXZlbnRcbn07XG5cbmZ1bmN0aW9uIGFkZEV2ZW50RWFzeSAoZWwsIHR5cGUsIGZuLCBjYXB0dXJpbmcpIHtcbiAgcmV0dXJuIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGNhcHR1cmluZyk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50SGFyZCAoZWwsIHR5cGUsIGZuKSB7XG4gIHJldHVybiBlbC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgd3JhcChlbCwgdHlwZSwgZm4pKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRFYXN5IChlbCwgdHlwZSwgZm4sIGNhcHR1cmluZykge1xuICByZXR1cm4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgY2FwdHVyaW5nKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRIYXJkIChlbCwgdHlwZSwgZm4pIHtcbiAgdmFyIGxpc3RlbmVyID0gdW53cmFwKGVsLCB0eXBlLCBmbik7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIHJldHVybiBlbC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZhYnJpY2F0ZUV2ZW50IChlbCwgdHlwZSwgbW9kZWwpIHtcbiAgdmFyIGUgPSBldmVudG1hcC5pbmRleE9mKHR5cGUpID09PSAtMSA/IG1ha2VDdXN0b21FdmVudCgpIDogbWFrZUNsYXNzaWNFdmVudCgpO1xuICBpZiAoZWwuZGlzcGF0Y2hFdmVudCkge1xuICAgIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuZmlyZUV2ZW50KCdvbicgKyB0eXBlLCBlKTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlQ2xhc3NpY0V2ZW50ICgpIHtcbiAgICB2YXIgZTtcbiAgICBpZiAoZG9jLmNyZWF0ZUV2ZW50KSB7XG4gICAgICBlID0gZG9jLmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChkb2MuY3JlYXRlRXZlbnRPYmplY3QpIHtcbiAgICAgIGUgPSBkb2MuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZUN1c3RvbUV2ZW50ICgpIHtcbiAgICByZXR1cm4gbmV3IGN1c3RvbUV2ZW50KHR5cGUsIHsgZGV0YWlsOiBtb2RlbCB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cmFwcGVyRmFjdG9yeSAoZWwsIHR5cGUsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwcGVyIChvcmlnaW5hbEV2ZW50KSB7XG4gICAgdmFyIGUgPSBvcmlnaW5hbEV2ZW50IHx8IGdsb2JhbC5ldmVudDtcbiAgICBlLnRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICBlLnByZXZlbnREZWZhdWx0ID0gZS5wcmV2ZW50RGVmYXVsdCB8fCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCAoKSB7IGUucmV0dXJuVmFsdWUgPSBmYWxzZTsgfTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbiA9IGUuc3RvcFByb3BhZ2F0aW9uIHx8IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbiAoKSB7IGUuY2FuY2VsQnViYmxlID0gdHJ1ZTsgfTtcbiAgICBlLndoaWNoID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgZm4uY2FsbChlbCwgZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdyYXAgKGVsLCB0eXBlLCBmbikge1xuICB2YXIgd3JhcHBlciA9IHVud3JhcChlbCwgdHlwZSwgZm4pIHx8IHdyYXBwZXJGYWN0b3J5KGVsLCB0eXBlLCBmbik7XG4gIGhhcmRDYWNoZS5wdXNoKHtcbiAgICB3cmFwcGVyOiB3cmFwcGVyLFxuICAgIGVsZW1lbnQ6IGVsLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgZm46IGZuXG4gIH0pO1xuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZnVuY3Rpb24gdW53cmFwIChlbCwgdHlwZSwgZm4pIHtcbiAgdmFyIGkgPSBmaW5kKGVsLCB0eXBlLCBmbik7XG4gIGlmIChpKSB7XG4gICAgdmFyIHdyYXBwZXIgPSBoYXJkQ2FjaGVbaV0ud3JhcHBlcjtcbiAgICBoYXJkQ2FjaGUuc3BsaWNlKGksIDEpOyAvLyBmcmVlIHVwIGEgdGFkIG9mIG1lbW9yeVxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmQgKGVsLCB0eXBlLCBmbikge1xuICB2YXIgaSwgaXRlbTtcbiAgZm9yIChpID0gMDsgaSA8IGhhcmRDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgIGl0ZW0gPSBoYXJkQ2FjaGVbaV07XG4gICAgaWYgKGl0ZW0uZWxlbWVudCA9PT0gZWwgJiYgaXRlbS50eXBlID09PSB0eXBlICYmIGl0ZW0uZm4gPT09IGZuKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jcm9zc3ZlbnQvc3JjL2Nyb3NzdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar NativeCustomEvent = global.CustomEvent;\n\nfunction useNative () {\n  try {\n    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */\n\nmodule.exports = useNative() ? NativeCustomEvent :\n\n// IE >= 9\n'function' === typeof document.createEvent ? function CustomEvent (type, params) {\n  var e = document.createEvent('CustomEvent');\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// IE <= 8\nfunction CustomEvent (type, params) {\n  var e = document.createEventObject();\n  e.type = type;\n  if (params) {\n    e.bubbles = Boolean(params.bubbles);\n    e.cancelable = Boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2N1c3RvbS1ldmVudC9pbmRleC5qcz8wNDBkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVUsYUFBYSxFQUFFO0FBQ25FO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBOYXRpdmVDdXN0b21FdmVudCA9IGdsb2JhbC5DdXN0b21FdmVudDtcblxuZnVuY3Rpb24gdXNlTmF0aXZlICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcCA9IG5ldyBOYXRpdmVDdXN0b21FdmVudCgnY2F0JywgeyBkZXRhaWw6IHsgZm9vOiAnYmFyJyB9IH0pO1xuICAgIHJldHVybiAgJ2NhdCcgPT09IHAudHlwZSAmJiAnYmFyJyA9PT0gcC5kZXRhaWwuZm9vO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENyb3NzLWJyb3dzZXIgYEN1c3RvbUV2ZW50YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQuQ3VzdG9tRXZlbnRcbiAqXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1c2VOYXRpdmUoKSA/IE5hdGl2ZUN1c3RvbUV2ZW50IDpcblxuLy8gSUUgPj0gOVxuJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID8gZnVuY3Rpb24gQ3VzdG9tRXZlbnQgKHR5cGUsIHBhcmFtcykge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICBpZiAocGFyYW1zKSB7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgfSBlbHNlIHtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIHZvaWQgMCk7XG4gIH1cbiAgcmV0dXJuIGU7XG59IDpcblxuLy8gSUUgPD0gOFxuZnVuY3Rpb24gQ3VzdG9tRXZlbnQgKHR5cGUsIHBhcmFtcykge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG4gIGUudHlwZSA9IHR5cGU7XG4gIGlmIChwYXJhbXMpIHtcbiAgICBlLmJ1YmJsZXMgPSBCb29sZWFuKHBhcmFtcy5idWJibGVzKTtcbiAgICBlLmNhbmNlbGFibGUgPSBCb29sZWFuKHBhcmFtcy5jYW5jZWxhYmxlKTtcbiAgICBlLmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG4gIH0gZWxzZSB7XG4gICAgZS5idWJibGVzID0gZmFsc2U7XG4gICAgZS5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgZS5kZXRhaWwgPSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3VzdG9tLWV2ZW50L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nvar eventmap = [];\nvar eventname = '';\nvar ron = /^on/;\n\nfor (eventname in global) {\n  if (ron.test(eventname)) {\n    eventmap.push(eventname.slice(2));\n  }\n}\n\nmodule.exports = eventmap;\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nyb3NzdmVudC9zcmMvZXZlbnRtYXAuanM/OTM1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50bWFwID0gW107XG52YXIgZXZlbnRuYW1lID0gJyc7XG52YXIgcm9uID0gL15vbi87XG5cbmZvciAoZXZlbnRuYW1lIGluIGdsb2JhbCkge1xuICBpZiAocm9uLnRlc3QoZXZlbnRuYW1lKSkge1xuICAgIGV2ZW50bWFwLnB1c2goZXZlbnRuYW1lLnNsaWNlKDIpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV2ZW50bWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nyb3NzdmVudC9zcmMvZXZlbnRtYXAuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	eval("'use strict';\n\nvar cache = {};\nvar start = '(?:^|\\\\s)';\nvar end = '(?:\\\\s|$)';\n\nfunction lookupClass (className) {\n  var cached = cache[className];\n  if (cached) {\n    cached.lastIndex = 0;\n  } else {\n    cache[className] = cached = new RegExp(start + className + end, 'g');\n  }\n  return cached;\n}\n\nfunction addClass (el, className) {\n  var current = el.className;\n  if (!current.length) {\n    el.className = className;\n  } else if (!lookupClass(className).test(current)) {\n    el.className += ' ' + className;\n  }\n}\n\nfunction rmClass (el, className) {\n  el.className = el.className.replace(lookupClass(className), ' ').trim();\n}\n\nmodule.exports = {\n  add: addClass,\n  rm: rmClass\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2RyYWd1bGEvY2xhc3Nlcy5qcz9kZmQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FjaGUgPSB7fTtcbnZhciBzdGFydCA9ICcoPzpefFxcXFxzKSc7XG52YXIgZW5kID0gJyg/OlxcXFxzfCQpJztcblxuZnVuY3Rpb24gbG9va3VwQ2xhc3MgKGNsYXNzTmFtZSkge1xuICB2YXIgY2FjaGVkID0gY2FjaGVbY2xhc3NOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIGNhY2hlZC5sYXN0SW5kZXggPSAwO1xuICB9IGVsc2Uge1xuICAgIGNhY2hlW2NsYXNzTmFtZV0gPSBjYWNoZWQgPSBuZXcgUmVnRXhwKHN0YXJ0ICsgY2xhc3NOYW1lICsgZW5kLCAnZycpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xhc3NOYW1lKSB7XG4gIHZhciBjdXJyZW50ID0gZWwuY2xhc3NOYW1lO1xuICBpZiAoIWN1cnJlbnQubGVuZ3RoKSB7XG4gICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICB9IGVsc2UgaWYgKCFsb29rdXBDbGFzcyhjbGFzc05hbWUpLnRlc3QoY3VycmVudCkpIHtcbiAgICBlbC5jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NOYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJtQ2xhc3MgKGVsLCBjbGFzc05hbWUpIHtcbiAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobG9va3VwQ2xhc3MoY2xhc3NOYW1lKSwgJyAnKS50cmltKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGQ6IGFkZENsYXNzLFxuICBybTogcm1DbGFzc1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kcmFndWxhL2NsYXNzZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ContentElement = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Drake = __webpack_require__(10);\n\nvar _Drake2 = _interopRequireDefault(_Drake);\n\nvar _ImageEditor = __webpack_require__(24);\n\nvar _ImageEditor2 = _interopRequireDefault(_ImageEditor);\n\nvar _IconEditor = __webpack_require__(26);\n\nvar _IconEditor2 = _interopRequireDefault(_IconEditor);\n\nvar _EE = __webpack_require__(1);\n\nvar _EE2 = _interopRequireDefault(_EE);\n\nvar _twig = __webpack_require__(27);\n\nvar _isomorphicFetch = __webpack_require__(6);\n\nvar _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ContentElement = exports.ContentElement = function () {\n    function ContentElement(config, el, dzName) {\n        var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n        var _this = this;\n\n        var content = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        var settings = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n        _classCallCheck(this, ContentElement);\n\n        this.config = config;\n        this.el = el;\n        this.template = (0, _twig.twig)({ data: this.el.innerHTML });\n        this.id = parseInt(this.el.dataset.fredElementId);\n        this.wrapper = null;\n\n        this.render = this.render.bind(this);\n\n        this.parent = parent;\n        this.dzName = dzName;\n        this.options = JSON.parse(JSON.stringify(this.el.elementOptions || {}));\n        this.content = JSON.parse(JSON.stringify(content));\n        this.settings = {};\n\n        if (this.options.settings) {\n            this.options.settings.forEach(function (setting) {\n                if (setting.group && setting.settings) {\n                    setting.settings.forEach(function (subSetting) {\n                        _this.settings[subSetting.name] = subSetting.value || '';\n                    });\n                } else {\n                    _this.settings[setting.name] = setting.value || '';\n                }\n            });\n        }\n\n        this.settings = _extends({}, this.settings, JSON.parse(JSON.stringify(settings)));\n\n        this.dzs = {};\n\n        this.inEditor = false;\n    }\n\n    _createClass(ContentElement, [{\n        key: 'setEl',\n        value: function setEl(el) {\n            if (!el.innerHTML) {\n                this.el.innerHTML = el;\n            } else {\n                this.el.innerHTML = el.innerHTML;\n            }\n\n            this.template = (0, _twig.twig)({ data: this.el.innerHTML });\n        }\n    }, {\n        key: 'getContent',\n        value: function getContent() {\n            var _this2 = this;\n\n            var content = {\n                widget: this.id,\n                values: this.content,\n                settings: this.settings,\n                children: {}\n            };\n\n            var _loop = function _loop(dzName) {\n                if (_this2.dzs.hasOwnProperty(dzName)) {\n                    if (_this2.dzs[dzName].children.length > 0) {\n                        content.children[dzName] = [];\n\n                        _this2.dzs[dzName].children.forEach(function (child) {\n                            content.children[dzName].push(child.fredEl.getContent());\n                        });\n                    }\n                }\n            };\n\n            for (var dzName in this.dzs) {\n                _loop(dzName);\n            }\n\n            return content;\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var _this3 = this;\n\n            var wrapper = document.createElement('div');\n            wrapper.classList.add('fred--block');\n            wrapper.fredEl = this;\n\n            wrapper.addEventListener('mouseover', function (e) {\n                e.stopPropagation();\n\n                var firstSet = false;\n\n                if (e.path) {\n                    e.path.forEach(function (el) {\n                        if (el.classList && el.classList.contains('fred--block')) {\n                            el.classList.add('fred--block-active');\n\n                            if (firstSet === true) {\n                                el.classList.add('fred--block-active_parent');\n                            }\n\n                            firstSet = true;\n                        }\n                    });\n                } else {\n                    var el = e.target.parentNode;\n                    while (el) {\n                        if (el.classList && el.classList.contains('fred--block')) {\n                            el.classList.add('fred--block-active');\n\n                            if (firstSet === true) {\n                                el.classList.add('fred--block-active_parent');\n                            }\n\n                            firstSet = true;\n                        }\n\n                        el = el.parentNode;\n                    }\n                }\n            });\n\n            wrapper.addEventListener('mouseout', function (e) {\n                if (_this3.inEditor === false) {\n                    wrapper.classList.remove('fred--block-active');\n                    wrapper.classList.remove('fred--block-active_parent');\n                }\n            });\n\n            var toolbar = document.createElement('div');\n            toolbar.classList.add('fred--toolbar', 'handle');\n\n            var moveHandle = document.createElement('div');\n            moveHandle.classList.add('fred--toolbar-grip');\n\n            toolbar.appendChild(moveHandle);\n\n            var duplicate = document.createElement('button');\n            duplicate.classList.add('fred--duplicate-icon');\n            duplicate.addEventListener('click', function (e) {\n                e.preventDefault();\n                _this3.duplicate();\n            });\n\n            var trashHandle = document.createElement('button');\n            trashHandle.classList.add('fred--trash');\n            trashHandle.addEventListener('click', function (e) {\n                e.preventDefault();\n                _this3.remove();\n            });\n\n            if (this.options.settings) {\n                var settings = document.createElement('button');\n                settings.classList.add('fred--element-settings');\n                settings.addEventListener('click', function (e) {\n                    e.preventDefault();\n                    _this3.openSettings();\n                });\n\n                toolbar.appendChild(settings);\n            }\n\n            toolbar.appendChild(duplicate);\n            toolbar.appendChild(trashHandle);\n\n            wrapper.appendChild(toolbar);\n\n            var content = document.createElement('div');\n            content.classList.add('fred--block_content');\n            content.dataset.fredElementId = this.el.dataset.fredElementId;\n\n            return this.templateRender().then(function (html) {\n                content.innerHTML = html;\n                _this3.initDropZones(wrapper, content);\n                _this3.initElements(wrapper, content);\n\n                wrapper.appendChild(content);\n\n                if (_this3.wrapper !== null) {\n                    _this3.wrapper.replaceWith(wrapper);\n                }\n\n                _this3.wrapper = wrapper;\n\n                return wrapper;\n            });\n        }\n    }, {\n        key: 'initDropZones',\n        value: function initDropZones(wrapper, content) {\n            var _this4 = this;\n\n            var dzs = content.querySelectorAll('[data-fred-dropzone]');\n\n            var prev = null;\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                var _loop2 = function _loop2() {\n                    var dz = _step.value;\n\n                    if (prev === null) {\n                        prev = dz;\n                        dz.fredEl = _this4;\n                        if (!_this4.dzs[dz.dataset.fredDropzone]) {\n                            _this4.dzs[dz.dataset.fredDropzone] = {\n                                el: dz,\n                                children: []\n                            };\n                        } else {\n                            _this4.dzs[dz.dataset.fredDropzone].el = dz;\n                            _this4.dzs[dz.dataset.fredDropzone].children.forEach(function (child) {\n                                _this4.dzs[dz.dataset.fredDropzone].el.appendChild(child);\n                            });\n                        }\n                    } else {\n                        if (!prev.contains(dz)) {\n                            dz.fredEl = _this4;\n                            prev = dz;\n                            if (!_this4.dzs[dz.dataset.fredDropzone]) {\n                                _this4.dzs[dz.dataset.fredDropzone] = {\n                                    el: dz,\n                                    children: []\n                                };\n                            } else {\n                                _this4.dzs[dz.dataset.fredDropzone].el = dz;\n                                _this4.dzs[dz.dataset.fredDropzone].children.forEach(function (child) {\n                                    _this4.dzs[dz.dataset.fredDropzone].el.appendChild(child);\n                                });\n                            }\n                        }\n                    }\n                };\n\n                for (var _iterator = dzs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    _loop2();\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'initElements',\n        value: function initElements(wrapper, content) {\n            var _this5 = this;\n\n            var fredElements = content.querySelectorAll('[data-fred-name]');\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                var _loop3 = function _loop3() {\n                    var el = _step2.value;\n\n                    el.fredEl = _this5;\n\n                    var observer = new MutationObserver(function (mutations) {\n                        mutations.forEach(function (mutation) {\n                            if (mutation.type === 'characterData' && !el.rte) {\n                                if (!_this5.content[el.dataset.fredName]) _this5.content[el.dataset.fredName] = {};\n                                if (!_this5.content[el.dataset.fredName]._raw) _this5.content[el.dataset.fredName]._raw = {};\n\n                                _this5.content[el.dataset.fredName]._raw._value = el.innerHTML;\n\n                                if (el.dataset.fredTarget) {\n                                    _EE2.default.emit('fred-page-setting-change', el.dataset.fredTarget, _this5.content[el.dataset.fredName]._raw._value, el);\n                                }\n\n                                return;\n                            }\n\n                            if (mutation.type === 'attributes') {\n                                if (el.nodeName.toLowerCase() === 'img' && mutation.attributeName === 'src') {\n                                    if (!_this5.content[el.dataset.fredName]) _this5.content[el.dataset.fredName] = {};\n                                    if (!_this5.content[el.dataset.fredName]._raw) _this5.content[el.dataset.fredName]._raw = {};\n\n                                    _this5.content[el.dataset.fredName]._raw._value = el.getAttribute(mutation.attributeName);\n\n                                    if (el.dataset.fredTarget) {\n                                        _EE2.default.emit('fred-page-setting-change', el.dataset.fredTarget, _this5.content[el.dataset.fredName]._raw._value, el);\n                                    }\n\n                                    return;\n                                }\n\n                                if (el.nodeName.toLowerCase() === 'i' && mutation.attributeName === 'class') {\n                                    if (!_this5.content[el.dataset.fredName]) _this5.content[el.dataset.fredName] = {};\n                                    if (!_this5.content[el.dataset.fredName]._raw) _this5.content[el.dataset.fredName]._raw = {};\n\n                                    _this5.content[el.dataset.fredName]._raw._value = el.className;\n\n                                    if (el.dataset.fredTarget) {\n                                        _EE2.default.emit('fred-page-setting-change', el.dataset.fredTarget, _this5.content[el.dataset.fredName]._raw._value, el);\n                                    }\n\n                                    return;\n                                }\n\n                                if (el.dataset.fredAttrs) {\n                                    var attrs = el.dataset.fredAttrs.split(',');\n                                    if (attrs.indexOf(mutation.attributeName) === -1) return;\n\n                                    if (!_this5.content[el.dataset.fredName]) _this5.content[el.dataset.fredName] = {};\n                                    if (!_this5.content[el.dataset.fredName]._raw) _this5.content[el.dataset.fredName]._raw = {};\n\n                                    _this5.content[el.dataset.fredName]._raw[mutation.attributeName] = el.getAttribute(mutation.attributeName);\n                                }\n                            }\n                        });\n                    });\n\n                    observer.observe(el, {\n                        attributes: true,\n                        characterData: true,\n                        subtree: true\n                    });\n\n                    if (el.dataset.fredRte === 'true') {\n                        // I hate this fix; tinemce throws an error on first drop from dragule\n                        setTimeout(function () {\n                            tinymce.init({\n                                target: el,\n                                theme: 'inlite',\n                                inline: true,\n                                plugins: 'modxlink',\n                                insert_toolbar: \"quickimage quicktable modxlink\",\n                                selection_toolbar: 'bold italic | h2 h3 blockquote modxlink',\n                                auto_focus: false,\n                                branding: false,\n                                setup: function setup(editor) {\n                                    el.rte = editor;\n\n                                    editor.on('change', function (e) {\n                                        if (!_this5.content[el.dataset.fredName]) _this5.content[el.dataset.fredName] = {};\n                                        if (!_this5.content[el.dataset.fredName]._raw) _this5.content[el.dataset.fredName]._raw = {};\n\n                                        _this5.content[el.dataset.fredName]._raw._value = editor.getContent();\n\n                                        if (el.dataset.fredTarget) {\n                                            _EE2.default.emit('fred-page-setting-change', el.dataset.fredTarget, _this5.content[el.dataset.fredName]._raw._value, el);\n                                        }\n                                    });\n\n                                    editor.on('focus', function (e) {\n                                        _this5.inEditor = true;\n                                    });\n\n                                    editor.on('blur', function (e) {\n                                        _this5.inEditor = false;\n                                        wrapper.classList.remove('fred--block-active');\n                                        wrapper.classList.remove('fred--block-active_parent');\n                                    });\n                                }\n                            });\n                        }, 1);\n                    }\n\n                    if (!_this5.content[el.dataset.fredName]) _this5.content[el.dataset.fredName] = {};\n                    if (!_this5.content[el.dataset.fredName]._raw) _this5.content[el.dataset.fredName]._raw = {};\n\n                    if (el.dataset.fredTarget) {\n                        if (_this5.config.pageSettings[el.dataset.fredTarget]) {\n                            _this5.content[el.dataset.fredName]._raw._value = _this5.config.pageSettings[el.dataset.fredTarget];\n                        }\n                    }\n\n                    if (_this5.content[el.dataset.fredName]._raw._value) {\n                        switch (el.nodeName.toLowerCase()) {\n                            case 'i':\n                                el.className = _this5.content[el.dataset.fredName]._raw._value;\n\n                                el.addEventListener('click', function (e) {\n                                    e.preventDefault();\n                                    _IconEditor2.default.edit(el);\n                                });\n                                break;\n                            case 'img':\n                                el.setAttribute('src', _this5.content[el.dataset.fredName]._raw._value);\n\n                                el.addEventListener('click', function (e) {\n                                    e.preventDefault();\n                                    _ImageEditor2.default.edit(el);\n                                });\n\n                                break;\n                            default:\n                                el.innerHTML = _this5.content[el.dataset.fredName]._raw._value;\n                        }\n\n                        if (el.dataset.fredAttrs) {\n                            var attrs = el.dataset.fredAttrs.split(',');\n                            attrs.forEach(function (attr) {\n                                if (_this5.content[el.dataset.fredName]._raw[attr]) {\n                                    el.setAttribute(attr, _this5.content[el.dataset.fredName]._raw[attr]);\n                                }\n                            });\n                        }\n                    } else {\n                        switch (el.nodeName.toLowerCase()) {\n                            case 'i':\n                                _this5.content[el.dataset.fredName]._raw._value = el.className;\n\n                                el.addEventListener('click', function (e) {\n                                    e.preventDefault();\n                                    _IconEditor2.default.edit(el);\n                                });\n                                break;\n                            case 'img':\n                                _this5.content[el.dataset.fredName]._raw._value = el.getAttribute('src');\n\n                                el.addEventListener('click', function (e) {\n                                    e.preventDefault();\n                                    _ImageEditor2.default.edit(el);\n                                });\n\n                                break;\n                            default:\n                                _this5.content[el.dataset.fredName]._raw._value = el.innerHTML;\n                        }\n\n                        if (el.dataset.fredAttrs) {\n                            var _attrs = el.dataset.fredAttrs.split(',');\n                            _attrs.forEach(function (attr) {\n                                if (_this5.content[el.dataset.fredName]._raw[attr]) {\n                                    _this5.content[el.dataset.fredName]._raw[attr] = el.getAttribute(attr);\n                                }\n                            });\n                        }\n                    }\n                };\n\n                for (var _iterator2 = fredElements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    _loop3();\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'setElValue',\n        value: function setElValue(el, value) {\n            if (!this.content[el.dataset.fredName]) this.content[el.dataset.fredName] = {};\n            if (!this.content[el.dataset.fredName]._raw) this.content[el.dataset.fredName]._raw = {};\n\n            switch (el.nodeName.toLowerCase()) {\n                case 'i':\n                    this.content[el.dataset.fredName]._raw._value = value;\n                    el.className = value;\n                    break;\n                case 'img':\n                    this.content[el.dataset.fredName]._raw._value = value;\n                    el.setAttribute('src', value);\n                    break;\n                default:\n                    this.content[el.dataset.fredName]._raw._value = value;\n                    el.innerHTML = value;\n            }\n        }\n    }, {\n        key: 'templateRender',\n        value: function templateRender() {\n            var parseModx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            if (this.options.remote === true) {\n                return this.remoteTemplateRender(parseModx);\n            }\n\n            return Promise.resolve(this.localTemplateRender());\n        }\n    }, {\n        key: 'localTemplateRender',\n        value: function localTemplateRender() {\n            return this.template.render(this.settings);\n        }\n    }, {\n        key: 'remoteTemplateRender',\n        value: function remoteTemplateRender() {\n            var _this6 = this;\n\n            var parseModx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            return (0, _isomorphicFetch2.default)(this.config.assetsUrl + 'endpoints/ajax.php?action=render-element', {\n                method: \"post\",\n                credentials: 'same-origin',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    resource: this.config.resource.id,\n                    parseModx: parseModx,\n                    element: this.id,\n                    settings: this.settings\n                })\n            }).then(function (response) {\n                if (response.status > 299) {\n                    return response.json().then(function (data) {\n                        throw new Error(data.message);\n                    });\n                }\n\n                return response.json();\n            }).then(function (json) {\n                _this6.setEl(json.data.html);\n                return json.data.html;\n            }).catch(function (err) {\n                console.log(err);\n                _EE2.default.emit('fred-loading', err.message);\n                return '';\n            });\n        }\n    }, {\n        key: 'cleanRender',\n        value: function cleanRender() {\n            var _this7 = this;\n\n            var element = document.createElement('div');\n            return this.templateRender(false).then(function (html) {\n                element.innerHTML = html;\n\n                var noRenderElements = element.querySelectorAll('[data-fred-render=\"false\"]');\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = noRenderElements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var noRenderElement = _step3.value;\n\n                        noRenderElement.remove();\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n\n                var fredElements = element.querySelectorAll('[data-fred-name]');\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n\n                try {\n                    var _loop4 = function _loop4() {\n                        var el = _step4.value;\n\n                        if (_this7.content[el.dataset.fredName] && _this7.content[el.dataset.fredName]._raw && _this7.content[el.dataset.fredName]._raw._value) {\n                            switch (el.nodeName.toLowerCase()) {\n                                case 'i':\n                                    el.className = _this7.content[el.dataset.fredName]._raw._value;\n                                    break;\n                                case 'img':\n                                    el.setAttribute('src', _this7.content[el.dataset.fredName]._raw._value);\n                                    break;\n                                default:\n                                    el.innerHTML = _this7.content[el.dataset.fredName]._raw._value;\n                            }\n\n                            if (el.dataset.fredAttrs) {\n                                var attrs = el.dataset.fredAttrs.split(',');\n                                attrs.forEach(function (attr) {\n                                    if (_this7.content[el.dataset.fredName]._raw[attr]) {\n                                        el.setAttribute(attr, _this7.content[el.dataset.fredName]._raw[attr]);\n                                    }\n                                });\n                            }\n                        }\n\n                        el.removeAttribute('contenteditable');\n                        el.removeAttribute('data-fred-name');\n                        el.removeAttribute('data-fred-rte');\n                        el.removeAttribute('data-fred-target');\n                        el.removeAttribute('data-fred-attrs');\n                    };\n\n                    for (var _iterator4 = fredElements[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                        _loop4();\n                    }\n                } catch (err) {\n                    _didIteratorError4 = true;\n                    _iteratorError4 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                            _iterator4.return();\n                        }\n                    } finally {\n                        if (_didIteratorError4) {\n                            throw _iteratorError4;\n                        }\n                    }\n                }\n\n                var fredLinks = element.querySelectorAll('[data-fred-link-page]');\n                var _iteratorNormalCompletion5 = true;\n                var _didIteratorError5 = false;\n                var _iteratorError5 = undefined;\n\n                try {\n                    for (var _iterator5 = fredLinks[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                        var fredLink = _step5.value;\n\n                        var resourceId = parseInt(fredLink.dataset.fredLinkPage);\n                        var anchor = fredLink.dataset.fredLinkAnchor ? '#' + fredLink.dataset.fredLinkAnchor : '#';\n                        if (resourceId > 0) {\n                            fredLink.setAttribute('href', '[[~' + resourceId + ']]' + anchor);\n                        } else {\n                            fredLink.setAttribute('href', anchor);\n                        }\n\n                        fredLink.removeAttribute('data-fred-link-page');\n                        fredLink.removeAttribute('data-fred-link-anchor');\n                    }\n                } catch (err) {\n                    _didIteratorError5 = true;\n                    _iteratorError5 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                            _iterator5.return();\n                        }\n                    } finally {\n                        if (_didIteratorError5) {\n                            throw _iteratorError5;\n                        }\n                    }\n                }\n\n                var fredAnchors = element.querySelectorAll('[data-fred-link-anchor]');\n                var _iteratorNormalCompletion6 = true;\n                var _didIteratorError6 = false;\n                var _iteratorError6 = undefined;\n\n                try {\n                    for (var _iterator6 = fredAnchors[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                        var fredAnchor = _step6.value;\n\n                        fredAnchor.setAttribute('href', '#' + fredAnchor.dataset.fredLinkAnchor);\n                        fredAnchor.removeAttribute('data-fred-link-anchor');\n                    }\n                } catch (err) {\n                    _didIteratorError6 = true;\n                    _iteratorError6 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                            _iterator6.return();\n                        }\n                    } finally {\n                        if (_didIteratorError6) {\n                            throw _iteratorError6;\n                        }\n                    }\n                }\n\n                for (var dzName in _this7.dzs) {\n                    if (_this7.dzs.hasOwnProperty(dzName)) {\n                        var dzEl = element.querySelector('[data-fred-dropzone=\"' + dzName + '\"]');\n                        if (dzEl) {\n                            dzEl.removeAttribute('data-fred-dropzone');\n\n                            if (_this7.dzs[dzName].children.length > 0) {\n\n                                var cleanedDropZoneContent = '';\n\n                                _this7.dzs[dzName].children.forEach(function (child) {\n                                    cleanedDropZoneContent += child.fredEl.cleanRender().innerHTML;\n                                });\n\n                                dzEl.innerHTML = cleanedDropZoneContent;\n                            }\n                        }\n                    }\n                }\n\n                return element;\n            });\n        }\n    }, {\n        key: 'remove',\n        value: function remove() {\n            if (this.parent) {\n                var index = this.parent.dzs[this.dzName].children.indexOf(this.wrapper);\n                if (index > -1) {\n                    this.parent.dzs[this.dzName].children.splice(index, 1);\n                }\n            }\n\n            this.wrapper.remove();\n        }\n    }, {\n        key: 'duplicateDropZones',\n        value: function duplicateDropZones(dzs) {\n            var _this8 = this;\n\n            var _loop5 = function _loop5(dzName) {\n                if (dzs.hasOwnProperty(dzName)) {\n                    dzs[dzName].children.forEach(function (child) {\n                        if (_this8.dzs[dzName]) {\n                            var clonedChild = new ContentElement(_this8.config, child.fredEl.el, dzName, _this8, child.fredEl.content, child.fredEl.settings);\n                            clonedChild.render().then(function () {\n                                _this8.addElementToDropZone(dzName, clonedChild);\n\n                                clonedChild.duplicateDropZones(child.fredEl.dzs);\n                            });\n                        }\n                    });\n                }\n            };\n\n            for (var dzName in dzs) {\n                _loop5(dzName);\n            }\n        }\n    }, {\n        key: 'duplicate',\n        value: function duplicate() {\n            var _this9 = this;\n\n            var clone = new ContentElement(this.config, this.el, this.dzName, this.parent, this.content, this.settings);\n            clone.render().then(function () {\n                clone.duplicateDropZones(_this9.dzs);\n\n                if (_this9.wrapper.nextSibling === null) {\n                    _this9.wrapper.parentNode.appendChild(clone.wrapper);\n                } else {\n                    _this9.wrapper.parentNode.insertBefore(clone.wrapper, _this9.wrapper.nextSibling);\n                }\n\n                if (_this9.parent) {\n                    var index = _this9.parent.dzs[_this9.dzName].children.indexOf(_this9.wrapper);\n                    if (index > -1) {\n                        _this9.parent.dzs[_this9.dzName].children.splice(index + 1, 0, clone.wrapper);\n                    }\n                }\n\n                _Drake2.default.reloadContainers();\n            });\n        }\n    }, {\n        key: 'openSettings',\n        value: function openSettings() {\n            _EE2.default.emit('fred-element-settings-open', this);\n        }\n    }, {\n        key: 'addElementToDropZone',\n        value: function addElementToDropZone(zoneName, element) {\n            if (!this.dzs[zoneName]) return false;\n\n            this.dzs[zoneName].children.push(element.wrapper);\n            this.dzs[zoneName].el.appendChild(element.wrapper);\n\n            return true;\n        }\n    }]);\n\n    return ContentElement;\n}();\n\nexports.default = ContentElement;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0NvbXBvbmVudHMvU2lkZWJhci9FbGVtZW50cy9Db250ZW50RWxlbWVudC5qcz83MzlhIl0sIm5hbWVzIjpbIkNvbnRlbnRFbGVtZW50IiwiY29uZmlnIiwiZWwiLCJkek5hbWUiLCJwYXJlbnQiLCJjb250ZW50Iiwic2V0dGluZ3MiLCJ0ZW1wbGF0ZSIsImRhdGEiLCJpbm5lckhUTUwiLCJpZCIsInBhcnNlSW50IiwiZGF0YXNldCIsImZyZWRFbGVtZW50SWQiLCJ3cmFwcGVyIiwicmVuZGVyIiwiYmluZCIsIm9wdGlvbnMiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJlbGVtZW50T3B0aW9ucyIsImZvckVhY2giLCJzZXR0aW5nIiwiZ3JvdXAiLCJzdWJTZXR0aW5nIiwibmFtZSIsInZhbHVlIiwiZHpzIiwiaW5FZGl0b3IiLCJ3aWRnZXQiLCJ2YWx1ZXMiLCJjaGlsZHJlbiIsImhhc093blByb3BlcnR5IiwibGVuZ3RoIiwicHVzaCIsImNoaWxkIiwiZnJlZEVsIiwiZ2V0Q29udGVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwic3RvcFByb3BhZ2F0aW9uIiwiZmlyc3RTZXQiLCJwYXRoIiwiY29udGFpbnMiLCJ0YXJnZXQiLCJwYXJlbnROb2RlIiwicmVtb3ZlIiwidG9vbGJhciIsIm1vdmVIYW5kbGUiLCJhcHBlbmRDaGlsZCIsImR1cGxpY2F0ZSIsInByZXZlbnREZWZhdWx0IiwidHJhc2hIYW5kbGUiLCJvcGVuU2V0dGluZ3MiLCJ0ZW1wbGF0ZVJlbmRlciIsInRoZW4iLCJodG1sIiwiaW5pdERyb3Bab25lcyIsImluaXRFbGVtZW50cyIsInJlcGxhY2VXaXRoIiwicXVlcnlTZWxlY3RvckFsbCIsInByZXYiLCJkeiIsImZyZWREcm9wem9uZSIsImZyZWRFbGVtZW50cyIsIm9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9ucyIsIm11dGF0aW9uIiwidHlwZSIsInJ0ZSIsImZyZWROYW1lIiwiX3JhdyIsIl92YWx1ZSIsImZyZWRUYXJnZXQiLCJlbWl0Iiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImF0dHJpYnV0ZU5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJjbGFzc05hbWUiLCJmcmVkQXR0cnMiLCJhdHRycyIsInNwbGl0IiwiaW5kZXhPZiIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwiY2hhcmFjdGVyRGF0YSIsInN1YnRyZWUiLCJmcmVkUnRlIiwic2V0VGltZW91dCIsInRpbnltY2UiLCJpbml0IiwidGhlbWUiLCJpbmxpbmUiLCJwbHVnaW5zIiwiaW5zZXJ0X3Rvb2xiYXIiLCJzZWxlY3Rpb25fdG9vbGJhciIsImF1dG9fZm9jdXMiLCJicmFuZGluZyIsInNldHVwIiwiZWRpdG9yIiwib24iLCJwYWdlU2V0dGluZ3MiLCJlZGl0Iiwic2V0QXR0cmlidXRlIiwiYXR0ciIsInBhcnNlTW9keCIsInJlbW90ZSIsInJlbW90ZVRlbXBsYXRlUmVuZGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2NhbFRlbXBsYXRlUmVuZGVyIiwiYXNzZXRzVXJsIiwibWV0aG9kIiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYm9keSIsInJlc291cmNlIiwiZWxlbWVudCIsInJlc3BvbnNlIiwic3RhdHVzIiwianNvbiIsIkVycm9yIiwibWVzc2FnZSIsInNldEVsIiwiY2F0Y2giLCJjb25zb2xlIiwibG9nIiwiZXJyIiwibm9SZW5kZXJFbGVtZW50cyIsIm5vUmVuZGVyRWxlbWVudCIsInJlbW92ZUF0dHJpYnV0ZSIsImZyZWRMaW5rcyIsImZyZWRMaW5rIiwicmVzb3VyY2VJZCIsImZyZWRMaW5rUGFnZSIsImFuY2hvciIsImZyZWRMaW5rQW5jaG9yIiwiZnJlZEFuY2hvcnMiLCJmcmVkQW5jaG9yIiwiZHpFbCIsInF1ZXJ5U2VsZWN0b3IiLCJjbGVhbmVkRHJvcFpvbmVDb250ZW50IiwiY2xlYW5SZW5kZXIiLCJpbmRleCIsInNwbGljZSIsImNsb25lZENoaWxkIiwiYWRkRWxlbWVudFRvRHJvcFpvbmUiLCJkdXBsaWNhdGVEcm9wWm9uZXMiLCJjbG9uZSIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwicmVsb2FkQ29udGFpbmVycyIsInpvbmVOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0lBRWFBLGMsV0FBQUEsYztBQUNULDRCQUFZQyxNQUFaLEVBQW9CQyxFQUFwQixFQUF3QkMsTUFBeEIsRUFBNEU7QUFBQSxZQUE1Q0MsTUFBNEMsdUVBQW5DLElBQW1DOztBQUFBOztBQUFBLFlBQTdCQyxPQUE2Qix1RUFBbkIsRUFBbUI7QUFBQSxZQUFmQyxRQUFlLHVFQUFKLEVBQUk7O0FBQUE7O0FBQ3hFLGFBQUtMLE1BQUwsR0FBY0EsTUFBZDtBQUNBLGFBQUtDLEVBQUwsR0FBVUEsRUFBVjtBQUNBLGFBQUtLLFFBQUwsR0FBZ0IsZ0JBQUssRUFBQ0MsTUFBTSxLQUFLTixFQUFMLENBQVFPLFNBQWYsRUFBTCxDQUFoQjtBQUNBLGFBQUtDLEVBQUwsR0FBVUMsU0FBUyxLQUFLVCxFQUFMLENBQVFVLE9BQVIsQ0FBZ0JDLGFBQXpCLENBQVY7QUFDQSxhQUFLQyxPQUFMLEdBQWUsSUFBZjs7QUFFQSxhQUFLQyxNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZQyxJQUFaLENBQWlCLElBQWpCLENBQWQ7O0FBRUEsYUFBS1osTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBS0QsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBS2MsT0FBTCxHQUFlQyxLQUFLQyxLQUFMLENBQVdELEtBQUtFLFNBQUwsQ0FBZ0IsS0FBS2xCLEVBQUwsQ0FBUW1CLGNBQVIsSUFBMEIsRUFBMUMsQ0FBWCxDQUFmO0FBQ0EsYUFBS2hCLE9BQUwsR0FBZWEsS0FBS0MsS0FBTCxDQUFXRCxLQUFLRSxTQUFMLENBQWVmLE9BQWYsQ0FBWCxDQUFm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RSxPQUFuRCxDQUFkO0FBQ0Esd0JBQUl3SSxRQUFRLENBQUMsQ0FBYixFQUFnQjtBQUNaLCtCQUFLbEosTUFBTCxDQUFZd0IsR0FBWixDQUFnQixPQUFLekIsTUFBckIsRUFBNkI2QixRQUE3QixDQUFzQ3VILE1BQXRDLENBQTZDRCxRQUFRLENBQXJELEVBQXdELENBQXhELEVBQTJESyxNQUFNN0ksT0FBakU7QUFDSDtBQUNKOztBQUVELGdDQUFNZ0osZ0JBQU47QUFDSCxhQWpCRDtBQWtCSDs7O3VDQUVjO0FBQ1gseUJBQVE5RSxJQUFSLENBQWEsNEJBQWIsRUFBMkMsSUFBM0M7QUFDSDs7OzZDQUVvQitFLFEsRUFBVW5DLE8sRUFBUztBQUNwQyxnQkFBSSxDQUFDLEtBQUtoRyxHQUFMLENBQVNtSSxRQUFULENBQUwsRUFBeUIsT0FBTyxLQUFQOztBQUV6QixpQkFBS25JLEdBQUwsQ0FBU21JLFFBQVQsRUFBbUIvSCxRQUFuQixDQUE0QkcsSUFBNUIsQ0FBaUN5RixRQUFROUcsT0FBekM7QUFDQSxpQkFBS2MsR0FBTCxDQUFTbUksUUFBVCxFQUFtQjdKLEVBQW5CLENBQXNCb0QsV0FBdEIsQ0FBa0NzRSxRQUFROUcsT0FBMUM7O0FBRUEsbUJBQU8sSUFBUDtBQUNIOzs7Ozs7a0JBR1VkLGMiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZHJha2UgZnJvbSAnLi4vLi4vLi4vRHJha2UnO1xuaW1wb3J0IGltYWdlRWRpdG9yIGZyb20gJy4uLy4uLy4uL0VkaXRvcnMvSW1hZ2VFZGl0b3InO1xuaW1wb3J0IGljb25FZGl0b3IgZnJvbSAnLi4vLi4vLi4vRWRpdG9ycy9JY29uRWRpdG9yJztcbmltcG9ydCBlbWl0dGVyIGZyb20gJy4uLy4uLy4uL0VFJztcbmltcG9ydCB7IHR3aWcgfSBmcm9tICd0d2lnJztcbmltcG9ydCBmZXRjaCBmcm9tIFwiaXNvbW9ycGhpYy1mZXRjaFwiO1xuXG5leHBvcnQgY2xhc3MgQ29udGVudEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgZWwsIGR6TmFtZSwgcGFyZW50ID0gbnVsbCwgY29udGVudCA9IHt9LCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0d2lnKHtkYXRhOiB0aGlzLmVsLmlubmVySFRNTH0pO1xuICAgICAgICB0aGlzLmlkID0gcGFyc2VJbnQodGhpcy5lbC5kYXRhc2V0LmZyZWRFbGVtZW50SWQpO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5kek5hbWUgPSBkek5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoKHRoaXMuZWwuZWxlbWVudE9wdGlvbnMgfHwge30pKSk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29udGVudCkpO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNldHRpbmdzLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcuZ3JvdXAgJiYgc2V0dGluZy5zZXR0aW5ncykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdzLmZvckVhY2goc3ViU2V0dGluZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzW3N1YlNldHRpbmcubmFtZV0gPSBzdWJTZXR0aW5nLnZhbHVlIHx8ICcnOyAgICBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1tzZXR0aW5nLm5hbWVdID0gc2V0dGluZy52YWx1ZSB8fCAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAuLi4odGhpcy5zZXR0aW5ncyksXG4gICAgICAgICAgICAuLi5KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmR6cyA9IHt9O1xuXG4gICAgICAgIHRoaXMuaW5FZGl0b3IgPSBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgc2V0RWwoZWwpIHtcbiAgICAgICAgaWYgKCFlbC5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9IGVsLmlubmVySFRNTDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHR3aWcoe2RhdGE6IHRoaXMuZWwuaW5uZXJIVE1MfSk7XG4gICAgfVxuXG4gICAgZ2V0Q29udGVudCgpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHtcbiAgICAgICAgICAgIHdpZGdldDogdGhpcy5pZCxcbiAgICAgICAgICAgIHZhbHVlczogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICBjaGlsZHJlbjoge31cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBkek5hbWUgaW4gdGhpcy5kenMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR6cy5oYXNPd25Qcm9wZXJ0eShkek5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHpzW2R6TmFtZV0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LmNoaWxkcmVuW2R6TmFtZV0gPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmR6c1tkek5hbWVdLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5jaGlsZHJlbltkek5hbWVdLnB1c2goY2hpbGQuZnJlZEVsLmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLWJsb2NrJyk7XG4gICAgICAgIHdyYXBwZXIuZnJlZEVsID0gdGhpcztcblxuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGUgPT4ge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgbGV0IGZpcnN0U2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBlLnBhdGguZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmcmVkLS1ibG9jaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmcmVkLS1ibG9jay1hY3RpdmUnKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLWJsb2NrLWFjdGl2ZV9wYXJlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0U2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZWwgPSBlLnRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHdoaWxlKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmcmVkLS1ibG9jaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmcmVkLS1ibG9jay1hY3RpdmUnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0U2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZnJlZC0tYmxvY2stYWN0aXZlX3BhcmVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBlID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluRWRpdG9yID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnZnJlZC0tYmxvY2stYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdmcmVkLS1ibG9jay1hY3RpdmVfcGFyZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9vbGJhci5jbGFzc0xpc3QuYWRkKCdmcmVkLS10b29sYmFyJywgJ2hhbmRsZScpO1xuXG4gICAgICAgIGNvbnN0IG1vdmVIYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbW92ZUhhbmRsZS5jbGFzc0xpc3QuYWRkKCdmcmVkLS10b29sYmFyLWdyaXAnKTtcblxuICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKG1vdmVIYW5kbGUpO1xuXG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBkdXBsaWNhdGUuY2xhc3NMaXN0LmFkZCgnZnJlZC0tZHVwbGljYXRlLWljb24nKTtcbiAgICAgICAgZHVwbGljYXRlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmR1cGxpY2F0ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0cmFzaEhhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICB0cmFzaEhhbmRsZS5jbGFzc0xpc3QuYWRkKCdmcmVkLS10cmFzaCcpO1xuICAgICAgICB0cmFzaEhhbmRsZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXR0aW5ncykge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIHNldHRpbmdzLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLWVsZW1lbnQtc2V0dGluZ3MnKTtcbiAgICAgICAgICAgIHNldHRpbmdzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlblNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZChzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBcbiAgICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZChkdXBsaWNhdGUpO1xuICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKHRyYXNoSGFuZGxlKTtcblxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRvb2xiYXIpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdmcmVkLS1ibG9ja19jb250ZW50Jyk7XG4gICAgICAgIGNvbnRlbnQuZGF0YXNldC5mcmVkRWxlbWVudElkID0gdGhpcy5lbC5kYXRhc2V0LmZyZWRFbGVtZW50SWQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVSZW5kZXIoKS50aGVuKGh0bWwgPT4ge1xuICAgICAgICAgICAgY29udGVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgdGhpcy5pbml0RHJvcFpvbmVzKHdyYXBwZXIsIGNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5pbml0RWxlbWVudHMod3JhcHBlcixjb250ZW50KTtcblxuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMud3JhcHBlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5yZXBsYWNlV2l0aCh3cmFwcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgaW5pdERyb3Bab25lcyh3cmFwcGVyLCBjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGR6cyA9IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZnJlZC1kcm9wem9uZV0nKTtcblxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG5cbiAgICAgICAgZm9yIChsZXQgZHogb2YgZHpzKSB7XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBkejtcbiAgICAgICAgICAgICAgICBkei5mcmVkRWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kenNbZHouZGF0YXNldC5mcmVkRHJvcHpvbmVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHpzW2R6LmRhdGFzZXQuZnJlZERyb3B6b25lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBkeixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHpzW2R6LmRhdGFzZXQuZnJlZERyb3B6b25lXS5lbCA9IGR6O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmR6c1tkei5kYXRhc2V0LmZyZWREcm9wem9uZV0uY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmR6c1tkei5kYXRhc2V0LmZyZWREcm9wem9uZV0uZWwuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghcHJldi5jb250YWlucyhkeikpIHtcbiAgICAgICAgICAgICAgICAgICAgZHouZnJlZEVsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IGR6O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZHpzW2R6LmRhdGFzZXQuZnJlZERyb3B6b25lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kenNbZHouZGF0YXNldC5mcmVkRHJvcHpvbmVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBkeixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmR6c1tkei5kYXRhc2V0LmZyZWREcm9wem9uZV0uZWwgPSBkejtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHpzW2R6LmRhdGFzZXQuZnJlZERyb3B6b25lXS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmR6c1tkei5kYXRhc2V0LmZyZWREcm9wem9uZV0uZWwuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaW5pdEVsZW1lbnRzKHdyYXBwZXIsIGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgZnJlZEVsZW1lbnRzID0gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mcmVkLW5hbWVdJyk7XG4gICAgICAgIGZvciAobGV0IGVsIG9mIGZyZWRFbGVtZW50cykge1xuICAgICAgICAgICAgZWwuZnJlZEVsID0gdGhpcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKG11dGF0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScpICYmICFlbC5ydGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdKSB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXcpIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3ID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZSA9IGVsLmlubmVySFRNTDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmRhdGFzZXQuZnJlZFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZnJlZC1wYWdlLXNldHRpbmctY2hhbmdlJywgZWwuZGF0YXNldC5mcmVkVGFyZ2V0LCB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3Jhdy5fdmFsdWUsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gJ2ltZycgJiYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09ICdzcmMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdKSB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3KSB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3JhdyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXcuX3ZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmRhdGFzZXQuZnJlZFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtcGFnZS1zZXR0aW5nLWNoYW5nZScsIGVsLmRhdGFzZXQuZnJlZFRhcmdldCwgdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXcuX3ZhbHVlLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpID09PSAnaScgJiYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09ICdjbGFzcycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0pIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXcpIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3ID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3Jhdy5fdmFsdWUgPSBlbC5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwuZGF0YXNldC5mcmVkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZnJlZC1wYWdlLXNldHRpbmctY2hhbmdlJywgZWwuZGF0YXNldC5mcmVkVGFyZ2V0LCB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3Jhdy5fdmFsdWUsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5kYXRhc2V0LmZyZWRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gZWwuZGF0YXNldC5mcmVkQXR0cnMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuaW5kZXhPZihtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKSA9PT0gLTEpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdKSB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3KSB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3JhdyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXdbbXV0YXRpb24uYXR0cmlidXRlTmFtZV0gPSBlbC5nZXRBdHRyaWJ1dGUobXV0YXRpb24uYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsLCB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZWwuZGF0YXNldC5mcmVkUnRlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBJIGhhdGUgdGhpcyBmaXg7IHRpbmVtY2UgdGhyb3dzIGFuIGVycm9yIG9uIGZpcnN0IGRyb3AgZnJvbSBkcmFndWxlXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRpbnltY2UuaW5pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU6ICdpbmxpdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luczogJ21vZHhsaW5rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydF90b29sYmFyOiBcInF1aWNraW1hZ2UgcXVpY2t0YWJsZSBtb2R4bGlua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3Rvb2xiYXI6ICdib2xkIGl0YWxpYyB8IGgyIGgzIGJsb2NrcXVvdGUgbW9keGxpbmsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b19mb2N1czogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBicmFuZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cDogZWRpdG9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5ydGUgPSBlZGl0b3I7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ2NoYW5nZScsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXSkgdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXcpIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3ID0ge307XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZSA9IGVkaXRvci5nZXRDb250ZW50KCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5kYXRhc2V0LmZyZWRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZnJlZC1wYWdlLXNldHRpbmctY2hhbmdlJywgZWwuZGF0YXNldC5mcmVkVGFyZ2V0LCB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3Jhdy5fdmFsdWUsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5vbignZm9jdXMnLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbkVkaXRvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdibHVyJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5FZGl0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdmcmVkLS1ibG9jay1hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdmcmVkLS1ibG9jay1hY3RpdmVfcGFyZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXSkgdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdID0ge307XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3KSB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3JhdyA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoZWwuZGF0YXNldC5mcmVkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnBhZ2VTZXR0aW5nc1tlbC5kYXRhc2V0LmZyZWRUYXJnZXRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZSA9IHRoaXMuY29uZmlnLnBhZ2VTZXR0aW5nc1tlbC5kYXRhc2V0LmZyZWRUYXJnZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkVkaXRvci5lZGl0KGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3NyYycsIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRWRpdG9yLmVkaXQoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXcuX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbC5kYXRhc2V0LmZyZWRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IGVsLmRhdGFzZXQuZnJlZEF0dHJzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXdbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXdbYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZSA9IGVsLmNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkVkaXRvci5lZGl0KGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3Jhdy5fdmFsdWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUVkaXRvci5lZGl0KGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZSA9IGVsLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWwuZGF0YXNldC5mcmVkQXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBlbC5kYXRhc2V0LmZyZWRBdHRycy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3W2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXdbYXR0cl0gPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBzZXRFbFZhbHVlKGVsLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXSkgdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdID0ge307XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXcpIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3ID0ge307XG5cbiAgICAgICAgc3dpdGNoIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3Jhdy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdLl9yYXcuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdzcmMnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIHRlbXBsYXRlUmVuZGVyKHBhcnNlTW9keCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZVRlbXBsYXRlUmVuZGVyKHBhcnNlTW9keCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5sb2NhbFRlbXBsYXRlUmVuZGVyKCkpO1xuICAgIH1cbiAgICBcbiAgICBsb2NhbFRlbXBsYXRlUmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZS5yZW5kZXIodGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuICAgIFxuICAgIHJlbW90ZVRlbXBsYXRlUmVuZGVyKHBhcnNlTW9keCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKGAke3RoaXMuY29uZmlnLmFzc2V0c1VybH1lbmRwb2ludHMvYWpheC5waHA/YWN0aW9uPXJlbmRlci1lbGVtZW50YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMuY29uZmlnLnJlc291cmNlLmlkLFxuICAgICAgICAgICAgICAgIHBhcnNlTW9keCxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPiAyOTkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UpOyAgICBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSkudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0RWwoanNvbi5kYXRhLmh0bWwpO1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uZGF0YS5odG1sO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtbG9hZGluZycsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGNsZWFuUmVuZGVyKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlUmVuZGVyKGZhbHNlKS50aGVuKGh0bWwgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBub1JlbmRlckVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mcmVkLXJlbmRlcj1cImZhbHNlXCJdJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBub1JlbmRlckVsZW1lbnQgb2Ygbm9SZW5kZXJFbGVtZW50cykge1xuICAgICAgICAgICAgICAgIG5vUmVuZGVyRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZnJlZEVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mcmVkLW5hbWVdJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBlbCBvZiBmcmVkRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50W2VsLmRhdGFzZXQuZnJlZE5hbWVdICYmIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3ICYmIHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3Ll92YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3Jhdy5fdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3Jhdy5fdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuZGF0YXNldC5mcmVkQXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gZWwuZGF0YXNldC5mcmVkQXR0cnMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudFtlbC5kYXRhc2V0LmZyZWROYW1lXS5fcmF3W2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmNvbnRlbnRbZWwuZGF0YXNldC5mcmVkTmFtZV0uX3Jhd1thdHRyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1mcmVkLW5hbWUnKTtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZnJlZC1ydGUnKTtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZnJlZC10YXJnZXQnKTtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZnJlZC1hdHRycycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBmcmVkTGlua3MgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZyZWQtbGluay1wYWdlXScpO1xuICAgICAgICAgICAgZm9yIChsZXQgZnJlZExpbmsgb2YgZnJlZExpbmtzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VJZCA9IHBhcnNlSW50KGZyZWRMaW5rLmRhdGFzZXQuZnJlZExpbmtQYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBmcmVkTGluay5kYXRhc2V0LmZyZWRMaW5rQW5jaG9yID8gKCcjJyArIGZyZWRMaW5rLmRhdGFzZXQuZnJlZExpbmtBbmNob3IpIDogJyMnO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZUlkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmcmVkTGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBgW1t+JHtyZXNvdXJjZUlkfV1dJHthbmNob3J9YCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJlZExpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZnJlZExpbmsucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWZyZWQtbGluay1wYWdlJyk7XG4gICAgICAgICAgICAgICAgZnJlZExpbmsucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWZyZWQtbGluay1hbmNob3InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZnJlZEFuY2hvcnMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZyZWQtbGluay1hbmNob3JdJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBmcmVkQW5jaG9yIG9mIGZyZWRBbmNob3JzKSB7XG4gICAgICAgICAgICAgICAgZnJlZEFuY2hvci5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBmcmVkQW5jaG9yLmRhdGFzZXQuZnJlZExpbmtBbmNob3IpO1xuICAgICAgICAgICAgICAgIGZyZWRBbmNob3IucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWZyZWQtbGluay1hbmNob3InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgZHpOYW1lIGluIHRoaXMuZHpzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHpzLmhhc093blByb3BlcnR5KGR6TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHpFbCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtZnJlZC1kcm9wem9uZT1cIicgKyBkek5hbWUgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkekVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkekVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1mcmVkLWRyb3B6b25lJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmR6c1tkek5hbWVdLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGVhbmVkRHJvcFpvbmVDb250ZW50ID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmR6c1tkek5hbWVdLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbmVkRHJvcFpvbmVDb250ZW50ICs9IGNoaWxkLmZyZWRFbC5jbGVhblJlbmRlcigpLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR6RWwuaW5uZXJIVE1MID0gY2xlYW5lZERyb3Bab25lQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFyZW50LmR6c1t0aGlzLmR6TmFtZV0uY2hpbGRyZW4uaW5kZXhPZih0aGlzLndyYXBwZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5kenNbdGhpcy5kek5hbWVdLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZHVwbGljYXRlRHJvcFpvbmVzKGR6cykge1xuICAgICAgICBmb3IgKGxldCBkek5hbWUgaW4gZHpzKSB7XG4gICAgICAgICAgICBpZiAoZHpzLmhhc093blByb3BlcnR5KGR6TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkenNbZHpOYW1lXS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZHpzW2R6TmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZENoaWxkID0gbmV3IENvbnRlbnRFbGVtZW50KHRoaXMuY29uZmlnLCBjaGlsZC5mcmVkRWwuZWwsIGR6TmFtZSwgdGhpcywgY2hpbGQuZnJlZEVsLmNvbnRlbnQsIGNoaWxkLmZyZWRFbC5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWRDaGlsZC5yZW5kZXIoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRUb0Ryb3Bab25lKGR6TmFtZSwgY2xvbmVkQ2hpbGQpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZENoaWxkLmR1cGxpY2F0ZURyb3Bab25lcyhjaGlsZC5mcmVkRWwuZHpzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkdXBsaWNhdGUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IENvbnRlbnRFbGVtZW50KHRoaXMuY29uZmlnLCB0aGlzLmVsLCB0aGlzLmR6TmFtZSwgdGhpcy5wYXJlbnQsIHRoaXMuY29udGVudCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIGNsb25lLnJlbmRlcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY2xvbmUuZHVwbGljYXRlRHJvcFpvbmVzKHRoaXMuZHpzKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLndyYXBwZXIubmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjbG9uZS53cmFwcGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lLndyYXBwZXIsIHRoaXMud3JhcHBlci5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFyZW50LmR6c1t0aGlzLmR6TmFtZV0uY2hpbGRyZW4uaW5kZXhPZih0aGlzLndyYXBwZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmR6c1t0aGlzLmR6TmFtZV0uY2hpbGRyZW4uc3BsaWNlKGluZGV4ICsgMSwgMCwgY2xvbmUud3JhcHBlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgZHJha2UucmVsb2FkQ29udGFpbmVycygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvcGVuU2V0dGluZ3MoKSB7XG4gICAgICAgIGVtaXR0ZXIuZW1pdCgnZnJlZC1lbGVtZW50LXNldHRpbmdzLW9wZW4nLCB0aGlzKTtcbiAgICB9XG5cbiAgICBhZGRFbGVtZW50VG9Ecm9wWm9uZSh6b25lTmFtZSwgZWxlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZHpzW3pvbmVOYW1lXSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHRoaXMuZHpzW3pvbmVOYW1lXS5jaGlsZHJlbi5wdXNoKGVsZW1lbnQud3JhcHBlcik7XG4gICAgICAgIHRoaXMuZHpzW3pvbmVOYW1lXS5lbC5hcHBlbmRDaGlsZChlbGVtZW50LndyYXBwZXIpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udGVudEVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vX2J1aWxkL2Fzc2V0cy9qcy9Db21wb25lbnRzL1NpZGViYXIvRWxlbWVudHMvQ29udGVudEVsZW1lbnQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Modal = __webpack_require__(25);\n\nvar _Modal2 = _interopRequireDefault(_Modal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ImageEditor = function () {\n    function ImageEditor() {\n        _classCallCheck(this, ImageEditor);\n\n        this.fredWrapper = null;\n        this.inited = false;\n    }\n\n    _createClass(ImageEditor, [{\n        key: 'init',\n        value: function init(fredWrapper) {\n            if (this.inited === true) return;\n\n            this.fredWrapper = fredWrapper;\n            this.inited = true;\n        }\n    }, {\n        key: 'edit',\n        value: function edit(img) {\n            var _this = this;\n\n            var wrapper = document.createElement('div');\n\n            var input = document.createElement('input');\n            input.setAttribute('type', 'text');\n            input.value = img.src || '';\n\n            var fields = [];\n\n            if (img.dataset.fredAttrs) {\n                var attrs = img.dataset.fredAttrs.split(',');\n                attrs.forEach(function (attr) {\n                    var field = document.createElement('input');\n                    field.dataset.name = attr;\n                    field.setAttribute('type', 'text');\n                    field.value = img.getAttribute(attr || '');\n\n                    fields.push(field);\n                });\n            }\n\n            wrapper.appendChild(this.labelWrapper(input, 'src'));\n\n            fields.forEach(function (field) {\n                wrapper.appendChild(_this.labelWrapper(field, field.dataset.name));\n            });\n\n            var modal = new _Modal2.default(this.fredWrapper, 'Edit Image', wrapper, function () {\n                img.src = input.value;\n\n                fields.forEach(function (field) {\n                    img.setAttribute(field.dataset.name, field.value);\n                });\n            });\n\n            modal.render();\n        }\n    }, {\n        key: 'labelWrapper',\n        value: function labelWrapper(input, name) {\n            var label = document.createElement('label');\n            label.innerText = name;\n\n            label.appendChild(input);\n\n            return label;\n        }\n    }]);\n\n    return ImageEditor;\n}();\n\nvar imageEditor = new ImageEditor();\n\nexports.default = imageEditor;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0VkaXRvcnMvSW1hZ2VFZGl0b3IuanM/NTFlNCJdLCJuYW1lcyI6WyJJbWFnZUVkaXRvciIsImZyZWRXcmFwcGVyIiwiaW5pdGVkIiwiaW1nIiwid3JhcHBlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlucHV0Iiwic2V0QXR0cmlidXRlIiwidmFsdWUiLCJzcmMiLCJmaWVsZHMiLCJkYXRhc2V0IiwiZnJlZEF0dHJzIiwiYXR0cnMiLCJzcGxpdCIsImZvckVhY2giLCJmaWVsZCIsIm5hbWUiLCJhdHRyIiwiZ2V0QXR0cmlidXRlIiwicHVzaCIsImFwcGVuZENoaWxkIiwibGFiZWxXcmFwcGVyIiwibW9kYWwiLCJyZW5kZXIiLCJsYWJlbCIsImlubmVyVGV4dCIsImltYWdlRWRpdG9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7OztJQUVNQSxXO0FBQ0YsMkJBQWM7QUFBQTs7QUFDVixhQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsYUFBS0MsTUFBTCxHQUFjLEtBQWQ7QUFDSDs7Ozs2QkFFSUQsVyxFQUFhO0FBQ2QsZ0JBQUksS0FBS0MsTUFBTCxLQUFnQixJQUFwQixFQUEwQjs7QUFFMUIsaUJBQUtELFdBQUwsR0FBbUJBLFdBQW5CO0FBQ0EsaUJBQUtDLE1BQUwsR0FBYyxJQUFkO0FBQ0g7Ozs2QkFFSUMsRyxFQUFLO0FBQUE7O0FBQ04sZ0JBQU1DLFVBQVVDLFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7O0FBR0EsZ0JBQU1DLFFBQVFGLFNBQVNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBZDtBQUNBQyxrQkFBTUMsWUFBTixDQUFtQixNQUFuQixFQUEyQixNQUEzQjtBQUNBRCxrQkFBTUUsS0FBTixHQUFjTixJQUFJTyxHQUFKLElBQVcsRUFBekI7O0FBRUEsZ0JBQU1DLFNBQVMsRUFBZjs7QUFFQSxnQkFBSVIsSUFBSVMsT0FBSixDQUFZQyxTQUFoQixFQUEyQjtBQUN2QixvQkFBTUMsUUFBUVgsSUFBSVMsT0FBSixDQUFZQyxTQUFaLENBQXNCRSxLQUF0QixDQUE0QixHQUE1QixDQUFkO0FBQ0FELHNCQUFNRSxPQUFOLENBQWMsZ0JBQVE7QUFDbEIsd0JBQU1DLFFBQVFaLFNBQVNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBZDtBQUNBVywwQkFBTUwsT0FBTixDQUFjTSxJQUFkLEdBQXFCQyxJQUFyQjtBQUNBRiwwQkFBTVQsWUFBTixDQUFtQixNQUFuQixFQUEyQixNQUEzQjtBQUNBUywwQkFBTVIsS0FBTixHQUFjTixJQUFJaUIsWUFBSixDQUFpQkQsUUFBUSxFQUF6QixDQUFkOztBQUVBUiwyQkFBT1UsSUFBUCxDQUFZSixLQUFaO0FBQ0gsaUJBUEQ7QUFRSDs7QUFFRGIsb0JBQVFrQixXQUFSLENBQW9CLEtBQUtDLFlBQUwsQ0FBa0JoQixLQUFsQixFQUF5QixLQUF6QixDQUFwQjs7QUFFQUksbUJBQU9LLE9BQVAsQ0FBZSxpQkFBUztBQUNwQlosd0JBQVFrQixXQUFSLENBQW9CLE1BQUtDLFlBQUwsQ0FBa0JOLEtBQWxCLEVBQXlCQSxNQUFNTCxPQUFOLENBQWNNLElBQXZDLENBQXBCO0FBQ0gsYUFGRDs7QUFLQSxnQkFBTU0sUUFBUSxvQkFBVSxLQUFLdkIsV0FBZixFQUE0QixZQUE1QixFQUEwQ0csT0FBMUMsRUFBbUQsWUFBTTtBQUNuRUQsb0JBQUlPLEdBQUosR0FBVUgsTUFBTUUsS0FBaEI7O0FBRUFFLHVCQUFPSyxPQUFQLENBQWUsaUJBQVM7QUFDcEJiLHdCQUFJSyxZQUFKLENBQWlCUyxNQUFNTCxPQUFOLENBQWNNLElBQS9CLEVBQXFDRCxNQUFNUixLQUEzQztBQUNILGlCQUZEO0FBR0gsYUFOYSxDQUFkOztBQVFBZSxrQkFBTUMsTUFBTjtBQUNIOzs7cUNBRVlsQixLLEVBQU9XLEksRUFBTTtBQUN0QixnQkFBTVEsUUFBUXJCLFNBQVNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBZDtBQUNBb0Isa0JBQU1DLFNBQU4sR0FBa0JULElBQWxCOztBQUVBUSxrQkFBTUosV0FBTixDQUFrQmYsS0FBbEI7O0FBRUEsbUJBQU9tQixLQUFQO0FBQ0g7Ozs7OztBQUlMLElBQU1FLGNBQWMsSUFBSTVCLFdBQUosRUFBcEI7O2tCQUVlNEIsVyIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNb2RhbCBmcm9tICcuLi9Nb2RhbCc7XG5cbmNsYXNzIEltYWdlRWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mcmVkV3JhcHBlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaW5pdChmcmVkV3JhcHBlcikge1xuICAgICAgICBpZiAodGhpcy5pbml0ZWQgPT09IHRydWUpIHJldHVybjtcblxuICAgICAgICB0aGlzLmZyZWRXcmFwcGVyID0gZnJlZFdyYXBwZXI7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBlZGl0KGltZykge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IGltZy5zcmMgfHwgJyc7XG5cbiAgICAgICAgY29uc3QgZmllbGRzID0gW107XG5cbiAgICAgICAgaWYgKGltZy5kYXRhc2V0LmZyZWRBdHRycykge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBpbWcuZGF0YXNldC5mcmVkQXR0cnMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGF0dHJzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFzZXQubmFtZSA9IGF0dHI7XG4gICAgICAgICAgICAgICAgZmllbGQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgICAgICAgICBmaWVsZC52YWx1ZSA9IGltZy5nZXRBdHRyaWJ1dGUoYXR0ciB8fCAnJyk7XG5cbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbFdyYXBwZXIoaW5wdXQsICdzcmMnKSk7XG4gICAgICAgIFxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMubGFiZWxXcmFwcGVyKGZpZWxkLCBmaWVsZC5kYXRhc2V0Lm5hbWUpKTsgICAgXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgY29uc3QgbW9kYWwgPSBuZXcgTW9kYWwodGhpcy5mcmVkV3JhcHBlciwgJ0VkaXQgSW1hZ2UnLCB3cmFwcGVyLCAoKSA9PiB7XG4gICAgICAgICAgICBpbWcuc3JjID0gaW5wdXQudmFsdWU7XG5cbiAgICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKGZpZWxkLmRhdGFzZXQubmFtZSwgZmllbGQudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vZGFsLnJlbmRlcigpO1xuICAgIH1cbiAgICBcbiAgICBsYWJlbFdyYXBwZXIoaW5wdXQsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBsYWJlbC5pbm5lclRleHQgPSBuYW1lO1xuICAgICAgICBcbiAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cblxufVxuXG5jb25zdCBpbWFnZUVkaXRvciA9IG5ldyBJbWFnZUVkaXRvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBpbWFnZUVkaXRvcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9fYnVpbGQvYXNzZXRzL2pzL0VkaXRvcnMvSW1hZ2VFZGl0b3IuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Modal = exports.Modal = function () {\n    function Modal(fredWrapper, title) {\n        var content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n        var onSave = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n\n        _classCallCheck(this, Modal);\n\n        this.fredWrapper = fredWrapper;\n        this.wrapper = null;\n        this.title = title;\n        this.content = content;\n        this.onSave = onSave;\n    }\n\n    _createClass(Modal, [{\n        key: 'setTitle',\n        value: function setTitle(title) {\n            this.title = title;\n\n            if (this.wrapper !== null) {\n                this.titleEl.innerHTML = title;\n            }\n        }\n    }, {\n        key: 'setContent',\n        value: function setContent(content) {\n            this.content = content;\n\n            if (this.wrapper !== null) {\n                if (typeof this.content === 'string') {\n                    this.body.innerHTML = this.content;\n                } else {\n                    this.body.innerHTML = '';\n                    this.body.appendChild(this.content);\n                }\n            }\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var _this = this;\n\n            this.wrapper = document.createElement('section');\n            this.wrapper.classList.add('fred--modal-bg');\n\n            var modal = document.createElement('div');\n            modal.classList.add('fred--modal');\n            modal.setAttribute('aria-hidden', 'true');\n\n            var header = document.createElement('div');\n            header.classList.add('fred--modal-header');\n\n            var close = document.createElement('button');\n            close.classList.add('button');\n            close.innerHTML = '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"20px\" height=\"20px\" viewBox=\"-4 -4 20 20\" enable-background=\"new -4 -4 20 20\" xml:space=\"preserve\"><polygon points=\"16.079,-0.666 12.717,-4.027 6.052,2.637 -0.613,-4.027 -3.975,-0.666 2.69,6 -3.975,12.664 -0.612,16.026 6.052,9.362 12.717,16.027 16.079,12.664 9.414,6 \"></polygon></svg>';\n            close.addEventListener('click', this.close.bind(this));\n\n            this.titleEl = document.createElement('h4');\n            this.titleEl.innerHTML = this.title;\n\n            this.body = document.createElement('div');\n            this.body.classList.add('fred--modal-body');\n\n            if (typeof this.content === 'string') {\n                this.body.innerHTML = this.content;\n            } else {\n                this.body.appendChild(this.content);\n            }\n\n            var footer = document.createElement('div');\n            footer.classList.add('fred--modal-footer');\n\n            var save = document.createElement('button');\n            save.classList.add('fred--btn-small');\n            save.setAttribute('type', 'button');\n            save.innerHTML = 'Save';\n            save.addEventListener('click', function (e) {\n                e.preventDefault();\n                _this.onSave();\n                _this.close();\n            });\n\n            header.appendChild(close);\n            header.appendChild(this.titleEl);\n\n            footer.appendChild(save);\n\n            modal.appendChild(header);\n            modal.appendChild(this.body);\n            modal.appendChild(footer);\n\n            this.wrapper.appendChild(modal);\n\n            this.fredWrapper.appendChild(this.wrapper);\n\n            return this.wrapper;\n        }\n    }, {\n        key: 'close',\n        value: function close() {\n            this.wrapper.remove();\n        }\n    }]);\n\n    return Modal;\n}();\n\nexports.default = Modal;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL01vZGFsLmpzP2FkOTIiXSwibmFtZXMiOlsiTW9kYWwiLCJmcmVkV3JhcHBlciIsInRpdGxlIiwiY29udGVudCIsIm9uU2F2ZSIsIndyYXBwZXIiLCJ0aXRsZUVsIiwiaW5uZXJIVE1MIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwibW9kYWwiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkZXIiLCJjbG9zZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJiaW5kIiwiZm9vdGVyIiwic2F2ZSIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInJlbW92ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztJQUFhQSxLLFdBQUFBLEs7QUFFVCxtQkFBWUMsV0FBWixFQUF5QkMsS0FBekIsRUFBaUU7QUFBQSxZQUFqQ0MsT0FBaUMsdUVBQXZCLEVBQXVCO0FBQUEsWUFBbkJDLE1BQW1CLHVFQUFWLFlBQU0sQ0FBRSxDQUFFOztBQUFBOztBQUM3RCxhQUFLSCxXQUFMLEdBQW1CQSxXQUFuQjtBQUNBLGFBQUtJLE9BQUwsR0FBZSxJQUFmO0FBQ0EsYUFBS0gsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsYUFBS0MsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsYUFBS0MsTUFBTCxHQUFjQSxNQUFkO0FBQ0g7Ozs7aUNBRVFGLEssRUFBTztBQUNaLGlCQUFLQSxLQUFMLEdBQWFBLEtBQWI7O0FBRUEsZ0JBQUksS0FBS0csT0FBTCxLQUFpQixJQUFyQixFQUEyQjtBQUN2QixxQkFBS0MsT0FBTCxDQUFhQyxTQUFiLEdBQXlCTCxLQUF6QjtBQUNIO0FBQ0o7OzttQ0FFVUMsTyxFQUFTO0FBQ2hCLGlCQUFLQSxPQUFMLEdBQWVBLE9BQWY7O0FBRUEsZ0JBQUksS0FBS0UsT0FBTCxLQUFpQixJQUFyQixFQUEyQjtBQUN2QixvQkFBSSxPQUFPLEtBQUtGLE9BQVosS0FBd0IsUUFBNUIsRUFB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QixLIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIE1vZGFsIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcihmcmVkV3JhcHBlciwgdGl0bGUsIGNvbnRlbnQgPSAnJywgb25TYXZlID0gKCkgPT4ge30pIHtcbiAgICAgICAgdGhpcy5mcmVkV3JhcHBlciA9IGZyZWRXcmFwcGVyO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMub25TYXZlID0gb25TYXZlO1xuICAgIH1cbiAgICBcbiAgICBzZXRUaXRsZSh0aXRsZSkge1xuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy53cmFwcGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlRWwuaW5uZXJIVE1MID0gdGl0bGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMud3JhcHBlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LmlubmVySFRNTCA9IHRoaXMuY29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCgnZnJlZC0tbW9kYWwtYmcnKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1vZGFsLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLW1vZGFsJyk7XG4gICAgICAgIG1vZGFsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBoZWFkZXIuY2xhc3NMaXN0LmFkZCgnZnJlZC0tbW9kYWwtaGVhZGVyJyk7XG5cbiAgICAgICAgY29uc3QgY2xvc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgY2xvc2UuY2xhc3NMaXN0LmFkZCgnYnV0dG9uJyk7XG4gICAgICAgIGNsb3NlLmlubmVySFRNTCA9ICc8c3ZnIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjIwcHhcIiBoZWlnaHQ9XCIyMHB4XCIgdmlld0JveD1cIi00IC00IDIwIDIwXCIgZW5hYmxlLWJhY2tncm91bmQ9XCJuZXcgLTQgLTQgMjAgMjBcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPjxwb2x5Z29uIHBvaW50cz1cIjE2LjA3OSwtMC42NjYgMTIuNzE3LC00LjAyNyA2LjA1MiwyLjYzNyAtMC42MTMsLTQuMDI3IC0zLjk3NSwtMC42NjYgMi42OSw2IC0zLjk3NSwxMi42NjQgLTAuNjEyLDE2LjAyNiA2LjA1Miw5LjM2MiAxMi43MTcsMTYuMDI3IDE2LjA3OSwxMi42NjQgOS40MTQsNiBcIj48L3BvbHlnb24+PC9zdmc+JztcbiAgICAgICAgY2xvc2UuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMudGl0bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2g0Jyk7XG4gICAgICAgIHRoaXMudGl0bGVFbC5pbm5lckhUTUwgPSB0aGlzLnRpdGxlO1xuXG4gICAgICAgIHRoaXMuYm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmJvZHkuY2xhc3NMaXN0LmFkZCgnZnJlZC0tbW9kYWwtYm9keScpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuaW5uZXJIVE1MID0gdGhpcy5jb250ZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmb290ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZm9vdGVyLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLW1vZGFsLWZvb3RlcicpO1xuXG4gICAgICAgIGNvbnN0IHNhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgc2F2ZS5jbGFzc0xpc3QuYWRkKCdmcmVkLS1idG4tc21hbGwnKTtcbiAgICAgICAgc2F2ZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgICAgIHNhdmUuaW5uZXJIVE1MID0gJ1NhdmUnO1xuICAgICAgICBzYXZlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm9uU2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChjbG9zZSk7XG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZCh0aGlzLnRpdGxlRWwpO1xuICAgICAgICBcbiAgICAgICAgZm9vdGVyLmFwcGVuZENoaWxkKHNhdmUpO1xuXG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKHRoaXMuYm9keSk7XG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGZvb3Rlcik7XG5cbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKG1vZGFsKTtcblxuICAgICAgICB0aGlzLmZyZWRXcmFwcGVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICAgIH1cbiAgICBcbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kYWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vX2J1aWxkL2Fzc2V0cy9qcy9Nb2RhbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Modal = __webpack_require__(25);\n\nvar _Modal2 = _interopRequireDefault(_Modal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar IconEditor = function () {\n    function IconEditor() {\n        _classCallCheck(this, IconEditor);\n\n        this.fredWrapper = null;\n        this.inited = false;\n    }\n\n    _createClass(IconEditor, [{\n        key: 'init',\n        value: function init(fredWrapper) {\n            if (this.inited === true) return;\n\n            this.fredWrapper = fredWrapper;\n            this.inited = true;\n        }\n    }, {\n        key: 'edit',\n        value: function edit(i) {\n            var _this = this;\n\n            var wrapper = document.createElement('div');\n\n            var input = document.createElement('input');\n            input.setAttribute('type', 'text');\n            input.value = i.className || '';\n\n            var fields = [];\n\n            if (i.dataset.fredAttrs) {\n                var attrs = i.dataset.fredAttrs.split(',');\n                attrs.forEach(function (attr) {\n                    var field = document.createElement('input');\n                    field.dataset.name = attr;\n                    field.setAttribute('type', 'text');\n                    field.value = i.getAttribute(attr || '');\n\n                    fields.push(field);\n                });\n            }\n\n            wrapper.appendChild(this.labelWrapper(input, 'class'));\n\n            fields.forEach(function (field) {\n                wrapper.appendChild(_this.labelWrapper(field, field.dataset.name));\n            });\n\n            var modal = new _Modal2.default(this.fredWrapper, 'Edit Icon', wrapper, function () {\n                i.className = input.value;\n\n                fields.forEach(function (field) {\n                    i.setAttribute(field.dataset.name, field.value);\n                });\n            });\n\n            modal.render();\n        }\n    }, {\n        key: 'labelWrapper',\n        value: function labelWrapper(input, name) {\n            var label = document.createElement('label');\n            label.innerText = name;\n\n            label.appendChild(input);\n\n            return label;\n        }\n    }]);\n\n    return IconEditor;\n}();\n\nvar iconEditor = new IconEditor();\n\nexports.default = iconEditor;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0VkaXRvcnMvSWNvbkVkaXRvci5qcz80OWU3Il0sIm5hbWVzIjpbIkljb25FZGl0b3IiLCJmcmVkV3JhcHBlciIsImluaXRlZCIsImkiLCJ3cmFwcGVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5wdXQiLCJzZXRBdHRyaWJ1dGUiLCJ2YWx1ZSIsImNsYXNzTmFtZSIsImZpZWxkcyIsImRhdGFzZXQiLCJmcmVkQXR0cnMiLCJhdHRycyIsInNwbGl0IiwiZm9yRWFjaCIsImZpZWxkIiwibmFtZSIsImF0dHIiLCJnZXRBdHRyaWJ1dGUiLCJwdXNoIiwiYXBwZW5kQ2hpbGQiLCJsYWJlbFdyYXBwZXIiLCJtb2RhbCIsInJlbmRlciIsImxhYmVsIiwiaW5uZXJUZXh0IiwiaWNvbkVkaXRvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7SUFFTUEsVTtBQUNGLDBCQUFjO0FBQUE7O0FBQ1YsYUFBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLGFBQUtDLE1BQUwsR0FBYyxLQUFkO0FBQ0g7Ozs7NkJBRUlELFcsRUFBYTtBQUNkLGdCQUFJLEtBQUtDLE1BQUwsS0FBZ0IsSUFBcEIsRUFBMEI7O0FBRTFCLGlCQUFLRCxXQUFMLEdBQW1CQSxXQUFuQjtBQUNBLGlCQUFLQyxNQUFMLEdBQWMsSUFBZDtBQUNIOzs7NkJBRUlDLEMsRUFBRztBQUFBOztBQUNKLGdCQUFNQyxVQUFVQyxTQUFTQyxhQUFULENBQXVCLEtBQXZCLENBQWhCOztBQUdBLGdCQUFNQyxRQUFRRixTQUFTQyxhQUFULENBQXVCLE9BQXZCLENBQWQ7QUFDQUMsa0JBQU1DLFlBQU4sQ0FBbUIsTUFBbkIsRUFBMkIsTUFBM0I7QUFDQUQsa0JBQU1FLEtBQU4sR0FBY04sRUFBRU8sU0FBRixJQUFlLEVBQTdCOztBQUVBLGdCQUFNQyxTQUFTLEVBQWY7O0FBRUEsZ0JBQUlSLEVBQUVTLE9BQUYsQ0FBVUMsU0FBZCxFQUF5QjtBQUNyQixvQkFBTUMsUUFBUVgsRUFBRVMsT0FBRixDQUFVQyxTQUFWLENBQW9CRSxLQUFwQixDQUEwQixHQUExQixDQUFkO0FBQ0FELHNCQUFNRSxPQUFOLENBQWMsZ0JBQVE7QUFDbEIsd0JBQU1DLFFBQVFaLFNBQVNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBZDtBQUNBVywwQkFBTUwsT0FBTixDQUFjTSxJQUFkLEdBQXFCQyxJQUFyQjtBQUNBRiwwQkFBTVQsWUFBTixDQUFtQixNQUFuQixFQUEyQixNQUEzQjtBQUNBUywwQkFBTVIsS0FBTixHQUFjTixFQUFFaUIsWUFBRixDQUFlRCxRQUFRLEVBQXZCLENBQWQ7O0FBRUFSLDJCQUFPVSxJQUFQLENBQVlKLEtBQVo7QUFDSCxpQkFQRDtBQVFIOztBQUVEYixvQkFBUWtCLFdBQVIsQ0FBb0IsS0FBS0MsWUFBTCxDQUFrQmhCLEtBQWxCLEVBQXlCLE9BQXpCLENBQXBCOztBQUVBSSxtQkFBT0ssT0FBUCxDQUFlLGlCQUFTO0FBQ3BCWix3QkFBUWtCLFdBQVIsQ0FBb0IsTUFBS0MsWUFBTCxDQUFrQk4sS0FBbEIsRUFBeUJBLE1BQU1MLE9BQU4sQ0FBY00sSUFBdkMsQ0FBcEI7QUFDSCxhQUZEOztBQUtBLGdCQUFNTSxRQUFRLG9CQUFVLEtBQUt2QixXQUFmLEVBQTRCLFdBQTVCLEVBQXlDRyxPQUF6QyxFQUFrRCxZQUFNO0FBQ2xFRCxrQkFBRU8sU0FBRixHQUFjSCxNQUFNRSxLQUFwQjs7QUFFQUUsdUJBQU9LLE9BQVAsQ0FBZSxpQkFBUztBQUNwQmIsc0JBQUVLLFlBQUYsQ0FBZVMsTUFBTUwsT0FBTixDQUFjTSxJQUE3QixFQUFtQ0QsTUFBTVIsS0FBekM7QUFDSCxpQkFGRDtBQUdILGFBTmEsQ0FBZDs7QUFRQWUsa0JBQU1DLE1BQU47QUFDSDs7O3FDQUVZbEIsSyxFQUFPVyxJLEVBQU07QUFDdEIsZ0JBQU1RLFFBQVFyQixTQUFTQyxhQUFULENBQXVCLE9BQXZCLENBQWQ7QUFDQW9CLGtCQUFNQyxTQUFOLEdBQWtCVCxJQUFsQjs7QUFFQVEsa0JBQU1KLFdBQU4sQ0FBa0JmLEtBQWxCOztBQUVBLG1CQUFPbUIsS0FBUDtBQUNIOzs7Ozs7QUFJTCxJQUFNRSxhQUFhLElBQUk1QixVQUFKLEVBQW5COztrQkFFZTRCLFUiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTW9kYWwgZnJvbSAnLi4vTW9kYWwnO1xuXG5jbGFzcyBJY29uRWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mcmVkV3JhcHBlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaW5pdChmcmVkV3JhcHBlcikge1xuICAgICAgICBpZiAodGhpcy5pbml0ZWQgPT09IHRydWUpIHJldHVybjtcblxuICAgICAgICB0aGlzLmZyZWRXcmFwcGVyID0gZnJlZFdyYXBwZXI7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBlZGl0KGkpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSBpLmNsYXNzTmFtZSB8fCAnJztcblxuICAgICAgICBjb25zdCBmaWVsZHMgPSBbXTtcblxuICAgICAgICBpZiAoaS5kYXRhc2V0LmZyZWRBdHRycykge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBpLmRhdGFzZXQuZnJlZEF0dHJzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhc2V0Lm5hbWUgPSBhdHRyO1xuICAgICAgICAgICAgICAgIGZpZWxkLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgZmllbGQudmFsdWUgPSBpLmdldEF0dHJpYnV0ZShhdHRyIHx8ICcnKTtcblxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsV3JhcHBlcihpbnB1dCwgJ2NsYXNzJykpO1xuICAgICAgICBcbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsV3JhcHBlcihmaWVsZCwgZmllbGQuZGF0YXNldC5uYW1lKSk7ICAgIFxuICAgICAgICB9KTtcblxuXG4gICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKHRoaXMuZnJlZFdyYXBwZXIsICdFZGl0IEljb24nLCB3cmFwcGVyLCAoKSA9PiB7XG4gICAgICAgICAgICBpLmNsYXNzTmFtZSA9IGlucHV0LnZhbHVlO1xuXG4gICAgICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgaS5zZXRBdHRyaWJ1dGUoZmllbGQuZGF0YXNldC5uYW1lLCBmaWVsZC52YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kYWwucmVuZGVyKCk7XG4gICAgfVxuICAgIFxuICAgIGxhYmVsV3JhcHBlcihpbnB1dCwgbmFtZSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGxhYmVsLmlubmVyVGV4dCA9IG5hbWU7XG4gICAgICAgIFxuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgfVxuXG59XG5cbmNvbnN0IGljb25FZGl0b3IgPSBuZXcgSWNvbkVkaXRvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBpY29uRWRpdG9yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL19idWlsZC9hc3NldHMvanMvRWRpdG9ycy9JY29uRWRpdG9yLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(__dirname) {(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory((function webpackLoadOptionalExternalModule() { try { return __webpack_require__(28); } catch(e) {} }()), __webpack_require__(29));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"fs\", \"path\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Twig\"] = factory((function webpackLoadOptionalExternalModule() { try { return require(\"fs\"); } catch(e) {} }()), require(\"path\"));\n\telse\n\t\troot[\"Twig\"] = factory(root[\"fs\"], root[\"path\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_19__, __WEBPACK_EXTERNAL_MODULE_20__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Twig.js\n\t *\n\t * @copyright 2011-2016 John Roepke and the Twig.js Contributors\n\t * @license   Available under the BSD 2-Clause License\n\t * @link      https://github.com/twigjs/twig.js\n\t */\n\n\tvar Twig = {\n\t    VERSION: '0.10.2'\n\t};\n\n\t__webpack_require__(1)(Twig);\n\t__webpack_require__(2)(Twig);\n\t__webpack_require__(3)(Twig);\n\t__webpack_require__(5)(Twig);\n\t__webpack_require__(6)(Twig);\n\t__webpack_require__(7)(Twig);\n\t__webpack_require__(17)(Twig);\n\t__webpack_require__(18)(Twig);\n\t__webpack_require__(21)(Twig);\n\t__webpack_require__(22)(Twig);\n\t__webpack_require__(23)(Twig);\n\t__webpack_require__(24)(Twig);\n\t__webpack_require__(25)(Twig);\n\t__webpack_require__(26)(Twig);\n\t__webpack_require__(27)(Twig);\n\n\tmodule.exports = Twig.exports;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// ## twig.core.js\n\t//\n\t// This file handles template level tokenizing, compiling and parsing.\n\tmodule.exports = function (Twig) {\n\t    \"use strict\";\n\n\t    Twig.trace = false;\n\t    Twig.debug = false;\n\n\t    // Default caching to true for the improved performance it offers\n\t    Twig.cache = true;\n\n\t    Twig.noop = function() {};\n\n\t    Twig.placeholders = {\n\t        parent: \"{{|PARENT|}}\"\n\t    };\n\n\t    /**\n\t     * Fallback for Array.indexOf for IE8 et al\n\t     */\n\t    Twig.indexOf = function (arr, searchElement /*, fromIndex */ ) {\n\t        if (Array.prototype.hasOwnProperty(\"indexOf\")) {\n\t            return arr.indexOf(searchElement);\n\t        }\n\t        if (arr === void 0 || arr === null) {\n\t            throw new TypeError();\n\t        }\n\t        var t = Object(arr);\n\t        var len = t.length >>> 0;\n\t        if (len === 0) {\n\t            return -1;\n\t        }\n\t        var n = 0;\n\t        if (arguments.length > 0) {\n\t            n = Number(arguments[1]);\n\t            if (n !== n) { // shortcut for verifying if it's NaN\n\t                n = 0;\n\t            } else if (n !== 0 && n !== Infinity && n !== -Infinity) {\n\t                n = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t            }\n\t        }\n\t        if (n >= len) {\n\t            // console.log(\"indexOf not found1 \", JSON.stringify(searchElement), JSON.stringify(arr));\n\t            return -1;\n\t        }\n\t        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n\t        for (; k < len; k++) {\n\t            if (k in t && t[k] === searchElement) {\n\t                return k;\n\t            }\n\t        }\n\t        if (arr == searchElement) {\n\t            return 0;\n\t        }\n\t        // console.log(\"indexOf not found2 \", JSON.stringify(searchElement), JSON.stringify(arr));\n\n\t        return -1;\n\t    }\n\n\t    Twig.forEach = function (arr, callback, thisArg) {\n\t        if (Array.prototype.forEach ) {\n\t            return arr.forEach(callback, thisArg);\n\t        }\n\n\t        var T, k;\n\n\t        if ( arr == null ) {\n\t          throw new TypeError( \" this is null or not defined\" );\n\t        }\n\n\t        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.\n\t        var O = Object(arr);\n\n\t        // 2. Let lenValue be the result of calling the Get internal method of O with the argument \"length\".\n\t        // 3. Let len be ToUint32(lenValue).\n\t        var len = O.length >>> 0; // Hack to convert O.length to a UInt32\n\n\t        // 4. If IsCallable(callback) is false, throw a TypeError exception.\n\t        // See: http://es5.github.com/#x9.11\n\t        if ( {}.toString.call(callback) != \"[object Function]\" ) {\n\t          throw new TypeError( callback + \" is not a function\" );\n\t        }\n\n\t        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n\t        if ( thisArg ) {\n\t          T = thisArg;\n\t        }\n\n\t        // 6. Let k be 0\n\t        k = 0;\n\n\t        // 7. Repeat, while k < len\n\t        while( k < len ) {\n\n\t          var kValue;\n\n\t          // a. Let Pk be ToString(k).\n\t          //   This is implicit for LHS operands of the in operator\n\t          // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.\n\t          //   This step can be combined with c\n\t          // c. If kPresent is true, then\n\t          if ( k in O ) {\n\n\t            // i. Let kValue be the result of calling the Get internal method of O with argument Pk.\n\t            kValue = O[ k ];\n\n\t            // ii. Call the Call internal method of callback with T as the this value and\n\t            // argument list containing kValue, k, and O.\n\t            callback.call( T, kValue, k, O );\n\t          }\n\t          // d. Increase k by 1.\n\t          k++;\n\t        }\n\t        // 8. return undefined\n\t    };\n\n\t    Twig.merge = function(target, source, onlyChanged) {\n\t        Twig.forEach(Object.keys(source), function (key) {\n\t            if (onlyChanged && !(key in target)) {\n\t                return;\n\t            }\n\n\t            target[key] = source[key]\n\t        });\n\n\t        return target;\n\t    };\n\n\t    /**\n\t     * Exception thrown by twig.js.\n\t     */\n\t    Twig.Error = function(message, file) {\n\t       this.message = message;\n\t       this.name = \"TwigException\";\n\t       this.type = \"TwigException\";\n\t       this.file = file;\n\t    };\n\n\t    /**\n\t     * Get the string representation of a Twig error.\n\t     */\n\t    Twig.Error.prototype.toString = function() {\n\t        var output = this.name + \": \" + this.message;\n\n\t        return output;\n\t    };\n\n\t    /**\n\t     * Wrapper for logging to the console.\n\t     */\n\t    Twig.log = {\n\t        trace: function() {if (Twig.trace && console) {console.log(Array.prototype.slice.call(arguments));}},\n\t        debug: function() {if (Twig.debug && console) {console.log(Array.prototype.slice.call(arguments));}}\n\t    };\n\n\n\t    if (typeof console !== \"undefined\") {\n\t        if (typeof console.error !== \"undefined\") {\n\t            Twig.log.error = function() {\n\t                console.error.apply(console, arguments);\n\t            }\n\t        } else if (typeof console.log !== \"undefined\") {\n\t            Twig.log.error = function() {\n\t                console.log.apply(console, arguments);\n\t            }\n\t        }\n\t    } else {\n\t        Twig.log.error = function(){};\n\t    }\n\n\t    /**\n\t     * Wrapper for child context objects in Twig.\n\t     *\n\t     * @param {Object} context Values to initialize the context with.\n\t     */\n\t    Twig.ChildContext = function(context) {\n\t        var ChildContext = function ChildContext() {};\n\t        ChildContext.prototype = context;\n\t        return new ChildContext();\n\t    };\n\n\t    /**\n\t     * Container for methods related to handling high level template tokens\n\t     *      (for example: {{ expression }}, {% logic %}, {# comment #}, raw data)\n\t     */\n\t    Twig.token = {};\n\n\t    /**\n\t     * Token types.\n\t     */\n\t    Twig.token.type = {\n\t        output:                 'output',\n\t        logic:                  'logic',\n\t        comment:                'comment',\n\t        raw:                    'raw',\n\t        output_whitespace_pre:  'output_whitespace_pre',\n\t        output_whitespace_post: 'output_whitespace_post',\n\t        output_whitespace_both: 'output_whitespace_both',\n\t        logic_whitespace_pre:   'logic_whitespace_pre',\n\t        logic_whitespace_post:  'logic_whitespace_post',\n\t        logic_whitespace_both:  'logic_whitespace_both'\n\t    };\n\n\t    /**\n\t     * Token syntax definitions.\n\t     */\n\t    Twig.token.definitions = [\n\t        {\n\t            type: Twig.token.type.raw,\n\t            open: '{% raw %}',\n\t            close: '{% endraw %}'\n\t        },\n\t        {\n\t            type: Twig.token.type.raw,\n\t            open: '{% verbatim %}',\n\t            close: '{% endverbatim %}'\n\t        },\n\t        // *Whitespace type tokens*\n\t        //\n\t        // These typically take the form `{{- expression -}}` or `{{- expression }}` or `{{ expression -}}`.\n\t        {\n\t            type: Twig.token.type.output_whitespace_pre,\n\t            open: '{{-',\n\t            close: '}}'\n\t        },\n\t        {\n\t            type: Twig.token.type.output_whitespace_post,\n\t            open: '{{',\n\t            close: '-}}'\n\t        },\n\t        {\n\t            type: Twig.token.type.output_whitespace_both,\n\t            open: '{{-',\n\t            close: '-}}'\n\t        },\n\t        {\n\t            type: Twig.token.type.logic_whitespace_pre,\n\t            open: '{%-',\n\t            close: '%}'\n\t        },\n\t        {\n\t            type: Twig.token.type.logic_whitespace_post,\n\t            open: '{%',\n\t            close: '-%}'\n\t        },\n\t        {\n\t            type: Twig.token.type.logic_whitespace_both,\n\t            open: '{%-',\n\t            close: '-%}'\n\t        },\n\t        // *Output type tokens*\n\t        //\n\t        // These typically take the form `{{ expression }}`.\n\t        {\n\t            type: Twig.token.type.output,\n\t            open: '{{',\n\t            close: '}}'\n\t        },\n\t        // *Logic type tokens*\n\t        //\n\t        // These typically take a form like `{% if expression %}` or `{% endif %}`\n\t        {\n\t            type: Twig.token.type.logic,\n\t            open: '{%',\n\t            close: '%}'\n\t        },\n\t        // *Comment type tokens*\n\t        //\n\t        // These take the form `{# anything #}`\n\t        {\n\t            type: Twig.token.type.comment,\n\t            open: '{#',\n\t            close: '#}'\n\t        }\n\t    ];\n\n\n\t    /**\n\t     * What characters start \"strings\" in token definitions. We need this to ignore token close\n\t     * strings inside an expression.\n\t     */\n\t    Twig.token.strings = ['\"', \"'\"];\n\n\t    Twig.token.findStart = function (template) {\n\t        var output = {\n\t                position: null,\n\t                close_position: null,\n\t                def: null\n\t            },\n\t            i,\n\t            token_template,\n\t            first_key_position,\n\t            close_key_position;\n\n\t        for (i=0;i<Twig.token.definitions.length;i++) {\n\t            token_template = Twig.token.definitions[i];\n\t            first_key_position = template.indexOf(token_template.open);\n\t            close_key_position = template.indexOf(token_template.close);\n\n\t            Twig.log.trace(\"Twig.token.findStart: \", \"Searching for \", token_template.open, \" found at \", first_key_position);\n\n\t            //Special handling for mismatched tokens\n\t            if (first_key_position >= 0) {\n\t                //This token matches the template\n\t                if (token_template.open.length !== token_template.close.length) {\n\t                    //This token has mismatched closing and opening tags\n\t                    if (close_key_position < 0) {\n\t                        //This token's closing tag does not match the template\n\t                        continue;\n\t                    }\n\t                }\n\t            }\n\t            // Does this token occur before any other types?\n\t            if (first_key_position >= 0 && (output.position === null || first_key_position < output.position)) {\n\t                output.position = first_key_position;\n\t                output.def = token_template;\n\t                output.close_position = close_key_position;\n\t            } else if (first_key_position >= 0 && output.position !== null && first_key_position === output.position) {\n\t                /*This token exactly matches another token,\n\t                greedily match to check if this token has a greater specificity*/\n\t                if (token_template.open.length > output.def.open.length) {\n\t                    //This token's opening tag is more specific than the previous match\n\t                    output.position = first_key_position;\n\t                    output.def = token_template;\n\t                    output.close_position = close_key_position;\n\t                } else if (token_template.open.length === output.def.open.length) {\n\t                    if (token_template.close.length > output.def.close.length) {\n\t                        //This token's opening tag is as specific as the previous match,\n\t                        //but the closing tag has greater specificity\n\t                        if (close_key_position >= 0 && close_key_position < output.close_position) {\n\t                            //This token's closing tag exists in the template,\n\t                            //and it occurs sooner than the previous match\n\t                            output.position = first_key_position;\n\t                            output.def = token_template;\n\t                            output.close_position = close_key_position;\n\t                        }\n\t                    } else if (close_key_position >= 0 && close_key_position < output.close_position) {\n\t                        //This token's closing tag is not more specific than the previous match,\n\t                        //but it occurs sooner than the previous match\n\t                        output.position = first_key_position;\n\t                        output.def = token_template;\n\t                        output.close_position = close_key_position;\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        delete output['close_position'];\n\n\t        return output;\n\t    };\n\n\t    Twig.token.findEnd = function (template, token_def, start) {\n\t        var end = null,\n\t            found = false,\n\t            offset = 0,\n\n\t            // String position variables\n\t            str_pos = null,\n\t            str_found = null,\n\t            pos = null,\n\t            end_offset = null,\n\t            this_str_pos = null,\n\t            end_str_pos = null,\n\n\t            // For loop variables\n\t            i,\n\t            l;\n\n\t        while (!found) {\n\t            str_pos = null;\n\t            str_found = null;\n\t            pos = template.indexOf(token_def.close, offset);\n\n\t            if (pos >= 0) {\n\t                end = pos;\n\t                found = true;\n\t            } else {\n\t                // throw an exception\n\t                throw new Twig.Error(\"Unable to find closing bracket '\" + token_def.close +\n\t                                \"'\" + \" opened near template position \" + start);\n\t            }\n\n\t            // Ignore quotes within comments; just look for the next comment close sequence,\n\t            // regardless of what comes before it. https://github.com/justjohn/twig.js/issues/95\n\t            if (token_def.type === Twig.token.type.comment) {\n\t              break;\n\t            }\n\t            // Ignore quotes within raw tag\n\t            // Fixes #283\n\t            if (token_def.type === Twig.token.type.raw) {\n\t                break;\n\t            }\n\n\t            l = Twig.token.strings.length;\n\t            for (i = 0; i < l; i += 1) {\n\t                this_str_pos = template.indexOf(Twig.token.strings[i], offset);\n\n\t                if (this_str_pos > 0 && this_str_pos < pos &&\n\t                        (str_pos === null || this_str_pos < str_pos)) {\n\t                    str_pos = this_str_pos;\n\t                    str_found = Twig.token.strings[i];\n\t                }\n\t            }\n\n\t            // We found a string before the end of the token, now find the string's end and set the search offset to it\n\t            if (str_pos !== null) {\n\t                end_offset = str_pos + 1;\n\t                end = null;\n\t                found = false;\n\t                while (true) {\n\t                    end_str_pos = template.indexOf(str_found, end_offset);\n\t                    if (end_str_pos < 0) {\n\t                        throw \"Unclosed string in template\";\n\t                    }\n\t                    // Ignore escaped quotes\n\t                    if (template.substr(end_str_pos - 1, 1) !== \"\\\\\") {\n\t                        offset = end_str_pos + 1;\n\t                        break;\n\t                    } else {\n\t                        end_offset = end_str_pos + 1;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return end;\n\t    };\n\n\t    /**\n\t     * Convert a template into high-level tokens.\n\t     */\n\t    Twig.tokenize = function (template) {\n\t        var tokens = [],\n\t            // An offset for reporting errors locations in the template.\n\t            error_offset = 0,\n\n\t            // The start and type of the first token found in the template.\n\t            found_token = null,\n\t            // The end position of the matched token.\n\t            end = null;\n\n\t        while (template.length > 0) {\n\t            // Find the first occurance of any token type in the template\n\t            found_token = Twig.token.findStart(template);\n\n\t            Twig.log.trace(\"Twig.tokenize: \", \"Found token: \", found_token);\n\n\t            if (found_token.position !== null) {\n\t                // Add a raw type token for anything before the start of the token\n\t                if (found_token.position > 0) {\n\t                    tokens.push({\n\t                        type: Twig.token.type.raw,\n\t                        value: template.substring(0, found_token.position)\n\t                    });\n\t                }\n\t                template = template.substr(found_token.position + found_token.def.open.length);\n\t                error_offset += found_token.position + found_token.def.open.length;\n\n\t                // Find the end of the token\n\t                end = Twig.token.findEnd(template, found_token.def, error_offset);\n\n\t                Twig.log.trace(\"Twig.tokenize: \", \"Token ends at \", end);\n\n\t                tokens.push({\n\t                    type:  found_token.def.type,\n\t                    value: template.substring(0, end).trim()\n\t                });\n\n\t                if (template.substr( end + found_token.def.close.length, 1 ) === \"\\n\") {\n\t                    switch (found_token.def.type) {\n\t                        case \"logic_whitespace_pre\":\n\t                        case \"logic_whitespace_post\":\n\t                        case \"logic_whitespace_both\":\n\t                        case \"logic\":\n\t                            // Newlines directly after logic tokens are ignored\n\t                            end += 1;\n\t                            break;\n\t                    }\n\t                }\n\n\t                template = template.substr(end + found_token.def.close.length);\n\n\t                // Increment the position in the template\n\t                error_offset += end + found_token.def.close.length;\n\n\t            } else {\n\t                // No more tokens -> add the rest of the template as a raw-type token\n\t                tokens.push({\n\t                    type: Twig.token.type.raw,\n\t                    value: template\n\t                });\n\t                template = '';\n\t            }\n\t        }\n\n\t        return tokens;\n\t    };\n\n\n\t    Twig.compile = function (tokens) {\n\t        try {\n\n\t            // Output and intermediate stacks\n\t            var output = [],\n\t                stack = [],\n\t                // The tokens between open and close tags\n\t                intermediate_output = [],\n\n\t                token = null,\n\t                logic_token = null,\n\t                unclosed_token = null,\n\t                // Temporary previous token.\n\t                prev_token = null,\n\t                // Temporary previous output.\n\t                prev_output = null,\n\t                // Temporary previous intermediate output.\n\t                prev_intermediate_output = null,\n\t                // The previous token's template\n\t                prev_template = null,\n\t                // Token lookahead\n\t                next_token = null,\n\t                // The output token\n\t                tok_output = null,\n\n\t                // Logic Token values\n\t                type = null,\n\t                open = null,\n\t                next = null;\n\n\t            var compile_output = function(token) {\n\t                Twig.expression.compile.apply(this, [token]);\n\t                if (stack.length > 0) {\n\t                    intermediate_output.push(token);\n\t                } else {\n\t                    output.push(token);\n\t                }\n\t            };\n\n\t            var compile_logic = function(token) {\n\t                // Compile the logic token\n\t                logic_token = Twig.logic.compile.apply(this, [token]);\n\n\t                type = logic_token.type;\n\t                open = Twig.logic.handler[type].open;\n\t                next = Twig.logic.handler[type].next;\n\n\t                Twig.log.trace(\"Twig.compile: \", \"Compiled logic token to \", logic_token,\n\t                                                 \" next is: \", next, \" open is : \", open);\n\n\t                // Not a standalone token, check logic stack to see if this is expected\n\t                if (open !== undefined && !open) {\n\t                    prev_token = stack.pop();\n\t                    prev_template = Twig.logic.handler[prev_token.type];\n\n\t                    if (Twig.indexOf(prev_template.next, type) < 0) {\n\t                        throw new Error(type + \" not expected after a \" + prev_token.type);\n\t                    }\n\n\t                    prev_token.output = prev_token.output || [];\n\n\t                    prev_token.output = prev_token.output.concat(intermediate_output);\n\t                    intermediate_output = [];\n\n\t                    tok_output = {\n\t                        type: Twig.token.type.logic,\n\t                        token: prev_token\n\t                    };\n\t                    if (stack.length > 0) {\n\t                        intermediate_output.push(tok_output);\n\t                    } else {\n\t                        output.push(tok_output);\n\t                    }\n\t                }\n\n\t                // This token requires additional tokens to complete the logic structure.\n\t                if (next !== undefined && next.length > 0) {\n\t                    Twig.log.trace(\"Twig.compile: \", \"Pushing \", logic_token, \" to logic stack.\");\n\n\t                    if (stack.length > 0) {\n\t                        // Put any currently held output into the output list of the logic operator\n\t                        // currently at the head of the stack before we push a new one on.\n\t                        prev_token = stack.pop();\n\t                        prev_token.output = prev_token.output || [];\n\t                        prev_token.output = prev_token.output.concat(intermediate_output);\n\t                        stack.push(prev_token);\n\t                        intermediate_output = [];\n\t                    }\n\n\t                    // Push the new logic token onto the logic stack\n\t                    stack.push(logic_token);\n\n\t                } else if (open !== undefined && open) {\n\t                    tok_output = {\n\t                        type: Twig.token.type.logic,\n\t                        token: logic_token\n\t                    };\n\t                    // Standalone token (like {% set ... %}\n\t                    if (stack.length > 0) {\n\t                        intermediate_output.push(tok_output);\n\t                    } else {\n\t                        output.push(tok_output);\n\t                    }\n\t                }\n\t            };\n\n\t            while (tokens.length > 0) {\n\t                token = tokens.shift();\n\t                prev_output = output[output.length - 1];\n\t                prev_intermediate_output = intermediate_output[intermediate_output.length - 1];\n\t                next_token = tokens[0];\n\t                Twig.log.trace(\"Compiling token \", token);\n\t                switch (token.type) {\n\t                    case Twig.token.type.raw:\n\t                        if (stack.length > 0) {\n\t                            intermediate_output.push(token);\n\t                        } else {\n\t                            output.push(token);\n\t                        }\n\t                        break;\n\n\t                    case Twig.token.type.logic:\n\t                        compile_logic.call(this, token);\n\t                        break;\n\n\t                    // Do nothing, comments should be ignored\n\t                    case Twig.token.type.comment:\n\t                        break;\n\n\t                    case Twig.token.type.output:\n\t                        compile_output.call(this, token);\n\t                        break;\n\n\t                    //Kill whitespace ahead and behind this token\n\t                    case Twig.token.type.logic_whitespace_pre:\n\t                    case Twig.token.type.logic_whitespace_post:\n\t                    case Twig.token.type.logic_whitespace_both:\n\t                    case Twig.token.type.output_whitespace_pre:\n\t                    case Twig.token.type.output_whitespace_post:\n\t                    case Twig.token.type.output_whitespace_both:\n\t                        if (token.type !== Twig.token.type.output_whitespace_post && token.type !== Twig.token.type.logic_whitespace_post) {\n\t                            if (prev_output) {\n\t                                //If the previous output is raw, pop it off\n\t                                if (prev_output.type === Twig.token.type.raw) {\n\t                                    output.pop();\n\n\t                                    //If the previous output is not just whitespace, trim it\n\t                                    if (prev_output.value.match(/^\\s*$/) === null) {\n\t                                        prev_output.value = prev_output.value.trim();\n\t                                        //Repush the previous output\n\t                                        output.push(prev_output);\n\t                                    }\n\t                                }\n\t                            }\n\n\t                            if (prev_intermediate_output) {\n\t                                //If the previous intermediate output is raw, pop it off\n\t                                if (prev_intermediate_output.type === Twig.token.type.raw) {\n\t                                    intermediate_output.pop();\n\n\t                                    //If the previous output is not just whitespace, trim it\n\t                                    if (prev_intermediate_output.value.match(/^\\s*$/) === null) {\n\t                                        prev_intermediate_output.value = prev_intermediate_output.value.trim();\n\t                                        //Repush the previous intermediate output\n\t                                        intermediate_output.push(prev_intermediate_output);\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\n\t                        //Compile this token\n\t                        switch (token.type) {\n\t                            case Twig.token.type.output_whitespace_pre:\n\t                            case Twig.token.type.output_whitespace_post:\n\t                            case Twig.token.type.output_whitespace_both:\n\t                                compile_output.call(this, token);\n\t                                break;\n\t                            case Twig.token.type.logic_whitespace_pre:\n\t                            case Twig.token.type.logic_whitespace_post:\n\t                            case Twig.token.type.logic_whitespace_both:\n\t                                compile_logic.call(this, token);\n\t                                break;\n\t                        }\n\n\t                        if (token.type !== Twig.token.type.output_whitespace_pre && token.type !== Twig.token.type.logic_whitespace_pre) {\n\t                            if (next_token) {\n\t                                //If the next token is raw, shift it out\n\t                                if (next_token.type === Twig.token.type.raw) {\n\t                                    tokens.shift();\n\n\t                                    //If the next token is not just whitespace, trim it\n\t                                    if (next_token.value.match(/^\\s*$/) === null) {\n\t                                        next_token.value = next_token.value.trim();\n\t                                        //Unshift the next token\n\t                                        tokens.unshift(next_token);\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\n\t                        break;\n\t                }\n\n\t                Twig.log.trace(\"Twig.compile: \", \" Output: \", output,\n\t                                                 \" Logic Stack: \", stack,\n\t                                                 \" Pending Output: \", intermediate_output );\n\t            }\n\n\t            // Verify that there are no logic tokens left in the stack.\n\t            if (stack.length > 0) {\n\t                unclosed_token = stack.pop();\n\t                throw new Error(\"Unable to find an end tag for \" + unclosed_token.type +\n\t                                \", expecting one of \" + unclosed_token.next);\n\t            }\n\t            return output;\n\t        } catch (ex) {\n\t            if (this.options.rethrow) {\n\t                if (ex.type == 'TwigException' && !ex.file) {\n\t                    ex.file = this.id;\n\t                }\n\n\t                throw ex\n\t            }\n\t            else {\n\t                Twig.log.error(\"Error compiling twig template \" + this.id + \": \");\n\t                if (ex.stack) {\n\t                    Twig.log.error(ex.stack);\n\t                } else {\n\t                    Twig.log.error(ex.toString());\n\t                }\n\t            }\n\t        }\n\t    };\n\n\t    /**\n\t     * Parse a compiled template.\n\t     *\n\t     * @param {Array} tokens The compiled tokens.\n\t     * @param {Object} context The render context.\n\t     *\n\t     * @return {string} The parsed template.\n\t     */\n\t    Twig.parse = function (tokens, context, allow_async) {\n\t        var that = this,\n\t            output = [],\n\n\t            // Store any error that might be thrown by the promise chain.\n\t            err = null,\n\n\t            // This will be set to is_async if template renders synchronously\n\t            is_async = true,\n\t            promise = null,\n\n\t            // Track logic chains\n\t            chain = true;\n\n\n\t        function handleException(ex) {\n\t            if (that.options.rethrow) {\n\t                if (typeof ex === 'string') {\n\t                    ex = new Twig.Error(ex)\n\t                }\n\n\t                if (ex.type == 'TwigException' && !ex.file) {\n\t                    ex.file = that.id;\n\t                }\n\n\t                throw ex;\n\t            }\n\t            else {\n\t                Twig.log.error(\"Error parsing twig template \" + that.id + \": \");\n\t                if (ex.stack) {\n\t                    Twig.log.error(ex.stack);\n\t                } else {\n\t                    Twig.log.error(ex.toString());\n\t                }\n\n\t                if (Twig.debug) {\n\t                    return ex.toString();\n\t                }\n\t            }\n\t        }\n\n\t        promise = Twig.async.forEach(tokens, function parseToken(token) {\n\t            Twig.log.debug(\"Twig.parse: \", \"Parsing token: \", token);\n\n\t            switch (token.type) {\n\t                case Twig.token.type.raw:\n\t                    output.push(Twig.filters.raw(token.value));\n\t                    break;\n\n\t                case Twig.token.type.logic:\n\t                    var logic_token = token.token;\n\n\t                    return Twig.logic.parseAsync.apply(that, [logic_token, context, chain])\n\t                    .then(function(logic) {\n\t                        if (logic.chain !== undefined) {\n\t                            chain = logic.chain;\n\t                        }\n\t                        if (logic.context !== undefined) {\n\t                            context = logic.context;\n\t                        }\n\t                        if (logic.output !== undefined) {\n\t                            output.push(logic.output);\n\t                        }\n\t                    });\n\t                    break;\n\n\t                case Twig.token.type.comment:\n\t                    // Do nothing, comments should be ignored\n\t                    break;\n\n\t                //Fall through whitespace to output\n\t                case Twig.token.type.output_whitespace_pre:\n\t                case Twig.token.type.output_whitespace_post:\n\t                case Twig.token.type.output_whitespace_both:\n\t                case Twig.token.type.output:\n\t                    Twig.log.debug(\"Twig.parse: \", \"Output token: \", token.stack);\n\t                    // Parse the given expression in the given context\n\t                    return Twig.expression.parseAsync.apply(that, [token.stack, context])\n\t                    .then(function(o) {\n\t                        output.push(o);\n\t                    });\n\t            }\n\t        })\n\t        .then(function() {\n\t            output = Twig.output.apply(that, [output]);\n\t            is_async = false;\n\t            return output;\n\t        })\n\t        .catch(function(e) {\n\t            if (allow_async)\n\t                handleException(e);\n\n\t            err = e;\n\t        });\n\n\t        // If `allow_async` we will always return a promise since we do not\n\t        // know in advance if we are going to run asynchronously or not.\n\t        if (allow_async)\n\t            return promise;\n\n\t        // Handle errors here if we fail synchronously.\n\t        if (err !== null)\n\t            return handleException(err);\n\n\t        // If `allow_async` is not true we should not allow the user\n\t        // to use asynchronous functions or filters.\n\t        if (is_async)\n\t            throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t        return output;\n\t    };\n\n\t    /**\n\t     * Tokenize and compile a string template.\n\t     *\n\t     * @param {string} data The template.\n\t     *\n\t     * @return {Array} The compiled tokens.\n\t     */\n\t    Twig.prepare = function(data) {\n\t        var tokens, raw_tokens;\n\n\t        // Tokenize\n\t        Twig.log.debug(\"Twig.prepare: \", \"Tokenizing \", data);\n\t        raw_tokens = Twig.tokenize.apply(this, [data]);\n\n\t        // Compile\n\t        Twig.log.debug(\"Twig.prepare: \", \"Compiling \", raw_tokens);\n\t        tokens = Twig.compile.apply(this, [raw_tokens]);\n\n\t        Twig.log.debug(\"Twig.prepare: \", \"Compiled \", tokens);\n\n\t        return tokens;\n\t    };\n\n\t    /**\n\t     * Join the output token's stack and escape it if needed\n\t     *\n\t     * @param {Array} Output token's stack\n\t     *\n\t     * @return {string|String} Autoescaped output\n\t     */\n\t    Twig.output = function(output) {\n\t        if (!this.options.autoescape) {\n\t            return output.join(\"\");\n\t        }\n\n\t        var strategy = 'html';\n\t        if(typeof this.options.autoescape == 'string')\n\t            strategy = this.options.autoescape;\n\n\t        // [].map would be better but it's not supported by IE8-\n\t        var escaped_output = [];\n\t        Twig.forEach(output, function (str) {\n\t            if (str && (str.twig_markup !== true && str.twig_markup != strategy)) {\n\t                str = Twig.filters.escape(str, [ strategy ]);\n\t            }\n\t            escaped_output.push(str);\n\t        });\n\t        return Twig.Markup(escaped_output.join(\"\"));\n\t    }\n\n\t    // Namespace for template storage and retrieval\n\t    Twig.Templates = {\n\t        /**\n\t         * Registered template loaders - use Twig.Templates.registerLoader to add supported loaders\n\t         * @type {Object}\n\t         */\n\t        loaders: {},\n\n\t        /**\n\t         * Registered template parsers - use Twig.Templates.registerParser to add supported parsers\n\t         * @type {Object}\n\t         */\n\t        parsers: {},\n\n\t        /**\n\t         * Cached / loaded templates\n\t         * @type {Object}\n\t         */\n\t        registry: {}\n\t    };\n\n\t    /**\n\t     * Is this id valid for a twig template?\n\t     *\n\t     * @param {string} id The ID to check.\n\t     *\n\t     * @throws {Twig.Error} If the ID is invalid or used.\n\t     * @return {boolean} True if the ID is valid.\n\t     */\n\t    Twig.validateId = function(id) {\n\t        if (id === \"prototype\") {\n\t            throw new Twig.Error(id + \" is not a valid twig identifier\");\n\t        } else if (Twig.cache && Twig.Templates.registry.hasOwnProperty(id)) {\n\t            throw new Twig.Error(\"There is already a template with the ID \" + id);\n\t        }\n\t        return true;\n\t    }\n\n\t    /**\n\t     * Register a template loader\n\t     *\n\t     * @example\n\t     * Twig.extend(function(Twig) {\n\t     *    Twig.Templates.registerLoader('custom_loader', function(location, params, callback, error_callback) {\n\t     *        // ... load the template ...\n\t     *        params.data = loadedTemplateData;\n\t     *        // create and return the template\n\t     *        var template = new Twig.Template(params);\n\t     *        if (typeof callback === 'function') {\n\t     *            callback(template);\n\t     *        }\n\t     *        return template;\n\t     *    });\n\t     * });\n\t     *\n\t     * @param {String} method_name The method this loader is intended for (ajax, fs)\n\t     * @param {Function} func The function to execute when loading the template\n\t     * @param {Object|undefined} scope Optional scope parameter to bind func to\n\t     *\n\t     * @throws Twig.Error\n\t     *\n\t     * @return {void}\n\t     */\n\t    Twig.Templates.registerLoader = function(method_name, func, scope) {\n\t        if (typeof func !== 'function') {\n\t            throw new Twig.Error('Unable to add loader for ' + method_name + ': Invalid function reference given.');\n\t        }\n\t        if (scope) {\n\t            func = func.bind(scope);\n\t        }\n\t        this.loaders[method_name] = func;\n\t    };\n\n\t    /**\n\t     * Remove a registered loader\n\t     *\n\t     * @param {String} method_name The method name for the loader you wish to remove\n\t     *\n\t     * @return {void}\n\t     */\n\t    Twig.Templates.unRegisterLoader = function(method_name) {\n\t        if (this.isRegisteredLoader(method_name)) {\n\t            delete this.loaders[method_name];\n\t        }\n\t    };\n\n\t    /**\n\t     * See if a loader is registered by its method name\n\t     *\n\t     * @param {String} method_name The name of the loader you are looking for\n\t     *\n\t     * @return {boolean}\n\t     */\n\t    Twig.Templates.isRegisteredLoader = function(method_name) {\n\t        return this.loaders.hasOwnProperty(method_name);\n\t    };\n\n\t    /**\n\t     * Register a template parser\n\t     *\n\t     * @example\n\t     * Twig.extend(function(Twig) {\n\t     *    Twig.Templates.registerParser('custom_parser', function(params) {\n\t     *        // this template source can be accessed in params.data\n\t     *        var template = params.data\n\t     *\n\t     *        // ... custom process that modifies the template\n\t     *\n\t     *        // return the parsed template\n\t     *        return template;\n\t     *    });\n\t     * });\n\t     *\n\t     * @param {String} method_name The method this parser is intended for (twig, source)\n\t     * @param {Function} func The function to execute when parsing the template\n\t     * @param {Object|undefined} scope Optional scope parameter to bind func to\n\t     *\n\t     * @throws Twig.Error\n\t     *\n\t     * @return {void}\n\t     */\n\t    Twig.Templates.registerParser = function(method_name, func, scope) {\n\t        if (typeof func !== 'function') {\n\t            throw new Twig.Error('Unable to add parser for ' + method_name + ': Invalid function regerence given.');\n\t        }\n\n\t        if (scope) {\n\t            func = func.bind(scope);\n\t        }\n\n\t        this.parsers[method_name] = func;\n\t    };\n\n\t    /**\n\t     * Remove a registered parser\n\t     *\n\t     * @param {String} method_name The method name for the parser you wish to remove\n\t     *\n\t     * @return {void}\n\t     */\n\t    Twig.Templates.unRegisterParser = function(method_name) {\n\t        if (this.isRegisteredParser(method_name)) {\n\t            delete this.parsers[method_name];\n\t        }\n\t    };\n\n\t    /**\n\t     * See if a parser is registered by its method name\n\t     *\n\t     * @param {String} method_name The name of the parser you are looking for\n\t     *\n\t     * @return {boolean}\n\t     */\n\t    Twig.Templates.isRegisteredParser = function(method_name) {\n\t        return this.parsers.hasOwnProperty(method_name);\n\t    };\n\n\t    /**\n\t     * Save a template object to the store.\n\t     *\n\t     * @param {Twig.Template} template   The twig.js template to store.\n\t     */\n\t    Twig.Templates.save = function(template) {\n\t        if (template.id === undefined) {\n\t            throw new Twig.Error(\"Unable to save template with no id\");\n\t        }\n\t        Twig.Templates.registry[template.id] = template;\n\t    };\n\n\t    /**\n\t     * Load a previously saved template from the store.\n\t     *\n\t     * @param {string} id   The ID of the template to load.\n\t     *\n\t     * @return {Twig.Template} A twig.js template stored with the provided ID.\n\t     */\n\t    Twig.Templates.load = function(id) {\n\t        if (!Twig.Templates.registry.hasOwnProperty(id)) {\n\t            return null;\n\t        }\n\t        return Twig.Templates.registry[id];\n\t    };\n\n\t    /**\n\t     * Load a template from a remote location using AJAX and saves in with the given ID.\n\t     *\n\t     * Available parameters:\n\t     *\n\t     *      async:       Should the HTTP request be performed asynchronously.\n\t     *                      Defaults to true.\n\t     *      method:      What method should be used to load the template\n\t     *                      (fs or ajax)\n\t     *      parser:      What method should be used to parse the template\n\t     *                      (twig or source)\n\t     *      precompiled: Has the template already been compiled.\n\t     *\n\t     * @param {string} location  The remote URL to load as a template.\n\t     * @param {Object} params The template parameters.\n\t     * @param {function} callback  A callback triggered when the template finishes loading.\n\t     * @param {function} error_callback  A callback triggered if an error occurs loading the template.\n\t     *\n\t     *\n\t     */\n\t    Twig.Templates.loadRemote = function(location, params, callback, error_callback) {\n\t        var loader;\n\n\t        // Default to async\n\t        if (params.async === undefined) {\n\t            params.async = true;\n\t        }\n\n\t        // Default to the URL so the template is cached.\n\t        if (params.id === undefined) {\n\t            params.id = location;\n\t        }\n\n\t        // Check for existing template\n\t        if (Twig.cache && Twig.Templates.registry.hasOwnProperty(params.id)) {\n\t            // A template is already saved with the given id.\n\t            if (typeof callback === 'function') {\n\t                callback(Twig.Templates.registry[params.id]);\n\t            }\n\t            // TODO: if async, return deferred promise\n\t            return Twig.Templates.registry[params.id];\n\t        }\n\n\t        //if the parser name hasn't been set, default it to twig\n\t        params.parser = params.parser || 'twig';\n\n\t        // Assume 'fs' if the loader is not defined\n\t        loader = this.loaders[params.method] || this.loaders.fs;\n\t        return loader.apply(this, arguments);\n\t    };\n\n\t    // Determine object type\n\t    function is(type, obj) {\n\t        var clas = Object.prototype.toString.call(obj).slice(8, -1);\n\t        return obj !== undefined && obj !== null && clas === type;\n\t    }\n\n\t    /**\n\t     * Create a new twig.js template.\n\t     *\n\t     * Parameters: {\n\t     *      data:   The template, either pre-compiled tokens or a string template\n\t     *      id:     The name of this template\n\t     *      blocks: Any pre-existing block from a child template\n\t     * }\n\t     *\n\t     * @param {Object} params The template parameters.\n\t     */\n\t    Twig.Template = function ( params ) {\n\t        var data = params.data,\n\t            id = params.id,\n\t            blocks = params.blocks,\n\t            macros = params.macros || {},\n\t            base = params.base,\n\t            path = params.path,\n\t            url = params.url,\n\t            name = params.name,\n\t            method = params.method,\n\t            // parser options\n\t            options = params.options;\n\n\t        // # What is stored in a Twig.Template\n\t        //\n\t        // The Twig Template hold several chucks of data.\n\t        //\n\t        //     {\n\t        //          id:     The token ID (if any)\n\t        //          tokens: The list of tokens that makes up this template.\n\t        //          blocks: The list of block this template contains.\n\t        //          base:   The base template (if any)\n\t        //            options:  {\n\t        //                Compiler/parser options\n\t        //\n\t        //                strict_variables: true/false\n\t        //                    Should missing variable/keys emit an error message. If false, they default to null.\n\t        //            }\n\t        //     }\n\t        //\n\n\t        this.id     = id;\n\t        this.method = method;\n\t        this.base   = base;\n\t        this.path   = path;\n\t        this.url    = url;\n\t        this.name   = name;\n\t        this.macros = macros;\n\t        this.options = options;\n\n\t        this.reset(blocks);\n\n\t        if (is('String', data)) {\n\t            this.tokens = Twig.prepare.apply(this, [data]);\n\t        } else {\n\t            this.tokens = data;\n\t        }\n\n\t        if (id !== undefined) {\n\t            Twig.Templates.save(this);\n\t        }\n\t    };\n\n\t    Twig.Template.prototype.reset = function(blocks) {\n\t        Twig.log.debug(\"Twig.Template.reset\", \"Reseting template \" + this.id);\n\t        this.blocks = {};\n\t        this.importedBlocks = [];\n\t        this.originalBlockTokens = {};\n\t        this.child = {\n\t            blocks: blocks || {}\n\t        };\n\t        this.extend = null;\n\t    };\n\n\t    Twig.Template.prototype.render = function (context, params, allow_async) {\n\t        params = params || {};\n\n\t        var that = this,\n\n\t            // Store any error that might be thrown by the promise chain.\n\t            err = null,\n\n\t            // This will be set to is_async if template renders synchronously\n\t            is_async = true,\n\t            promise = null,\n\n\t            result,\n\t            url;\n\n\t        this.context = context || {};\n\n\t        // Clear any previous state\n\t        this.reset();\n\t        if (params.blocks) {\n\t            this.blocks = params.blocks;\n\t        }\n\t        if (params.macros) {\n\t            this.macros = params.macros;\n\t        }\n\n\t        var cb = function(output) {\n\t            // Does this template extend another\n\t            if (that.extend) {\n\t                var ext_template;\n\n\t                // check if the template is provided inline\n\t                if ( that.options.allowInlineIncludes ) {\n\t                    ext_template = Twig.Templates.load(that.extend);\n\t                    if ( ext_template ) {\n\t                        ext_template.options = that.options;\n\t                    }\n\t                }\n\n\t                // check for the template file via include\n\t                if (!ext_template) {\n\t                    url = Twig.path.parsePath(that, that.extend);\n\n\t                    ext_template = Twig.Templates.loadRemote(url, {\n\t                        method: that.getLoaderMethod(),\n\t                        base: that.base,\n\t                        async:  false,\n\t                        id:     url,\n\t                        options: that.options\n\t                    });\n\t                }\n\n\t                that.parent = ext_template;\n\n\t                return that.parent.renderAsync(that.context, {\n\t                    blocks: that.blocks\n\t                });\n\t            }\n\n\t            if (params.output == 'blocks') {\n\t                return that.blocks;\n\t            } else if (params.output == 'macros') {\n\t                return that.macros;\n\t            } else {\n\t                return output;\n\t            }\n\t        };\n\n\t        promise = Twig.parseAsync.apply(this, [this.tokens, this.context])\n\t        .then(cb)\n\t        .then(function(v) {\n\t            is_async = false;\n\t            result = v;\n\t            return v;\n\t        })\n\t        .catch(function(e) {\n\t            if (allow_async)\n\t                throw e;\n\n\t            err = e;\n\t        })\n\n\t        // If `allow_async` we will always return a promise since we do not\n\t        // know in advance if we are going to run asynchronously or not.\n\t        if (allow_async)\n\t            return promise;\n\n\t        // Handle errors here if we fail synchronously.\n\t        if (err !== null)\n\t            throw err;\n\n\t        // If `allow_async` is not true we should not allow the user\n\t        // to use asynchronous functions or filters.\n\t        if (is_async)\n\t            throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t        return result;\n\t    };\n\n\t    Twig.Template.prototype.importFile = function(file) {\n\t        var url, sub_template;\n\t        if (!this.url && this.options.allowInlineIncludes) {\n\t            file = this.path ? Twig.path.parsePath(this, file) : file;\n\t            sub_template = Twig.Templates.load(file);\n\n\t            if (!sub_template) {\n\t                sub_template = Twig.Templates.loadRemote(url, {\n\t                    id: file,\n\t                    method: this.getLoaderMethod(),\n\t                    async: false,\n\t                    path: file,\n\t                    options: this.options\n\t                });\n\n\t                if (!sub_template) {\n\t                    throw new Twig.Error(\"Unable to find the template \" + file);\n\t                }\n\t            }\n\n\t            sub_template.options = this.options;\n\n\t            return sub_template;\n\t        }\n\n\t        url = Twig.path.parsePath(this, file);\n\n\t        // Load blocks from an external file\n\t        sub_template = Twig.Templates.loadRemote(url, {\n\t            method: this.getLoaderMethod(),\n\t            base: this.base,\n\t            async: false,\n\t            options: this.options,\n\t            id: url\n\t        });\n\n\t        return sub_template;\n\t    };\n\n\t    Twig.Template.prototype.importBlocks = function(file, override) {\n\t        var sub_template = this.importFile(file),\n\t            context = this.context,\n\t            that = this,\n\t            key;\n\n\t        override = override || false;\n\n\t        sub_template.render(context);\n\n\t        // Mixin blocks\n\t        Twig.forEach(Object.keys(sub_template.blocks), function(key) {\n\t            if (override || that.blocks[key] === undefined) {\n\t                that.blocks[key] = sub_template.blocks[key];\n\t                that.importedBlocks.push(key);\n\t            }\n\t        });\n\t    };\n\n\t    Twig.Template.prototype.importMacros = function(file) {\n\t        var url = Twig.path.parsePath(this, file);\n\n\t        // load remote template\n\t        var remoteTemplate = Twig.Templates.loadRemote(url, {\n\t            method: this.getLoaderMethod(),\n\t            async: false,\n\t            id: url\n\t        });\n\n\t        return remoteTemplate;\n\t    };\n\n\t    Twig.Template.prototype.getLoaderMethod = function() {\n\t        if (this.path) {\n\t            return 'fs';\n\t        }\n\t        if (this.url) {\n\t            return 'ajax';\n\t        }\n\t        return this.method || 'fs';\n\t    };\n\n\t    Twig.Template.prototype.compile = function(options) {\n\t        // compile the template into raw JS\n\t        return Twig.compiler.compile(this, options);\n\t    };\n\n\t    /**\n\t     * Create safe output\n\t     *\n\t     * @param {string} Content safe to output\n\t     *\n\t     * @return {String} Content wrapped into a String\n\t     */\n\n\t    Twig.Markup = function(content, strategy) {\n\t        if(typeof strategy == 'undefined') {\n\t            strategy = true;\n\t        }\n\n\t        if (typeof content === 'string' && content.length > 0) {\n\t            content = new String(content);\n\t            content.twig_markup = strategy;\n\t        }\n\t        return content;\n\t    };\n\n\t    return Twig;\n\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// ## twig.compiler.js\n\t//\n\t// This file handles compiling templates into JS\n\tmodule.exports = function (Twig) {\n\t    /**\n\t     * Namespace for compilation.\n\t     */\n\t    Twig.compiler = {\n\t        module: {}\n\t    };\n\n\t    // Compile a Twig Template to output.\n\t    Twig.compiler.compile = function(template, options) {\n\t        // Get tokens\n\t        var tokens = JSON.stringify(template.tokens)\n\t            , id = template.id\n\t            , output;\n\n\t        if (options.module) {\n\t            if (Twig.compiler.module[options.module] === undefined) {\n\t                throw new Twig.Error(\"Unable to find module type \" + options.module);\n\t            }\n\t            output = Twig.compiler.module[options.module](id, tokens, options.twig);\n\t        } else {\n\t            output = Twig.compiler.wrap(id, tokens);\n\t        }\n\t        return output;\n\t    };\n\n\t    Twig.compiler.module = {\n\t        amd: function(id, tokens, pathToTwig) {\n\t            return 'define([\"' + pathToTwig + '\"], function (Twig) {\\n\\tvar twig, templates;\\ntwig = Twig.twig;\\ntemplates = ' + Twig.compiler.wrap(id, tokens) + '\\n\\treturn templates;\\n});';\n\t        }\n\t        , node: function(id, tokens) {\n\t            return 'var twig = require(\"twig\").twig;\\n'\n\t                + 'exports.template = ' + Twig.compiler.wrap(id, tokens)\n\t        }\n\t        , cjs2: function(id, tokens, pathToTwig) {\n\t            return 'module.declare([{ twig: \"' + pathToTwig + '\" }], function (require, exports, module) {\\n'\n\t                        + '\\tvar twig = require(\"twig\").twig;\\n'\n\t                        + '\\texports.template = ' + Twig.compiler.wrap(id, tokens)\n\t                    + '\\n});'\n\t        }\n\t    };\n\n\t    Twig.compiler.wrap = function(id, tokens) {\n\t        return 'twig({id:\"'+id.replace('\"', '\\\\\"')+'\", data:'+tokens+', precompiled: true});\\n';\n\t    };\n\n\t    return Twig;\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// ## twig.expression.js\n\t//\n\t// This file handles tokenizing, compiling and parsing expressions.\n\tmodule.exports = function (Twig) {\n\t    \"use strict\";\n\n\t    function parseParams(thisArg, params, context) {\n\t        if (params)\n\t            return Twig.expression.parseAsync.apply(thisArg, [params, context]);\n\n\t        return Twig.Promise.resolve(false);\n\t    }\n\n\t    /**\n\t     * Namespace for expression handling.\n\t     */\n\t    Twig.expression = { };\n\n\t    __webpack_require__(4)(Twig);\n\n\t    /**\n\t     * Reserved word that can't be used as variable names.\n\t     */\n\t    Twig.expression.reservedWords = [\n\t        \"true\", \"false\", \"null\", \"TRUE\", \"FALSE\", \"NULL\", \"_context\", \"and\", \"b-and\", \"or\", \"b-or\", \"b-xor\", \"in\", \"not in\", \"if\"\n\t    ];\n\n\t    /**\n\t     * The type of tokens used in expressions.\n\t     */\n\t    Twig.expression.type = {\n\t        comma:      'Twig.expression.type.comma',\n\t        operator: {\n\t            unary:  'Twig.expression.type.operator.unary',\n\t            binary: 'Twig.expression.type.operator.binary'\n\t        },\n\t        string:     'Twig.expression.type.string',\n\t        bool:       'Twig.expression.type.bool',\n\t        slice:      'Twig.expression.type.slice',\n\t        array: {\n\t            start:  'Twig.expression.type.array.start',\n\t            end:    'Twig.expression.type.array.end'\n\t        },\n\t        object: {\n\t            start:  'Twig.expression.type.object.start',\n\t            end:    'Twig.expression.type.object.end'\n\t        },\n\t        parameter: {\n\t            start:  'Twig.expression.type.parameter.start',\n\t            end:    'Twig.expression.type.parameter.end'\n\t        },\n\t        subexpression: {\n\t            start:  'Twig.expression.type.subexpression.start',\n\t            end:    'Twig.expression.type.subexpression.end'\n\t        },\n\t        key: {\n\t            period:   'Twig.expression.type.key.period',\n\t            brackets: 'Twig.expression.type.key.brackets'\n\t        },\n\t        filter:     'Twig.expression.type.filter',\n\t        _function:  'Twig.expression.type._function',\n\t        variable:   'Twig.expression.type.variable',\n\t        number:     'Twig.expression.type.number',\n\t        _null:     'Twig.expression.type.null',\n\t        context:    'Twig.expression.type.context',\n\t        test:       'Twig.expression.type.test'\n\t    };\n\n\t    Twig.expression.set = {\n\t        // What can follow an expression (in general)\n\t        operations: [\n\t            Twig.expression.type.filter,\n\t            Twig.expression.type.operator.unary,\n\t            Twig.expression.type.operator.binary,\n\t            Twig.expression.type.array.end,\n\t            Twig.expression.type.object.end,\n\t            Twig.expression.type.parameter.end,\n\t            Twig.expression.type.subexpression.end,\n\t            Twig.expression.type.comma,\n\t            Twig.expression.type.test\n\t        ],\n\t        expressions: [\n\t            Twig.expression.type._function,\n\t            Twig.expression.type.bool,\n\t            Twig.expression.type.string,\n\t            Twig.expression.type.variable,\n\t            Twig.expression.type.number,\n\t            Twig.expression.type._null,\n\t            Twig.expression.type.context,\n\t            Twig.expression.type.parameter.start,\n\t            Twig.expression.type.array.start,\n\t            Twig.expression.type.object.start,\n\t            Twig.expression.type.subexpression.start,\n\t            Twig.expression.type.operator.unary\n\t        ]\n\t    };\n\n\t    // Most expressions allow a '.' or '[' after them, so we provide a convenience set\n\t    Twig.expression.set.operations_extended = Twig.expression.set.operations.concat([\n\t                    Twig.expression.type.key.period,\n\t                    Twig.expression.type.key.brackets,\n\t                    Twig.expression.type.slice]);\n\n\t    // Some commonly used compile and parse functions.\n\t    Twig.expression.fn = {\n\t        compile: {\n\t            push: function(token, stack, output) {\n\t                output.push(token);\n\t            },\n\t            push_both: function(token, stack, output) {\n\t                output.push(token);\n\t                stack.push(token);\n\t            }\n\t        },\n\t        parse: {\n\t            push: function(token, stack, context) {\n\t                stack.push(token);\n\t            },\n\t            push_value: function(token, stack, context) {\n\t                stack.push(token.value);\n\t            }\n\t        }\n\t    };\n\n\t    // The regular expressions and compile/parse logic used to match tokens in expressions.\n\t    //\n\t    // Properties:\n\t    //\n\t    //      type:  The type of expression this matches\n\t    //\n\t    //      regex: One or more regular expressions that matche the format of the token.\n\t    //\n\t    //      next:  Valid tokens that can occur next in the expression.\n\t    //\n\t    // Functions:\n\t    //\n\t    //      compile: A function that compiles the raw regular expression match into a token.\n\t    //\n\t    //      parse:   A function that parses the compiled token into output.\n\t    //\n\t    Twig.expression.definitions = [\n\t        {\n\t            type: Twig.expression.type.test,\n\t            regex: /^is\\s+(not)?\\s*([a-zA-Z_][a-zA-Z0-9_]*(\\s?as)?)/,\n\t            next: Twig.expression.set.operations.concat([Twig.expression.type.parameter.start]),\n\t            compile: function(token, stack, output) {\n\t                token.filter   = token.match[2];\n\t                token.modifier = token.match[1];\n\t                delete token.match;\n\t                delete token.value;\n\t                output.push(token);\n\t            },\n\t            parse: function(token, stack, context) {\n\t                var value = stack.pop();\n\n\t                return parseParams(this, token.params, context)\n\t                .then(function(params) {\n\t                    var result = Twig.test(token.filter, value, params);\n\n\t                    if (token.modifier == 'not') {\n\t                        stack.push(!result);\n\t                    } else {\n\t                        stack.push(result);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t        {\n\t            type: Twig.expression.type.comma,\n\t            // Match a comma\n\t            regex: /^,/,\n\t            next: Twig.expression.set.expressions.concat([Twig.expression.type.array.end, Twig.expression.type.object.end]),\n\t            compile: function(token, stack, output) {\n\t                var i = stack.length - 1,\n\t                    stack_token;\n\n\t                delete token.match;\n\t                delete token.value;\n\n\t                // pop tokens off the stack until the start of the object\n\t                for(;i >= 0; i--) {\n\t                    stack_token = stack.pop();\n\t                    if (stack_token.type === Twig.expression.type.object.start\n\t                            || stack_token.type === Twig.expression.type.parameter.start\n\t                            || stack_token.type === Twig.expression.type.array.start) {\n\t                        stack.push(stack_token);\n\t                        break;\n\t                    }\n\t                    output.push(stack_token);\n\t                }\n\t                output.push(token);\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Match a number (integer or decimal)\n\t             */\n\t            type: Twig.expression.type.number,\n\t            // match a number\n\t            regex: /^\\-?\\d+(\\.\\d+)?/,\n\t            next: Twig.expression.set.operations,\n\t            compile: function(token, stack, output) {\n\t                token.value = Number(token.value);\n\t                output.push(token);\n\t            },\n\t            parse: Twig.expression.fn.parse.push_value\n\t        },\n\t        {\n\t            type: Twig.expression.type.operator.binary,\n\t            // Match any of ?:, +, *, /, -, %, ~, <, <=, >, >=, !=, ==, **, ?, :, and, b-and, or, b-or, b-xor, in, not in\n\t            // and, or, in, not in can be followed by a space or parenthesis\n\t            regex: /(^\\?\\:|^(b\\-and)|^(b\\-or)|^(b\\-xor)|^[\\+\\-~%\\?]|^[\\:](?!\\d\\])|^[!=]==?|^[!<>]=?|^\\*\\*?|^\\/\\/?|^(and)[\\(|\\s+]|^(or)[\\(|\\s+]|^(in)[\\(|\\s+]|^(not in)[\\(|\\s+]|^\\.\\.)/,\n\t            next: Twig.expression.set.expressions,\n\t            transform: function(match, tokens) {\n\t                switch(match[0]) {\n\t                    case 'and(':\n\t                    case 'or(':\n\t                    case 'in(':\n\t                    case 'not in(':\n\t                        //Strip off the ( if it exists\n\t                        tokens[tokens.length - 1].value = match[2];\n\t                        return match[0];\n\t                        break;\n\t                    default:\n\t                        return '';\n\t                }\n\t            },\n\t            compile: function(token, stack, output) {\n\t                delete token.match;\n\n\t                token.value = token.value.trim();\n\t                var value = token.value,\n\t                    operator = Twig.expression.operator.lookup(value, token);\n\n\t                Twig.log.trace(\"Twig.expression.compile: \", \"Operator: \", operator, \" from \", value);\n\n\t                while (stack.length > 0 &&\n\t                       (stack[stack.length-1].type == Twig.expression.type.operator.unary || stack[stack.length-1].type == Twig.expression.type.operator.binary) &&\n\t                            (\n\t                                (operator.associativity === Twig.expression.operator.leftToRight &&\n\t                                 operator.precidence    >= stack[stack.length-1].precidence) ||\n\n\t                                (operator.associativity === Twig.expression.operator.rightToLeft &&\n\t                                 operator.precidence    >  stack[stack.length-1].precidence)\n\t                            )\n\t                       ) {\n\t                     var temp = stack.pop();\n\t                     output.push(temp);\n\t                }\n\n\t                if (value === \":\") {\n\t                    // Check if this is a ternary or object key being set\n\t                    if (stack[stack.length - 1] && stack[stack.length-1].value === \"?\") {\n\t                        // Continue as normal for a ternary\n\t                    } else {\n\t                        // This is not a ternary so we push the token to the output where it can be handled\n\t                        //   when the assocated object is closed.\n\t                        var key_token = output.pop();\n\n\t                        if (key_token.type === Twig.expression.type.string ||\n\t                                key_token.type === Twig.expression.type.variable) {\n\t                            token.key = key_token.value;\n\t                        } else if (key_token.type === Twig.expression.type.number) {\n\t                            // Convert integer keys into string keys\n\t                            token.key = key_token.value.toString();\n\t                        } else if (key_token.expression &&\n\t                            (key_token.type === Twig.expression.type.parameter.end ||\n\t                            key_token.type == Twig.expression.type.subexpression.end)) {\n\t                            token.params = key_token.params;\n\t                        } else {\n\t                            throw new Twig.Error(\"Unexpected value before ':' of \" + key_token.type + \" = \" + key_token.value);\n\t                        }\n\n\t                        output.push(token);\n\t                        return;\n\t                    }\n\t                } else {\n\t                    stack.push(operator);\n\t                }\n\t            },\n\t            parse: function(token, stack, context) {\n\t                if (token.key) {\n\t                    // handle ternary ':' operator\n\t                    stack.push(token);\n\t                } else if (token.params) {\n\t                    // handle \"{(expression):value}\"\n\t                    return Twig.expression.parseAsync.apply(this, [token.params, context])\n\t                    .then(function(key) {\n\t                        token.key = key;\n\t                        stack.push(token);\n\n\t                        //If we're in a loop, we might need token.params later, especially in this form of \"(expression):value\"\n\t                        if (!context.loop) {\n\t                            delete(token.params);\n\t                        }\n\t                    });\n\t                } else {\n\t                    Twig.expression.operator.parse(token.value, stack);\n\t                }\n\t            }\n\t        },\n\t        {\n\t            type: Twig.expression.type.operator.unary,\n\t            // Match any of not\n\t            regex: /(^not\\s+)/,\n\t            next: Twig.expression.set.expressions,\n\t            compile: function(token, stack, output) {\n\t                delete token.match;\n\n\t                token.value = token.value.trim();\n\t                var value = token.value,\n\t                    operator = Twig.expression.operator.lookup(value, token);\n\n\t                Twig.log.trace(\"Twig.expression.compile: \", \"Operator: \", operator, \" from \", value);\n\n\t                while (stack.length > 0 &&\n\t                       (stack[stack.length-1].type == Twig.expression.type.operator.unary || stack[stack.length-1].type == Twig.expression.type.operator.binary) &&\n\t                            (\n\t                                (operator.associativity === Twig.expression.operator.leftToRight &&\n\t                                 operator.precidence    >= stack[stack.length-1].precidence) ||\n\n\t                                (operator.associativity === Twig.expression.operator.rightToLeft &&\n\t                                 operator.precidence    >  stack[stack.length-1].precidence)\n\t                            )\n\t                       ) {\n\t                     var temp = stack.pop();\n\t                     output.push(temp);\n\t                }\n\n\t                stack.push(operator);\n\t            },\n\t            parse: function(token, stack, context) {\n\t                Twig.expression.operator.parse(token.value, stack);\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Match a string. This is anything between a pair of single or double quotes.\n\t             */\n\t            type: Twig.expression.type.string,\n\t            // See: http://blog.stevenlevithan.com/archives/match-quoted-string\n\t            regex: /^([\"'])(?:(?=(\\\\?))\\2[\\s\\S])*?\\1/,\n\t            next: Twig.expression.set.operations_extended,\n\t            compile: function(token, stack, output) {\n\t                var value = token.value;\n\t                delete token.match\n\n\t                // Remove the quotes from the string\n\t                if (value.substring(0, 1) === '\"') {\n\t                    value = value.replace('\\\\\"', '\"');\n\t                } else {\n\t                    value = value.replace(\"\\\\'\", \"'\");\n\t                }\n\t                token.value = value.substring(1, value.length-1).replace( /\\\\n/g, \"\\n\" ).replace( /\\\\r/g, \"\\r\" );\n\t                Twig.log.trace(\"Twig.expression.compile: \", \"String value: \", token.value);\n\t                output.push(token);\n\t            },\n\t            parse: Twig.expression.fn.parse.push_value\n\t        },\n\t        {\n\t            /**\n\t             * Match a subexpression set start.\n\t             */\n\t            type: Twig.expression.type.subexpression.start,\n\t            regex: /^\\(/,\n\t            next: Twig.expression.set.expressions.concat([Twig.expression.type.subexpression.end]),\n\t            compile: function(token, stack, output) {\n\t                token.value = '(';\n\t                output.push(token);\n\t                stack.push(token);\n\t            },\n\t            parse: Twig.expression.fn.parse.push\n\t        },\n\t        {\n\t            /**\n\t             * Match a subexpression set end.\n\t             */\n\t            type: Twig.expression.type.subexpression.end,\n\t            regex: /^\\)/,\n\t            next: Twig.expression.set.operations_extended,\n\t            validate: function(match, tokens) {\n\t                // Iterate back through previous tokens to ensure we follow a subexpression start\n\t                var i = tokens.length - 1,\n\t                    found_subexpression_start = false,\n\t                    next_subexpression_start_invalid = false,\n\t                    unclosed_parameter_count = 0;\n\n\t                while(!found_subexpression_start && i >= 0) {\n\t                    var token = tokens[i];\n\n\t                    found_subexpression_start = token.type === Twig.expression.type.subexpression.start;\n\n\t                    // If we have previously found a subexpression end, then this subexpression start is the start of\n\t                    // that subexpression, not the subexpression we are searching for\n\t                    if (found_subexpression_start && next_subexpression_start_invalid) {\n\t                        next_subexpression_start_invalid = false;\n\t                        found_subexpression_start = false;\n\t                    }\n\n\t                    // Count parameter tokens to ensure we dont return truthy for a parameter opener\n\t                    if (token.type === Twig.expression.type.parameter.start) {\n\t                        unclosed_parameter_count++;\n\t                    } else if (token.type === Twig.expression.type.parameter.end) {\n\t                        unclosed_parameter_count--;\n\t                    } else if (token.type === Twig.expression.type.subexpression.end) {\n\t                        next_subexpression_start_invalid = true;\n\t                    }\n\n\t                    i--;\n\t                }\n\n\t                // If we found unclosed parameters, return false\n\t                // If we didnt find subexpression start, return false\n\t                // Otherwise return true\n\n\t                return (found_subexpression_start && (unclosed_parameter_count === 0));\n\t            },\n\t            compile: function(token, stack, output) {\n\t                // This is basically a copy of parameter end compilation\n\t                var stack_token,\n\t                    end_token = token;\n\n\t                stack_token = stack.pop();\n\t                while(stack.length > 0 && stack_token.type != Twig.expression.type.subexpression.start) {\n\t                    output.push(stack_token);\n\t                    stack_token = stack.pop();\n\t                }\n\n\t                // Move contents of parens into preceding filter\n\t                var param_stack = [];\n\t                while(token.type !== Twig.expression.type.subexpression.start) {\n\t                    // Add token to arguments stack\n\t                    param_stack.unshift(token);\n\t                    token = output.pop();\n\t                }\n\n\t                param_stack.unshift(token);\n\n\t                var is_expression = false;\n\n\t                //If the token at the top of the *stack* is a function token, pop it onto the output queue.\n\t                // Get the token preceding the parameters\n\t                stack_token = stack[stack.length-1];\n\n\t                if (stack_token === undefined ||\n\t                    (stack_token.type !== Twig.expression.type._function &&\n\t                    stack_token.type !== Twig.expression.type.filter &&\n\t                    stack_token.type !== Twig.expression.type.test &&\n\t                    stack_token.type !== Twig.expression.type.key.brackets)) {\n\n\t                    end_token.expression = true;\n\n\t                    // remove start and end token from stack\n\t                    param_stack.pop();\n\t                    param_stack.shift();\n\n\t                    end_token.params = param_stack;\n\n\t                    output.push(end_token);\n\t                } else {\n\t                    // This should never be hit\n\t                    end_token.expression = false;\n\t                    stack_token.params = param_stack;\n\t                }\n\t            },\n\t            parse: function(token, stack, context) {\n\t                var new_array = [],\n\t                    array_ended = false,\n\t                    value = null;\n\n\t                if (token.expression) {\n\t                    return Twig.expression.parseAsync.apply(this, [token.params, context])\n\t                    .then(function(value) {\n\t                        stack.push(value);\n\t                    });\n\t                } else {\n\t                    throw new Twig.Error(\"Unexpected subexpression end when token is not marked as an expression\");\n\t                }\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Match a parameter set start.\n\t             */\n\t            type: Twig.expression.type.parameter.start,\n\t            regex: /^\\(/,\n\t            next: Twig.expression.set.expressions.concat([Twig.expression.type.parameter.end]),\n\t            validate: function(match, tokens) {\n\t                var last_token = tokens[tokens.length - 1];\n\t                // We can't use the regex to test if we follow a space because expression is trimmed\n\t                return last_token && (Twig.indexOf(Twig.expression.reservedWords, last_token.value.trim()) < 0);\n\t            },\n\t            compile: Twig.expression.fn.compile.push_both,\n\t            parse: Twig.expression.fn.parse.push\n\t        },\n\t        {\n\t            /**\n\t             * Match a parameter set end.\n\t             */\n\t            type: Twig.expression.type.parameter.end,\n\t            regex: /^\\)/,\n\t            next: Twig.expression.set.operations_extended,\n\t            compile: function(token, stack, output) {\n\t                var stack_token,\n\t                    end_token = token;\n\n\t                stack_token = stack.pop();\n\t                while(stack.length > 0 && stack_token.type != Twig.expression.type.parameter.start) {\n\t                    output.push(stack_token);\n\t                    stack_token = stack.pop();\n\t                }\n\n\t                // Move contents of parens into preceding filter\n\t                var param_stack = [];\n\t                while(token.type !== Twig.expression.type.parameter.start) {\n\t                    // Add token to arguments stack\n\t                    param_stack.unshift(token);\n\t                    token = output.pop();\n\t                }\n\t                param_stack.unshift(token);\n\n\t                var is_expression = false;\n\n\t                // Get the token preceding the parameters\n\t                token = output[output.length-1];\n\n\t                if (token === undefined ||\n\t                    (token.type !== Twig.expression.type._function &&\n\t                    token.type !== Twig.expression.type.filter &&\n\t                    token.type !== Twig.expression.type.test &&\n\t                    token.type !== Twig.expression.type.key.brackets)) {\n\n\t                    end_token.expression = true;\n\n\t                    // remove start and end token from stack\n\t                    param_stack.pop();\n\t                    param_stack.shift();\n\n\t                    end_token.params = param_stack;\n\n\t                    output.push(end_token);\n\n\t                } else {\n\t                    end_token.expression = false;\n\t                    token.params = param_stack;\n\t                }\n\t            },\n\t            parse: function(token, stack, context) {\n\t                var new_array = [],\n\t                    array_ended = false,\n\t                    value = null;\n\n\t                if (token.expression) {\n\t                    return Twig.expression.parseAsync.apply(this, [token.params, context])\n\t                    .then(function(value) {\n\t                        stack.push(value);\n\t                    });\n\t                } else {\n\n\t                    while (stack.length > 0) {\n\t                        value = stack.pop();\n\t                        // Push values into the array until the start of the array\n\t                        if (value && value.type && value.type == Twig.expression.type.parameter.start) {\n\t                            array_ended = true;\n\t                            break;\n\t                        }\n\t                        new_array.unshift(value);\n\t                    }\n\n\t                    if (!array_ended) {\n\t                        throw new Twig.Error(\"Expected end of parameter set.\");\n\t                    }\n\n\t                    stack.push(new_array);\n\t                }\n\t            }\n\t        },\n\t        {\n\t            type: Twig.expression.type.slice,\n\t            regex: /^\\[(\\d*\\:\\d*)\\]/,\n\t            next: Twig.expression.set.operations_extended,\n\t            compile: function(token, stack, output) {\n\t                var sliceRange = token.match[1].split(':');\n\n\t                //sliceStart can be undefined when we pass parameters to the slice filter later\n\t                var sliceStart = (sliceRange[0]) ? parseInt(sliceRange[0]) : undefined;\n\t                var sliceEnd = (sliceRange[1]) ? parseInt(sliceRange[1]) : undefined;\n\n\t                token.value = 'slice';\n\t                token.params = [sliceStart, sliceEnd];\n\n\t                //sliceEnd can't be undefined as the slice filter doesn't check for this, but it does check the length\n\t                //of the params array, so just shorten it.\n\t                if (!sliceEnd) {\n\t                    token.params = [sliceStart];\n\t                }\n\n\t                output.push(token);\n\t            },\n\t            parse: function(token, stack, context) {\n\t                var input = stack.pop(),\n\t                    params = token.params;\n\n\t                stack.push(Twig.filter.apply(this, [token.value, input, params]));\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Match an array start.\n\t             */\n\t            type: Twig.expression.type.array.start,\n\t            regex: /^\\[/,\n\t            next: Twig.expression.set.expressions.concat([Twig.expression.type.array.end]),\n\t            compile: Twig.expression.fn.compile.push_both,\n\t            parse: Twig.expression.fn.parse.push\n\t        },\n\t        {\n\t            /**\n\t             * Match an array end.\n\t             */\n\t            type: Twig.expression.type.array.end,\n\t            regex: /^\\]/,\n\t            next: Twig.expression.set.operations_extended,\n\t            compile: function(token, stack, output) {\n\t                var i = stack.length - 1,\n\t                    stack_token;\n\t                // pop tokens off the stack until the start of the object\n\t                for(;i >= 0; i--) {\n\t                    stack_token = stack.pop();\n\t                    if (stack_token.type === Twig.expression.type.array.start) {\n\t                        break;\n\t                    }\n\t                    output.push(stack_token);\n\t                }\n\t                output.push(token);\n\t            },\n\t            parse: function(token, stack, context) {\n\t                var new_array = [],\n\t                    array_ended = false,\n\t                    value = null;\n\n\t                while (stack.length > 0) {\n\t                    value = stack.pop();\n\t                    // Push values into the array until the start of the array\n\t                    if (value.type && value.type == Twig.expression.type.array.start) {\n\t                        array_ended = true;\n\t                        break;\n\t                    }\n\t                    new_array.unshift(value);\n\t                }\n\t                if (!array_ended) {\n\t                    throw new Twig.Error(\"Expected end of array.\");\n\t                }\n\n\t                stack.push(new_array);\n\t            }\n\t        },\n\t        // Token that represents the start of a hash map '}'\n\t        //\n\t        // Hash maps take the form:\n\t        //    { \"key\": 'value', \"another_key\": item }\n\t        //\n\t        // Keys must be quoted (either single or double) and values can be any expression.\n\t        {\n\t            type: Twig.expression.type.object.start,\n\t            regex: /^\\{/,\n\t            next: Twig.expression.set.expressions.concat([Twig.expression.type.object.end]),\n\t            compile: Twig.expression.fn.compile.push_both,\n\t            parse: Twig.expression.fn.parse.push\n\t        },\n\n\t        // Token that represents the end of a Hash Map '}'\n\t        //\n\t        // This is where the logic for building the internal\n\t        // representation of a hash map is defined.\n\t        {\n\t            type: Twig.expression.type.object.end,\n\t            regex: /^\\}/,\n\t            next: Twig.expression.set.operations_extended,\n\t            compile: function(token, stack, output) {\n\t                var i = stack.length-1,\n\t                    stack_token;\n\n\t                // pop tokens off the stack until the start of the object\n\t                for(;i >= 0; i--) {\n\t                    stack_token = stack.pop();\n\t                    if (stack_token && stack_token.type === Twig.expression.type.object.start) {\n\t                        break;\n\t                    }\n\t                    output.push(stack_token);\n\t                }\n\t                output.push(token);\n\t            },\n\t            parse: function(end_token, stack, context) {\n\t                var new_object = {},\n\t                    object_ended = false,\n\t                    token = null,\n\t                    token_key = null,\n\t                    has_value = false,\n\t                    value = null;\n\n\t                while (stack.length > 0) {\n\t                    token = stack.pop();\n\t                    // Push values into the array until the start of the object\n\t                    if (token && token.type && token.type === Twig.expression.type.object.start) {\n\t                        object_ended = true;\n\t                        break;\n\t                    }\n\t                    if (token && token.type && (token.type === Twig.expression.type.operator.binary || token.type === Twig.expression.type.operator.unary) && token.key) {\n\t                        if (!has_value) {\n\t                            throw new Twig.Error(\"Missing value for key '\" + token.key + \"' in object definition.\");\n\t                        }\n\t                        new_object[token.key] = value;\n\n\t                        // Preserve the order that elements are added to the map\n\t                        // This is necessary since JavaScript objects don't\n\t                        // guarantee the order of keys\n\t                        if (new_object._keys === undefined) new_object._keys = [];\n\t                        new_object._keys.unshift(token.key);\n\n\t                        // reset value check\n\t                        value = null;\n\t                        has_value = false;\n\n\t                    } else {\n\t                        has_value = true;\n\t                        value = token;\n\t                    }\n\t                }\n\t                if (!object_ended) {\n\t                    throw new Twig.Error(\"Unexpected end of object.\");\n\t                }\n\n\t                stack.push(new_object);\n\t            }\n\t        },\n\n\t        // Token representing a filter\n\t        //\n\t        // Filters can follow any expression and take the form:\n\t        //    expression|filter(optional, args)\n\t        //\n\t        // Filter parsing is done in the Twig.filters namespace.\n\t        {\n\t            type: Twig.expression.type.filter,\n\t            // match a | then a letter or _, then any number of letters, numbers, _ or -\n\t            regex: /^\\|\\s?([a-zA-Z_][a-zA-Z0-9_\\-]*)/,\n\t            next: Twig.expression.set.operations_extended.concat([\n\t                    Twig.expression.type.parameter.start]),\n\t            compile: function(token, stack, output) {\n\t                token.value = token.match[1];\n\t                output.push(token);\n\t            },\n\t            parse: function(token, stack, context) {\n\t                var that = this,\n\t                    input = stack.pop();\n\n\t                return parseParams(this, token.params, context)\n\t                .then(function(params) {\n\t                    return Twig.filter.apply(that, [token.value, input, params]);\n\t                })\n\t                .then(function(value) {\n\t                    stack.push(value);\n\t                });\n\t            }\n\t        },\n\t        {\n\t            type: Twig.expression.type._function,\n\t            // match any letter or _, then any number of letters, numbers, _ or - followed by (\n\t            regex: /^([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(/,\n\t            next: Twig.expression.type.parameter.start,\n\t            validate: function(match, tokens) {\n\t                // Make sure this function is not a reserved word\n\t                return match[1] && (Twig.indexOf(Twig.expression.reservedWords, match[1]) < 0);\n\t            },\n\t            transform: function(match, tokens) {\n\t                return '(';\n\t            },\n\t            compile: function(token, stack, output) {\n\t                var fn = token.match[1];\n\t                token.fn = fn;\n\t                // cleanup token\n\t                delete token.match;\n\t                delete token.value;\n\n\t                output.push(token);\n\t            },\n\t            parse: function(token, stack, context) {\n\n\t                var that = this,\n\t                    fn = token.fn,\n\t                    value;\n\n\t                return parseParams(this, token.params, context)\n\t                .then(function(params) {\n\t                    if (Twig.functions[fn]) {\n\t                        // Get the function from the built-in functions\n\t                        value = Twig.functions[fn].apply(that, params);\n\n\t                    } else if (typeof context[fn] == 'function') {\n\t                        // Get the function from the user/context defined functions\n\t                        value = context[fn].apply(context, params);\n\n\t                    } else {\n\t                        throw new Twig.Error(fn + ' function does not exist and is not defined in the context');\n\t                    }\n\n\t                    return value;\n\t                })\n\t                .then(function(result) {\n\t                    stack.push(result);\n\t                });\n\t            }\n\t        },\n\n\t        // Token representing a variable.\n\t        //\n\t        // Variables can contain letters, numbers, underscores and\n\t        // dashes, but must start with a letter or underscore.\n\t        //\n\t        // Variables are retrieved from the render context and take\n\t        // the value of 'undefined' if the given variable doesn't\n\t        // exist in the context.\n\t        {\n\t            type: Twig.expression.type.variable,\n\t            // match any letter or _, then any number of letters, numbers, _ or -\n\t            regex: /^[a-zA-Z_][a-zA-Z0-9_]*/,\n\t            next: Twig.expression.set.operations_extended.concat([\n\t                    Twig.expression.type.parameter.start]),\n\t            compile: Twig.expression.fn.compile.push,\n\t            validate: function(match, tokens) {\n\t                return (Twig.indexOf(Twig.expression.reservedWords, match[0]) < 0);\n\t            },\n\t            parse: function(token, stack, context) {\n\t                // Get the variable from the context\n\t                return Twig.expression.resolveAsync.apply(this, [context[token.value], context])\n\t                .then(function(value) {\n\t                    stack.push(value);\n\t                });\n\t            }\n\t        },\n\t        {\n\t            type: Twig.expression.type.key.period,\n\t            regex: /^\\.([a-zA-Z0-9_]+)/,\n\t            next: Twig.expression.set.operations_extended.concat([\n\t                    Twig.expression.type.parameter.start]),\n\t            compile: function(token, stack, output) {\n\t                token.key = token.match[1];\n\t                delete token.match;\n\t                delete token.value;\n\n\t                output.push(token);\n\t            },\n\t            parse: function(token, stack, context, next_token) {\n\t                var that = this,\n\t                    key = token.key,\n\t                    object = stack.pop(),\n\t                    value;\n\n\t                return parseParams(this, token.params, context)\n\t                .then(function(params) {\n\t                    if (object === null || object === undefined) {\n\t                        if (that.options.strict_variables) {\n\t                            throw new Twig.Error(\"Can't access a key \" + key + \" on an null or undefined object.\");\n\t                        } else {\n\t                            value = undefined;\n\t                        }\n\t                    } else {\n\t                        var capitalize = function (value) {\n\t                            return value.substr(0, 1).toUpperCase() + value.substr(1);\n\t                        };\n\n\t                        // Get the variable from the context\n\t                        if (typeof object === 'object' && key in object) {\n\t                            value = object[key];\n\t                        } else if (object[\"get\" + capitalize(key)] !== undefined) {\n\t                            value = object[\"get\" + capitalize(key)];\n\t                        } else if (object[\"is\" + capitalize(key)] !== undefined) {\n\t                            value = object[\"is\" + capitalize(key)];\n\t                        } else {\n\t                            value = undefined;\n\t                        }\n\t                    }\n\n\t                    // When resolving an expression we need to pass next_token in case the expression is a function\n\t                    return Twig.expression.resolveAsync.apply(that, [value, context, params, next_token, object]);\n\t                })\n\t                .then(function(result) {\n\t                    stack.push(result);\n\t                });\n\t            }\n\t        },\n\t        {\n\t            type: Twig.expression.type.key.brackets,\n\t            regex: /^\\[([^\\]\\:]*)\\]/,\n\t            next: Twig.expression.set.operations_extended.concat([\n\t                    Twig.expression.type.parameter.start]),\n\t            compile: function(token, stack, output) {\n\t                var match = token.match[1];\n\t                delete token.value;\n\t                delete token.match;\n\n\t                // The expression stack for the key\n\t                token.stack = Twig.expression.compile({\n\t                    value: match\n\t                }).stack;\n\n\t                output.push(token);\n\t            },\n\t            parse: function(token, stack, context, next_token) {\n\t                // Evaluate key\n\t                var that = this,\n\t                    params = null,\n\t                    object,\n\t                    value;\n\n\t                return parseParams(this, token.params, context)\n\t                .then(function(parameters) {\n\t                    params = parameters;\n\t                    return Twig.expression.parseAsync.apply(that, [token.stack, context]);\n\t                })\n\t                .then(function(key) {\n\t                    object = stack.pop();\n\n\t                    if (object === null || object === undefined) {\n\t                        if (that.options.strict_variables) {\n\t                            throw new Twig.Error(\"Can't access a key \" + key + \" on an null or undefined object.\");\n\t                        } else {\n\t                            return null;\n\t                        }\n\t                    }\n\n\t                    // Get the variable from the context\n\t                    if (typeof object === 'object' && key in object) {\n\t                        value = object[key];\n\t                    } else {\n\t                        value = null;\n\t                    }\n\n\t                    // When resolving an expression we need to pass next_token in case the expression is a function\n\t                    return Twig.expression.resolveAsync.apply(that, [value, object, params, next_token]);\n\t                })\n\t                .then(function(result) {\n\t                    stack.push(result);\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Match a null value.\n\t             */\n\t            type: Twig.expression.type._null,\n\t            // match a number\n\t            regex: /^(null|NULL|none|NONE)/,\n\t            next: Twig.expression.set.operations,\n\t            compile: function(token, stack, output) {\n\t                delete token.match;\n\t                token.value = null;\n\t                output.push(token);\n\t            },\n\t            parse: Twig.expression.fn.parse.push_value\n\t        },\n\t        {\n\t            /**\n\t             * Match the context\n\t             */\n\t            type: Twig.expression.type.context,\n\t            regex: /^_context/,\n\t            next: Twig.expression.set.operations_extended.concat([\n\t                    Twig.expression.type.parameter.start]),\n\t            compile: Twig.expression.fn.compile.push,\n\t            parse: function(token, stack, context) {\n\t                stack.push(context);\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Match a boolean\n\t             */\n\t            type: Twig.expression.type.bool,\n\t            regex: /^(true|TRUE|false|FALSE)/,\n\t            next: Twig.expression.set.operations,\n\t            compile: function(token, stack, output) {\n\t                token.value = (token.match[0].toLowerCase( ) === \"true\");\n\t                delete token.match;\n\t                output.push(token);\n\t            },\n\t            parse: Twig.expression.fn.parse.push_value\n\t        }\n\t    ];\n\n\t    /**\n\t     * Resolve a context value.\n\t     *\n\t     * If the value is a function, it is executed with a context parameter.\n\t     *\n\t     * @param {string} key The context object key.\n\t     * @param {Object} context The render context.\n\t     */\n\t    Twig.expression.resolveAsync = function(value, context, params, next_token, object) {\n\t        if (typeof value == 'function') {\n\t            var promise = Twig.Promise.resolve(params);\n\n\t            /*\n\t            If value is a function, it will have been impossible during the compile stage to determine that a following\n\t            set of parentheses were parameters for this function.\n\n\t            Those parentheses will have therefore been marked as an expression, with their own parameters, which really\n\t            belong to this function.\n\n\t            Those parameters will also need parsing in case they are actually an expression to pass as parameters.\n\t             */\n\t            if (next_token && next_token.type === Twig.expression.type.parameter.end) {\n\t                //When parsing these parameters, we need to get them all back, not just the last item on the stack.\n\t                var tokens_are_parameters = true;\n\n\t                promise = promise.then(function() {\n\t                    return next_token.params && Twig.expression.parseAsync.apply(this, [next_token.params, context, tokens_are_parameters]);\n\t                })\n\t                .then(function(p) {\n\t                    //Clean up the parentheses tokens on the next loop\n\t                    next_token.cleanup = true;\n\n\t                    return p;\n\t                });\n\t            }\n\n\t            return promise.then(function(params) {\n\t                return value.apply(object || context, params || []);\n\t            });\n\t        } else {\n\t            return Twig.Promise.resolve(value);\n\t        }\n\t    };\n\n\t    Twig.expression.resolve = function(value, context, params, next_token, object) {\n\t        var is_async = true,\n\t            result;\n\n\t        Twig.expression.resolveAsync.apply(this, [value, context, params, next_token, object])\n\t        .then(function(r) {\n\t            is_async = false;\n\t            result = r;\n\t        });\n\n\t        if (is_async)\n\t            throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t        return result;\n\t    }\n\n\t    /**\n\t     * Registry for logic handlers.\n\t     */\n\t    Twig.expression.handler = {};\n\n\t    /**\n\t     * Define a new expression type, available at Twig.logic.type.{type}\n\t     *\n\t     * @param {string} type The name of the new type.\n\t     */\n\t    Twig.expression.extendType = function (type) {\n\t        Twig.expression.type[type] = \"Twig.expression.type.\" + type;\n\t    };\n\n\t    /**\n\t     * Extend the expression parsing functionality with a new definition.\n\t     *\n\t     * Token definitions follow this format:\n\t     *  {\n\t     *      type:     One of Twig.expression.type.[type], either pre-defined or added using\n\t     *                    Twig.expression.extendType\n\t     *\n\t     *      next:     Array of types from Twig.expression.type that can follow this token,\n\t     *\n\t     *      regex:    A regex or array of regex's that should match the token.\n\t     *\n\t     *      compile: function(token, stack, output) called when this token is being compiled.\n\t     *                   Should return an object with stack and output set.\n\t     *\n\t     *      parse:   function(token, stack, context) called when this token is being parsed.\n\t     *                   Should return an object with stack and context set.\n\t     *  }\n\t     *\n\t     * @param {Object} definition A token definition.\n\t     */\n\t    Twig.expression.extend = function (definition) {\n\t        if (!definition.type) {\n\t            throw new Twig.Error(\"Unable to extend logic definition. No type provided for \" + definition);\n\t        }\n\t        Twig.expression.handler[definition.type] = definition;\n\t    };\n\n\t    // Extend with built-in expressions\n\t    while (Twig.expression.definitions.length > 0) {\n\t        Twig.expression.extend(Twig.expression.definitions.shift());\n\t    }\n\n\t    /**\n\t     * Break an expression into tokens defined in Twig.expression.definitions.\n\t     *\n\t     * @param {string} expression The string to tokenize.\n\t     *\n\t     * @return {Array} An array of tokens.\n\t     */\n\t    Twig.expression.tokenize = function (expression) {\n\t        var tokens = [],\n\t            // Keep an offset of the location in the expression for error messages.\n\t            exp_offset = 0,\n\t            // The valid next tokens of the previous token\n\t            next = null,\n\t            // Match information\n\t            type, regex, regex_array,\n\t            // The possible next token for the match\n\t            token_next,\n\t            // Has a match been found from the definitions\n\t            match_found, invalid_matches = [], match_function;\n\n\t        match_function = function () {\n\t            var match = Array.prototype.slice.apply(arguments),\n\t                string = match.pop(),\n\t                offset = match.pop();\n\n\t            Twig.log.trace(\"Twig.expression.tokenize\",\n\t                           \"Matched a \", type, \" regular expression of \", match);\n\n\t            if (next && Twig.indexOf(next, type) < 0) {\n\t                invalid_matches.push(\n\t                    type + \" cannot follow a \" + tokens[tokens.length - 1].type +\n\t                           \" at template:\" + exp_offset + \" near '\" + match[0].substring(0, 20) +\n\t                           \"...'\"\n\t                );\n\t                // Not a match, don't change the expression\n\t                return match[0];\n\t            }\n\n\t            // Validate the token if a validation function is provided\n\t            if (Twig.expression.handler[type].validate &&\n\t                    !Twig.expression.handler[type].validate(match, tokens)) {\n\t                return match[0];\n\t            }\n\n\t            invalid_matches = [];\n\n\t            tokens.push({\n\t                type:  type,\n\t                value: match[0],\n\t                match: match\n\t            });\n\n\t            match_found = true;\n\t            next = token_next;\n\t            exp_offset += match[0].length;\n\n\t            // Does the token need to return output back to the expression string\n\t            // e.g. a function match of cycle( might return the '(' back to the expression\n\t            // This allows look-ahead to differentiate between token types (e.g. functions and variable names)\n\t            if (Twig.expression.handler[type].transform) {\n\t                return Twig.expression.handler[type].transform(match, tokens);\n\t            }\n\t            return '';\n\t        };\n\n\t        Twig.log.debug(\"Twig.expression.tokenize\", \"Tokenizing expression \", expression);\n\n\t        while (expression.length > 0) {\n\t            expression = expression.trim();\n\t            for (type in Twig.expression.handler) {\n\t                if (Twig.expression.handler.hasOwnProperty(type)) {\n\t                    token_next = Twig.expression.handler[type].next;\n\t                    regex = Twig.expression.handler[type].regex;\n\t                    Twig.log.trace(\"Checking type \", type, \" on \", expression);\n\t                    if (regex instanceof Array) {\n\t                        regex_array = regex;\n\t                    } else {\n\t                        regex_array = [regex];\n\t                    }\n\n\t                    match_found = false;\n\t                    while (regex_array.length > 0) {\n\t                        regex = regex_array.pop();\n\t                        expression = expression.replace(regex, match_function);\n\t                    }\n\t                    // An expression token has been matched. Break the for loop and start trying to\n\t                    //  match the next template (if expression isn't empty.)\n\t                    if (match_found) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            if (!match_found) {\n\t                if (invalid_matches.length > 0) {\n\t                    throw new Twig.Error(invalid_matches.join(\" OR \"));\n\t                } else {\n\t                    throw new Twig.Error(\"Unable to parse '\" + expression + \"' at template position\" + exp_offset);\n\t                }\n\t            }\n\t        }\n\n\t        Twig.log.trace(\"Twig.expression.tokenize\", \"Tokenized to \", tokens);\n\t        return tokens;\n\t    };\n\n\t    /**\n\t     * Compile an expression token.\n\t     *\n\t     * @param {Object} raw_token The uncompiled token.\n\t     *\n\t     * @return {Object} The compiled token.\n\t     */\n\t    Twig.expression.compile = function (raw_token) {\n\t        var expression = raw_token.value,\n\t            // Tokenize expression\n\t            tokens = Twig.expression.tokenize(expression),\n\t            token = null,\n\t            output = [],\n\t            stack = [],\n\t            token_template = null;\n\n\t        Twig.log.trace(\"Twig.expression.compile: \", \"Compiling \", expression);\n\n\t        // Push tokens into RPN stack using the Shunting-yard algorithm\n\t        // See http://en.wikipedia.org/wiki/Shunting_yard_algorithm\n\n\t        while (tokens.length > 0) {\n\t            token = tokens.shift();\n\t            token_template = Twig.expression.handler[token.type];\n\n\t            Twig.log.trace(\"Twig.expression.compile: \", \"Compiling \", token);\n\n\t            // Compile the template\n\t            token_template.compile && token_template.compile(token, stack, output);\n\n\t            Twig.log.trace(\"Twig.expression.compile: \", \"Stack is\", stack);\n\t            Twig.log.trace(\"Twig.expression.compile: \", \"Output is\", output);\n\t        }\n\n\t        while(stack.length > 0) {\n\t            output.push(stack.pop());\n\t        }\n\n\t        Twig.log.trace(\"Twig.expression.compile: \", \"Final output is\", output);\n\n\t        raw_token.stack = output;\n\t        delete raw_token.value;\n\n\t        return raw_token;\n\t    };\n\n\n\t    /**\n\t     * Parse an RPN expression stack within a context.\n\t     *\n\t     * @param {Array} tokens An array of compiled expression tokens.\n\t     * @param {Object} context The render context to parse the tokens with.\n\t     *\n\t     * @return {Object} The result of parsing all the tokens. The result\n\t     *                  can be anything, String, Array, Object, etc... based on\n\t     *                  the given expression.\n\t     */\n\t    Twig.expression.parse = function (tokens, context, tokens_are_parameters, allow_async) {\n\t        var that = this;\n\n\t        // If the token isn't an array, make it one.\n\t        if (!(tokens instanceof Array)) {\n\t            tokens = [tokens];\n\t        }\n\n\t        // The output stack\n\t        var stack = [],\n\t            next_token,\n\t            output = null,\n\t            promise = null,\n\t            is_async = true,\n\t            token_template = null,\n\t            loop_token_fixups = [];\n\n\t        promise = Twig.async.forEach(tokens, function (token, index) {\n\t            //If the token is marked for cleanup, we don't need to parse it\n\t            if (token.cleanup) {\n\t                return;\n\t            }\n\n\t            var result = null;\n\n\t            //Determine the token that follows this one so that we can pass it to the parser\n\t            if (tokens.length > index + 1) {\n\t                next_token = tokens[index + 1];\n\t            }\n\n\t            token_template = Twig.expression.handler[token.type];\n\n\t            if (token_template.parse)\n\t                result = token_template.parse.apply(that, [token, stack, context, next_token]);\n\n\t            //Store any binary tokens for later if we are in a loop.\n\t            if (context.loop && token.type === Twig.expression.type.operator.binary) {\n\t                loop_token_fixups.push(token);\n\t            }\n\n\t            return result;\n\t        })\n\t        .then(function() {\n\t            //Check every fixup and remove \"key\" as long as they still have \"params\". This covers the use case where\n\t            //a \":\" operator is used in a loop with a \"(expression):\" statement. We need to be able to evaluate the expression\n\t            Twig.forEach(loop_token_fixups, function (loop_token_fixup) {\n\t                if (loop_token_fixup.params && loop_token_fixup.key) {\n\t                    delete loop_token_fixup[\"key\"];\n\t                }\n\t            });\n\n\t            //If parse has been called with a set of tokens that are parameters, we need to return the whole stack,\n\t            //wrapped in an Array.\n\t            if (tokens_are_parameters) {\n\t                var params = [];\n\t                while (stack.length > 0) {\n\t                    params.unshift(stack.pop());\n\t                }\n\n\t                stack.push(params);\n\t            }\n\n\t            if (allow_async)\n\t                return Twig.Promise.resolve(stack.pop());\n\t        })\n\t        .then(function(v) {\n\t            is_async = false;\n\t            return v;\n\t        });\n\n\t        if (allow_async)\n\t            return promise;\n\n\t        if (is_async)\n\t            throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t        // Pop the final value off the stack\n\t        return stack.pop();\n\t    };\n\n\t    return Twig;\n\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t// ## twig.expression.operator.js\n\t//\n\t// This file handles operator lookups and parsing.\n\tmodule.exports = function (Twig) {\n\t    \"use strict\";\n\n\t    /**\n\t     * Operator associativity constants.\n\t     */\n\t    Twig.expression.operator = {\n\t        leftToRight: 'leftToRight',\n\t        rightToLeft: 'rightToLeft'\n\t    };\n\n\t    var containment = function(a, b) {\n\t        if (b === undefined || b === null) {\n\t            return null;\n\t        } else if (b.indexOf !== undefined) {\n\t            // String\n\t            return a === b || a !== '' && b.indexOf(a) > -1;\n\t        } else {\n\t            var el;\n\t            for (el in b) {\n\t                if (b.hasOwnProperty(el) && b[el] === a) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t    };\n\n\t    /**\n\t     * Get the precidence and associativity of an operator. These follow the order that C/C++ use.\n\t     * See http://en.wikipedia.org/wiki/Operators_in_C_and_C++ for the table of values.\n\t     */\n\t    Twig.expression.operator.lookup = function (operator, token) {\n\t        switch (operator) {\n\t            case \"..\":\n\t                token.precidence = 20;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case ',':\n\t                token.precidence = 18;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            // Ternary\n\t            case '?:':\n\t            case '?':\n\t            case ':':\n\t                token.precidence = 16;\n\t                token.associativity = Twig.expression.operator.rightToLeft;\n\t                break;\n\n\t            case 'or':\n\t                token.precidence = 14;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case 'and':\n\t                token.precidence = 13;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case 'b-or':\n\t                token.precidence = 12;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case 'b-xor':\n\t                token.precidence = 11;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case 'b-and':\n\t                token.precidence = 10;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case '==':\n\t            case '!=':\n\t                token.precidence = 9;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case '<':\n\t            case '<=':\n\t            case '>':\n\t            case '>=':\n\t            case 'not in':\n\t            case 'in':\n\t                token.precidence = 8;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case '~': // String concatination\n\t            case '+':\n\t            case '-':\n\t                token.precidence = 6;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case '//':\n\t            case '**':\n\t            case '*':\n\t            case '/':\n\t            case '%':\n\t                token.precidence = 5;\n\t                token.associativity = Twig.expression.operator.leftToRight;\n\t                break;\n\n\t            case 'not':\n\t                token.precidence = 3;\n\t                token.associativity = Twig.expression.operator.rightToLeft;\n\t                break;\n\n\t            default:\n\t                throw new Twig.Error(\"Failed to lookup operator: \" + operator + \" is an unknown operator.\");\n\t        }\n\t        token.operator = operator;\n\t        return token;\n\t    };\n\n\t    /**\n\t     * Handle operations on the RPN stack.\n\t     *\n\t     * Returns the updated stack.\n\t     */\n\t    Twig.expression.operator.parse = function (operator, stack) {\n\t        Twig.log.trace(\"Twig.expression.operator.parse: \", \"Handling \", operator);\n\t        var a, b, c;\n\n\t        if (operator === '?') {\n\t            c = stack.pop();\n\t        }\n\n\t        b = stack.pop();\n\t        if (operator !== 'not') {\n\t            a = stack.pop();\n\t        }\n\n\t        if (operator !== 'in' && operator !== 'not in') {\n\t            if (a && Array.isArray(a)) {\n\t                a = a.length;\n\t            }\n\n\t            if (b && Array.isArray(b)) {\n\t                b = b.length;\n\t            }\n\t        }\n\n\t        switch (operator) {\n\t            case ':':\n\t                // Ignore\n\t                break;\n\n\t            case '?:':\n\t                if (Twig.lib.boolval(a)) {\n\t                    stack.push(a);\n\t                } else {\n\t                    stack.push(b);\n\t                }\n\t                break;\n\t            case '?':\n\t                if (a === undefined) {\n\t                    //An extended ternary.\n\t                    a = b;\n\t                    b = c;\n\t                    c = undefined;\n\t                }\n\n\t                if (Twig.lib.boolval(a)) {\n\t                    stack.push(b);\n\t                } else {\n\t                    stack.push(c);\n\t                }\n\t                break;\n\n\t            case '+':\n\t                b = parseFloat(b);\n\t                a = parseFloat(a);\n\t                stack.push(a + b);\n\t                break;\n\n\t            case '-':\n\t                b = parseFloat(b);\n\t                a = parseFloat(a);\n\t                stack.push(a - b);\n\t                break;\n\n\t            case '*':\n\t                b = parseFloat(b);\n\t                a = parseFloat(a);\n\t                stack.push(a * b);\n\t                break;\n\n\t            case '/':\n\t                b = parseFloat(b);\n\t                a = parseFloat(a);\n\t                stack.push(a / b);\n\t                break;\n\n\t            case '//':\n\t                b = parseFloat(b);\n\t                a = parseFloat(a);\n\t                stack.push(Math.floor(a / b));\n\t                break;\n\n\t            case '%':\n\t                b = parseFloat(b);\n\t                a = parseFloat(a);\n\t                stack.push(a % b);\n\t                break;\n\n\t            case '~':\n\t                stack.push( (a != null ? a.toString() : \"\")\n\t                          + (b != null ? b.toString() : \"\") );\n\t                break;\n\n\t            case 'not':\n\t            case '!':\n\t                stack.push(!Twig.lib.boolval(b));\n\t                break;\n\n\t            case '<':\n\t                stack.push(a < b);\n\t                break;\n\n\t            case '<=':\n\t                stack.push(a <= b);\n\t                break;\n\n\t            case '>':\n\t                stack.push(a > b);\n\t                break;\n\n\t            case '>=':\n\t                stack.push(a >= b);\n\t                break;\n\n\t            case '===':\n\t                stack.push(a === b);\n\t                break;\n\n\t            case '==':\n\t                stack.push(a == b);\n\t                break;\n\n\t            case '!==':\n\t                stack.push(a !== b);\n\t                break;\n\n\t            case '!=':\n\t                stack.push(a != b);\n\t                break;\n\n\t            case 'or':\n\t                stack.push(a || b);\n\t                break;\n\n\t            case 'b-or':\n\t                stack.push(a | b);\n\t                break;\n\n\t            case 'b-xor':\n\t                stack.push(a ^ b);\n\t                break;\n\n\t            case 'and':\n\t                stack.push(a && b);\n\t                break;\n\n\t            case 'b-and':\n\t                stack.push(a & b);\n\t                break;\n\n\t            case '**':\n\t                stack.push(Math.pow(a, b));\n\t                break;\n\n\t            case 'not in':\n\t                stack.push( !containment(a, b) );\n\t                break;\n\n\t            case 'in':\n\t                stack.push( containment(a, b) );\n\t                break;\n\n\t            case '..':\n\t                stack.push( Twig.functions.range(a, b) );\n\t                break;\n\n\t            default:\n\t                debugger;\n\t                throw new Twig.Error(\"Failed to parse operator: \" + operator + \" is an unknown operator.\");\n\t        }\n\t    };\n\n\t    return Twig;\n\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t// ## twig.filters.js\n\t//\n\t// This file handles parsing filters.\n\tmodule.exports = function (Twig) {\n\n\t    // Determine object type\n\t    function is(type, obj) {\n\t        var clas = Object.prototype.toString.call(obj).slice(8, -1);\n\t        return obj !== undefined && obj !== null && clas === type;\n\t    }\n\n\t    Twig.filters = {\n\t        // String Filters\n\t        upper:  function(value) {\n\t            if ( typeof value !== \"string\" ) {\n\t               return value;\n\t            }\n\n\t            return value.toUpperCase();\n\t        },\n\t        lower: function(value) {\n\t            if ( typeof value !== \"string\" ) {\n\t               return value;\n\t            }\n\n\t            return value.toLowerCase();\n\t        },\n\t        capitalize: function(value) {\n\t            if ( typeof value !== \"string\" ) {\n\t                 return value;\n\t            }\n\n\t            return value.substr(0, 1).toUpperCase() + value.toLowerCase().substr(1);\n\t        },\n\t        title: function(value) {\n\t            if ( typeof value !== \"string\" ) {\n\t               return value;\n\t            }\n\n\t            return value.toLowerCase().replace( /(^|\\s)([a-z])/g , function(m, p1, p2){\n\t                return p1 + p2.toUpperCase();\n\t            });\n\t        },\n\t        length: function(value) {\n\t            if (Twig.lib.is(\"Array\", value) || typeof value === \"string\") {\n\t                return value.length;\n\t            } else if (Twig.lib.is(\"Object\", value)) {\n\t                if (value._keys === undefined) {\n\t                    return Object.keys(value).length;\n\t                } else {\n\t                    return value._keys.length;\n\t                }\n\t            } else {\n\t                return 0;\n\t            }\n\t        },\n\n\t        // Array/Object Filters\n\t        reverse: function(value) {\n\t            if (is(\"Array\", value)) {\n\t                return value.reverse();\n\t            } else if (is(\"String\", value)) {\n\t                return value.split(\"\").reverse().join(\"\");\n\t            } else if (is(\"Object\", value)) {\n\t                var keys = value._keys || Object.keys(value).reverse();\n\t                value._keys = keys;\n\t                return value;\n\t            }\n\t        },\n\t        sort: function(value) {\n\t            if (is(\"Array\", value)) {\n\t                return value.sort();\n\t            } else if (is('Object', value)) {\n\t                // Sorting objects isn't obvious since the order of\n\t                // returned keys isn't guaranteed in JavaScript.\n\t                // Because of this we use a \"hidden\" key called _keys to\n\t                // store the keys in the order we want to return them.\n\n\t                delete value._keys;\n\t                var keys = Object.keys(value),\n\t                    sorted_keys = keys.sort(function(a, b) {\n\t                        var a1, a2;\n\n\t                        // if a and b are comparable, we're fine :-)\n\t                        if((value[a] > value[b]) == !(value[a] <= value[b])) {\n\t                            return value[a] > value[b] ? 1 :\n\t\t\t\t           value[a] < value[b] ? -1 :\n\t\t\t\t\t   0;\n\t                        }\n\t                        // if a and b can be parsed as numbers, we can compare\n\t                        // their numeric value\n\t                        else if(!isNaN(a1 = parseFloat(value[a])) &&\n\t                                !isNaN(b1 = parseFloat(value[b]))) {\n\t                            return a1 > b1 ? 1 :\n\t\t\t\t           a1 < b1 ? -1 :\n\t\t\t\t\t   0;\n\t                        }\n\t                        // if one of the values is a string, we convert the\n\t                        // other value to string as well\n\t                        else if(typeof value[a] == 'string') {\n\t                            return value[a] > value[b].toString() ? 1 :\n\t                                   value[a] < value[b].toString() ? -1 :\n\t\t\t\t\t   0;\n\t                        }\n\t                        else if(typeof value[b] == 'string') {\n\t                            return value[a].toString() > value[b] ? 1 :\n\t                                   value[a].toString() < value[b] ? -1 :\n\t\t\t\t\t   0;\n\t                        }\n\t                        // everything failed - return 'null' as sign, that\n\t                        // the values are not comparable\n\t                        else {\n\t                            return null;\n\t                        }\n\t                    });\n\t                value._keys = sorted_keys;\n\t                return value;\n\t            }\n\t        },\n\t        keys: function(value) {\n\t            if (value === undefined || value === null){\n\t                return;\n\t           }\n\n\t            var keyset = value._keys || Object.keys(value),\n\t                output = [];\n\n\t            Twig.forEach(keyset, function(key) {\n\t                if (key === \"_keys\") return; // Ignore the _keys property\n\t                if (value.hasOwnProperty(key)) {\n\t                    output.push(key);\n\t                }\n\t            });\n\t            return output;\n\t        },\n\t        url_encode: function(value) {\n\t            if (value === undefined || value === null){\n\t                return;\n\t            }\n\n\t            var result = encodeURIComponent(value);\n\t            result = result.replace(\"'\", \"%27\");\n\t            return result;\n\t        },\n\t        join: function(value, params) {\n\t            if (value === undefined || value === null){\n\t                return;\n\t            }\n\n\t            var join_str = \"\",\n\t                output = [],\n\t                keyset = null;\n\n\t            if (params && params[0]) {\n\t                join_str = params[0];\n\t            }\n\t            if (is(\"Array\", value)) {\n\t                output = value;\n\t            } else {\n\t                keyset = value._keys || Object.keys(value);\n\t                Twig.forEach(keyset, function(key) {\n\t                    if (key === \"_keys\") return; // Ignore the _keys property\n\t                    if (value.hasOwnProperty(key)) {\n\t                        output.push(value[key]);\n\t                    }\n\t                });\n\t            }\n\t            return output.join(join_str);\n\t        },\n\t        \"default\": function(value, params) {\n\t            if (params !== undefined && params.length > 1) {\n\t                throw new Twig.Error(\"default filter expects one argument\");\n\t            }\n\t            if (value === undefined || value === null || value === '' ) {\n\t                if (params === undefined) {\n\t                    return '';\n\t                }\n\n\t                return params[0];\n\t            } else {\n\t                return value;\n\t            }\n\t        },\n\t        json_encode: function(value) {\n\t            if(value === undefined || value === null) {\n\t                return \"null\";\n\t            }\n\t            else if ((typeof value == 'object') && (is(\"Array\", value))) {\n\t                output = [];\n\n\t                Twig.forEach(value, function(v) {\n\t                    output.push(Twig.filters.json_encode(v));\n\t                });\n\n\t                return \"[\" + output.join(\",\") + \"]\";\n\t            }\n\t            else if (typeof value == 'object') {\n\t                var keyset = value._keys || Object.keys(value),\n\t                output = [];\n\n\t                Twig.forEach(keyset, function(key) {\n\t                    output.push(JSON.stringify(key) + \":\" + Twig.filters.json_encode(value[key]));\n\t                });\n\n\t                return \"{\" + output.join(\",\") + \"}\";\n\t            }\n\t            else {\n\t                return JSON.stringify(value);\n\t            }\n\t        },\n\t        merge: function(value, params) {\n\t            var obj = [],\n\t                arr_index = 0,\n\t                keyset = [];\n\n\t            // Check to see if all the objects being merged are arrays\n\t            if (!is(\"Array\", value)) {\n\t                // Create obj as an Object\n\t                obj = { };\n\t            } else {\n\t                Twig.forEach(params, function(param) {\n\t                    if (!is(\"Array\", param)) {\n\t                        obj = { };\n\t                    }\n\t                });\n\t            }\n\t            if (!is(\"Array\", obj)) {\n\t                obj._keys = [];\n\t            }\n\n\t            if (is(\"Array\", value)) {\n\t                Twig.forEach(value, function(val) {\n\t                    if (obj._keys) obj._keys.push(arr_index);\n\t                    obj[arr_index] = val;\n\t                    arr_index++;\n\t                });\n\t            } else {\n\t                keyset = value._keys || Object.keys(value);\n\t                Twig.forEach(keyset, function(key) {\n\t                    obj[key] = value[key];\n\t                    obj._keys.push(key);\n\n\t                    // Handle edge case where a number index in an object is greater than\n\t                    //   the array counter. In such a case, the array counter is increased\n\t                    //   one past the index.\n\t                    //\n\t                    // Example {{ [\"a\", \"b\"]|merge({\"4\":\"value\"}, [\"c\", \"d\"])\n\t                    // Without this, d would have an index of \"4\" and overwrite the value\n\t                    //   of \"value\"\n\t                    var int_key = parseInt(key, 10);\n\t                    if (!isNaN(int_key) && int_key >= arr_index) {\n\t                        arr_index = int_key + 1;\n\t                    }\n\t                });\n\t            }\n\n\t            // mixin the merge arrays\n\t            Twig.forEach(params, function(param) {\n\t                if (is(\"Array\", param)) {\n\t                    Twig.forEach(param, function(val) {\n\t                        if (obj._keys) obj._keys.push(arr_index);\n\t                        obj[arr_index] = val;\n\t                        arr_index++;\n\t                    });\n\t                } else {\n\t                    keyset = param._keys || Object.keys(param);\n\t                    Twig.forEach(keyset, function(key) {\n\t                        if (!obj[key]) obj._keys.push(key);\n\t                        obj[key] = param[key];\n\n\t                        var int_key = parseInt(key, 10);\n\t                        if (!isNaN(int_key) && int_key >= arr_index) {\n\t                            arr_index = int_key + 1;\n\t                        }\n\t                    });\n\t                }\n\t            });\n\t            if (params.length === 0) {\n\t                throw new Twig.Error(\"Filter merge expects at least one parameter\");\n\t            }\n\n\t            return obj;\n\t        },\n\t        date: function(value, params) {\n\t            var date = Twig.functions.date(value);\n\t            var format = params && params.length ? params[0] : 'F j, Y H:i';\n\t            return Twig.lib.date(format, date);\n\t        },\n\n\t        date_modify: function(value, params) {\n\t            if (value === undefined || value === null) {\n\t                return;\n\t            }\n\t            if (params === undefined || params.length !== 1) {\n\t                throw new Twig.Error(\"date_modify filter expects 1 argument\");\n\t            }\n\n\t            var modifyText = params[0], time;\n\n\t            if (Twig.lib.is(\"Date\", value)) {\n\t                time = Twig.lib.strtotime(modifyText, value.getTime() / 1000);\n\t            }\n\t            if (Twig.lib.is(\"String\", value)) {\n\t                time = Twig.lib.strtotime(modifyText, Twig.lib.strtotime(value));\n\t            }\n\t            if (Twig.lib.is(\"Number\", value)) {\n\t                time = Twig.lib.strtotime(modifyText, value);\n\t            }\n\n\t            return new Date(time * 1000);\n\t        },\n\n\t        replace: function(value, params) {\n\t            if (value === undefined||value === null){\n\t                return;\n\t            }\n\n\t            var pairs = params[0],\n\t                tag;\n\t            for (tag in pairs) {\n\t                if (pairs.hasOwnProperty(tag) && tag !== \"_keys\") {\n\t                    value = Twig.lib.replaceAll(value, tag, pairs[tag]);\n\t                }\n\t            }\n\t            return value;\n\t        },\n\n\t        format: function(value, params) {\n\t            if (value === undefined || value === null){\n\t                return;\n\t            }\n\n\t            return Twig.lib.vsprintf(value, params);\n\t        },\n\n\t        striptags: function(value) {\n\t            if (value === undefined || value === null){\n\t                return;\n\t            }\n\n\t            return Twig.lib.strip_tags(value);\n\t        },\n\n\t        escape: function(value, params) {\n\t            if (value === undefined|| value === null){\n\t                return;\n\t            }\n\n\t            var strategy = \"html\";\n\t            if(params && params.length && params[0] !== true)\n\t                strategy = params[0];\n\n\t            if(strategy == \"html\") {\n\t                var raw_value = value.toString().replace(/&/g, \"&amp;\")\n\t                            .replace(/</g, \"&lt;\")\n\t                            .replace(/>/g, \"&gt;\")\n\t                            .replace(/\"/g, \"&quot;\")\n\t                            .replace(/'/g, \"&#039;\");\n\t                return Twig.Markup(raw_value, 'html');\n\t            } else if(strategy == \"js\") {\n\t                var raw_value = value.toString();\n\t                var result = \"\";\n\n\t                for(var i = 0; i < raw_value.length; i++) {\n\t                    if(raw_value[i].match(/^[a-zA-Z0-9,\\._]$/))\n\t                        result += raw_value[i];\n\t                    else {\n\t                        var char_code = raw_value.charCodeAt(i);\n\n\t                        if(char_code < 0x80)\n\t                            result += \"\\\\x\" + char_code.toString(16).toUpperCase();\n\t                        else\n\t                            result += Twig.lib.sprintf(\"\\\\u%04s\", char_code.toString(16).toUpperCase());\n\t                    }\n\t                }\n\n\t                return Twig.Markup(result, 'js');\n\t            } else if(strategy == \"css\") {\n\t                var raw_value = value.toString();\n\t                var result = \"\";\n\n\t                for(var i = 0; i < raw_value.length; i++) {\n\t                    if(raw_value[i].match(/^[a-zA-Z0-9]$/))\n\t                        result += raw_value[i];\n\t                    else {\n\t                        var char_code = raw_value.charCodeAt(i);\n\t                        result += \"\\\\\" + char_code.toString(16).toUpperCase() + \" \";\n\t                    }\n\t                }\n\n\t                return Twig.Markup(result, 'css');\n\t            } else if(strategy == \"url\") {\n\t                var result = Twig.filters.url_encode(value);\n\t                return Twig.Markup(result, 'url');\n\t            } else if(strategy == \"html_attr\") {\n\t                var raw_value = value.toString();\n\t                var result = \"\";\n\n\t                for(var i = 0; i < raw_value.length; i++) {\n\t                    if(raw_value[i].match(/^[a-zA-Z0-9,\\.\\-_]$/))\n\t                        result += raw_value[i];\n\t                    else if(raw_value[i].match(/^[&<>\"]$/))\n\t                        result += raw_value[i].replace(/&/g, \"&amp;\")\n\t                                .replace(/</g, \"&lt;\")\n\t                                .replace(/>/g, \"&gt;\")\n\t                                .replace(/\"/g, \"&quot;\");\n\t                    else {\n\t                        var char_code = raw_value.charCodeAt(i);\n\n\t                        // The following replaces characters undefined in HTML with\n\t                        // the hex entity for the Unicode replacement character.\n\t                        if(char_code <= 0x1f && char_code != 0x09 && char_code != 0x0a && char_code != 0x0d)\n\t                            result += \"&#xFFFD;\";\n\t                        else if(char_code < 0x80)\n\t                            result += Twig.lib.sprintf(\"&#x%02s;\", char_code.toString(16).toUpperCase());\n\t                        else\n\t                            result += Twig.lib.sprintf(\"&#x%04s;\", char_code.toString(16).toUpperCase());\n\t                    }\n\t                }\n\n\t                return Twig.Markup(result, 'html_attr');\n\t            } else {\n\t                throw new Twig.Error(\"escape strategy unsupported\");\n\t            }\n\t        },\n\n\t        /* Alias of escape */\n\t        \"e\": function(value, params) {\n\t            return Twig.filters.escape(value, params);\n\t        },\n\n\t        nl2br: function(value) {\n\t            if (value === undefined || value === null){\n\t                return;\n\t            }\n\t            var linebreak_tag = \"BACKSLASH_n_replace\",\n\t                br = \"<br />\" + linebreak_tag;\n\n\t            value = Twig.filters.escape(value)\n\t                        .replace(/\\r\\n/g, br)\n\t                        .replace(/\\r/g, br)\n\t                        .replace(/\\n/g, br);\n\n\t            value = Twig.lib.replaceAll(value, linebreak_tag, \"\\n\");\n\n\t            return Twig.Markup(value);\n\t        },\n\n\t        /**\n\t         * Adapted from: http://phpjs.org/functions/number_format:481\n\t         */\n\t        number_format: function(value, params) {\n\t            var number = value,\n\t                decimals = (params && params[0]) ? params[0] : undefined,\n\t                dec      = (params && params[1] !== undefined) ? params[1] : \".\",\n\t                sep      = (params && params[2] !== undefined) ? params[2] : \",\";\n\n\t            number = (number + '').replace(/[^0-9+\\-Ee.]/g, '');\n\t            var n = !isFinite(+number) ? 0 : +number,\n\t                prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),\n\t                s = '',\n\t                toFixedFix = function (n, prec) {\n\t                    var k = Math.pow(10, prec);\n\t                    return '' + Math.round(n * k) / k;\n\t                };\n\t            // Fix for IE parseFloat(0.55).toFixed(0) = 0;\n\t            s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.');\n\t            if (s[0].length > 3) {\n\t                s[0] = s[0].replace(/\\B(?=(?:\\d{3})+(?!\\d))/g, sep);\n\t            }\n\t            if ((s[1] || '').length < prec) {\n\t                s[1] = s[1] || '';\n\t                s[1] += new Array(prec - s[1].length + 1).join('0');\n\t            }\n\t            return s.join(dec);\n\t        },\n\n\t        trim: function(value, params) {\n\t            if (value === undefined|| value === null){\n\t                return;\n\t            }\n\n\t            var str = Twig.filters.escape( '' + value ),\n\t                whitespace;\n\t            if ( params && params[0] ) {\n\t                whitespace = '' + params[0];\n\t            } else {\n\t                whitespace = ' \\n\\r\\t\\f\\x0b\\xa0\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u3000';\n\t            }\n\t            for (var i = 0; i < str.length; i++) {\n\t                if (whitespace.indexOf(str.charAt(i)) === -1) {\n\t                    str = str.substring(i);\n\t                    break;\n\t                }\n\t            }\n\t            for (i = str.length - 1; i >= 0; i--) {\n\t                if (whitespace.indexOf(str.charAt(i)) === -1) {\n\t                    str = str.substring(0, i + 1);\n\t                    break;\n\t                }\n\t            }\n\t            return whitespace.indexOf(str.charAt(0)) === -1 ? str : '';\n\t        },\n\n\t        truncate: function (value, params) {\n\t            var length = 30,\n\t                preserve = false,\n\t                separator = '...';\n\n\t            value =  value + '';\n\t            if (params) {\n\t                if (params[0]) {\n\t                    length = params[0];\n\t                }\n\t                if (params[1]) {\n\t                    preserve = params[1];\n\t                }\n\t                if (params[2]) {\n\t                    separator = params[2];\n\t                }\n\t            }\n\n\t            if (value.length > length) {\n\n\t                if (preserve) {\n\t                    length = value.indexOf(' ', length);\n\t                    if (length === -1) {\n\t                        return value;\n\t                    }\n\t                }\n\n\t                value =  value.substr(0, length) + separator;\n\t            }\n\n\t            return value;\n\t        },\n\n\t        slice: function(value, params) {\n\t            if (value === undefined || value === null) {\n\t                return;\n\t            }\n\t            if (params === undefined || params.length < 1) {\n\t                throw new Twig.Error(\"slice filter expects at least 1 argument\");\n\t            }\n\n\t            // default to start of string\n\t            var start = params[0] || 0;\n\t            // default to length of string\n\t            var length = params.length > 1 ? params[1] : value.length;\n\t            // handle negative start values\n\t            var startIndex = start >= 0 ? start : Math.max( value.length + start, 0 );\n\n\t            if (Twig.lib.is(\"Array\", value)) {\n\t                var output = [];\n\t                for (var i = startIndex; i < startIndex + length && i < value.length; i++) {\n\t                    output.push(value[i]);\n\t                }\n\t                return output;\n\t            } else if (Twig.lib.is(\"String\", value)) {\n\t                return value.substr(startIndex, length);\n\t            } else {\n\t                throw new Twig.Error(\"slice filter expects value to be an array or string\");\n\t            }\n\t        },\n\n\t        abs: function(value) {\n\t            if (value === undefined || value === null) {\n\t                return;\n\t            }\n\n\t            return Math.abs(value);\n\t        },\n\n\t        first: function(value) {\n\t            if (is(\"Array\", value)) {\n\t                return value[0];\n\t            } else if (is(\"Object\", value)) {\n\t                if ('_keys' in value) {\n\t                    return value[value._keys[0]];\n\t                }\n\t            } else if ( typeof value === \"string\" ) {\n\t                return value.substr(0, 1);\n\t            }\n\n\t            return;\n\t        },\n\n\t        split: function(value, params) {\n\t            if (value === undefined || value === null) {\n\t                return;\n\t            }\n\t            if (params === undefined || params.length < 1 || params.length > 2) {\n\t                throw new Twig.Error(\"split filter expects 1 or 2 argument\");\n\t            }\n\t            if (Twig.lib.is(\"String\", value)) {\n\t                var delimiter = params[0],\n\t                    limit = params[1],\n\t                    split = value.split(delimiter);\n\n\t                if (limit === undefined) {\n\n\t                    return split;\n\n\t                } else if (limit < 0) {\n\n\t                    return value.split(delimiter, split.length + limit);\n\n\t                } else {\n\n\t                    var limitedSplit = [];\n\n\t                    if (delimiter == '') {\n\t                        // empty delimiter\n\t                        // \"aabbcc\"|split('', 2)\n\t                        //     -> ['aa', 'bb', 'cc']\n\n\t                        while(split.length > 0) {\n\t                            var temp = \"\";\n\t                            for (var i=0; i<limit && split.length > 0; i++) {\n\t                                temp += split.shift();\n\t                            }\n\t                            limitedSplit.push(temp);\n\t                        }\n\n\t                    } else {\n\t                        // non-empty delimiter\n\t                        // \"one,two,three,four,five\"|split(',', 3)\n\t                        //     -> ['one', 'two', 'three,four,five']\n\n\t                        for (var i=0; i<limit-1 && split.length > 0; i++) {\n\t                            limitedSplit.push(split.shift());\n\t                        }\n\n\t                        if (split.length > 0) {\n\t                            limitedSplit.push(split.join(delimiter));\n\t                        }\n\t                    }\n\n\t                    return limitedSplit;\n\t                }\n\n\t            } else {\n\t                throw new Twig.Error(\"split filter expects value to be a string\");\n\t            }\n\t        },\n\t        last: function(value) {\n\t            if (Twig.lib.is('Object', value)) {\n\t                var keys;\n\n\t                if (value._keys === undefined) {\n\t                    keys = Object.keys(value);\n\t                } else {\n\t                    keys = value._keys;\n\t                }\n\n\t                return value[keys[keys.length - 1]];\n\t            }\n\n\t            // string|array\n\t            return value[value.length - 1];\n\t        },\n\t        raw: function(value) {\n\t            return Twig.Markup(value);\n\t        },\n\t        batch: function(items, params) {\n\t            var size = params.shift(),\n\t                fill = params.shift(),\n\t                result,\n\t                last,\n\t                missing;\n\n\t            if (!Twig.lib.is(\"Array\", items)) {\n\t                throw new Twig.Error(\"batch filter expects items to be an array\");\n\t            }\n\n\t            if (!Twig.lib.is(\"Number\", size)) {\n\t                throw new Twig.Error(\"batch filter expects size to be a number\");\n\t            }\n\n\t            size = Math.ceil(size);\n\n\t            result = Twig.lib.chunkArray(items, size);\n\n\t            if (fill && items.length % size != 0) {\n\t                last = result.pop();\n\t                missing = size - last.length;\n\n\t                while (missing--) {\n\t                    last.push(fill);\n\t                }\n\n\t                result.push(last);\n\t            }\n\n\t            return result;\n\t        },\n\t        round: function(value, params) {\n\t            params = params || [];\n\n\t            var precision = params.length > 0 ? params[0] : 0,\n\t                method = params.length > 1 ? params[1] : \"common\";\n\n\t            value = parseFloat(value);\n\n\t            if(precision && !Twig.lib.is(\"Number\", precision)) {\n\t                throw new Twig.Error(\"round filter expects precision to be a number\");\n\t            }\n\n\t            if (method === \"common\") {\n\t                return Twig.lib.round(value, precision);\n\t            }\n\n\t            if(!Twig.lib.is(\"Function\", Math[method])) {\n\t                throw new Twig.Error(\"round filter expects method to be 'floor', 'ceil', or 'common'\");\n\t            }\n\n\t            return Math[method](value * Math.pow(10, precision)) / Math.pow(10, precision);\n\t        }\n\t    };\n\n\t    Twig.filter = function(filter, value, params) {\n\t        if (!Twig.filters[filter]) {\n\t            throw \"Unable to find filter \" + filter;\n\t        }\n\t        return Twig.filters[filter].apply(this, [value, params]);\n\t    };\n\n\t    Twig.filter.extend = function(filter, definition) {\n\t        Twig.filters[filter] = definition;\n\t    };\n\n\t    return Twig;\n\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t// ## twig.functions.js\n\t//\n\t// This file handles parsing filters.\n\tmodule.exports = function (Twig) {\n\t    /**\n\t     * @constant\n\t     * @type {string}\n\t     */\n\t    var TEMPLATE_NOT_FOUND_MESSAGE = 'Template \"{name}\" is not defined.';\n\n\t    // Determine object type\n\t    function is(type, obj) {\n\t        var clas = Object.prototype.toString.call(obj).slice(8, -1);\n\t        return obj !== undefined && obj !== null && clas === type;\n\t    }\n\n\t    Twig.functions = {\n\t        //  attribute, block, constant, date, dump, parent, random,.\n\n\t        // Range function from http://phpjs.org/functions/range:499\n\t        // Used under an MIT License\n\t        range: function (low, high, step) {\n\t            // http://kevin.vanzonneveld.net\n\t            // +   original by: Waldo Malqui Silva\n\t            // *     example 1: range ( 0, 12 );\n\t            // *     returns 1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\t            // *     example 2: range( 0, 100, 10 );\n\t            // *     returns 2: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n\t            // *     example 3: range( 'a', 'i' );\n\t            // *     returns 3: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']\n\t            // *     example 4: range( 'c', 'a' );\n\t            // *     returns 4: ['c', 'b', 'a']\n\t            var matrix = [];\n\t            var inival, endval, plus;\n\t            var walker = step || 1;\n\t            var chars = false;\n\n\t            if (!isNaN(low) && !isNaN(high)) {\n\t                inival = parseInt(low, 10);\n\t                endval = parseInt(high, 10);\n\t            } else if (isNaN(low) && isNaN(high)) {\n\t                chars = true;\n\t                inival = low.charCodeAt(0);\n\t                endval = high.charCodeAt(0);\n\t            } else {\n\t                inival = (isNaN(low) ? 0 : low);\n\t                endval = (isNaN(high) ? 0 : high);\n\t            }\n\n\t            plus = ((inival > endval) ? false : true);\n\t            if (plus) {\n\t                while (inival <= endval) {\n\t                    matrix.push(((chars) ? String.fromCharCode(inival) : inival));\n\t                    inival += walker;\n\t                }\n\t            } else {\n\t                while (inival >= endval) {\n\t                    matrix.push(((chars) ? String.fromCharCode(inival) : inival));\n\t                    inival -= walker;\n\t                }\n\t            }\n\n\t            return matrix;\n\t        },\n\t        cycle: function(arr, i) {\n\t            var pos = i % arr.length;\n\t            return arr[pos];\n\t        },\n\t        dump: function() {\n\t            var EOL = '\\n',\n\t                indentChar = '  ',\n\t                indentTimes = 0,\n\t                out = '',\n\t                args = Array.prototype.slice.call(arguments),\n\t                indent = function(times) {\n\t                    var ind  = '';\n\t                    while (times > 0) {\n\t                        times--;\n\t                        ind += indentChar;\n\t                    }\n\t                    return ind;\n\t                },\n\t                displayVar = function(variable) {\n\t                    out += indent(indentTimes);\n\t                    if (typeof(variable) === 'object') {\n\t                        dumpVar(variable);\n\t                    } else if (typeof(variable) === 'function') {\n\t                        out += 'function()' + EOL;\n\t                    } else if (typeof(variable) === 'string') {\n\t                        out += 'string(' + variable.length + ') \"' + variable + '\"' + EOL;\n\t                    } else if (typeof(variable) === 'number') {\n\t                        out += 'number(' + variable + ')' + EOL;\n\t                    } else if (typeof(variable) === 'boolean') {\n\t                        out += 'bool(' + variable + ')' + EOL;\n\t                    }\n\t                },\n\t                dumpVar = function(variable) {\n\t                    var i;\n\t                    if (variable === null) {\n\t                        out += 'NULL' + EOL;\n\t                    } else if (variable === undefined) {\n\t                        out += 'undefined' + EOL;\n\t                    } else if (typeof variable === 'object') {\n\t                        out += indent(indentTimes) + typeof(variable);\n\t                        indentTimes++;\n\t                        out += '(' + (function(obj) {\n\t                            var size = 0, key;\n\t                            for (key in obj) {\n\t                                if (obj.hasOwnProperty(key)) {\n\t                                    size++;\n\t                                }\n\t                            }\n\t                            return size;\n\t                        })(variable) + ') {' + EOL;\n\t                        for (i in variable) {\n\t                            out += indent(indentTimes) + '[' + i + ']=> ' + EOL;\n\t                            displayVar(variable[i]);\n\t                        }\n\t                        indentTimes--;\n\t                        out += indent(indentTimes) + '}' + EOL;\n\t                    } else {\n\t                        displayVar(variable);\n\t                    }\n\t                };\n\n\t            // handle no argument case by dumping the entire render context\n\t            if (args.length == 0) args.push(this.context);\n\n\t            Twig.forEach(args, function(variable) {\n\t                dumpVar(variable);\n\t            });\n\n\t            return out;\n\t        },\n\t        date: function(date, time) {\n\t            var dateObj;\n\t            if (date === undefined || date === null || date === \"\") {\n\t                dateObj = new Date();\n\t            } else if (Twig.lib.is(\"Date\", date)) {\n\t                dateObj = date;\n\t            } else if (Twig.lib.is(\"String\", date)) {\n\t                if (date.match(/^[0-9]+$/)) {\n\t                    dateObj = new Date(date * 1000);\n\t                }\n\t                else {\n\t                    dateObj = new Date(Twig.lib.strtotime(date) * 1000);\n\t                }\n\t            } else if (Twig.lib.is(\"Number\", date)) {\n\t                // timestamp\n\t                dateObj = new Date(date * 1000);\n\t            } else {\n\t                throw new Twig.Error(\"Unable to parse date \" + date);\n\t            }\n\t            return dateObj;\n\t        },\n\t        block: function(block) {\n\t            if (this.originalBlockTokens[block]) {\n\t                return Twig.logic.parse.apply(this, [this.originalBlockTokens[block], this.context]).output;\n\t            } else {\n\t                return this.blocks[block];\n\t            }\n\t        },\n\t        parent: function() {\n\t            // Add a placeholder\n\t            return Twig.placeholders.parent;\n\t        },\n\t        attribute: function(object, method, params) {\n\t            if (Twig.lib.is('Object', object)) {\n\t                if (object.hasOwnProperty(method)) {\n\t                    if (typeof object[method] === \"function\") {\n\t                        return object[method].apply(undefined, params);\n\t                    }\n\t                    else {\n\t                        return object[method];\n\t                    }\n\t                }\n\t            }\n\t            // Array will return element 0-index\n\t            return object[method] || undefined;\n\t        },\n\t        max: function(values) {\n\t            if(Twig.lib.is(\"Object\", values)) {\n\t                delete values[\"_keys\"];\n\t                return Twig.lib.max(values);\n\t            }\n\n\t            return Twig.lib.max.apply(null, arguments);\n\t        },\n\t        min: function(values) {\n\t            if(Twig.lib.is(\"Object\", values)) {\n\t                delete values[\"_keys\"];\n\t                return Twig.lib.min(values);\n\t            }\n\n\t            return Twig.lib.min.apply(null, arguments);\n\t        },\n\t        template_from_string: function(template) {\n\t            if (template === undefined) {\n\t                template = '';\n\t            }\n\t            return Twig.Templates.parsers.twig({\n\t                options: this.options,\n\t                data: template\n\t            });\n\t        },\n\t        random: function(value) {\n\t            var LIMIT_INT31 = 0x80000000;\n\n\t            function getRandomNumber(n) {\n\t                var random = Math.floor(Math.random() * LIMIT_INT31);\n\t                var limits = [0, n];\n\t                var min = Math.min.apply(null, limits),\n\t                    max = Math.max.apply(null, limits);\n\t                return min + Math.floor((max - min + 1) * random / LIMIT_INT31);\n\t            }\n\n\t            if(Twig.lib.is(\"Number\", value)) {\n\t                return getRandomNumber(value);\n\t            }\n\n\t            if(Twig.lib.is(\"String\", value)) {\n\t                return value.charAt(getRandomNumber(value.length-1));\n\t            }\n\n\t            if(Twig.lib.is(\"Array\", value)) {\n\t                return value[getRandomNumber(value.length-1)];\n\t            }\n\n\t            if(Twig.lib.is(\"Object\", value)) {\n\t                var keys = Object.keys(value);\n\t                return value[keys[getRandomNumber(keys.length-1)]];\n\t            }\n\n\t            return getRandomNumber(LIMIT_INT31-1);\n\t        },\n\n\t        /**\n\t         * Returns the content of a template without rendering it\n\t         * @param {string} name\n\t         * @param {boolean} [ignore_missing=false]\n\t         * @returns {string}\n\t         */\n\t        source: function(name, ignore_missing) {\n\t            var templateSource;\n\t            var templateFound = false;\n\t            var isNodeEnvironment = typeof module !== 'undefined' && typeof module.exports !== 'undefined' && typeof window === 'undefined';\n\t            var loader;\n\t            var path;\n\n\t            //if we are running in a node.js environment, set the loader to 'fs' and ensure the\n\t            // path is relative to the CWD of the running script\n\t            //else, set the loader to 'ajax' and set the path to the value of name\n\t            if (isNodeEnvironment) {\n\t                loader = 'fs';\n\t                path = __dirname + '/' + name;\n\t            } else {\n\t                loader = 'ajax';\n\t                path = name;\n\t            }\n\n\t            //build the params object\n\t            var params = {\n\t                id: name,\n\t                path: path,\n\t                method: loader,\n\t                parser: 'source',\n\t                async: false,\n\t                fetchTemplateSource: true\n\t            };\n\n\t            //default ignore_missing to false\n\t            if (typeof ignore_missing === 'undefined') {\n\t                ignore_missing = false;\n\t            }\n\n\t            //try to load the remote template\n\t            //\n\t            //on exception, log it\n\t            try {\n\t                templateSource = Twig.Templates.loadRemote(name, params);\n\n\t                //if the template is undefined or null, set the template to an empty string and do NOT flip the\n\t                // boolean indicating we found the template\n\t                //\n\t                //else, all is good! flip the boolean indicating we found the template\n\t                if (typeof templateSource === 'undefined' || templateSource === null) {\n\t                    templateSource = '';\n\t                } else {\n\t                    templateFound = true;\n\t                }\n\t            } catch (e) {\n\t                Twig.log.debug('Twig.functions.source: ', 'Problem loading template  ', e);\n\t            }\n\n\t            //if the template was NOT found AND we are not ignoring missing templates, return the same message\n\t            // that is returned by the PHP implementation of the twig source() function\n\t            //\n\t            //else, return the template source\n\t            if (!templateFound && !ignore_missing) {\n\t                return TEMPLATE_NOT_FOUND_MESSAGE.replace('{name}', name);\n\t            } else {\n\t                return templateSource;\n\t            }\n\t        }\n\t    };\n\n\t    Twig._function = function(_function, value, params) {\n\t        if (!Twig.functions[_function]) {\n\t            throw \"Unable to find function \" + _function;\n\t        }\n\t        return Twig.functions[_function](value, params);\n\t    };\n\n\t    Twig._function.extend = function(_function, definition) {\n\t        Twig.functions[_function] = definition;\n\t    };\n\n\t    return Twig;\n\n\t};\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// ## twig.lib.js\n\t//\n\t// This file contains 3rd party libraries used within twig.\n\t//\n\t// Copies of the licenses for the code included here can be found in the\n\t// LICENSES.md file.\n\t//\n\n\tmodule.exports = function(Twig) {\n\n\t    // Namespace for libraries\n\t    Twig.lib = { };\n\n\t    Twig.lib.sprintf = __webpack_require__(8);\n\t    Twig.lib.vsprintf = __webpack_require__(9);\n\t    Twig.lib.round = __webpack_require__(10);\n\t    Twig.lib.max = __webpack_require__(11);\n\t    Twig.lib.min = __webpack_require__(12);\n\t    Twig.lib.strip_tags = __webpack_require__(13);\n\t    Twig.lib.strtotime = __webpack_require__(14);\n\t    Twig.lib.date = __webpack_require__(15);\n\t    Twig.lib.boolval = __webpack_require__(16);\n\n\t    Twig.lib.is = function(type, obj) {\n\t        var clas = Object.prototype.toString.call(obj).slice(8, -1);\n\t        return obj !== undefined && obj !== null && clas === type;\n\t    };\n\n\t    // shallow-copy an object\n\t    Twig.lib.copy = function(src) {\n\t        var target = {},\n\t            key;\n\t        for (key in src)\n\t            target[key] = src[key];\n\n\t        return target;\n\t    };\n\n\t    Twig.lib.extend = function (src, add) {\n\t        var keys = Object.keys(add),\n\t            i;\n\n\t        i = keys.length;\n\n\t        while (i--) {\n\t            src[keys[i]] = add[keys[i]];\n\t        }\n\n\t        return src;\n\t    };\n\n\t    Twig.lib.replaceAll = function(string, search, replace) {\n\t        return string.split(search).join(replace);\n\t    };\n\n\t    // chunk an array (arr) into arrays of (size) items, returns an array of arrays, or an empty array on invalid input\n\t    Twig.lib.chunkArray = function (arr, size) {\n\t        var returnVal = [],\n\t            x = 0,\n\t            len = arr.length;\n\n\t        if (size < 1 || !Twig.lib.is(\"Array\", arr)) {\n\t            return [];\n\t        }\n\n\t        while (x < len) {\n\t            returnVal.push(arr.slice(x, x += size));\n\t        }\n\n\t        return returnVal;\n\t    };\n\n\t    return Twig;\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tmodule.exports = function sprintf() {\n\t  //  discuss at: http://locutus.io/php/sprintf/\n\t  // original by: Ash Searle (http://hexmen.com/blog/)\n\t  // improved by: Michael White (http://getsprink.com)\n\t  // improved by: Jack\n\t  // improved by: Kevin van Zonneveld (http://kvz.io)\n\t  // improved by: Kevin van Zonneveld (http://kvz.io)\n\t  // improved by: Kevin van Zonneveld (http://kvz.io)\n\t  // improved by: Dj\n\t  // improved by: Allidylls\n\t  //    input by: Paulo Freitas\n\t  //    input by: Brett Zamir (http://brett-zamir.me)\n\t  //   example 1: sprintf(\"%01.2f\", 123.1)\n\t  //   returns 1: '123.10'\n\t  //   example 2: sprintf(\"[%10s]\", 'monkey')\n\t  //   returns 2: '[    monkey]'\n\t  //   example 3: sprintf(\"[%'#10s]\", 'monkey')\n\t  //   returns 3: '[####monkey]'\n\t  //   example 4: sprintf(\"%d\", 123456789012345)\n\t  //   returns 4: '123456789012345'\n\t  //   example 5: sprintf('%-03s', 'E')\n\t  //   returns 5: 'E00'\n\n\t  var regex = /%%|%(\\d+\\$)?([-+'#0 ]*)(\\*\\d+\\$|\\*|\\d+)?(?:\\.(\\*\\d+\\$|\\*|\\d+))?([scboxXuideEfFgG])/g;\n\t  var a = arguments;\n\t  var i = 0;\n\t  var format = a[i++];\n\n\t  var _pad = function _pad(str, len, chr, leftJustify) {\n\t    if (!chr) {\n\t      chr = ' ';\n\t    }\n\t    var padding = str.length >= len ? '' : new Array(1 + len - str.length >>> 0).join(chr);\n\t    return leftJustify ? str + padding : padding + str;\n\t  };\n\n\t  var justify = function justify(value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {\n\t    var diff = minWidth - value.length;\n\t    if (diff > 0) {\n\t      if (leftJustify || !zeroPad) {\n\t        value = _pad(value, minWidth, customPadChar, leftJustify);\n\t      } else {\n\t        value = [value.slice(0, prefix.length), _pad('', diff, '0', true), value.slice(prefix.length)].join('');\n\t      }\n\t    }\n\t    return value;\n\t  };\n\n\t  var _formatBaseX = function _formatBaseX(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {\n\t    // Note: casts negative numbers to positive ones\n\t    var number = value >>> 0;\n\t    prefix = prefix && number && {\n\t      '2': '0b',\n\t      '8': '0',\n\t      '16': '0x'\n\t    }[base] || '';\n\t    value = prefix + _pad(number.toString(base), precision || 0, '0', false);\n\t    return justify(value, prefix, leftJustify, minWidth, zeroPad);\n\t  };\n\n\t  // _formatString()\n\t  var _formatString = function _formatString(value, leftJustify, minWidth, precision, zeroPad, customPadChar) {\n\t    if (precision !== null && precision !== undefined) {\n\t      value = value.slice(0, precision);\n\t    }\n\t    return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);\n\t  };\n\n\t  // doFormat()\n\t  var doFormat = function doFormat(substring, valueIndex, flags, minWidth, precision, type) {\n\t    var number, prefix, method, textTransform, value;\n\n\t    if (substring === '%%') {\n\t      return '%';\n\t    }\n\n\t    // parse flags\n\t    var leftJustify = false;\n\t    var positivePrefix = '';\n\t    var zeroPad = false;\n\t    var prefixBaseX = false;\n\t    var customPadChar = ' ';\n\t    var flagsl = flags.length;\n\t    var j;\n\t    for (j = 0; j < flagsl; j++) {\n\t      switch (flags.charAt(j)) {\n\t        case ' ':\n\t          positivePrefix = ' ';\n\t          break;\n\t        case '+':\n\t          positivePrefix = '+';\n\t          break;\n\t        case '-':\n\t          leftJustify = true;\n\t          break;\n\t        case \"'\":\n\t          customPadChar = flags.charAt(j + 1);\n\t          break;\n\t        case '0':\n\t          zeroPad = true;\n\t          customPadChar = '0';\n\t          break;\n\t        case '#':\n\t          prefixBaseX = true;\n\t          break;\n\t      }\n\t    }\n\n\t    // parameters may be null, undefined, empty-string or real valued\n\t    // we want to ignore null, undefined and empty-string values\n\t    if (!minWidth) {\n\t      minWidth = 0;\n\t    } else if (minWidth === '*') {\n\t      minWidth = +a[i++];\n\t    } else if (minWidth.charAt(0) === '*') {\n\t      minWidth = +a[minWidth.slice(1, -1)];\n\t    } else {\n\t      minWidth = +minWidth;\n\t    }\n\n\t    // Note: undocumented perl feature:\n\t    if (minWidth < 0) {\n\t      minWidth = -minWidth;\n\t      leftJustify = true;\n\t    }\n\n\t    if (!isFinite(minWidth)) {\n\t      throw new Error('sprintf: (minimum-)width must be finite');\n\t    }\n\n\t    if (!precision) {\n\t      precision = 'fFeE'.indexOf(type) > -1 ? 6 : type === 'd' ? 0 : undefined;\n\t    } else if (precision === '*') {\n\t      precision = +a[i++];\n\t    } else if (precision.charAt(0) === '*') {\n\t      precision = +a[precision.slice(1, -1)];\n\t    } else {\n\t      precision = +precision;\n\t    }\n\n\t    // grab value using valueIndex if required?\n\t    value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];\n\n\t    switch (type) {\n\t      case 's':\n\t        return _formatString(value + '', leftJustify, minWidth, precision, zeroPad, customPadChar);\n\t      case 'c':\n\t        return _formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);\n\t      case 'b':\n\t        return _formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n\t      case 'o':\n\t        return _formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n\t      case 'x':\n\t        return _formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n\t      case 'X':\n\t        return _formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();\n\t      case 'u':\n\t        return _formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n\t      case 'i':\n\t      case 'd':\n\t        number = +value || 0;\n\t        // Plain Math.round doesn't just truncate\n\t        number = Math.round(number - number % 1);\n\t        prefix = number < 0 ? '-' : positivePrefix;\n\t        value = prefix + _pad(String(Math.abs(number)), precision, '0', false);\n\t        return justify(value, prefix, leftJustify, minWidth, zeroPad);\n\t      case 'e':\n\t      case 'E':\n\t      case 'f': // @todo: Should handle locales (as per setlocale)\n\t      case 'F':\n\t      case 'g':\n\t      case 'G':\n\t        number = +value;\n\t        prefix = number < 0 ? '-' : positivePrefix;\n\t        method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];\n\t        textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];\n\t        value = prefix + Math.abs(number)[method](precision);\n\t        return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();\n\t      default:\n\t        return substring;\n\t    }\n\t  };\n\n\t  return format.replace(regex, doFormat);\n\t};\n\t//# sourceMappingURL=sprintf.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tmodule.exports = function vsprintf(format, args) {\n\t  //  discuss at: http://locutus.io/php/vsprintf/\n\t  // original by: ejsanders\n\t  //   example 1: vsprintf('%04d-%02d-%02d', [1988, 8, 1])\n\t  //   returns 1: '1988-08-01'\n\n\t  var sprintf = __webpack_require__(8);\n\n\t  return sprintf.apply(this, [format].concat(args));\n\t};\n\t//# sourceMappingURL=vsprintf.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tmodule.exports = function round(value, precision, mode) {\n\t  //  discuss at: http://locutus.io/php/round/\n\t  // original by: Philip Peterson\n\t  //  revised by: Onno Marsman (https://twitter.com/onnomarsman)\n\t  //  revised by: T.Wild\n\t  //  revised by: Rafa Kukawski (http://blog.kukawski.pl)\n\t  //    input by: Greenseed\n\t  //    input by: meo\n\t  //    input by: William\n\t  //    input by: Josep Sanz (http://www.ws3.es/)\n\t  // bugfixed by: Brett Zamir (http://brett-zamir.me)\n\t  //      note 1: Great work. Ideas for improvement:\n\t  //      note 1: - code more compliant with developer guidelines\n\t  //      note 1: - for implementing PHP constant arguments look at\n\t  //      note 1: the pathinfo() function, it offers the greatest\n\t  //      note 1: flexibility & compatibility possible\n\t  //   example 1: round(1241757, -3)\n\t  //   returns 1: 1242000\n\t  //   example 2: round(3.6)\n\t  //   returns 2: 4\n\t  //   example 3: round(2.835, 2)\n\t  //   returns 3: 2.84\n\t  //   example 4: round(1.1749999999999, 2)\n\t  //   returns 4: 1.17\n\t  //   example 5: round(58551.799999999996, 2)\n\t  //   returns 5: 58551.8\n\n\t  var m, f, isHalf, sgn; // helper variables\n\t  // making sure precision is integer\n\t  precision |= 0;\n\t  m = Math.pow(10, precision);\n\t  value *= m;\n\t  // sign of the number\n\t  sgn = value > 0 | -(value < 0);\n\t  isHalf = value % 1 === 0.5 * sgn;\n\t  f = Math.floor(value);\n\n\t  if (isHalf) {\n\t    switch (mode) {\n\t      case 'PHP_ROUND_HALF_DOWN':\n\t        // rounds .5 toward zero\n\t        value = f + (sgn < 0);\n\t        break;\n\t      case 'PHP_ROUND_HALF_EVEN':\n\t        // rouds .5 towards the next even integer\n\t        value = f + f % 2 * sgn;\n\t        break;\n\t      case 'PHP_ROUND_HALF_ODD':\n\t        // rounds .5 towards the next odd integer\n\t        value = f + !(f % 2);\n\t        break;\n\t      default:\n\t        // rounds .5 away from zero\n\t        value = f + (sgn > 0);\n\t    }\n\t  }\n\n\t  return (isHalf ? value : Math.round(value)) / m;\n\t};\n\t//# sourceMappingURL=round.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\tmodule.exports = function max() {\n\t  //  discuss at: http://locutus.io/php/max/\n\t  // original by: Onno Marsman (https://twitter.com/onnomarsman)\n\t  //  revised by: Onno Marsman (https://twitter.com/onnomarsman)\n\t  // improved by: Jack\n\t  //      note 1: Long code cause we're aiming for maximum PHP compatibility\n\t  //   example 1: max(1, 3, 5, 6, 7)\n\t  //   returns 1: 7\n\t  //   example 2: max([2, 4, 5])\n\t  //   returns 2: 5\n\t  //   example 3: max(0, 'hello')\n\t  //   returns 3: 0\n\t  //   example 4: max('hello', 0)\n\t  //   returns 4: 'hello'\n\t  //   example 5: max(-1, 'hello')\n\t  //   returns 5: 'hello'\n\t  //   example 6: max([2, 4, 8], [2, 5, 7])\n\t  //   returns 6: [2, 5, 7]\n\n\t  var ar;\n\t  var retVal;\n\t  var i = 0;\n\t  var n = 0;\n\t  var argv = arguments;\n\t  var argc = argv.length;\n\t  var _obj2Array = function _obj2Array(obj) {\n\t    if (Object.prototype.toString.call(obj) === '[object Array]') {\n\t      return obj;\n\t    } else {\n\t      var ar = [];\n\t      for (var i in obj) {\n\t        if (obj.hasOwnProperty(i)) {\n\t          ar.push(obj[i]);\n\t        }\n\t      }\n\t      return ar;\n\t    }\n\t  };\n\t  var _compare = function _compare(current, next) {\n\t    var i = 0;\n\t    var n = 0;\n\t    var tmp = 0;\n\t    var nl = 0;\n\t    var cl = 0;\n\n\t    if (current === next) {\n\t      return 0;\n\t    } else if ((typeof current === 'undefined' ? 'undefined' : _typeof(current)) === 'object') {\n\t      if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {\n\t        current = _obj2Array(current);\n\t        next = _obj2Array(next);\n\t        cl = current.length;\n\t        nl = next.length;\n\t        if (nl > cl) {\n\t          return 1;\n\t        } else if (nl < cl) {\n\t          return -1;\n\t        }\n\t        for (i = 0, n = cl; i < n; ++i) {\n\t          tmp = _compare(current[i], next[i]);\n\t          if (tmp === 1) {\n\t            return 1;\n\t          } else if (tmp === -1) {\n\t            return -1;\n\t          }\n\t        }\n\t        return 0;\n\t      }\n\t      return -1;\n\t    } else if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {\n\t      return 1;\n\t    } else if (isNaN(next) && !isNaN(current)) {\n\t      if (current === 0) {\n\t        return 0;\n\t      }\n\t      return current < 0 ? 1 : -1;\n\t    } else if (isNaN(current) && !isNaN(next)) {\n\t      if (next === 0) {\n\t        return 0;\n\t      }\n\t      return next > 0 ? 1 : -1;\n\t    }\n\n\t    if (next === current) {\n\t      return 0;\n\t    }\n\n\t    return next > current ? 1 : -1;\n\t  };\n\n\t  if (argc === 0) {\n\t    throw new Error('At least one value should be passed to max()');\n\t  } else if (argc === 1) {\n\t    if (_typeof(argv[0]) === 'object') {\n\t      ar = _obj2Array(argv[0]);\n\t    } else {\n\t      throw new Error('Wrong parameter count for max()');\n\t    }\n\t    if (ar.length === 0) {\n\t      throw new Error('Array must contain at least one element for max()');\n\t    }\n\t  } else {\n\t    ar = argv;\n\t  }\n\n\t  retVal = ar[0];\n\t  for (i = 1, n = ar.length; i < n; ++i) {\n\t    if (_compare(retVal, ar[i]) === 1) {\n\t      retVal = ar[i];\n\t    }\n\t  }\n\n\t  return retVal;\n\t};\n\t//# sourceMappingURL=max.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\tmodule.exports = function min() {\n\t  //  discuss at: http://locutus.io/php/min/\n\t  // original by: Onno Marsman (https://twitter.com/onnomarsman)\n\t  //  revised by: Onno Marsman (https://twitter.com/onnomarsman)\n\t  // improved by: Jack\n\t  //      note 1: Long code cause we're aiming for maximum PHP compatibility\n\t  //   example 1: min(1, 3, 5, 6, 7)\n\t  //   returns 1: 1\n\t  //   example 2: min([2, 4, 5])\n\t  //   returns 2: 2\n\t  //   example 3: min(0, 'hello')\n\t  //   returns 3: 0\n\t  //   example 4: min('hello', 0)\n\t  //   returns 4: 'hello'\n\t  //   example 5: min(-1, 'hello')\n\t  //   returns 5: -1\n\t  //   example 6: min([2, 4, 8], [2, 5, 7])\n\t  //   returns 6: [2, 4, 8]\n\n\t  var ar;\n\t  var retVal;\n\t  var i = 0;\n\t  var n = 0;\n\t  var argv = arguments;\n\t  var argc = argv.length;\n\t  var _obj2Array = function _obj2Array(obj) {\n\t    if (Object.prototype.toString.call(obj) === '[object Array]') {\n\t      return obj;\n\t    }\n\t    var ar = [];\n\t    for (var i in obj) {\n\t      if (obj.hasOwnProperty(i)) {\n\t        ar.push(obj[i]);\n\t      }\n\t    }\n\t    return ar;\n\t  };\n\n\t  var _compare = function _compare(current, next) {\n\t    var i = 0;\n\t    var n = 0;\n\t    var tmp = 0;\n\t    var nl = 0;\n\t    var cl = 0;\n\n\t    if (current === next) {\n\t      return 0;\n\t    } else if ((typeof current === 'undefined' ? 'undefined' : _typeof(current)) === 'object') {\n\t      if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {\n\t        current = _obj2Array(current);\n\t        next = _obj2Array(next);\n\t        cl = current.length;\n\t        nl = next.length;\n\t        if (nl > cl) {\n\t          return 1;\n\t        } else if (nl < cl) {\n\t          return -1;\n\t        }\n\t        for (i = 0, n = cl; i < n; ++i) {\n\t          tmp = _compare(current[i], next[i]);\n\t          if (tmp === 1) {\n\t            return 1;\n\t          } else if (tmp === -1) {\n\t            return -1;\n\t          }\n\t        }\n\t        return 0;\n\t      }\n\t      return -1;\n\t    } else if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {\n\t      return 1;\n\t    } else if (isNaN(next) && !isNaN(current)) {\n\t      if (current === 0) {\n\t        return 0;\n\t      }\n\t      return current < 0 ? 1 : -1;\n\t    } else if (isNaN(current) && !isNaN(next)) {\n\t      if (next === 0) {\n\t        return 0;\n\t      }\n\t      return next > 0 ? 1 : -1;\n\t    }\n\n\t    if (next === current) {\n\t      return 0;\n\t    }\n\n\t    return next > current ? 1 : -1;\n\t  };\n\n\t  if (argc === 0) {\n\t    throw new Error('At least one value should be passed to min()');\n\t  } else if (argc === 1) {\n\t    if (_typeof(argv[0]) === 'object') {\n\t      ar = _obj2Array(argv[0]);\n\t    } else {\n\t      throw new Error('Wrong parameter count for min()');\n\t    }\n\n\t    if (ar.length === 0) {\n\t      throw new Error('Array must contain at least one element for min()');\n\t    }\n\t  } else {\n\t    ar = argv;\n\t  }\n\n\t  retVal = ar[0];\n\n\t  for (i = 1, n = ar.length; i < n; ++i) {\n\t    if (_compare(retVal, ar[i]) === -1) {\n\t      retVal = ar[i];\n\t    }\n\t  }\n\n\t  return retVal;\n\t};\n\t//# sourceMappingURL=min.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tmodule.exports = function strip_tags(input, allowed) {\n\t  // eslint-disable-line camelcase\n\t  //  discuss at: http://locutus.io/php/strip_tags/\n\t  // original by: Kevin van Zonneveld (http://kvz.io)\n\t  // improved by: Luke Godfrey\n\t  // improved by: Kevin van Zonneveld (http://kvz.io)\n\t  //    input by: Pul\n\t  //    input by: Alex\n\t  //    input by: Marc Palau\n\t  //    input by: Brett Zamir (http://brett-zamir.me)\n\t  //    input by: Bobby Drake\n\t  //    input by: Evertjan Garretsen\n\t  // bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t  // bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)\n\t  // bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t  // bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t  // bugfixed by: Eric Nagel\n\t  // bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t  // bugfixed by: Tomasz Wesolowski\n\t  //  revised by: Rafa Kukawski (http://blog.kukawski.pl)\n\t  //   example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>')\n\t  //   returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'\n\t  //   example 2: strip_tags('<p>Kevin <img src=\"someimage.png\" onmouseover=\"someFunction()\">van <i>Zonneveld</i></p>', '<p>')\n\t  //   returns 2: '<p>Kevin van Zonneveld</p>'\n\t  //   example 3: strip_tags(\"<a href='http://kvz.io'>Kevin van Zonneveld</a>\", \"<a>\")\n\t  //   returns 3: \"<a href='http://kvz.io'>Kevin van Zonneveld</a>\"\n\t  //   example 4: strip_tags('1 < 5 5 > 1')\n\t  //   returns 4: '1 < 5 5 > 1'\n\t  //   example 5: strip_tags('1 <br/> 1')\n\t  //   returns 5: '1  1'\n\t  //   example 6: strip_tags('1 <br/> 1', '<br>')\n\t  //   returns 6: '1 <br/> 1'\n\t  //   example 7: strip_tags('1 <br/> 1', '<br><br/>')\n\t  //   returns 7: '1 <br/> 1'\n\n\t  // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)\n\t  allowed = (((allowed || '') + '').toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join('');\n\n\t  var tags = /<\\/?([a-z][a-z0-9]*)\\b[^>]*>/gi;\n\t  var commentsAndPhpTags = /<!--[\\s\\S]*?-->|<\\?(?:php)?[\\s\\S]*?\\?>/gi;\n\n\t  return input.replace(commentsAndPhpTags, '').replace(tags, function ($0, $1) {\n\t    return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';\n\t  });\n\t};\n\t//# sourceMappingURL=strip_tags.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tmodule.exports = function strtotime(text, now) {\n\t  //  discuss at: http://locutus.io/php/strtotime/\n\t  // original by: Caio Ariede (http://caioariede.com)\n\t  // improved by: Kevin van Zonneveld (http://kvz.io)\n\t  // improved by: Caio Ariede (http://caioariede.com)\n\t  // improved by: A. Matas Quezada (http://amatiasq.com)\n\t  // improved by: preuter\n\t  // improved by: Brett Zamir (http://brett-zamir.me)\n\t  // improved by: Mirko Faber\n\t  //    input by: David\n\t  // bugfixed by: Wagner B. Soares\n\t  // bugfixed by: Artur Tchernychev\n\t  // bugfixed by: Stephan Bsch-Plepelits (http://github.com/plepe)\n\t  //      note 1: Examples all have a fixed timestamp to prevent\n\t  //      note 1: tests to fail because of variable time(zones)\n\t  //   example 1: strtotime('+1 day', 1129633200)\n\t  //   returns 1: 1129719600\n\t  //   example 2: strtotime('+1 week 2 days 4 hours 2 seconds', 1129633200)\n\t  //   returns 2: 1130425202\n\t  //   example 3: strtotime('last month', 1129633200)\n\t  //   returns 3: 1127041200\n\t  //   example 4: strtotime('2009-05-04 08:30:00 GMT')\n\t  //   returns 4: 1241425800\n\t  //   example 5: strtotime('2009-05-04 08:30:00+00')\n\t  //   returns 5: 1241425800\n\t  //   example 6: strtotime('2009-05-04 08:30:00+02:00')\n\t  //   returns 6: 1241418600\n\t  //   example 7: strtotime('2009-05-04T08:30:00Z')\n\t  //   returns 7: 1241425800\n\n\t  var parsed;\n\t  var match;\n\t  var today;\n\t  var year;\n\t  var date;\n\t  var days;\n\t  var ranges;\n\t  var len;\n\t  var times;\n\t  var regex;\n\t  var i;\n\t  var fail = false;\n\n\t  if (!text) {\n\t    return fail;\n\t  }\n\n\t  // Unecessary spaces\n\t  text = text.replace(/^\\s+|\\s+$/g, '').replace(/\\s{2,}/g, ' ').replace(/[\\t\\r\\n]/g, '').toLowerCase();\n\n\t  // in contrast to php, js Date.parse function interprets:\n\t  // dates given as yyyy-mm-dd as in timezone: UTC,\n\t  // dates with \".\" or \"-\" as MDY instead of DMY\n\t  // dates with two-digit years differently\n\t  // etc...etc...\n\t  // ...therefore we manually parse lots of common date formats\n\t  var pattern = new RegExp(['^(\\\\d{1,4})', '([\\\\-\\\\.\\\\/:])', '(\\\\d{1,2})', '([\\\\-\\\\.\\\\/:])', '(\\\\d{1,4})', '(?:\\\\s(\\\\d{1,2}):(\\\\d{2})?:?(\\\\d{2})?)?', '(?:\\\\s([A-Z]+)?)?$'].join(''));\n\t  match = text.match(pattern);\n\n\t  if (match && match[2] === match[4]) {\n\t    if (match[1] > 1901) {\n\t      switch (match[2]) {\n\t        case '-':\n\t          // YYYY-M-D\n\t          if (match[3] > 12 || match[5] > 31) {\n\t            return fail;\n\t          }\n\n\t          return new Date(match[1], parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t        case '.':\n\t          // YYYY.M.D is not parsed by strtotime()\n\t          return fail;\n\t        case '/':\n\t          // YYYY/M/D\n\t          if (match[3] > 12 || match[5] > 31) {\n\t            return fail;\n\t          }\n\n\t          return new Date(match[1], parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t      }\n\t    } else if (match[5] > 1901) {\n\t      switch (match[2]) {\n\t        case '-':\n\t          // D-M-YYYY\n\t          if (match[3] > 12 || match[1] > 31) {\n\t            return fail;\n\t          }\n\n\t          return new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t        case '.':\n\t          // D.M.YYYY\n\t          if (match[3] > 12 || match[1] > 31) {\n\t            return fail;\n\t          }\n\n\t          return new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t        case '/':\n\t          // M/D/YYYY\n\t          if (match[1] > 12 || match[3] > 31) {\n\t            return fail;\n\t          }\n\n\t          return new Date(match[5], parseInt(match[1], 10) - 1, match[3], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t      }\n\t    } else {\n\t      switch (match[2]) {\n\t        case '-':\n\t          // YY-M-D\n\t          if (match[3] > 12 || match[5] > 31 || match[1] < 70 && match[1] > 38) {\n\t            return fail;\n\t          }\n\n\t          year = match[1] >= 0 && match[1] <= 38 ? +match[1] + 2000 : match[1];\n\t          return new Date(year, parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t        case '.':\n\t          // D.M.YY or H.MM.SS\n\t          if (match[5] >= 70) {\n\t            // D.M.YY\n\t            if (match[3] > 12 || match[1] > 31) {\n\t              return fail;\n\t            }\n\n\t            return new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t          }\n\t          if (match[5] < 60 && !match[6]) {\n\t            // H.MM.SS\n\t            if (match[1] > 23 || match[3] > 59) {\n\t              return fail;\n\t            }\n\n\t            today = new Date();\n\t            return new Date(today.getFullYear(), today.getMonth(), today.getDate(), match[1] || 0, match[3] || 0, match[5] || 0, match[9] || 0) / 1000;\n\t          }\n\n\t          // invalid format, cannot be parsed\n\t          return fail;\n\t        case '/':\n\t          // M/D/YY\n\t          if (match[1] > 12 || match[3] > 31 || match[5] < 70 && match[5] > 38) {\n\t            return fail;\n\t          }\n\n\t          year = match[5] >= 0 && match[5] <= 38 ? +match[5] + 2000 : match[5];\n\t          return new Date(year, parseInt(match[1], 10) - 1, match[3], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t        case ':':\n\t          // HH:MM:SS\n\t          if (match[1] > 23 || match[3] > 59 || match[5] > 59) {\n\t            return fail;\n\t          }\n\n\t          today = new Date();\n\t          return new Date(today.getFullYear(), today.getMonth(), today.getDate(), match[1] || 0, match[3] || 0, match[5] || 0) / 1000;\n\t      }\n\t    }\n\t  }\n\n\t  // other formats and \"now\" should be parsed by Date.parse()\n\t  if (text === 'now') {\n\t    return now === null || isNaN(now) ? new Date().getTime() / 1000 | 0 : now | 0;\n\t  }\n\t  if (!isNaN(parsed = Date.parse(text))) {\n\t    return parsed / 1000 | 0;\n\t  }\n\t  // Browsers !== Chrome have problems parsing ISO 8601 date strings, as they do\n\t  // not accept lower case characters, space, or shortened time zones.\n\t  // Therefore, fix these problems and try again.\n\t  // Examples:\n\t  //   2015-04-15 20:33:59+02\n\t  //   2015-04-15 20:33:59z\n\t  //   2015-04-15t20:33:59+02:00\n\t  pattern = new RegExp(['^([0-9]{4}-[0-9]{2}-[0-9]{2})', '[ t]', '([0-9]{2}:[0-9]{2}:[0-9]{2}(\\\\.[0-9]+)?)', '([\\\\+-][0-9]{2}(:[0-9]{2})?|z)'].join(''));\n\t  match = text.match(pattern);\n\t  if (match) {\n\t    // @todo: time zone information\n\t    if (match[4] === 'z') {\n\t      match[4] = 'Z';\n\t    } else if (match[4].match(/^([+-][0-9]{2})$/)) {\n\t      match[4] = match[4] + ':00';\n\t    }\n\n\t    if (!isNaN(parsed = Date.parse(match[1] + 'T' + match[2] + match[4]))) {\n\t      return parsed / 1000 | 0;\n\t    }\n\t  }\n\n\t  date = now ? new Date(now * 1000) : new Date();\n\t  days = {\n\t    'sun': 0,\n\t    'mon': 1,\n\t    'tue': 2,\n\t    'wed': 3,\n\t    'thu': 4,\n\t    'fri': 5,\n\t    'sat': 6\n\t  };\n\t  ranges = {\n\t    'yea': 'FullYear',\n\t    'mon': 'Month',\n\t    'day': 'Date',\n\t    'hou': 'Hours',\n\t    'min': 'Minutes',\n\t    'sec': 'Seconds'\n\t  };\n\n\t  function lastNext(type, range, modifier) {\n\t    var diff;\n\t    var day = days[range];\n\n\t    if (typeof day !== 'undefined') {\n\t      diff = day - date.getDay();\n\n\t      if (diff === 0) {\n\t        diff = 7 * modifier;\n\t      } else if (diff > 0 && type === 'last') {\n\t        diff -= 7;\n\t      } else if (diff < 0 && type === 'next') {\n\t        diff += 7;\n\t      }\n\n\t      date.setDate(date.getDate() + diff);\n\t    }\n\t  }\n\n\t  function process(val) {\n\t    // @todo: Reconcile this with regex using \\s, taking into account\n\t    // browser issues with split and regexes\n\t    var splt = val.split(' ');\n\t    var type = splt[0];\n\t    var range = splt[1].substring(0, 3);\n\t    var typeIsNumber = /\\d+/.test(type);\n\t    var ago = splt[2] === 'ago';\n\t    var num = (type === 'last' ? -1 : 1) * (ago ? -1 : 1);\n\n\t    if (typeIsNumber) {\n\t      num *= parseInt(type, 10);\n\t    }\n\n\t    if (ranges.hasOwnProperty(range) && !splt[1].match(/^mon(day|\\.)?$/i)) {\n\t      return date['set' + ranges[range]](date['get' + ranges[range]]() + num);\n\t    }\n\n\t    if (range === 'wee') {\n\t      return date.setDate(date.getDate() + num * 7);\n\t    }\n\n\t    if (type === 'next' || type === 'last') {\n\t      lastNext(type, range, num);\n\t    } else if (!typeIsNumber) {\n\t      return false;\n\t    }\n\n\t    return true;\n\t  }\n\n\t  times = '(years?|months?|weeks?|days?|hours?|minutes?|min|seconds?|sec' + '|sunday|sun\\\\.?|monday|mon\\\\.?|tuesday|tue\\\\.?|wednesday|wed\\\\.?' + '|thursday|thu\\\\.?|friday|fri\\\\.?|saturday|sat\\\\.?)';\n\t  regex = '([+-]?\\\\d+\\\\s' + times + '|' + '(last|next)\\\\s' + times + ')(\\\\sago)?';\n\n\t  match = text.match(new RegExp(regex, 'gi'));\n\t  if (!match) {\n\t    return fail;\n\t  }\n\n\t  for (i = 0, len = match.length; i < len; i++) {\n\t    if (!process(match[i])) {\n\t      return fail;\n\t    }\n\t  }\n\n\t  return date.getTime() / 1000;\n\t};\n\t//# sourceMappingURL=strtotime.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tmodule.exports = function date(format, timestamp) {\n\t  //  discuss at: http://locutus.io/php/date/\n\t  // original by: Carlos R. L. Rodrigues (http://www.jsfromhell.com)\n\t  // original by: gettimeofday\n\t  //    parts by: Peter-Paul Koch (http://www.quirksmode.org/js/beat.html)\n\t  // improved by: Kevin van Zonneveld (http://kvz.io)\n\t  // improved by: MeEtc (http://yass.meetcweb.com)\n\t  // improved by: Brad Touesnard\n\t  // improved by: Tim Wiel\n\t  // improved by: Bryan Elliott\n\t  // improved by: David Randall\n\t  // improved by: Theriault (https://github.com/Theriault)\n\t  // improved by: Theriault (https://github.com/Theriault)\n\t  // improved by: Brett Zamir (http://brett-zamir.me)\n\t  // improved by: Theriault (https://github.com/Theriault)\n\t  // improved by: Thomas Beaucourt (http://www.webapp.fr)\n\t  // improved by: JT\n\t  // improved by: Theriault (https://github.com/Theriault)\n\t  // improved by: Rafa Kukawski (http://blog.kukawski.pl)\n\t  // improved by: Theriault (https://github.com/Theriault)\n\t  //    input by: Brett Zamir (http://brett-zamir.me)\n\t  //    input by: majak\n\t  //    input by: Alex\n\t  //    input by: Martin\n\t  //    input by: Alex Wilson\n\t  //    input by: Haravikk\n\t  // bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t  // bugfixed by: majak\n\t  // bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t  // bugfixed by: Brett Zamir (http://brett-zamir.me)\n\t  // bugfixed by: omid (http://locutus.io/php/380:380#comment_137122)\n\t  // bugfixed by: Chris (http://www.devotis.nl/)\n\t  //      note 1: Uses global: locutus to store the default timezone\n\t  //      note 1: Although the function potentially allows timezone info\n\t  //      note 1: (see notes), it currently does not set\n\t  //      note 1: per a timezone specified by date_default_timezone_set(). Implementers might use\n\t  //      note 1: $locutus.currentTimezoneOffset and\n\t  //      note 1: $locutus.currentTimezoneDST set by that function\n\t  //      note 1: in order to adjust the dates in this function\n\t  //      note 1: (or our other date functions!) accordingly\n\t  //   example 1: date('H:m:s \\\\m \\\\i\\\\s \\\\m\\\\o\\\\n\\\\t\\\\h', 1062402400)\n\t  //   returns 1: '07:09:40 m is month'\n\t  //   example 2: date('F j, Y, g:i a', 1062462400)\n\t  //   returns 2: 'September 2, 2003, 12:26 am'\n\t  //   example 3: date('Y W o', 1062462400)\n\t  //   returns 3: '2003 36 2003'\n\t  //   example 4: var $x = date('Y m d', (new Date()).getTime() / 1000)\n\t  //   example 4: $x = $x + ''\n\t  //   example 4: var $result = $x.length // 2009 01 09\n\t  //   returns 4: 10\n\t  //   example 5: date('W', 1104534000)\n\t  //   returns 5: '52'\n\t  //   example 6: date('B t', 1104534000)\n\t  //   returns 6: '999 31'\n\t  //   example 7: date('W U', 1293750000.82); // 2010-12-31\n\t  //   returns 7: '52 1293750000'\n\t  //   example 8: date('W', 1293836400); // 2011-01-01\n\t  //   returns 8: '52'\n\t  //   example 9: date('W Y-m-d', 1293974054); // 2011-01-02\n\t  //   returns 9: '52 2011-01-02'\n\t  //        test: skip-1 skip-2 skip-5\n\n\t  var jsdate, f;\n\t  // Keep this here (works, but for code commented-out below for file size reasons)\n\t  // var tal= [];\n\t  var txtWords = ['Sun', 'Mon', 'Tues', 'Wednes', 'Thurs', 'Fri', 'Satur', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n\t  // trailing backslash -> (dropped)\n\t  // a backslash followed by any character (including backslash) -> the character\n\t  // empty string -> empty string\n\t  var formatChr = /\\\\?(.?)/gi;\n\t  var formatChrCb = function formatChrCb(t, s) {\n\t    return f[t] ? f[t]() : s;\n\t  };\n\t  var _pad = function _pad(n, c) {\n\t    n = String(n);\n\t    while (n.length < c) {\n\t      n = '0' + n;\n\t    }\n\t    return n;\n\t  };\n\t  f = {\n\t    // Day\n\t    d: function d() {\n\t      // Day of month w/leading 0; 01..31\n\t      return _pad(f.j(), 2);\n\t    },\n\t    D: function D() {\n\t      // Shorthand day name; Mon...Sun\n\t      return f.l().slice(0, 3);\n\t    },\n\t    j: function j() {\n\t      // Day of month; 1..31\n\t      return jsdate.getDate();\n\t    },\n\t    l: function l() {\n\t      // Full day name; Monday...Sunday\n\t      return txtWords[f.w()] + 'day';\n\t    },\n\t    N: function N() {\n\t      // ISO-8601 day of week; 1[Mon]..7[Sun]\n\t      return f.w() || 7;\n\t    },\n\t    S: function S() {\n\t      // Ordinal suffix for day of month; st, nd, rd, th\n\t      var j = f.j();\n\t      var i = j % 10;\n\t      if (i <= 3 && parseInt(j % 100 / 10, 10) === 1) {\n\t        i = 0;\n\t      }\n\t      return ['st', 'nd', 'rd'][i - 1] || 'th';\n\t    },\n\t    w: function w() {\n\t      // Day of week; 0[Sun]..6[Sat]\n\t      return jsdate.getDay();\n\t    },\n\t    z: function z() {\n\t      // Day of year; 0..365\n\t      var a = new Date(f.Y(), f.n() - 1, f.j());\n\t      var b = new Date(f.Y(), 0, 1);\n\t      return Math.round((a - b) / 864e5);\n\t    },\n\n\t    // Week\n\t    W: function W() {\n\t      // ISO-8601 week number\n\t      var a = new Date(f.Y(), f.n() - 1, f.j() - f.N() + 3);\n\t      var b = new Date(a.getFullYear(), 0, 4);\n\t      return _pad(1 + Math.round((a - b) / 864e5 / 7), 2);\n\t    },\n\n\t    // Month\n\t    F: function F() {\n\t      // Full month name; January...December\n\t      return txtWords[6 + f.n()];\n\t    },\n\t    m: function m() {\n\t      // Month w/leading 0; 01...12\n\t      return _pad(f.n(), 2);\n\t    },\n\t    M: function M() {\n\t      // Shorthand month name; Jan...Dec\n\t      return f.F().slice(0, 3);\n\t    },\n\t    n: function n() {\n\t      // Month; 1...12\n\t      return jsdate.getMonth() + 1;\n\t    },\n\t    t: function t() {\n\t      // Days in month; 28...31\n\t      return new Date(f.Y(), f.n(), 0).getDate();\n\t    },\n\n\t    // Year\n\t    L: function L() {\n\t      // Is leap year?; 0 or 1\n\t      var j = f.Y();\n\t      return j % 4 === 0 & j % 100 !== 0 | j % 400 === 0;\n\t    },\n\t    o: function o() {\n\t      // ISO-8601 year\n\t      var n = f.n();\n\t      var W = f.W();\n\t      var Y = f.Y();\n\t      return Y + (n === 12 && W < 9 ? 1 : n === 1 && W > 9 ? -1 : 0);\n\t    },\n\t    Y: function Y() {\n\t      // Full year; e.g. 1980...2010\n\t      return jsdate.getFullYear();\n\t    },\n\t    y: function y() {\n\t      // Last two digits of year; 00...99\n\t      return f.Y().toString().slice(-2);\n\t    },\n\n\t    // Time\n\t    a: function a() {\n\t      // am or pm\n\t      return jsdate.getHours() > 11 ? 'pm' : 'am';\n\t    },\n\t    A: function A() {\n\t      // AM or PM\n\t      return f.a().toUpperCase();\n\t    },\n\t    B: function B() {\n\t      // Swatch Internet time; 000..999\n\t      var H = jsdate.getUTCHours() * 36e2;\n\t      // Hours\n\t      var i = jsdate.getUTCMinutes() * 60;\n\t      // Minutes\n\t      // Seconds\n\t      var s = jsdate.getUTCSeconds();\n\t      return _pad(Math.floor((H + i + s + 36e2) / 86.4) % 1e3, 3);\n\t    },\n\t    g: function g() {\n\t      // 12-Hours; 1..12\n\t      return f.G() % 12 || 12;\n\t    },\n\t    G: function G() {\n\t      // 24-Hours; 0..23\n\t      return jsdate.getHours();\n\t    },\n\t    h: function h() {\n\t      // 12-Hours w/leading 0; 01..12\n\t      return _pad(f.g(), 2);\n\t    },\n\t    H: function H() {\n\t      // 24-Hours w/leading 0; 00..23\n\t      return _pad(f.G(), 2);\n\t    },\n\t    i: function i() {\n\t      // Minutes w/leading 0; 00..59\n\t      return _pad(jsdate.getMinutes(), 2);\n\t    },\n\t    s: function s() {\n\t      // Seconds w/leading 0; 00..59\n\t      return _pad(jsdate.getSeconds(), 2);\n\t    },\n\t    u: function u() {\n\t      // Microseconds; 000000-999000\n\t      return _pad(jsdate.getMilliseconds() * 1000, 6);\n\t    },\n\n\t    // Timezone\n\t    e: function e() {\n\t      // Timezone identifier; e.g. Atlantic/Azores, ...\n\t      // The following works, but requires inclusion of the very large\n\t      // timezone_abbreviations_list() function.\n\t      /*              return that.date_default_timezone_get();\n\t       */\n\t      var msg = 'Not supported (see source code of date() for timezone on how to add support)';\n\t      throw new Error(msg);\n\t    },\n\t    I: function I() {\n\t      // DST observed?; 0 or 1\n\t      // Compares Jan 1 minus Jan 1 UTC to Jul 1 minus Jul 1 UTC.\n\t      // If they are not equal, then DST is observed.\n\t      var a = new Date(f.Y(), 0);\n\t      // Jan 1\n\t      var c = Date.UTC(f.Y(), 0);\n\t      // Jan 1 UTC\n\t      var b = new Date(f.Y(), 6);\n\t      // Jul 1\n\t      // Jul 1 UTC\n\t      var d = Date.UTC(f.Y(), 6);\n\t      return a - c !== b - d ? 1 : 0;\n\t    },\n\t    O: function O() {\n\t      // Difference to GMT in hour format; e.g. +0200\n\t      var tzo = jsdate.getTimezoneOffset();\n\t      var a = Math.abs(tzo);\n\t      return (tzo > 0 ? '-' : '+') + _pad(Math.floor(a / 60) * 100 + a % 60, 4);\n\t    },\n\t    P: function P() {\n\t      // Difference to GMT w/colon; e.g. +02:00\n\t      var O = f.O();\n\t      return O.substr(0, 3) + ':' + O.substr(3, 2);\n\t    },\n\t    T: function T() {\n\t      // The following works, but requires inclusion of the very\n\t      // large timezone_abbreviations_list() function.\n\t      /*              var abbr, i, os, _default;\n\t      if (!tal.length) {\n\t        tal = that.timezone_abbreviations_list();\n\t      }\n\t      if ($locutus && $locutus.default_timezone) {\n\t        _default = $locutus.default_timezone;\n\t        for (abbr in tal) {\n\t          for (i = 0; i < tal[abbr].length; i++) {\n\t            if (tal[abbr][i].timezone_id === _default) {\n\t              return abbr.toUpperCase();\n\t            }\n\t          }\n\t        }\n\t      }\n\t      for (abbr in tal) {\n\t        for (i = 0; i < tal[abbr].length; i++) {\n\t          os = -jsdate.getTimezoneOffset() * 60;\n\t          if (tal[abbr][i].offset === os) {\n\t            return abbr.toUpperCase();\n\t          }\n\t        }\n\t      }\n\t      */\n\t      return 'UTC';\n\t    },\n\t    Z: function Z() {\n\t      // Timezone offset in seconds (-43200...50400)\n\t      return -jsdate.getTimezoneOffset() * 60;\n\t    },\n\n\t    // Full Date/Time\n\t    c: function c() {\n\t      // ISO-8601 date.\n\t      return 'Y-m-d\\\\TH:i:sP'.replace(formatChr, formatChrCb);\n\t    },\n\t    r: function r() {\n\t      // RFC 2822\n\t      return 'D, d M Y H:i:s O'.replace(formatChr, formatChrCb);\n\t    },\n\t    U: function U() {\n\t      // Seconds since UNIX epoch\n\t      return jsdate / 1000 | 0;\n\t    }\n\t  };\n\n\t  var _date = function _date(format, timestamp) {\n\t    jsdate = timestamp === undefined ? new Date() // Not provided\n\t    : timestamp instanceof Date ? new Date(timestamp) // JS Date()\n\t    : new Date(timestamp * 1000) // UNIX timestamp (auto-convert to int)\n\t    ;\n\t    return format.replace(formatChr, formatChrCb);\n\t  };\n\n\t  return _date(format, timestamp);\n\t};\n\t//# sourceMappingURL=date.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tmodule.exports = function boolval(mixedVar) {\n\t  // original by: Will Rowe\n\t  //   example 1: boolval(true)\n\t  //   returns 1: true\n\t  //   example 2: boolval(false)\n\t  //   returns 2: false\n\t  //   example 3: boolval(0)\n\t  //   returns 3: false\n\t  //   example 4: boolval(0.0)\n\t  //   returns 4: false\n\t  //   example 5: boolval('')\n\t  //   returns 5: false\n\t  //   example 6: boolval('0')\n\t  //   returns 6: false\n\t  //   example 7: boolval([])\n\t  //   returns 7: false\n\t  //   example 8: boolval('')\n\t  //   returns 8: false\n\t  //   example 9: boolval(null)\n\t  //   returns 9: false\n\t  //   example 10: boolval(undefined)\n\t  //   returns 10: false\n\t  //   example 11: boolval('true')\n\t  //   returns 11: true\n\n\t  if (mixedVar === false) {\n\t    return false;\n\t  }\n\n\t  if (mixedVar === 0 || mixedVar === 0.0) {\n\t    return false;\n\t  }\n\n\t  if (mixedVar === '' || mixedVar === '0') {\n\t    return false;\n\t  }\n\n\t  if (Array.isArray(mixedVar) && mixedVar.length === 0) {\n\t    return false;\n\t  }\n\n\t  if (mixedVar === null || mixedVar === undefined) {\n\t    return false;\n\t  }\n\n\t  return true;\n\t};\n\t//# sourceMappingURL=boolval.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(Twig) {\n\t    'use strict';\n\n\t    Twig.Templates.registerLoader('ajax', function(location, params, callback, error_callback) {\n\t        var template,\n\t            xmlhttp,\n\t            precompiled = params.precompiled,\n\t            parser = this.parsers[params.parser] || this.parser.twig;\n\n\t        if (typeof XMLHttpRequest === \"undefined\") {\n\t            throw new Twig.Error('Unsupported platform: Unable to do ajax requests ' +\n\t                                 'because there is no \"XMLHTTPRequest\" implementation');\n\t        }\n\n\t        xmlhttp = new XMLHttpRequest();\n\t        xmlhttp.onreadystatechange = function() {\n\t            var data = null;\n\n\t            if(xmlhttp.readyState === 4) {\n\t                if (xmlhttp.status === 200 || (window.cordova && xmlhttp.status == 0)) {\n\t                    Twig.log.debug(\"Got template \", xmlhttp.responseText);\n\n\t                    if (precompiled === true) {\n\t                        data = JSON.parse(xmlhttp.responseText);\n\t                    } else {\n\t                        data = xmlhttp.responseText;\n\t                    }\n\n\t                    params.url = location;\n\t                    params.data = data;\n\n\t                    template = parser.call(this, params);\n\n\t                    if (typeof callback === 'function') {\n\t                        callback(template);\n\t                    }\n\t                } else {\n\t                    if (typeof error_callback === 'function') {\n\t                        error_callback(xmlhttp);\n\t                    }\n\t                }\n\t            }\n\t        };\n\t        xmlhttp.open(\"GET\", location, !!params.async);\n\t        xmlhttp.send();\n\n\t        if (params.async) {\n\t            // TODO: return deferred promise\n\t            return true;\n\t        } else {\n\t            return template;\n\t        }\n\t    });\n\n\t};\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(Twig) {\n\t    'use strict';\n\n\t    var fs, path;\n\n\t    try {\n\t    \t// require lib dependencies at runtime\n\t    \tfs = __webpack_require__(19);\n\t    \tpath = __webpack_require__(20);\n\t    } catch (e) {\n\t    \t// NOTE: this is in a try/catch to avoid errors cross platform\n\t    }\n\n\t    Twig.Templates.registerLoader('fs', function(location, params, callback, error_callback) {\n\t        var template,\n\t            data = null,\n\t            precompiled = params.precompiled,\n\t            parser = this.parsers[params.parser] || this.parser.twig;\n\n\t        if (!fs || !path) {\n\t            throw new Twig.Error('Unsupported platform: Unable to load from file ' +\n\t                                 'because there is no \"fs\" or \"path\" implementation');\n\t        }\n\n\t        var loadTemplateFn = function(err, data) {\n\t            if (err) {\n\t                if (typeof error_callback === 'function') {\n\t                    error_callback(err);\n\t                }\n\t                return;\n\t            }\n\n\t            if (precompiled === true) {\n\t                data = JSON.parse(data);\n\t            }\n\n\t            params.data = data;\n\t            params.path = params.path || location;\n\n\t            // template is in data\n\t            template = parser.call(this, params);\n\n\t            if (typeof callback === 'function') {\n\t                callback(template);\n\t            }\n\t        };\n\t        params.path = params.path || location;\n\n\t        if (params.async) {\n\t            fs.stat(params.path, function (err, stats) {\n\t                if (err || !stats.isFile()) {\n\t                    if (typeof error_callback === 'function') {\n\t                        error_callback(new Twig.Error('Unable to find template file ' + params.path));\n\t                    }\n\t                    return;\n\t                }\n\t                fs.readFile(params.path, 'utf8', loadTemplateFn);\n\t            });\n\t            // TODO: return deferred promise\n\t            return true;\n\t        } else {\n\t            try {\n\t                if (!fs.statSync(params.path).isFile()) {\n\t                    throw new Twig.Error('Unable to find template file ' + params.path);\n\t                }\n\t            } catch (err) {\n\t                throw new Twig.Error('Unable to find template file ' + params.path);\n\t            }\n\t            data = fs.readFileSync(params.path, 'utf8');\n\t            loadTemplateFn(undefined, data);\n\t            return template\n\t        }\n\t    });\n\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __webpack_require__(28);\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __webpack_require__(29);\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// ## twig.logic.js\n\t//\n\t// This file handles tokenizing, compiling and parsing logic tokens. {% ... %}\n\tmodule.exports = function (Twig) {\n\t    \"use strict\";\n\n\t    /**\n\t     * Namespace for logic handling.\n\t     */\n\t    Twig.logic = {};\n\n\t    /**\n\t     * Logic token types.\n\t     */\n\t    Twig.logic.type = {\n\t        if_:       'Twig.logic.type.if',\n\t        endif:     'Twig.logic.type.endif',\n\t        for_:      'Twig.logic.type.for',\n\t        endfor:    'Twig.logic.type.endfor',\n\t        else_:     'Twig.logic.type.else',\n\t        elseif:    'Twig.logic.type.elseif',\n\t        set:       'Twig.logic.type.set',\n\t        setcapture:'Twig.logic.type.setcapture',\n\t        endset:    'Twig.logic.type.endset',\n\t        filter:    'Twig.logic.type.filter',\n\t        endfilter: 'Twig.logic.type.endfilter',\n\t        shortblock: 'Twig.logic.type.shortblock',\n\t        block:     'Twig.logic.type.block',\n\t        endblock:  'Twig.logic.type.endblock',\n\t        extends_:  'Twig.logic.type.extends',\n\t        use:       'Twig.logic.type.use',\n\t        include:   'Twig.logic.type.include',\n\t        spaceless: 'Twig.logic.type.spaceless',\n\t        endspaceless: 'Twig.logic.type.endspaceless',\n\t        macro:     'Twig.logic.type.macro',\n\t        endmacro:  'Twig.logic.type.endmacro',\n\t        import_:   'Twig.logic.type.import',\n\t        from:      'Twig.logic.type.from',\n\t        embed:     'Twig.logic.type.embed',\n\t        endembed:  'Twig.logic.type.endembed'\n\t    };\n\n\n\t    // Regular expressions for handling logic tokens.\n\t    //\n\t    // Properties:\n\t    //\n\t    //      type:  The type of expression this matches\n\t    //\n\t    //      regex: A regular expression that matches the format of the token\n\t    //\n\t    //      next:  What logic tokens (if any) pop this token off the logic stack. If empty, the\n\t    //             logic token is assumed to not require an end tag and isn't push onto the stack.\n\t    //\n\t    //      open:  Does this tag open a logic expression or is it standalone. For example,\n\t    //             {% endif %} cannot exist without an opening {% if ... %} tag, so open = false.\n\t    //\n\t    //  Functions:\n\t    //\n\t    //      compile: A function that handles compiling the token into an output token ready for\n\t    //               parsing with the parse function.\n\t    //\n\t    //      parse:   A function that parses the compiled token into output (HTML / whatever the\n\t    //               template represents).\n\t    Twig.logic.definitions = [\n\t        {\n\t            /**\n\t             * If type logic tokens.\n\t             *\n\t             *  Format: {% if expression %}\n\t             */\n\t            type: Twig.logic.type.if_,\n\t            regex: /^if\\s+([\\s\\S]+)$/,\n\t            next: [\n\t                Twig.logic.type.else_,\n\t                Twig.logic.type.elseif,\n\t                Twig.logic.type.endif\n\t            ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var expression = token.match[1];\n\t                // Compile the expression.\n\t                token.stack = Twig.expression.compile.apply(this, [{\n\t                    type:  Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\t                delete token.match;\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                var that = this;\n\n\t                return Twig.expression.parseAsync.apply(this, [token.stack, context])\n\t                .then(function(result) {\n\t                    chain = true;\n\n\t                    if (Twig.lib.boolval(result)) {\n\t                        chain = false;\n\n\t                        return Twig.parseAsync.apply(that, [token.output, context]);\n\t                    }\n\n\t                    return '';\n\t                })\n\t                .then(function(output) {\n\t                    return {\n\t                        chain: chain,\n\t                        output: output\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Else if type logic tokens.\n\t             *\n\t             *  Format: {% elseif expression %}\n\t             */\n\t            type: Twig.logic.type.elseif,\n\t            regex: /^elseif\\s+([^\\s].*)$/,\n\t            next: [\n\t                Twig.logic.type.else_,\n\t                Twig.logic.type.elseif,\n\t                Twig.logic.type.endif\n\t            ],\n\t            open: false,\n\t            compile: function (token) {\n\t                var expression = token.match[1];\n\t                // Compile the expression.\n\t                token.stack = Twig.expression.compile.apply(this, [{\n\t                    type:  Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\t                delete token.match;\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                var that = this;\n\n\t                return Twig.expression.parseAsync.apply(this, [token.stack, context])\n\t                .then(function(result) {\n\t                    if (chain && Twig.lib.boolval(result)) {\n\t                        chain = false;\n\n\t                        return Twig.parseAsync.apply(that, [token.output, context]);\n\t                    }\n\n\t                    return '';\n\t                })\n\t                .then(function(output) {\n\t                    return {\n\t                        chain: chain,\n\t                        output: output\n\t                    }\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Else if type logic tokens.\n\t             *\n\t             *  Format: {% elseif expression %}\n\t             */\n\t            type: Twig.logic.type.else_,\n\t            regex: /^else$/,\n\t            next: [\n\t                Twig.logic.type.endif,\n\t                Twig.logic.type.endfor\n\t            ],\n\t            open: false,\n\t            parse: function (token, context, chain) {\n\t                var promise = Twig.Promise.resolve('');\n\n\t                if (chain) {\n\t                    promise = Twig.parseAsync.apply(this, [token.output, context]);\n\t                }\n\n\t                return promise.then(function(output) {\n\t                    return {\n\t                        chain: chain,\n\t                        output: output\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * End if type logic tokens.\n\t             *\n\t             *  Format: {% endif %}\n\t             */\n\t            type: Twig.logic.type.endif,\n\t            regex: /^endif$/,\n\t            next: [ ],\n\t            open: false\n\t        },\n\t        {\n\t            /**\n\t             * For type logic tokens.\n\t             *\n\t             *  Format: {% for expression %}\n\t             */\n\t            type: Twig.logic.type.for_,\n\t            regex: /^for\\s+([a-zA-Z0-9_,\\s]+)\\s+in\\s+([^\\s].*?)(?:\\s+if\\s+([^\\s].*))?$/,\n\t            next: [\n\t                Twig.logic.type.else_,\n\t                Twig.logic.type.endfor\n\t            ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var key_value = token.match[1],\n\t                    expression = token.match[2],\n\t                    conditional = token.match[3],\n\t                    kv_split = null;\n\n\t                token.key_var = null;\n\t                token.value_var = null;\n\n\t                if (key_value.indexOf(\",\") >= 0) {\n\t                    kv_split = key_value.split(',');\n\t                    if (kv_split.length === 2) {\n\t                        token.key_var = kv_split[0].trim();\n\t                        token.value_var = kv_split[1].trim();\n\t                    } else {\n\t                        throw new Twig.Error(\"Invalid expression in for loop: \" + key_value);\n\t                    }\n\t                } else {\n\t                    token.value_var = key_value;\n\t                }\n\n\t                // Valid expressions for a for loop\n\t                //   for item     in expression\n\t                //   for key,item in expression\n\n\t                // Compile the expression.\n\t                token.expression = Twig.expression.compile.apply(this, [{\n\t                    type:  Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\n\t                // Compile the conditional (if available)\n\t                if (conditional) {\n\t                    token.conditional = Twig.expression.compile.apply(this, [{\n\t                        type:  Twig.expression.type.expression,\n\t                        value: conditional\n\t                    }]).stack;\n\t                }\n\n\t                delete token.match;\n\t                return token;\n\t            },\n\t            parse: function (token, context, continue_chain) {\n\t                // Parse expression\n\t                var output = [],\n\t                    len,\n\t                    index = 0,\n\t                    keyset,\n\t                    that = this,\n\t                    conditional = token.conditional,\n\t                    buildLoop = function(index, len) {\n\t                        var isConditional = conditional !== undefined;\n\t                        return {\n\t                            index: index+1,\n\t                            index0: index,\n\t                            revindex: isConditional?undefined:len-index,\n\t                            revindex0: isConditional?undefined:len-index-1,\n\t                            first: (index === 0),\n\t                            last: isConditional?undefined:(index === len-1),\n\t                            length: isConditional?undefined:len,\n\t                            parent: context\n\t                        };\n\t                    },\n\t                    // run once for each iteration of the loop\n\t                    loop = function(key, value) {\n\t                        var inner_context = Twig.ChildContext(context);\n\n\t                        inner_context[token.value_var] = value;\n\n\t                        if (token.key_var) {\n\t                            inner_context[token.key_var] = key;\n\t                        }\n\n\t                        // Loop object\n\t                        inner_context.loop = buildLoop(index, len);\n\n\t                        var promise = conditional === undefined ?\n\t                            Twig.Promise.resolve(true) :\n\t                            Twig.expression.parseAsync.apply(that, [conditional, inner_context]);\n\n\t                        promise.then(function(condition) {\n\t                            if (!condition)\n\t                                return;\n\n\t                            return Twig.parseAsync.apply(that, [token.output, inner_context])\n\t                            .then(function(o) {\n\t                                output.push(o);\n\t                                index += 1;\n\t                            });\n\t                        })\n\t                        .then(function() {\n\t                            // Delete loop-related variables from the context\n\t                            delete inner_context['loop'];\n\t                            delete inner_context[token.value_var];\n\t                            delete inner_context[token.key_var];\n\n\t                            // Merge in values that exist in context but have changed\n\t                            // in inner_context.\n\t                            Twig.merge(context, inner_context, true);\n\t                        });\n\t                    };\n\n\n\t                return Twig.expression.parseAsync.apply(this, [token.expression, context])\n\t                .then(function(result) {\n\t                    if (Twig.lib.is('Array', result)) {\n\t                        len = result.length;\n\t                        Twig.async.forEach(result, function (value) {\n\t                            var key = index;\n\n\t                            return loop(key, value);\n\t                        });\n\t                    } else if (Twig.lib.is('Object', result)) {\n\t                        if (result._keys !== undefined) {\n\t                            keyset = result._keys;\n\t                        } else {\n\t                            keyset = Object.keys(result);\n\t                        }\n\t                        len = keyset.length;\n\t                        Twig.forEach(keyset, function(key) {\n\t                            // Ignore the _keys property, it's internal to twig.js\n\t                            if (key === \"_keys\") return;\n\n\t                            loop(key,  result[key]);\n\t                        });\n\t                    }\n\n\t                    // Only allow else statements if no output was generated\n\t                    continue_chain = (output.length === 0);\n\n\t                    return {\n\t                        chain: continue_chain,\n\t                        output: Twig.output.apply(that, [output])\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * End if type logic tokens.\n\t             *\n\t             *  Format: {% endif %}\n\t             */\n\t            type: Twig.logic.type.endfor,\n\t            regex: /^endfor$/,\n\t            next: [ ],\n\t            open: false\n\t        },\n\t        {\n\t            /**\n\t             * Set type logic tokens.\n\t             *\n\t             *  Format: {% set key = expression %}\n\t             */\n\t            type: Twig.logic.type.set,\n\t            regex: /^set\\s+([a-zA-Z0-9_,\\s]+)\\s*=\\s*([\\s\\S]+)$/,\n\t            next: [ ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var key = token.match[1].trim(),\n\t                    expression = token.match[2],\n\t                    // Compile the expression.\n\t                    expression_stack  = Twig.expression.compile.apply(this, [{\n\t                        type:  Twig.expression.type.expression,\n\t                        value: expression\n\t                    }]).stack;\n\n\t                token.key = key;\n\t                token.expression = expression_stack;\n\n\t                delete token.match;\n\t                return token;\n\t            },\n\t            parse: function (token, context, continue_chain) {\n\t                var key = token.key;\n\n\t                return Twig.expression.parseAsync.apply(this, [token.expression, context])\n\t                .then(function(value) {\n\t                    if (value === context) {\n\t                        /*  If storing the context in a variable, it needs to be a clone of the current state of context.\n\t                            Otherwise we have a context with infinite recursion.\n\t                            Fixes #341\n\t                        */\n\t                        value = Twig.lib.copy(value);\n\t                    }\n\n\t                    context[key] = value;\n\n\t                    return {\n\t                        chain: continue_chain,\n\t                        context: context\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Set capture type logic tokens.\n\t             *\n\t             *  Format: {% set key %}\n\t             */\n\t            type: Twig.logic.type.setcapture,\n\t            regex: /^set\\s+([a-zA-Z0-9_,\\s]+)$/,\n\t            next: [\n\t                Twig.logic.type.endset\n\t            ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var key = token.match[1].trim();\n\n\t                token.key = key;\n\n\t                delete token.match;\n\t                return token;\n\t            },\n\t            parse: function (token, context, continue_chain) {\n\t                var that = this,\n\t                    key = token.key;\n\n\t                return Twig.parseAsync.apply(this, [token.output, context])\n\t                .then(function(value) {\n\t                    // set on both the global and local context\n\t                    that.context[key] = value;\n\t                    context[key] = value;\n\n\t                    return {\n\t                        chain: continue_chain,\n\t                        context: context\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * End set type block logic tokens.\n\t             *\n\t             *  Format: {% endset %}\n\t             */\n\t            type: Twig.logic.type.endset,\n\t            regex: /^endset$/,\n\t            next: [ ],\n\t            open: false\n\t        },\n\t        {\n\t            /**\n\t             * Filter logic tokens.\n\t             *\n\t             *  Format: {% filter upper %} or {% filter lower|escape %}\n\t             */\n\t            type: Twig.logic.type.filter,\n\t            regex: /^filter\\s+(.+)$/,\n\t            next: [\n\t                Twig.logic.type.endfilter\n\t            ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var expression = \"|\" + token.match[1].trim();\n\t                // Compile the expression.\n\t                token.stack = Twig.expression.compile.apply(this, [{\n\t                    type:  Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\t                delete token.match;\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                return Twig.parseAsync.apply(this, [token.output, context])\n\t                .then(function(unfiltered) {\n\t                    var stack = [{\n\t                        type: Twig.expression.type.string,\n\t                        value: unfiltered\n\t                    }].concat(token.stack);\n\n\t                    return Twig.expression.parseAsync.apply(that, [stack, context]);\n\t                })\n\t                .then(function(output) {\n\t                    return {\n\t                        chain: chain,\n\t                        output: output\n\t                    }\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * End filter logic tokens.\n\t             *\n\t             *  Format: {% endfilter %}\n\t             */\n\t            type: Twig.logic.type.endfilter,\n\t            regex: /^endfilter$/,\n\t            next: [ ],\n\t            open: false\n\t        },\n\t        {\n\t            /**\n\t             * Block logic tokens.\n\t             *\n\t             *  Format: {% block title %}\n\t             */\n\t            type: Twig.logic.type.block,\n\t            regex: /^block\\s+([a-zA-Z0-9_]+)$/,\n\t            next: [\n\t                Twig.logic.type.endblock\n\t            ],\n\t            open: true,\n\t            compile: function (token) {\n\t                token.block = token.match[1].trim();\n\t                delete token.match;\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                var that = this,\n\t                    block_output,\n\t                    output,\n\t                    promise = Twig.Promise.resolve(),\n\t                    isImported = Twig.indexOf(this.importedBlocks, token.block) > -1,\n\t                    hasParent = this.blocks[token.block] && Twig.indexOf(this.blocks[token.block], Twig.placeholders.parent) > -1;\n\n\t                // Don't override previous blocks unless they're imported with \"use\"\n\t                // Loops should be exempted as well.\n\t                if (this.blocks[token.block] === undefined || isImported || hasParent || context.loop || token.overwrite) {\n\t                    if (token.expression) {\n\t                        promise = Twig.expression.parseAsync.apply(this, [token.output, context])\n\t                        .then(function(value) {\n\t                            return Twig.expression.parseAsync.apply(that, [{\n\t                                type: Twig.expression.type.string,\n\t                                value: value\n\t                            }, context]);\n\t                        });\n\t                    } else {\n\t                        promise = Twig.parseAsync.apply(this, [token.output, context])\n\t                        .then(function(value) {\n\t                            return Twig.expression.parseAsync.apply(that, [{\n\t                                type: Twig.expression.type.string,\n\t                                value: value\n\t                            }, context]);\n\t                        });\n\t                    }\n\n\t                    promise = promise.then(function(block_output) {\n\t                        if (isImported) {\n\t                            // once the block is overridden, remove it from the list of imported blocks\n\t                            that.importedBlocks.splice(that.importedBlocks.indexOf(token.block), 1);\n\t                        }\n\n\t                        if (hasParent) {\n\t                            that.blocks[token.block] = Twig.Markup(that.blocks[token.block].replace(Twig.placeholders.parent, block_output));\n\t                        } else {\n\t                            that.blocks[token.block] = block_output;\n\t                        }\n\n\t                        that.originalBlockTokens[token.block] = {\n\t                            type: token.type,\n\t                            block: token.block,\n\t                            output: token.output,\n\t                            overwrite: true\n\t                        };\n\t                    });\n\t                }\n\n\t                return promise.then(function() {\n\t                    // Check if a child block has been set from a template extending this one.\n\t                    if (that.child.blocks[token.block]) {\n\t                        output = that.child.blocks[token.block];\n\t                    } else {\n\t                        output = that.blocks[token.block];\n\t                    }\n\n\t                    return {\n\t                        chain: chain,\n\t                        output: output\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Block shorthand logic tokens.\n\t             *\n\t             *  Format: {% block title expression %}\n\t             */\n\t            type: Twig.logic.type.shortblock,\n\t            regex: /^block\\s+([a-zA-Z0-9_]+)\\s+(.+)$/,\n\t            next: [ ],\n\t            open: true,\n\t            compile: function (token) {\n\t                token.expression = token.match[2].trim();\n\n\t                token.output = Twig.expression.compile({\n\t                    type: Twig.expression.type.expression,\n\t                    value: token.expression\n\t                }).stack;\n\n\t                token.block = token.match[1].trim();\n\t                delete token.match;\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                return Twig.logic.handler[Twig.logic.type.block].parse.apply(this, arguments);\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * End block logic tokens.\n\t             *\n\t             *  Format: {% endblock %}\n\t             */\n\t            type: Twig.logic.type.endblock,\n\t            regex: /^endblock(?:\\s+([a-zA-Z0-9_]+))?$/,\n\t            next: [ ],\n\t            open: false\n\t        },\n\t        {\n\t            /**\n\t             * Block logic tokens.\n\t             *\n\t             *  Format: {% extends \"template.twig\" %}\n\t             */\n\t            type: Twig.logic.type.extends_,\n\t            regex: /^extends\\s+(.+)$/,\n\t            next: [ ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var expression = token.match[1].trim();\n\t                delete token.match;\n\n\t                token.stack   = Twig.expression.compile.apply(this, [{\n\t                    type:  Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                var template,\n\t                    that = this,\n\t                    innerContext = Twig.ChildContext(context);\n\n\t                // Resolve filename\n\t                return Twig.expression.parseAsync.apply(this, [token.stack, context])\n\t                .then(function(file) {\n\t                    // Set parent template\n\t                    that.extend = file;\n\n\t                    if (file instanceof Twig.Template) {\n\t                        template = file;\n\t                    } else {\n\t                        // Import file\n\t                        template = that.importFile(file);\n\t                    }\n\n\t                    // Render the template in case it puts anything in its context\n\t                    return template.renderAsync(innerContext);\n\t                })\n\t                .then(function() {\n\t                    // Extend the parent context with the extended context\n\t                    Twig.lib.extend(context, innerContext);\n\n\t                    return {\n\t                        chain: chain,\n\t                        output: ''\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Block logic tokens.\n\t             *\n\t             *  Format: {% use \"template.twig\" %}\n\t             */\n\t            type: Twig.logic.type.use,\n\t            regex: /^use\\s+(.+)$/,\n\t            next: [ ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var expression = token.match[1].trim();\n\t                delete token.match;\n\n\t                token.stack = Twig.expression.compile.apply(this, [{\n\t                    type:  Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                var that = this;\n\n\t                // Resolve filename\n\t                return Twig.expression.parseAsync.apply(this, [token.stack, context])\n\t                .then(function(file) {\n\t                    // Import blocks\n\t                    that.importBlocks(file);\n\n\t                    return {\n\t                        chain: chain,\n\t                        output: ''\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * Block logic tokens.\n\t             *\n\t             *  Format: {% includes \"template.twig\" [with {some: 'values'} only] %}\n\t             */\n\t            type: Twig.logic.type.include,\n\t            regex: /^include\\s+(.+?)(?:\\s|$)(ignore missing(?:\\s|$))?(?:with\\s+([\\S\\s]+?))?(?:\\s|$)(only)?$/,\n\t            next: [ ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var match = token.match,\n\t                    expression = match[1].trim(),\n\t                    ignoreMissing = match[2] !== undefined,\n\t                    withContext = match[3],\n\t                    only = ((match[4] !== undefined) && match[4].length);\n\n\t                delete token.match;\n\n\t                token.only = only;\n\t                token.ignoreMissing = ignoreMissing;\n\n\t                token.stack = Twig.expression.compile.apply(this, [{\n\t                    type:  Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\n\t                if (withContext !== undefined) {\n\t                    token.withStack = Twig.expression.compile.apply(this, [{\n\t                        type:  Twig.expression.type.expression,\n\t                        value: withContext.trim()\n\t                    }]).stack;\n\t                }\n\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                // Resolve filename\n\t                var innerContext = {},\n\t                    i,\n\t                    template,\n\t                    that = this,\n\t                    promise = Twig.Promise.resolve();\n\n\t                if (!token.only) {\n\t                    innerContext = Twig.ChildContext(context);\n\t                }\n\n\t                if (token.withStack !== undefined) {\n\t                    promise = Twig.expression.parseAsync.apply(this, [token.withStack, context])\n\t                    .then(function(withContext) {\n\t                        for (i in withContext) {\n\t                            if (withContext.hasOwnProperty(i))\n\t                                innerContext[i] = withContext[i];\n\t                        }\n\t                    });\n\t                }\n\n\t                return promise\n\t                .then(function() {\n\t                    return Twig.expression.parseAsync.apply(that, [token.stack, context]);\n\t                })\n\t                .then(function(file) {\n\t                    if (file instanceof Twig.Template) {\n\t                        template = file;\n\t                    } else {\n\t                        // Import file\n\t                        try {\n\t                            template = that.importFile(file);\n\t                        } catch (err) {\n\t                            if (token.ignoreMissing) {\n\t                                return '';\n\t                            }\n\n\t                            throw err;\n\t                        }\n\t                    }\n\n\t                    return template.renderAsync(innerContext);\n\t                })\n\t                .then(function(output) {\n\t                    return {\n\t                        chain: chain,\n\t                        output: output\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        {\n\t            type: Twig.logic.type.spaceless,\n\t            regex: /^spaceless$/,\n\t            next: [\n\t                Twig.logic.type.endspaceless\n\t            ],\n\t            open: true,\n\n\t            // Parse the html and return it without any spaces between tags\n\t            parse: function (token, context, chain) {\n\t                // Parse the output without any filter\n\t                return Twig.parseAsync.apply(this, [token.output, context])\n\t                .then(function(unfiltered) {\n\t                    var // A regular expression to find closing and opening tags with spaces between them\n\t                        rBetweenTagSpaces = />\\s+</g,\n\t                        // Replace all space between closing and opening html tags\n\t                        output = unfiltered.replace(rBetweenTagSpaces,'><').trim();\n\t                        // Rewrap output as a Twig.Markup\n\t                        output = Twig.Markup(output);\n\t                    return {\n\t                        chain: chain,\n\t                        output: output\n\t                    };\n\t                });\n\t            }\n\t        },\n\n\t        // Add the {% endspaceless %} token\n\t        {\n\t            type: Twig.logic.type.endspaceless,\n\t            regex: /^endspaceless$/,\n\t            next: [ ],\n\t            open: false\n\t        },\n\t        {\n\t            /**\n\t             * Macro logic tokens.\n\t             *\n\t             * Format: {% maro input(name, value, type, size) %}\n\t             *\n\t             */\n\t            type: Twig.logic.type.macro,\n\t            regex: /^macro\\s+([a-zA-Z0-9_]+)\\s*\\(\\s*((?:[a-zA-Z0-9_]+(?:,\\s*)?)*)\\s*\\)$/,\n\t            next: [\n\t                Twig.logic.type.endmacro\n\t            ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var macroName = token.match[1],\n\t                    parameters = token.match[2].split(/[\\s,]+/);\n\n\t                //TODO: Clean up duplicate check\n\t                for (var i=0; i<parameters.length; i++) {\n\t                    for (var j=0; j<parameters.length; j++){\n\t                        if (parameters[i] === parameters[j] && i !== j) {\n\t                            throw new Twig.Error(\"Duplicate arguments for parameter: \"+ parameters[i]);\n\t                        }\n\t                    }\n\t                }\n\n\t                token.macroName = macroName;\n\t                token.parameters = parameters;\n\n\t                delete token.match;\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                var template = this;\n\t                this.macros[token.macroName] = function() {\n\t                    // Pass global context and other macros\n\t                    var macroContext = {\n\t                        _self: template.macros\n\t                    }\n\t                    // Add parameters from context to macroContext\n\t                    for (var i=0; i<token.parameters.length; i++) {\n\t                        var prop = token.parameters[i];\n\t                        if(typeof arguments[i] !== 'undefined') {\n\t                            macroContext[prop] = arguments[i];\n\t                        } else {\n\t                            macroContext[prop] = undefined;\n\t                        }\n\t                    }\n\n\t                    // Render\n\t                    return Twig.parseAsync.apply(template, [token.output, macroContext]);\n\t                };\n\n\t                return {\n\t                    chain: chain,\n\t                    output: ''\n\t                };\n\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * End macro logic tokens.\n\t             *\n\t             * Format: {% endmacro %}\n\t             */\n\t             type: Twig.logic.type.endmacro,\n\t             regex: /^endmacro$/,\n\t             next: [ ],\n\t             open: false\n\t        },\n\t        {\n\t            /*\n\t            * import logic tokens.\n\t            *\n\t            * Format: {% import \"template.twig\" as form %}\n\t            */\n\t            type: Twig.logic.type.import_,\n\t            regex: /^import\\s+(.+)\\s+as\\s+([a-zA-Z0-9_]+)$/,\n\t            next: [ ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var expression = token.match[1].trim(),\n\t                    contextName = token.match[2].trim();\n\t                delete token.match;\n\n\t                token.expression = expression;\n\t                token.contextName = contextName;\n\n\t                token.stack = Twig.expression.compile.apply(this, [{\n\t                    type: Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                var that = this,\n\t                    output = { chain: chain, output: '' };\n\n\t                if (token.expression === '_self') {\n\t                    context[token.contextName] = this.macros;\n\t                    return Twig.Promise.resolve(output);\n\t                }\n\n\t                return Twig.expression.parseAsync.apply(this, [token.stack, context])\n\t                .then(function(file) {\n\t                    return that.importFile(file || token.expression);\n\t                })\n\t                .then(function(template) {\n\t                    context[token.contextName] = template.renderAsync({}, {output: 'macros'});\n\n\t                    return output;\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /*\n\t            * from logic tokens.\n\t            *\n\t            * Format: {% from \"template.twig\" import func as form %}\n\t            */\n\t            type: Twig.logic.type.from,\n\t            regex: /^from\\s+(.+)\\s+import\\s+([a-zA-Z0-9_, ]+)$/,\n\t            next: [ ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var expression = token.match[1].trim(),\n\t                    macroExpressions = token.match[2].trim().split(/\\s*,\\s*/),\n\t                    macroNames = {};\n\n\t                for (var i=0; i<macroExpressions.length; i++) {\n\t                    var res = macroExpressions[i];\n\n\t                    // match function as variable\n\t                    var macroMatch = res.match(/^([a-zA-Z0-9_]+)\\s+as\\s+([a-zA-Z0-9_]+)$/);\n\t                    if (macroMatch) {\n\t                        macroNames[macroMatch[1].trim()] = macroMatch[2].trim();\n\t                    }\n\t                    else if (res.match(/^([a-zA-Z0-9_]+)$/)) {\n\t                        macroNames[res] = res;\n\t                    }\n\t                    else {\n\t                        // ignore import\n\t                    }\n\n\t                }\n\n\t                delete token.match;\n\n\t                token.expression = expression;\n\t                token.macroNames = macroNames;\n\n\t                token.stack = Twig.expression.compile.apply(this, [{\n\t                    type: Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                var that = this,\n\t                    promise = Twig.Promise.resolve(this.macros);\n\n\t                if (token.expression !== \"_self\") {\n\t                    promise = Twig.expression.parseAsync.apply(this, [token.stack, context])\n\t                    .then(function(file) {\n\t                        return that.importFile(file || token.expression);\n\t                    })\n\t                    .then(function(template) {\n\t                        return template.renderAsync({}, {output: 'macros'});\n\t                    });\n\t                }\n\n\t                return promise\n\t                .then(function(macros) {\n\t                    for (var macroName in token.macroNames) {\n\t                        if (macros.hasOwnProperty(macroName)) {\n\t                            context[token.macroNames[macroName]] = macros[macroName];\n\t                        }\n\t                    }\n\n\t                    return {\n\t                        chain: chain,\n\t                        output: ''\n\t                    }\n\t                });\n\t            }\n\t        },\n\t        {\n\t            /**\n\t             * The embed tag combines the behaviour of include and extends.\n\t             * It allows you to include another template's contents, just like include does.\n\t             *\n\t             *  Format: {% embed \"template.twig\" [with {some: 'values'} only] %}\n\t             */\n\t            type: Twig.logic.type.embed,\n\t            regex: /^embed\\s+(.+?)(?:\\s|$)(ignore missing(?:\\s|$))?(?:with\\s+([\\S\\s]+?))?(?:\\s|$)(only)?$/,\n\t            next: [\n\t                Twig.logic.type.endembed\n\t            ],\n\t            open: true,\n\t            compile: function (token) {\n\t                var match = token.match,\n\t                    expression = match[1].trim(),\n\t                    ignoreMissing = match[2] !== undefined,\n\t                    withContext = match[3],\n\t                    only = ((match[4] !== undefined) && match[4].length);\n\n\t                delete token.match;\n\n\t                token.only = only;\n\t                token.ignoreMissing = ignoreMissing;\n\n\t                token.stack = Twig.expression.compile.apply(this, [{\n\t                    type:  Twig.expression.type.expression,\n\t                    value: expression\n\t                }]).stack;\n\n\t                if (withContext !== undefined) {\n\t                    token.withStack = Twig.expression.compile.apply(this, [{\n\t                        type:  Twig.expression.type.expression,\n\t                        value: withContext.trim()\n\t                    }]).stack;\n\t                }\n\n\t                return token;\n\t            },\n\t            parse: function (token, context, chain) {\n\t                // Resolve filename\n\t                var innerContext = {},\n\t                    that = this,\n\t                    i,\n\t                    template,\n\t                    promise = Twig.Promise.resolve();\n\n\t                if (!token.only) {\n\t                    for (i in context) {\n\t                        if (context.hasOwnProperty(i))\n\t                            innerContext[i] = context[i];\n\t                    }\n\t                }\n\n\t                if (token.withStack !== undefined) {\n\t                    promise = Twig.expression.parseAsync.apply(this, [token.withStack, context])\n\t                    .then(function(withContext) {\n\t                        for (i in withContext) {\n\t                            if (withContext.hasOwnProperty(i))\n\t                                innerContext[i] = withContext[i];\n\t                        }\n\t                    });\n\t                }\n\n\t                return promise.then(function() {\n\t                    return Twig.expression.parseAsync.apply(that, [token.stack, innerContext]);\n\t                })\n\t                .then(function(file) {\n\t                    if (file instanceof Twig.Template) {\n\t                        template = file;\n\t                    } else {\n\t                        // Import file\n\t                        try {\n\t                            template = that.importFile(file);\n\t                        } catch (err) {\n\t                            if (token.ignoreMissing) {\n\t                                return '';\n\t                            }\n\n\t                            throw err;\n\t                        }\n\t                    }\n\n\t                    // reset previous blocks\n\t                    that.blocks = {};\n\n\t                    // parse tokens. output will be not used\n\t                    return Twig.parseAsync.apply(that, [token.output, innerContext])\n\t                    .then(function() {\n\t                        // render tempalte with blocks defined in embed block\n\t                        return template.renderAsync(innerContext, {'blocks':that.blocks});\n\t                    });\n\t                })\n\t                .then(function(output) {\n\t                    return {\n\t                        chain: chain,\n\t                        output: output\n\t                    };\n\t                });\n\t            }\n\t        },\n\t        /* Add the {% endembed %} token\n\t         *\n\t         */\n\t        {\n\t            type: Twig.logic.type.endembed,\n\t            regex: /^endembed$/,\n\t            next: [ ],\n\t            open: false\n\t        }\n\n\t    ];\n\n\n\t    /**\n\t     * Registry for logic handlers.\n\t     */\n\t    Twig.logic.handler = {};\n\n\t    /**\n\t     * Define a new token type, available at Twig.logic.type.{type}\n\t     */\n\t    Twig.logic.extendType = function (type, value) {\n\t        value = value || (\"Twig.logic.type\" + type);\n\t        Twig.logic.type[type] = value;\n\t    };\n\n\t    /**\n\t     * Extend the logic parsing functionality with a new token definition.\n\t     *\n\t     * // Define a new tag\n\t     * Twig.logic.extend({\n\t     *     type: Twig.logic.type.{type},\n\t     *     // The pattern to match for this token\n\t     *     regex: ...,\n\t     *     // What token types can follow this token, leave blank if any.\n\t     *     next: [ ... ]\n\t     *     // Create and return compiled version of the token\n\t     *     compile: function(token) { ... }\n\t     *     // Parse the compiled token with the context provided by the render call\n\t     *     //   and whether this token chain is complete.\n\t     *     parse: function(token, context, chain) { ... }\n\t     * });\n\t     *\n\t     * @param {Object} definition The new logic expression.\n\t     */\n\t    Twig.logic.extend = function (definition) {\n\n\t        if (!definition.type) {\n\t            throw new Twig.Error(\"Unable to extend logic definition. No type provided for \" + definition);\n\t        } else {\n\t            Twig.logic.extendType(definition.type);\n\t        }\n\t        Twig.logic.handler[definition.type] = definition;\n\t    };\n\n\t    // Extend with built-in expressions\n\t    while (Twig.logic.definitions.length > 0) {\n\t        Twig.logic.extend(Twig.logic.definitions.shift());\n\t    }\n\n\t    /**\n\t     * Compile a logic token into an object ready for parsing.\n\t     *\n\t     * @param {Object} raw_token An uncompiled logic token.\n\t     *\n\t     * @return {Object} A compiled logic token, ready for parsing.\n\t     */\n\t    Twig.logic.compile = function (raw_token) {\n\t        var expression = raw_token.value.trim(),\n\t            token = Twig.logic.tokenize.apply(this, [expression]),\n\t            token_template = Twig.logic.handler[token.type];\n\n\t        // Check if the token needs compiling\n\t        if (token_template.compile) {\n\t            token = token_template.compile.apply(this, [token]);\n\t            Twig.log.trace(\"Twig.logic.compile: \", \"Compiled logic token to \", token);\n\t        }\n\n\t        return token;\n\t    };\n\n\t    /**\n\t     * Tokenize logic expressions. This function matches token expressions against regular\n\t     * expressions provided in token definitions provided with Twig.logic.extend.\n\t     *\n\t     * @param {string} expression the logic token expression to tokenize\n\t     *                (i.e. what's between {% and %})\n\t     *\n\t     * @return {Object} The matched token with type set to the token type and match to the regex match.\n\t     */\n\t    Twig.logic.tokenize = function (expression) {\n\t        var token = {},\n\t            token_template_type = null,\n\t            token_type = null,\n\t            token_regex = null,\n\t            regex_array = null,\n\t            regex = null,\n\t            match = null;\n\n\t        // Ignore whitespace around expressions.\n\t        expression = expression.trim();\n\n\t        for (token_template_type in Twig.logic.handler) {\n\t            if (Twig.logic.handler.hasOwnProperty(token_template_type)) {\n\t                // Get the type and regex for this template type\n\t                token_type = Twig.logic.handler[token_template_type].type;\n\t                token_regex = Twig.logic.handler[token_template_type].regex;\n\n\t                // Handle multiple regular expressions per type.\n\t                regex_array = [];\n\t                if (token_regex instanceof Array) {\n\t                    regex_array = token_regex;\n\t                } else {\n\t                    regex_array.push(token_regex);\n\t                }\n\n\t                // Check regular expressions in the order they were specified in the definition.\n\t                while (regex_array.length > 0) {\n\t                    regex = regex_array.shift();\n\t                    match = regex.exec(expression.trim());\n\t                    if (match !== null) {\n\t                        token.type  = token_type;\n\t                        token.match = match;\n\t                        Twig.log.trace(\"Twig.logic.tokenize: \", \"Matched a \", token_type, \" regular expression of \", match);\n\t                        return token;\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        // No regex matches\n\t        throw new Twig.Error(\"Unable to parse '\" + expression.trim() + \"'\");\n\t    };\n\n\t    /**\n\t     * Parse a logic token within a given context.\n\t     *\n\t     * What are logic chains?\n\t     *      Logic chains represent a series of tokens that are connected,\n\t     *          for example:\n\t     *          {% if ... %} {% else %} {% endif %}\n\t     *\n\t     *      The chain parameter is used to signify if a chain is open of closed.\n\t     *      open:\n\t     *          More tokens in this chain should be parsed.\n\t     *      closed:\n\t     *          This token chain has completed parsing and any additional\n\t     *          tokens (else, elseif, etc...) should be ignored.\n\t     *\n\t     * @param {Object} token The compiled token.\n\t     * @param {Object} context The render context.\n\t     * @param {boolean} chain Is this an open logic chain. If false, that means a\n\t     *                        chain is closed and no further cases should be parsed.\n\t     */\n\t    Twig.logic.parse = function (token, context, chain, allow_async) {\n\t        var output = '',\n\t            promise,\n\t            is_async = true,\n\t            token_template;\n\n\t        context = context || { };\n\n\t        Twig.log.debug(\"Twig.logic.parse: \", \"Parsing logic token \", token);\n\n\t        token_template = Twig.logic.handler[token.type];\n\n\t        if (token_template.parse) {\n\t            output = token_template.parse.apply(this, [token, context, chain]);\n\t        }\n\n\t        promise = Twig.isPromise(output) ? output : Twig.Promise.resolve(output);\n\n\t        promise.then(function(o) {\n\t            is_async = false;\n\t            output = o;\n\t        });\n\n\t        if (allow_async)\n\t            return promise || Twig.Promise.resolve(output);\n\n\t        if (is_async)\n\t            throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t        return output;\n\t    };\n\n\t    return Twig;\n\n\t};\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(Twig) {\n\t    'use strict';\n\n\t    Twig.Templates.registerParser('source', function(params) {\n\t        return params.data || '';\n\t    });\n\t};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(Twig) {\n\t    'use strict';\n\n\t    Twig.Templates.registerParser('twig', function(params) {\n\t        return new Twig.Template(params);\n\t    });\n\t};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// ## twig.path.js\n\t//\n\t// This file handles path parsing\n\tmodule.exports = function (Twig) {\n\t    \"use strict\";\n\n\t    /**\n\t     * Namespace for path handling.\n\t     */\n\t    Twig.path = {};\n\n\t    /**\n\t     * Generate the canonical version of a url based on the given base path and file path and in\n\t     * the previously registered namespaces.\n\t     *\n\t     * @param  {string} template The Twig Template\n\t     * @param  {string} file     The file path, may be relative and may contain namespaces.\n\t     *\n\t     * @return {string}          The canonical version of the path\n\t     */\n\t     Twig.path.parsePath = function(template, file) {\n\t        var namespaces = null,\n\t            file = file || \"\";\n\n\t        if (typeof template === 'object' && typeof template.options === 'object') {\n\t            namespaces = template.options.namespaces;\n\t        }\n\n\t        if (typeof namespaces === 'object' && (file.indexOf('::') > 0) || file.indexOf('@') >= 0){\n\t            for (var k in namespaces){\n\t                if (namespaces.hasOwnProperty(k)) {\n\t                    file = file.replace(k + '::', namespaces[k]);\n\t                    file = file.replace('@' + k, namespaces[k]);\n\t                }\n\t            }\n\n\t            return file;\n\t        }\n\n\t        return Twig.path.relativePath(template, file);\n\t    };\n\n\t    /**\n\t     * Generate the relative canonical version of a url based on the given base path and file path.\n\t     *\n\t     * @param {Twig.Template} template The Twig.Template.\n\t     * @param {string} file The file path, relative to the base path.\n\t     *\n\t     * @return {string} The canonical version of the path.\n\t     */\n\t    Twig.path.relativePath = function(template, file) {\n\t        var base,\n\t            base_path,\n\t            sep_chr = \"/\",\n\t            new_path = [],\n\t            file = file || \"\",\n\t            val;\n\n\t        if (template.url) {\n\t            if (typeof template.base !== 'undefined') {\n\t                base = template.base + ((template.base.charAt(template.base.length-1) === '/') ? '' : '/');\n\t            } else {\n\t                base = template.url;\n\t            }\n\t        } else if (template.path) {\n\t            // Get the system-specific path separator\n\t            var path = __webpack_require__(20),\n\t                sep = path.sep || sep_chr,\n\t                relative = new RegExp(\"^\\\\.{1,2}\" + sep.replace(\"\\\\\", \"\\\\\\\\\"));\n\t            file = file.replace(/\\//g, sep);\n\n\t            if (template.base !== undefined && file.match(relative) == null) {\n\t                file = file.replace(template.base, '');\n\t                base = template.base + sep;\n\t            } else {\n\t                base = path.normalize(template.path);\n\t            }\n\n\t            base = base.replace(sep+sep, sep);\n\t            sep_chr = sep;\n\t        } else if ((template.name || template.id) && template.method && template.method !== 'fs' && template.method !== 'ajax') {\n\t            // Custom registered loader\n\t            base = template.base || template.name || template.id;\n\t        } else {\n\t            throw new Twig.Error(\"Cannot extend an inline template.\");\n\t        }\n\n\t        base_path = base.split(sep_chr);\n\n\t        // Remove file from url\n\t        base_path.pop();\n\t        base_path = base_path.concat(file.split(sep_chr));\n\n\t        while (base_path.length > 0) {\n\t            val = base_path.shift();\n\t            if (val == \".\") {\n\t                // Ignore\n\t            } else if (val == \"..\" && new_path.length > 0 && new_path[new_path.length-1] != \"..\") {\n\t                new_path.pop();\n\t            } else {\n\t                new_path.push(val);\n\t            }\n\t        }\n\n\t        return new_path.join(sep_chr);\n\t    };\n\n\t    return Twig;\n\t};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t// ## twig.tests.js\n\t//\n\t// This file handles expression tests. (is empty, is not defined, etc...)\n\tmodule.exports = function (Twig) {\n\t    \"use strict\";\n\t    Twig.tests = {\n\t        empty: function(value) {\n\t            if (value === null || value === undefined) return true;\n\t            // Handler numbers\n\t            if (typeof value === \"number\") return false; // numbers are never \"empty\"\n\t            // Handle strings and arrays\n\t            if (value.length && value.length > 0) return false;\n\t            // Handle objects\n\t            for (var key in value) {\n\t                if (value.hasOwnProperty(key)) return false;\n\t            }\n\t            return true;\n\t        },\n\t        odd: function(value) {\n\t            return value % 2 === 1;\n\t        },\n\t        even: function(value) {\n\t            return value % 2 === 0;\n\t        },\n\t        divisibleby: function(value, params) {\n\t            return value % params[0] === 0;\n\t        },\n\t        defined: function(value) {\n\t            return value !== undefined;\n\t        },\n\t        none: function(value) {\n\t            return value === null;\n\t        },\n\t        'null': function(value) {\n\t            return this.none(value); // Alias of none\n\t        },\n\t        'same as': function(value, params) {\n\t            return value === params[0];\n\t        },\n\t        sameas: function(value, params) {\n\t            console.warn('`sameas` is deprecated use `same as`');\n\t            return Twig.tests['same as'](value, params);\n\t        },\n\t        iterable: function(value) {\n\t            return value && (Twig.lib.is(\"Array\", value) || Twig.lib.is(\"Object\", value));\n\t        }\n\t        /*\n\t        constant ?\n\t         */\n\t    };\n\n\t    Twig.test = function(test, value, params) {\n\t        if (!Twig.tests[test]) {\n\t            throw \"Test \" + test + \" is not defined.\";\n\t        }\n\t        return Twig.tests[test](value, params);\n\t    };\n\n\t    Twig.test.extend = function(test, definition) {\n\t        Twig.tests[test] = definition;\n\t    };\n\n\t    return Twig;\n\t};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t// ## twig.async.js\n\t//\n\t// This file handles asynchronous tasks within twig.\n\tmodule.exports = function (Twig) {\n\t    \"use strict\";\n\n\t    Twig.parseAsync = function (tokens, context) {\n\t        return Twig.parse.apply(this, [tokens, context, true]);\n\t    }\n\n\t    Twig.expression.parseAsync = function (tokens, context, tokens_are_parameters) {\n\t        return Twig.expression.parse.apply(this, [tokens, context, tokens_are_parameters, true]);\n\t    }\n\n\t    Twig.logic.parseAsync = function (token, context, chain) {\n\t        return Twig.logic.parse.apply(this, [token, context, chain, true]);\n\t    }\n\n\t    Twig.Template.prototype.renderAsync = function (context, params) {\n\t        return this.render(context, params, true);\n\t    }\n\n\t    Twig.async = {};\n\n\t    /**\n\t     * Checks for `thenable` objects\n\t     */\n\t    Twig.isPromise = function(obj) {\n\t        return obj && (typeof obj.then == 'function');\n\t    }\n\n\t    /**\n\t     * An alternate implementation of a Promise that does not fully follow\n\t     * the spec, but instead works fully synchronous while still being\n\t     * thenable.\n\t     *\n\t     * These promises can be mixed with regular promises at which point\n\t     * the synchronous behaviour is lost.\n\t     */\n\t    Twig.Promise = function(executor) {\n\t        // State\n\t        var state = 'unknown';\n\t        var value = null;\n\t        var handlers = null;\n\n\t        function changeState(newState, v) {\n\t            state = newState;\n\t            value = v;\n\t            notify();\n\t        };\n\t        function onResolve(v) { changeState('resolve', v); }\n\t        function onReject(e) { changeState('reject', e); }\n\n\t        function notify() {\n\t            if (!handlers) return;\n\n\t            Twig.forEach(handlers, function(h) {\n\t                append(h.resolve, h.reject);\n\t            });\n\t            handlers = null;\n\t        }\n\n\t        function append(onResolved, onRejected) {\n\t            var h = {\n\t                resolve: onResolved,\n\t                reject: onRejected\n\t            };\n\n\t            // The promise has yet to be rejected or resolved.\n\t            if (state == 'unknown') {\n\t                handlers = handlers || [];\n\t                return handlers.push(h);\n\t            }\n\n\t            // The state has been changed to either resolve, or reject\n\t            // which means we should call the handler.\n\t            if (h[state])\n\t                h[state](value);\n\t        }\n\n\t        function run(fn, resolve, reject) {\n\t            var done = false;\n\t            try {\n\t                fn(function(v) {\n\t                    if (done) return;\n\t                    done = true;\n\t                    resolve(v);\n\t                }, function(e) {\n\t                    if (done) return;\n\t                    done = true;\n\t                    reject(e);\n\t                });\n\t            } catch(e) {\n\t                done = true;\n\t                reject(e);\n\t            }\n\t        }\n\n\t        function ready(result) {\n\t            try {\n\t                if (!Twig.isPromise(result)) {\n\t                    return onResolve(result);\n\t                }\n\n\t                run(result.then.bind(result), ready, onReject);\n\t            } catch (e) {\n\t                onReject(e);\n\t            }\n\t        }\n\n\t        run(executor, ready, onReject);\n\n\t        return {\n\t            then: function(onResolved, onRejected) {\n\t                var hasResolved = typeof onResolved == 'function';\n\t                var hasRejected = typeof onRejected == 'function';\n\n\t                return new Twig.Promise(function(resolve, reject) {\n\t                    append(function(result) {\n\t                        if (hasResolved) {\n\t                            try {\n\t                                resolve(onResolved(result));\n\t                            } catch (e) {\n\t                                reject(e);\n\t                            }\n\t                        } else {\n\t                            resolve(result);\n\t                        }\n\t                    }, function(err) {\n\t                        if (hasRejected) {\n\t                            try {\n\t                                resolve(onRejected(err));\n\t                            } catch (e) {\n\t                                reject(e);\n\t                            }\n\t                        } else {\n\t                            reject(err);\n\t                        }\n\t                    });\n\t                });\n\t            },\n\t            catch: function(onRejected) {\n\t                return this.then(null, onRejected);\n\t            }\n\t        };\n\t    }\n\n\t    Twig.Promise.resolve = function(value) {\n\t        return new Twig.Promise(function(resolve) {\n\t            resolve(value);\n\t        });\n\t    };\n\n\t    Twig.Promise.reject = function(e) {\n\t        return new Twig.Promise(function(resolve, reject) {\n\t            reject(e);\n\t        });\n\t    };\n\n\t    Twig.Promise.all = function(promises) {\n\t        var results = [];\n\n\t        return Twig.async.forEach(promises, function(p, index) {\n\t            if (!Twig.isPromise(p)) {\n\t                results[index] = p;\n\t                return;\n\t            }\n\n\t            return p.then(function(v) {\n\t                results[index] = v;\n\t            });\n\t        })\n\t        .then(function() {\n\t            return results;\n\t        });\n\t    };\n\n\t    /**\n\t    * Go over each item in a fashion compatible with Twig.forEach,\n\t    * allow the function to return a promise or call the third argument\n\t    * to signal it is finished.\n\t    *\n\t    * Each item in the array will be called sequentially.\n\t    */\n\t    Twig.async.forEach = function forEachAsync(arr, callback) {\n\t        var arg_index = 0;\n\t        var callbacks = {};\n\t        var promise = new Twig.Promise(function(resolve, reject) {\n\t            callbacks = {\n\t                resolve: resolve,\n\t                reject: reject\n\t            };\n\t        });\n\n\t        function fail(err) {\n\t            callbacks.reject(err);\n\t        }\n\n\t        function next(value) {\n\t            if (!Twig.isPromise(value))\n\t                return iterate();\n\n\t            value.then(next, fail);\n\t        }\n\n\t        function iterate() {\n\t            var index = arg_index++;\n\n\t            if (index == arr.length) {\n\t                callbacks.resolve();\n\t                return;\n\t            }\n\n\t            next(callback(arr[index], index));\n\t        }\n\n\t        iterate();\n\n\t        return promise;\n\t    };\n\n\t    return Twig;\n\n\t};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t// ## twig.exports.js\n\t//\n\t// This file provides extension points and other hooks into the twig functionality.\n\n\tmodule.exports = function (Twig) {\n\t    \"use strict\";\n\t    Twig.exports = {\n\t        VERSION: Twig.VERSION\n\t    };\n\n\t    /**\n\t     * Create and compile a twig.js template.\n\t     *\n\t     * @param {Object} param Paramteres for creating a Twig template.\n\t     *\n\t     * @return {Twig.Template} A Twig template ready for rendering.\n\t     */\n\t    Twig.exports.twig = function twig(params) {\n\t        'use strict';\n\t        var id = params.id,\n\t            options = {\n\t                strict_variables: params.strict_variables || false,\n\t                // TODO: turn autoscape on in the next major version\n\t                autoescape: params.autoescape != null && params.autoescape || false,\n\t                allowInlineIncludes: params.allowInlineIncludes || false,\n\t                rethrow: params.rethrow || false,\n\t                namespaces: params.namespaces\n\t            };\n\n\t        if (Twig.cache && id) {\n\t            Twig.validateId(id);\n\t        }\n\n\t        if (params.debug !== undefined) {\n\t            Twig.debug = params.debug;\n\t        }\n\t        if (params.trace !== undefined) {\n\t            Twig.trace = params.trace;\n\t        }\n\n\t        if (params.data !== undefined) {\n\t            return Twig.Templates.parsers.twig({\n\t                data: params.data,\n\t                path: params.hasOwnProperty('path') ? params.path : undefined,\n\t                module: params.module,\n\t                id:   id,\n\t                options: options\n\t            });\n\n\t        } else if (params.ref !== undefined) {\n\t            if (params.id !== undefined) {\n\t                throw new Twig.Error(\"Both ref and id cannot be set on a twig.js template.\");\n\t            }\n\t            return Twig.Templates.load(params.ref);\n\t        \n\t        } else if (params.method !== undefined) {\n\t            if (!Twig.Templates.isRegisteredLoader(params.method)) {\n\t                throw new Twig.Error('Loader for \"' + params.method + '\" is not defined.');\n\t            }\n\t            return Twig.Templates.loadRemote(params.name || params.href || params.path || id || undefined, {\n\t                id: id,\n\t                method: params.method,\n\t                parser: params.parser || 'twig',\n\t                base: params.base,\n\t                module: params.module,\n\t                precompiled: params.precompiled,\n\t                async: params.async,\n\t                options: options\n\n\t            }, params.load, params.error);\n\n\t        } else if (params.href !== undefined) {\n\t            return Twig.Templates.loadRemote(params.href, {\n\t                id: id,\n\t                method: 'ajax',\n\t                parser: params.parser || 'twig',\n\t                base: params.base,\n\t                module: params.module,\n\t                precompiled: params.precompiled,\n\t                async: params.async,\n\t                options: options\n\n\t            }, params.load, params.error);\n\n\t        } else if (params.path !== undefined) {\n\t            return Twig.Templates.loadRemote(params.path, {\n\t                id: id,\n\t                method: 'fs',\n\t                parser: params.parser || 'twig',\n\t                base: params.base,\n\t                module: params.module,\n\t                precompiled: params.precompiled,\n\t                async: params.async,\n\t                options: options\n\n\t            }, params.load, params.error);\n\t        }\n\t    };\n\n\t    // Extend Twig with a new filter.\n\t    Twig.exports.extendFilter = function(filter, definition) {\n\t        Twig.filter.extend(filter, definition);\n\t    };\n\n\t    // Extend Twig with a new function.\n\t    Twig.exports.extendFunction = function(fn, definition) {\n\t        Twig._function.extend(fn, definition);\n\t    };\n\n\t    // Extend Twig with a new test.\n\t    Twig.exports.extendTest = function(test, definition) {\n\t        Twig.test.extend(test, definition);\n\t    };\n\n\t    // Extend Twig with a new definition.\n\t    Twig.exports.extendTag = function(definition) {\n\t        Twig.logic.extend(definition);\n\t    };\n\n\t    // Provide an environment for extending Twig core.\n\t    // Calls fn with the internal Twig object.\n\t    Twig.exports.extend = function(fn) {\n\t        fn(Twig);\n\t    };\n\n\n\t    /**\n\t     * Provide an extension for use with express 2.\n\t     *\n\t     * @param {string} markup The template markup.\n\t     * @param {array} options The express options.\n\t     *\n\t     * @return {string} The rendered template.\n\t     */\n\t    Twig.exports.compile = function(markup, options) {\n\t        var id = options.filename,\n\t            path = options.filename,\n\t            template;\n\n\t        // Try to load the template from the cache\n\t        template = new Twig.Template({\n\t            data: markup,\n\t            path: path,\n\t            id: id,\n\t            options: options.settings['twig options']\n\t        }); // Twig.Templates.load(id) ||\n\n\t        return function(context) {\n\t            return template.render(context);\n\t        };\n\t    };\n\n\t    /**\n\t     * Provide an extension for use with express 3.\n\t     *\n\t     * @param {string} path The location of the template file on disk.\n\t     * @param {Object|Function} The options or callback.\n\t     * @param {Function} fn callback.\n\t     * \n\t     * @throws Twig.Error\n\t     */\n\t    Twig.exports.renderFile = function(path, options, fn) {\n\t        // handle callback in options\n\t        if (typeof options === 'function') {\n\t            fn = options;\n\t            options = {};\n\t        }\n\n\t        options = options || {};\n\n\t        var settings = options.settings || {};\n\n\t        var params = {\n\t            path: path,\n\t            base: settings.views,\n\t            load: function(template) {\n\t                // render and return template as a simple string, see https://github.com/twigjs/twig.js/pull/348 for more information\n\t                fn(null, '' + template.render(options));\n\t            }\n\t        };\n\n\t        // mixin any options provided to the express app.\n\t        var view_options = settings['twig options'];\n\n\t        if (view_options) {\n\t            for (var option in view_options) {\n\t                if (view_options.hasOwnProperty(option)) {\n\t                    params[option] = view_options[option];\n\t                }\n\t            }\n\t        }\n\n\t        Twig.exports.twig(params);\n\t    };\n\n\t    // Express 3 handler\n\t    Twig.exports.__express = Twig.exports.renderFile;\n\n\t    /**\n\t     * Shoud Twig.js cache templates.\n\t     * Disable during development to see changes to templates without\n\t     * reloading, and disable in production to improve performance.\n\t     *\n\t     * @param {boolean} cache\n\t     */\n\t    Twig.exports.cache = function(cache) {\n\t        Twig.cache = cache;\n\t    };\n\n\t    //We need to export the path module so we can effectively test it\n\t    Twig.exports.path = Twig.path;\n\n\t    //Export our filters.\n\t    //Resolves #307\n\t    Twig.exports.filters = Twig.filters;\n\n\t    return Twig;\n\t};\n\n\n/***/ }\n/******/ ])\n});\n;\n/* WEBPACK VAR INJECTION */}.call(exports, \"/\"))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3R3aWcvdHdpZy5qcz9iNGE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSwwRUFBMEUsTUFBTSxnQ0FBc0IsRUFBRSxZQUFZLEVBQUU7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE1BQU0sc0JBQXNCLEVBQUUsWUFBWSxFQUFFO0FBQ3ZIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osU0FBUztBQUNUO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFNBQVM7QUFDVDtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUUsd0JBQXdCLG1CQUFtQix5RUFBeUUsR0FBRyxFQUFFO0FBQzlMO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZCQUE2Qix3Q0FBd0M7QUFDM0csOERBQThEO0FBQzlEO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvRUFBb0UsRUFBRTtBQUM3Rjs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDViw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esa0RBQWtELEtBQUs7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FB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QUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxxR0FBcUcsbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFM1E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEscUdBQXFHLG1CQUFtQixFQUFFLG1CQUFtQiw4SEFBOEg7O0FBRTNRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsR0FBRzs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUksNEJBQTRCLElBQUksNEJBQTRCLElBQUksZ0JBQWdCLElBQUksT0FBTyxFQUFFLFNBQVMsRUFBRTtBQUNoSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEVBQUUsT0FB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxrQ0FBa0MsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDLGVBQWU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgoZnVuY3Rpb24gd2VicGFja0xvYWRPcHRpb25hbEV4dGVybmFsTW9kdWxlKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZShcImZzXCIpOyB9IGNhdGNoKGUpIHt9IH0oKSksIHJlcXVpcmUoXCJwYXRoXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImZzXCIsIFwicGF0aFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJUd2lnXCJdID0gZmFjdG9yeSgoZnVuY3Rpb24gd2VicGFja0xvYWRPcHRpb25hbEV4dGVybmFsTW9kdWxlKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZShcImZzXCIpOyB9IGNhdGNoKGUpIHt9IH0oKSksIHJlcXVpcmUoXCJwYXRoXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJUd2lnXCJdID0gZmFjdG9yeShyb290W1wiZnNcIl0sIHJvb3RbXCJwYXRoXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yMF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHQgKiBUd2lnLmpzXG5cdCAqXG5cdCAqIEBjb3B5cmlnaHQgMjAxMS0yMDE2IEpvaG4gUm9lcGtlIGFuZCB0aGUgVHdpZy5qcyBDb250cmlidXRvcnNcblx0ICogQGxpY2Vuc2UgICBBdmFpbGFibGUgdW5kZXIgdGhlIEJTRCAyLUNsYXVzZSBMaWNlbnNlXG5cdCAqIEBsaW5rICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3R3aWdqcy90d2lnLmpzXG5cdCAqL1xuXG5cdHZhciBUd2lnID0ge1xuXHQgICAgVkVSU0lPTjogJzAuMTAuMidcblx0fTtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKFR3aWcpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKFR3aWcpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKFR3aWcpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKFR3aWcpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKFR3aWcpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKFR3aWcpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KShUd2lnKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxOCkoVHdpZyk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oMjEpKFR3aWcpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKShUd2lnKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXygyMykoVHdpZyk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oMjQpKFR3aWcpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KShUd2lnKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXygyNikoVHdpZyk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oMjcpKFR3aWcpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gVHdpZy5leHBvcnRzO1xuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyAjIyB0d2lnLmNvcmUuanNcblx0Ly9cblx0Ly8gVGhpcyBmaWxlIGhhbmRsZXMgdGVtcGxhdGUgbGV2ZWwgdG9rZW5pemluZywgY29tcGlsaW5nIGFuZCBwYXJzaW5nLlxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG5cdCAgICBcInVzZSBzdHJpY3RcIjtcblxuXHQgICAgVHdpZy50cmFjZSA9IGZhbHNlO1xuXHQgICAgVHdpZy5kZWJ1ZyA9IGZhbHNlO1xuXG5cdCAgICAvLyBEZWZhdWx0IGNhY2hpbmcgdG8gdHJ1ZSBmb3IgdGhlIGltcHJvdmVkIHBlcmZvcm1hbmNlIGl0IG9mZmVyc1xuXHQgICAgVHdpZy5jYWNoZSA9IHRydWU7XG5cblx0ICAgIFR3aWcubm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0ICAgIFR3aWcucGxhY2Vob2xkZXJzID0ge1xuXHQgICAgICAgIHBhcmVudDogXCJ7e3xQQVJFTlR8fX1cIlxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBGYWxsYmFjayBmb3IgQXJyYXkuaW5kZXhPZiBmb3IgSUU4IGV0IGFsXG5cdCAgICAgKi9cblx0ICAgIFR3aWcuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnIsIHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyApIHtcblx0ICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwiaW5kZXhPZlwiKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gYXJyLmluZGV4T2Yoc2VhcmNoRWxlbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChhcnIgPT09IHZvaWQgMCB8fCBhcnIgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdCA9IE9iamVjdChhcnIpO1xuXHQgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblx0ICAgICAgICBpZiAobGVuID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG4gPSAwO1xuXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBuID0gTnVtYmVyKGFyZ3VtZW50c1sxXSk7XG5cdCAgICAgICAgICAgIGlmIChuICE9PSBuKSB7IC8vIHNob3J0Y3V0IGZvciB2ZXJpZnlpbmcgaWYgaXQncyBOYU5cblx0ICAgICAgICAgICAgICAgIG4gPSAwO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gSW5maW5pdHkgJiYgbiAhPT0gLUluZmluaXR5KSB7XG5cdCAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChuID49IGxlbikge1xuXHQgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImluZGV4T2Ygbm90IGZvdW5kMSBcIiwgSlNPTi5zdHJpbmdpZnkoc2VhcmNoRWxlbWVudCksIEpTT04uc3RyaW5naWZ5KGFycikpO1xuXHQgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcblx0ICAgICAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XG5cdCAgICAgICAgICAgIGlmIChrIGluIHQgJiYgdFtrXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGFyciA9PSBzZWFyY2hFbGVtZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBjb25zb2xlLmxvZyhcImluZGV4T2Ygbm90IGZvdW5kMiBcIiwgSlNPTi5zdHJpbmdpZnkoc2VhcmNoRWxlbWVudCksIEpTT04uc3RyaW5naWZ5KGFycikpO1xuXG5cdCAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgfVxuXG5cdCAgICBUd2lnLmZvckVhY2ggPSBmdW5jdGlvbiAoYXJyLCBjYWxsYmFjaywgdGhpc0FyZykge1xuXHQgICAgICAgIGlmIChBcnJheS5wcm90b3R5cGUuZm9yRWFjaCApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgVCwgaztcblxuXHQgICAgICAgIGlmICggYXJyID09IG51bGwgKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCBcIiB0aGlzIGlzIG51bGwgb3Igbm90IGRlZmluZWRcIiApO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIDEuIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCBwYXNzaW5nIHRoZSB8dGhpc3wgdmFsdWUgYXMgdGhlIGFyZ3VtZW50LlxuXHQgICAgICAgIHZhciBPID0gT2JqZWN0KGFycik7XG5cblx0ICAgICAgICAvLyAyLiBMZXQgbGVuVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCB0aGUgYXJndW1lbnQgXCJsZW5ndGhcIi5cblx0ICAgICAgICAvLyAzLiBMZXQgbGVuIGJlIFRvVWludDMyKGxlblZhbHVlKS5cblx0ICAgICAgICB2YXIgbGVuID0gTy5sZW5ndGggPj4+IDA7IC8vIEhhY2sgdG8gY29udmVydCBPLmxlbmd0aCB0byBhIFVJbnQzMlxuXG5cdCAgICAgICAgLy8gNC4gSWYgSXNDYWxsYWJsZShjYWxsYmFjaykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cblx0ICAgICAgICAvLyBTZWU6IGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuMTFcblx0ICAgICAgICBpZiAoIHt9LnRvU3RyaW5nLmNhbGwoY2FsbGJhY2spICE9IFwiW29iamVjdCBGdW5jdGlvbl1cIiApIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIGNhbGxiYWNrICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIiApO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIDUuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cblx0ICAgICAgICBpZiAoIHRoaXNBcmcgKSB7XG5cdCAgICAgICAgICBUID0gdGhpc0FyZztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyA2LiBMZXQgayBiZSAwXG5cdCAgICAgICAgayA9IDA7XG5cblx0ICAgICAgICAvLyA3LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW5cblx0ICAgICAgICB3aGlsZSggayA8IGxlbiApIHtcblxuXHQgICAgICAgICAgdmFyIGtWYWx1ZTtcblxuXHQgICAgICAgICAgLy8gYS4gTGV0IFBrIGJlIFRvU3RyaW5nKGspLlxuXHQgICAgICAgICAgLy8gICBUaGlzIGlzIGltcGxpY2l0IGZvciBMSFMgb3BlcmFuZHMgb2YgdGhlIGluIG9wZXJhdG9yXG5cdCAgICAgICAgICAvLyBiLiBMZXQga1ByZXNlbnQgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBIYXNQcm9wZXJ0eSBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuXHQgICAgICAgICAgLy8gICBUaGlzIHN0ZXAgY2FuIGJlIGNvbWJpbmVkIHdpdGggY1xuXHQgICAgICAgICAgLy8gYy4gSWYga1ByZXNlbnQgaXMgdHJ1ZSwgdGhlblxuXHQgICAgICAgICAgaWYgKCBrIGluIE8gKSB7XG5cblx0ICAgICAgICAgICAgLy8gaS4gTGV0IGtWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuXHQgICAgICAgICAgICBrVmFsdWUgPSBPWyBrIF07XG5cblx0ICAgICAgICAgICAgLy8gaWkuIENhbGwgdGhlIENhbGwgaW50ZXJuYWwgbWV0aG9kIG9mIGNhbGxiYWNrIHdpdGggVCBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcblx0ICAgICAgICAgICAgLy8gYXJndW1lbnQgbGlzdCBjb250YWluaW5nIGtWYWx1ZSwgaywgYW5kIE8uXG5cdCAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoIFQsIGtWYWx1ZSwgaywgTyApO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgLy8gZC4gSW5jcmVhc2UgayBieSAxLlxuXHQgICAgICAgICAgaysrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyA4LiByZXR1cm4gdW5kZWZpbmVkXG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLm1lcmdlID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UsIG9ubHlDaGFuZ2VkKSB7XG5cdCAgICAgICAgVHdpZy5mb3JFYWNoKE9iamVjdC5rZXlzKHNvdXJjZSksIGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgaWYgKG9ubHlDaGFuZ2VkICYmICEoa2V5IGluIHRhcmdldCkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHJldHVybiB0YXJnZXQ7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEV4Y2VwdGlvbiB0aHJvd24gYnkgdHdpZy5qcy5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5FcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGZpbGUpIHtcblx0ICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdCAgICAgICB0aGlzLm5hbWUgPSBcIlR3aWdFeGNlcHRpb25cIjtcblx0ICAgICAgIHRoaXMudHlwZSA9IFwiVHdpZ0V4Y2VwdGlvblwiO1xuXHQgICAgICAgdGhpcy5maWxlID0gZmlsZTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBUd2lnIGVycm9yLlxuXHQgICAgICovXG5cdCAgICBUd2lnLkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG5cblx0ICAgICAgICByZXR1cm4gb3V0cHV0O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBXcmFwcGVyIGZvciBsb2dnaW5nIHRvIHRoZSBjb25zb2xlLlxuXHQgICAgICovXG5cdCAgICBUd2lnLmxvZyA9IHtcblx0ICAgICAgICB0cmFjZTogZnVuY3Rpb24oKSB7aWYgKFR3aWcudHJhY2UgJiYgY29uc29sZSkge2NvbnNvbGUubG9nKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO319LFxuXHQgICAgICAgIGRlYnVnOiBmdW5jdGlvbigpIHtpZiAoVHdpZy5kZWJ1ZyAmJiBjb25zb2xlKSB7Y29uc29sZS5sb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7fX1cblx0ICAgIH07XG5cblxuXHQgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgICAgIFR3aWcubG9nLmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICAgICAgICBUd2lnLmxvZy5lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgVHdpZy5sb2cuZXJyb3IgPSBmdW5jdGlvbigpe307XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogV3JhcHBlciBmb3IgY2hpbGQgY29udGV4dCBvYmplY3RzIGluIFR3aWcuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVmFsdWVzIHRvIGluaXRpYWxpemUgdGhlIGNvbnRleHQgd2l0aC5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5DaGlsZENvbnRleHQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdCAgICAgICAgdmFyIENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIENoaWxkQ29udGV4dCgpIHt9O1xuXHQgICAgICAgIENoaWxkQ29udGV4dC5wcm90b3R5cGUgPSBjb250ZXh0O1xuXHQgICAgICAgIHJldHVybiBuZXcgQ2hpbGRDb250ZXh0KCk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIENvbnRhaW5lciBmb3IgbWV0aG9kcyByZWxhdGVkIHRvIGhhbmRsaW5nIGhpZ2ggbGV2ZWwgdGVtcGxhdGUgdG9rZW5zXG5cdCAgICAgKiAgICAgIChmb3IgZXhhbXBsZToge3sgZXhwcmVzc2lvbiB9fSwgeyUgbG9naWMgJX0sIHsjIGNvbW1lbnQgI30sIHJhdyBkYXRhKVxuXHQgICAgICovXG5cdCAgICBUd2lnLnRva2VuID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogVG9rZW4gdHlwZXMuXG5cdCAgICAgKi9cblx0ICAgIFR3aWcudG9rZW4udHlwZSA9IHtcblx0ICAgICAgICBvdXRwdXQ6ICAgICAgICAgICAgICAgICAnb3V0cHV0Jyxcblx0ICAgICAgICBsb2dpYzogICAgICAgICAgICAgICAgICAnbG9naWMnLFxuXHQgICAgICAgIGNvbW1lbnQ6ICAgICAgICAgICAgICAgICdjb21tZW50Jyxcblx0ICAgICAgICByYXc6ICAgICAgICAgICAgICAgICAgICAncmF3Jyxcblx0ICAgICAgICBvdXRwdXRfd2hpdGVzcGFjZV9wcmU6ICAnb3V0cHV0X3doaXRlc3BhY2VfcHJlJyxcblx0ICAgICAgICBvdXRwdXRfd2hpdGVzcGFjZV9wb3N0OiAnb3V0cHV0X3doaXRlc3BhY2VfcG9zdCcsXG5cdCAgICAgICAgb3V0cHV0X3doaXRlc3BhY2VfYm90aDogJ291dHB1dF93aGl0ZXNwYWNlX2JvdGgnLFxuXHQgICAgICAgIGxvZ2ljX3doaXRlc3BhY2VfcHJlOiAgICdsb2dpY193aGl0ZXNwYWNlX3ByZScsXG5cdCAgICAgICAgbG9naWNfd2hpdGVzcGFjZV9wb3N0OiAgJ2xvZ2ljX3doaXRlc3BhY2VfcG9zdCcsXG5cdCAgICAgICAgbG9naWNfd2hpdGVzcGFjZV9ib3RoOiAgJ2xvZ2ljX3doaXRlc3BhY2VfYm90aCdcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVG9rZW4gc3ludGF4IGRlZmluaXRpb25zLlxuXHQgICAgICovXG5cdCAgICBUd2lnLnRva2VuLmRlZmluaXRpb25zID0gW1xuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLnJhdyxcblx0ICAgICAgICAgICAgb3BlbjogJ3slIHJhdyAlfScsXG5cdCAgICAgICAgICAgIGNsb3NlOiAneyUgZW5kcmF3ICV9J1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLnRva2VuLnR5cGUucmF3LFxuXHQgICAgICAgICAgICBvcGVuOiAneyUgdmVyYmF0aW0gJX0nLFxuXHQgICAgICAgICAgICBjbG9zZTogJ3slIGVuZHZlcmJhdGltICV9J1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy8gKldoaXRlc3BhY2UgdHlwZSB0b2tlbnMqXG5cdCAgICAgICAgLy9cblx0ICAgICAgICAvLyBUaGVzZSB0eXBpY2FsbHkgdGFrZSB0aGUgZm9ybSBge3stIGV4cHJlc3Npb24gLX19YCBvciBge3stIGV4cHJlc3Npb24gfX1gIG9yIGB7eyBleHByZXNzaW9uIC19fWAuXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLnRva2VuLnR5cGUub3V0cHV0X3doaXRlc3BhY2VfcHJlLFxuXHQgICAgICAgICAgICBvcGVuOiAne3stJyxcblx0ICAgICAgICAgICAgY2xvc2U6ICd9fSdcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLm91dHB1dF93aGl0ZXNwYWNlX3Bvc3QsXG5cdCAgICAgICAgICAgIG9wZW46ICd7eycsXG5cdCAgICAgICAgICAgIGNsb3NlOiAnLX19J1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLnRva2VuLnR5cGUub3V0cHV0X3doaXRlc3BhY2VfYm90aCxcblx0ICAgICAgICAgICAgb3BlbjogJ3t7LScsXG5cdCAgICAgICAgICAgIGNsb3NlOiAnLX19J1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLnRva2VuLnR5cGUubG9naWNfd2hpdGVzcGFjZV9wcmUsXG5cdCAgICAgICAgICAgIG9wZW46ICd7JS0nLFxuXHQgICAgICAgICAgICBjbG9zZTogJyV9J1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLnRva2VuLnR5cGUubG9naWNfd2hpdGVzcGFjZV9wb3N0LFxuXHQgICAgICAgICAgICBvcGVuOiAneyUnLFxuXHQgICAgICAgICAgICBjbG9zZTogJy0lfSdcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLmxvZ2ljX3doaXRlc3BhY2VfYm90aCxcblx0ICAgICAgICAgICAgb3BlbjogJ3slLScsXG5cdCAgICAgICAgICAgIGNsb3NlOiAnLSV9J1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy8gKk91dHB1dCB0eXBlIHRva2Vucypcblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vIFRoZXNlIHR5cGljYWxseSB0YWtlIHRoZSBmb3JtIGB7eyBleHByZXNzaW9uIH19YC5cblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcudG9rZW4udHlwZS5vdXRwdXQsXG5cdCAgICAgICAgICAgIG9wZW46ICd7eycsXG5cdCAgICAgICAgICAgIGNsb3NlOiAnfX0nXG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvLyAqTG9naWMgdHlwZSB0b2tlbnMqXG5cdCAgICAgICAgLy9cblx0ICAgICAgICAvLyBUaGVzZSB0eXBpY2FsbHkgdGFrZSBhIGZvcm0gbGlrZSBgeyUgaWYgZXhwcmVzc2lvbiAlfWAgb3IgYHslIGVuZGlmICV9YFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLmxvZ2ljLFxuXHQgICAgICAgICAgICBvcGVuOiAneyUnLFxuXHQgICAgICAgICAgICBjbG9zZTogJyV9J1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy8gKkNvbW1lbnQgdHlwZSB0b2tlbnMqXG5cdCAgICAgICAgLy9cblx0ICAgICAgICAvLyBUaGVzZSB0YWtlIHRoZSBmb3JtIGB7IyBhbnl0aGluZyAjfWBcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcudG9rZW4udHlwZS5jb21tZW50LFxuXHQgICAgICAgICAgICBvcGVuOiAneyMnLFxuXHQgICAgICAgICAgICBjbG9zZTogJyN9J1xuXHQgICAgICAgIH1cblx0ICAgIF07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiBXaGF0IGNoYXJhY3RlcnMgc3RhcnQgXCJzdHJpbmdzXCIgaW4gdG9rZW4gZGVmaW5pdGlvbnMuIFdlIG5lZWQgdGhpcyB0byBpZ25vcmUgdG9rZW4gY2xvc2Vcblx0ICAgICAqIHN0cmluZ3MgaW5zaWRlIGFuIGV4cHJlc3Npb24uXG5cdCAgICAgKi9cblx0ICAgIFR3aWcudG9rZW4uc3RyaW5ncyA9IFsnXCInLCBcIidcIl07XG5cblx0ICAgIFR3aWcudG9rZW4uZmluZFN0YXJ0ID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG5cdCAgICAgICAgdmFyIG91dHB1dCA9IHtcblx0ICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgY2xvc2VfcG9zaXRpb246IG51bGwsXG5cdCAgICAgICAgICAgICAgICBkZWY6IG51bGxcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgdG9rZW5fdGVtcGxhdGUsXG5cdCAgICAgICAgICAgIGZpcnN0X2tleV9wb3NpdGlvbixcblx0ICAgICAgICAgICAgY2xvc2Vfa2V5X3Bvc2l0aW9uO1xuXG5cdCAgICAgICAgZm9yIChpPTA7aTxUd2lnLnRva2VuLmRlZmluaXRpb25zLmxlbmd0aDtpKyspIHtcblx0ICAgICAgICAgICAgdG9rZW5fdGVtcGxhdGUgPSBUd2lnLnRva2VuLmRlZmluaXRpb25zW2ldO1xuXHQgICAgICAgICAgICBmaXJzdF9rZXlfcG9zaXRpb24gPSB0ZW1wbGF0ZS5pbmRleE9mKHRva2VuX3RlbXBsYXRlLm9wZW4pO1xuXHQgICAgICAgICAgICBjbG9zZV9rZXlfcG9zaXRpb24gPSB0ZW1wbGF0ZS5pbmRleE9mKHRva2VuX3RlbXBsYXRlLmNsb3NlKTtcblxuXHQgICAgICAgICAgICBUd2lnLmxvZy50cmFjZShcIlR3aWcudG9rZW4uZmluZFN0YXJ0OiBcIiwgXCJTZWFyY2hpbmcgZm9yIFwiLCB0b2tlbl90ZW1wbGF0ZS5vcGVuLCBcIiBmb3VuZCBhdCBcIiwgZmlyc3Rfa2V5X3Bvc2l0aW9uKTtcblxuXHQgICAgICAgICAgICAvL1NwZWNpYWwgaGFuZGxpbmcgZm9yIG1pc21hdGNoZWQgdG9rZW5zXG5cdCAgICAgICAgICAgIGlmIChmaXJzdF9rZXlfcG9zaXRpb24gPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgLy9UaGlzIHRva2VuIG1hdGNoZXMgdGhlIHRlbXBsYXRlXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW5fdGVtcGxhdGUub3Blbi5sZW5ndGggIT09IHRva2VuX3RlbXBsYXRlLmNsb3NlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vVGhpcyB0b2tlbiBoYXMgbWlzbWF0Y2hlZCBjbG9zaW5nIGFuZCBvcGVuaW5nIHRhZ3Ncblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2Vfa2V5X3Bvc2l0aW9uIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL1RoaXMgdG9rZW4ncyBjbG9zaW5nIHRhZyBkb2VzIG5vdCBtYXRjaCB0aGUgdGVtcGxhdGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIERvZXMgdGhpcyB0b2tlbiBvY2N1ciBiZWZvcmUgYW55IG90aGVyIHR5cGVzP1xuXHQgICAgICAgICAgICBpZiAoZmlyc3Rfa2V5X3Bvc2l0aW9uID49IDAgJiYgKG91dHB1dC5wb3NpdGlvbiA9PT0gbnVsbCB8fCBmaXJzdF9rZXlfcG9zaXRpb24gPCBvdXRwdXQucG9zaXRpb24pKSB7XG5cdCAgICAgICAgICAgICAgICBvdXRwdXQucG9zaXRpb24gPSBmaXJzdF9rZXlfcG9zaXRpb247XG5cdCAgICAgICAgICAgICAgICBvdXRwdXQuZGVmID0gdG9rZW5fdGVtcGxhdGU7XG5cdCAgICAgICAgICAgICAgICBvdXRwdXQuY2xvc2VfcG9zaXRpb24gPSBjbG9zZV9rZXlfcG9zaXRpb247XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3Rfa2V5X3Bvc2l0aW9uID49IDAgJiYgb3V0cHV0LnBvc2l0aW9uICE9PSBudWxsICYmIGZpcnN0X2tleV9wb3NpdGlvbiA9PT0gb3V0cHV0LnBvc2l0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAvKlRoaXMgdG9rZW4gZXhhY3RseSBtYXRjaGVzIGFub3RoZXIgdG9rZW4sXG5cdCAgICAgICAgICAgICAgICBncmVlZGlseSBtYXRjaCB0byBjaGVjayBpZiB0aGlzIHRva2VuIGhhcyBhIGdyZWF0ZXIgc3BlY2lmaWNpdHkqL1xuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuX3RlbXBsYXRlLm9wZW4ubGVuZ3RoID4gb3V0cHV0LmRlZi5vcGVuLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vVGhpcyB0b2tlbidzIG9wZW5pbmcgdGFnIGlzIG1vcmUgc3BlY2lmaWMgdGhhbiB0aGUgcHJldmlvdXMgbWF0Y2hcblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQucG9zaXRpb24gPSBmaXJzdF9rZXlfcG9zaXRpb247XG5cdCAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmRlZiA9IHRva2VuX3RlbXBsYXRlO1xuXHQgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jbG9zZV9wb3NpdGlvbiA9IGNsb3NlX2tleV9wb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5fdGVtcGxhdGUub3Blbi5sZW5ndGggPT09IG91dHB1dC5kZWYub3Blbi5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5fdGVtcGxhdGUuY2xvc2UubGVuZ3RoID4gb3V0cHV0LmRlZi5jbG9zZS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGlzIHRva2VuJ3Mgb3BlbmluZyB0YWcgaXMgYXMgc3BlY2lmaWMgYXMgdGhlIHByZXZpb3VzIG1hdGNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL2J1dCB0aGUgY2xvc2luZyB0YWcgaGFzIGdyZWF0ZXIgc3BlY2lmaWNpdHlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlX2tleV9wb3NpdGlvbiA+PSAwICYmIGNsb3NlX2tleV9wb3NpdGlvbiA8IG91dHB1dC5jbG9zZV9wb3NpdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGlzIHRva2VuJ3MgY2xvc2luZyB0YWcgZXhpc3RzIGluIHRoZSB0ZW1wbGF0ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYW5kIGl0IG9jY3VycyBzb29uZXIgdGhhbiB0aGUgcHJldmlvdXMgbWF0Y2hcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wb3NpdGlvbiA9IGZpcnN0X2tleV9wb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5kZWYgPSB0b2tlbl90ZW1wbGF0ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5jbG9zZV9wb3NpdGlvbiA9IGNsb3NlX2tleV9wb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xvc2Vfa2V5X3Bvc2l0aW9uID49IDAgJiYgY2xvc2Vfa2V5X3Bvc2l0aW9uIDwgb3V0cHV0LmNsb3NlX3Bvc2l0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhpcyB0b2tlbidzIGNsb3NpbmcgdGFnIGlzIG5vdCBtb3JlIHNwZWNpZmljIHRoYW4gdGhlIHByZXZpb3VzIG1hdGNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL2J1dCBpdCBvY2N1cnMgc29vbmVyIHRoYW4gdGhlIHByZXZpb3VzIG1hdGNoXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wb3NpdGlvbiA9IGZpcnN0X2tleV9wb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmRlZiA9IHRva2VuX3RlbXBsYXRlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY2xvc2VfcG9zaXRpb24gPSBjbG9zZV9rZXlfcG9zaXRpb247XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZGVsZXRlIG91dHB1dFsnY2xvc2VfcG9zaXRpb24nXTtcblxuXHQgICAgICAgIHJldHVybiBvdXRwdXQ7XG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLnRva2VuLmZpbmRFbmQgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHRva2VuX2RlZiwgc3RhcnQpIHtcblx0ICAgICAgICB2YXIgZW5kID0gbnVsbCxcblx0ICAgICAgICAgICAgZm91bmQgPSBmYWxzZSxcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gMCxcblxuXHQgICAgICAgICAgICAvLyBTdHJpbmcgcG9zaXRpb24gdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHN0cl9wb3MgPSBudWxsLFxuXHQgICAgICAgICAgICBzdHJfZm91bmQgPSBudWxsLFxuXHQgICAgICAgICAgICBwb3MgPSBudWxsLFxuXHQgICAgICAgICAgICBlbmRfb2Zmc2V0ID0gbnVsbCxcblx0ICAgICAgICAgICAgdGhpc19zdHJfcG9zID0gbnVsbCxcblx0ICAgICAgICAgICAgZW5kX3N0cl9wb3MgPSBudWxsLFxuXG5cdCAgICAgICAgICAgIC8vIEZvciBsb29wIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICBpLFxuXHQgICAgICAgICAgICBsO1xuXG5cdCAgICAgICAgd2hpbGUgKCFmb3VuZCkge1xuXHQgICAgICAgICAgICBzdHJfcG9zID0gbnVsbDtcblx0ICAgICAgICAgICAgc3RyX2ZvdW5kID0gbnVsbDtcblx0ICAgICAgICAgICAgcG9zID0gdGVtcGxhdGUuaW5kZXhPZih0b2tlbl9kZWYuY2xvc2UsIG9mZnNldCk7XG5cblx0ICAgICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBlbmQgPSBwb3M7XG5cdCAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb25cblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiVW5hYmxlIHRvIGZpbmQgY2xvc2luZyBicmFja2V0ICdcIiArIHRva2VuX2RlZi5jbG9zZSArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInXCIgKyBcIiBvcGVuZWQgbmVhciB0ZW1wbGF0ZSBwb3NpdGlvbiBcIiArIHN0YXJ0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElnbm9yZSBxdW90ZXMgd2l0aGluIGNvbW1lbnRzOyBqdXN0IGxvb2sgZm9yIHRoZSBuZXh0IGNvbW1lbnQgY2xvc2Ugc2VxdWVuY2UsXG5cdCAgICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBjb21lcyBiZWZvcmUgaXQuIGh0dHBzOi8vZ2l0aHViLmNvbS9qdXN0am9obi90d2lnLmpzL2lzc3Vlcy85NVxuXHQgICAgICAgICAgICBpZiAodG9rZW5fZGVmLnR5cGUgPT09IFR3aWcudG9rZW4udHlwZS5jb21tZW50KSB7XG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gSWdub3JlIHF1b3RlcyB3aXRoaW4gcmF3IHRhZ1xuXHQgICAgICAgICAgICAvLyBGaXhlcyAjMjgzXG5cdCAgICAgICAgICAgIGlmICh0b2tlbl9kZWYudHlwZSA9PT0gVHdpZy50b2tlbi50eXBlLnJhdykge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBsID0gVHdpZy50b2tlbi5zdHJpbmdzLmxlbmd0aDtcblx0ICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgdGhpc19zdHJfcG9zID0gdGVtcGxhdGUuaW5kZXhPZihUd2lnLnRva2VuLnN0cmluZ3NbaV0sIG9mZnNldCk7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzX3N0cl9wb3MgPiAwICYmIHRoaXNfc3RyX3BvcyA8IHBvcyAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAoc3RyX3BvcyA9PT0gbnVsbCB8fCB0aGlzX3N0cl9wb3MgPCBzdHJfcG9zKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0cl9wb3MgPSB0aGlzX3N0cl9wb3M7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RyX2ZvdW5kID0gVHdpZy50b2tlbi5zdHJpbmdzW2ldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBzdHJpbmcgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHRva2VuLCBub3cgZmluZCB0aGUgc3RyaW5nJ3MgZW5kIGFuZCBzZXQgdGhlIHNlYXJjaCBvZmZzZXQgdG8gaXRcblx0ICAgICAgICAgICAgaWYgKHN0cl9wb3MgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGVuZF9vZmZzZXQgPSBzdHJfcG9zICsgMTtcblx0ICAgICAgICAgICAgICAgIGVuZCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmRfc3RyX3BvcyA9IHRlbXBsYXRlLmluZGV4T2Yoc3RyX2ZvdW5kLCBlbmRfb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZW5kX3N0cl9wb3MgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiVW5jbG9zZWQgc3RyaW5nIGluIHRlbXBsYXRlXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlc2NhcGVkIHF1b3Rlc1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZS5zdWJzdHIoZW5kX3N0cl9wb3MgLSAxLCAxKSAhPT0gXCJcXFxcXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZW5kX3N0cl9wb3MgKyAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmRfb2Zmc2V0ID0gZW5kX3N0cl9wb3MgKyAxO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZW5kO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb252ZXJ0IGEgdGVtcGxhdGUgaW50byBoaWdoLWxldmVsIHRva2Vucy5cblx0ICAgICAqL1xuXHQgICAgVHdpZy50b2tlbml6ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuXHQgICAgICAgIHZhciB0b2tlbnMgPSBbXSxcblx0ICAgICAgICAgICAgLy8gQW4gb2Zmc2V0IGZvciByZXBvcnRpbmcgZXJyb3JzIGxvY2F0aW9ucyBpbiB0aGUgdGVtcGxhdGUuXG5cdCAgICAgICAgICAgIGVycm9yX29mZnNldCA9IDAsXG5cblx0ICAgICAgICAgICAgLy8gVGhlIHN0YXJ0IGFuZCB0eXBlIG9mIHRoZSBmaXJzdCB0b2tlbiBmb3VuZCBpbiB0aGUgdGVtcGxhdGUuXG5cdCAgICAgICAgICAgIGZvdW5kX3Rva2VuID0gbnVsbCxcblx0ICAgICAgICAgICAgLy8gVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgbWF0Y2hlZCB0b2tlbi5cblx0ICAgICAgICAgICAgZW5kID0gbnVsbDtcblxuXHQgICAgICAgIHdoaWxlICh0ZW1wbGF0ZS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VyYW5jZSBvZiBhbnkgdG9rZW4gdHlwZSBpbiB0aGUgdGVtcGxhdGVcblx0ICAgICAgICAgICAgZm91bmRfdG9rZW4gPSBUd2lnLnRva2VuLmZpbmRTdGFydCh0ZW1wbGF0ZSk7XG5cblx0ICAgICAgICAgICAgVHdpZy5sb2cudHJhY2UoXCJUd2lnLnRva2VuaXplOiBcIiwgXCJGb3VuZCB0b2tlbjogXCIsIGZvdW5kX3Rva2VuKTtcblxuXHQgICAgICAgICAgICBpZiAoZm91bmRfdG9rZW4ucG9zaXRpb24gIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEFkZCBhIHJhdyB0eXBlIHRva2VuIGZvciBhbnl0aGluZyBiZWZvcmUgdGhlIHN0YXJ0IG9mIHRoZSB0b2tlblxuXHQgICAgICAgICAgICAgICAgaWYgKGZvdW5kX3Rva2VuLnBvc2l0aW9uID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLnJhdyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRlbXBsYXRlLnN1YnN0cmluZygwLCBmb3VuZF90b2tlbi5wb3NpdGlvbilcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuc3Vic3RyKGZvdW5kX3Rva2VuLnBvc2l0aW9uICsgZm91bmRfdG9rZW4uZGVmLm9wZW4ubGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgIGVycm9yX29mZnNldCArPSBmb3VuZF90b2tlbi5wb3NpdGlvbiArIGZvdW5kX3Rva2VuLmRlZi5vcGVuLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZW5kIG9mIHRoZSB0b2tlblxuXHQgICAgICAgICAgICAgICAgZW5kID0gVHdpZy50b2tlbi5maW5kRW5kKHRlbXBsYXRlLCBmb3VuZF90b2tlbi5kZWYsIGVycm9yX29mZnNldCk7XG5cblx0ICAgICAgICAgICAgICAgIFR3aWcubG9nLnRyYWNlKFwiVHdpZy50b2tlbml6ZTogXCIsIFwiVG9rZW4gZW5kcyBhdCBcIiwgZW5kKTtcblxuXHQgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6ICBmb3VuZF90b2tlbi5kZWYudHlwZSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGVtcGxhdGUuc3Vic3RyaW5nKDAsIGVuZCkudHJpbSgpXG5cdCAgICAgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlLnN1YnN0ciggZW5kICsgZm91bmRfdG9rZW4uZGVmLmNsb3NlLmxlbmd0aCwgMSApID09PSBcIlxcblwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmb3VuZF90b2tlbi5kZWYudHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibG9naWNfd2hpdGVzcGFjZV9wcmVcIjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxvZ2ljX3doaXRlc3BhY2VfcG9zdFwiOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibG9naWNfd2hpdGVzcGFjZV9ib3RoXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsb2dpY1wiOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV3bGluZXMgZGlyZWN0bHkgYWZ0ZXIgbG9naWMgdG9rZW5zIGFyZSBpZ25vcmVkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgKz0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5zdWJzdHIoZW5kICsgZm91bmRfdG9rZW4uZGVmLmNsb3NlLmxlbmd0aCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCB0aGUgcG9zaXRpb24gaW4gdGhlIHRlbXBsYXRlXG5cdCAgICAgICAgICAgICAgICBlcnJvcl9vZmZzZXQgKz0gZW5kICsgZm91bmRfdG9rZW4uZGVmLmNsb3NlLmxlbmd0aDtcblxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gTm8gbW9yZSB0b2tlbnMgLT4gYWRkIHRoZSByZXN0IG9mIHRoZSB0ZW1wbGF0ZSBhcyBhIHJhdy10eXBlIHRva2VuXG5cdCAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLnJhdyxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGVtcGxhdGVcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSAnJztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB0b2tlbnM7XG5cdCAgICB9O1xuXG5cblx0ICAgIFR3aWcuY29tcGlsZSA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcblx0ICAgICAgICB0cnkge1xuXG5cdCAgICAgICAgICAgIC8vIE91dHB1dCBhbmQgaW50ZXJtZWRpYXRlIHN0YWNrc1xuXHQgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG5cdCAgICAgICAgICAgICAgICBzdGFjayA9IFtdLFxuXHQgICAgICAgICAgICAgICAgLy8gVGhlIHRva2VucyBiZXR3ZWVuIG9wZW4gYW5kIGNsb3NlIHRhZ3Ncblx0ICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZV9vdXRwdXQgPSBbXSxcblxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBudWxsLFxuXHQgICAgICAgICAgICAgICAgbG9naWNfdG9rZW4gPSBudWxsLFxuXHQgICAgICAgICAgICAgICAgdW5jbG9zZWRfdG9rZW4gPSBudWxsLFxuXHQgICAgICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IHByZXZpb3VzIHRva2VuLlxuXHQgICAgICAgICAgICAgICAgcHJldl90b2tlbiA9IG51bGwsXG5cdCAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgcHJldmlvdXMgb3V0cHV0LlxuXHQgICAgICAgICAgICAgICAgcHJldl9vdXRwdXQgPSBudWxsLFxuXHQgICAgICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IHByZXZpb3VzIGludGVybWVkaWF0ZSBvdXRwdXQuXG5cdCAgICAgICAgICAgICAgICBwcmV2X2ludGVybWVkaWF0ZV9vdXRwdXQgPSBudWxsLFxuXHQgICAgICAgICAgICAgICAgLy8gVGhlIHByZXZpb3VzIHRva2VuJ3MgdGVtcGxhdGVcblx0ICAgICAgICAgICAgICAgIHByZXZfdGVtcGxhdGUgPSBudWxsLFxuXHQgICAgICAgICAgICAgICAgLy8gVG9rZW4gbG9va2FoZWFkXG5cdCAgICAgICAgICAgICAgICBuZXh0X3Rva2VuID0gbnVsbCxcblx0ICAgICAgICAgICAgICAgIC8vIFRoZSBvdXRwdXQgdG9rZW5cblx0ICAgICAgICAgICAgICAgIHRva19vdXRwdXQgPSBudWxsLFxuXG5cdCAgICAgICAgICAgICAgICAvLyBMb2dpYyBUb2tlbiB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgIHR5cGUgPSBudWxsLFxuXHQgICAgICAgICAgICAgICAgb3BlbiA9IG51bGwsXG5cdCAgICAgICAgICAgICAgICBuZXh0ID0gbnVsbDtcblxuXHQgICAgICAgICAgICB2YXIgY29tcGlsZV9vdXRwdXQgPSBmdW5jdGlvbih0b2tlbikge1xuXHQgICAgICAgICAgICAgICAgVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuYXBwbHkodGhpcywgW3Rva2VuXSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZV9vdXRwdXQucHVzaCh0b2tlbik7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICB2YXIgY29tcGlsZV9sb2dpYyA9IGZ1bmN0aW9uKHRva2VuKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb21waWxlIHRoZSBsb2dpYyB0b2tlblxuXHQgICAgICAgICAgICAgICAgbG9naWNfdG9rZW4gPSBUd2lnLmxvZ2ljLmNvbXBpbGUuYXBwbHkodGhpcywgW3Rva2VuXSk7XG5cblx0ICAgICAgICAgICAgICAgIHR5cGUgPSBsb2dpY190b2tlbi50eXBlO1xuXHQgICAgICAgICAgICAgICAgb3BlbiA9IFR3aWcubG9naWMuaGFuZGxlclt0eXBlXS5vcGVuO1xuXHQgICAgICAgICAgICAgICAgbmV4dCA9IFR3aWcubG9naWMuaGFuZGxlclt0eXBlXS5uZXh0O1xuXG5cdCAgICAgICAgICAgICAgICBUd2lnLmxvZy50cmFjZShcIlR3aWcuY29tcGlsZTogXCIsIFwiQ29tcGlsZWQgbG9naWMgdG9rZW4gdG8gXCIsIGxvZ2ljX3Rva2VuLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbmV4dCBpczogXCIsIG5leHQsIFwiIG9wZW4gaXMgOiBcIiwgb3Blbik7XG5cblx0ICAgICAgICAgICAgICAgIC8vIE5vdCBhIHN0YW5kYWxvbmUgdG9rZW4sIGNoZWNrIGxvZ2ljIHN0YWNrIHRvIHNlZSBpZiB0aGlzIGlzIGV4cGVjdGVkXG5cdCAgICAgICAgICAgICAgICBpZiAob3BlbiAhPT0gdW5kZWZpbmVkICYmICFvcGVuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJldl90b2tlbiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHByZXZfdGVtcGxhdGUgPSBUd2lnLmxvZ2ljLmhhbmRsZXJbcHJldl90b2tlbi50eXBlXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChUd2lnLmluZGV4T2YocHJldl90ZW1wbGF0ZS5uZXh0LCB0eXBlKSA8IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBub3QgZXhwZWN0ZWQgYWZ0ZXIgYSBcIiArIHByZXZfdG9rZW4udHlwZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcHJldl90b2tlbi5vdXRwdXQgPSBwcmV2X3Rva2VuLm91dHB1dCB8fCBbXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHByZXZfdG9rZW4ub3V0cHV0ID0gcHJldl90b2tlbi5vdXRwdXQuY29uY2F0KGludGVybWVkaWF0ZV9vdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZV9vdXRwdXQgPSBbXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHRva19vdXRwdXQgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aWcudG9rZW4udHlwZS5sb2dpYyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHByZXZfdG9rZW5cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZV9vdXRwdXQucHVzaCh0b2tfb3V0cHV0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh0b2tfb3V0cHV0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFRoaXMgdG9rZW4gcmVxdWlyZXMgYWRkaXRpb25hbCB0b2tlbnMgdG8gY29tcGxldGUgdGhlIGxvZ2ljIHN0cnVjdHVyZS5cblx0ICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dC5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgVHdpZy5sb2cudHJhY2UoXCJUd2lnLmNvbXBpbGU6IFwiLCBcIlB1c2hpbmcgXCIsIGxvZ2ljX3Rva2VuLCBcIiB0byBsb2dpYyBzdGFjay5cIik7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXQgYW55IGN1cnJlbnRseSBoZWxkIG91dHB1dCBpbnRvIHRoZSBvdXRwdXQgbGlzdCBvZiB0aGUgbG9naWMgb3BlcmF0b3Jcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudGx5IGF0IHRoZSBoZWFkIG9mIHRoZSBzdGFjayBiZWZvcmUgd2UgcHVzaCBhIG5ldyBvbmUgb24uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByZXZfdG9rZW4gPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJldl90b2tlbi5vdXRwdXQgPSBwcmV2X3Rva2VuLm91dHB1dCB8fCBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJldl90b2tlbi5vdXRwdXQgPSBwcmV2X3Rva2VuLm91dHB1dC5jb25jYXQoaW50ZXJtZWRpYXRlX291dHB1dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocHJldl90b2tlbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZV9vdXRwdXQgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBQdXNoIHRoZSBuZXcgbG9naWMgdG9rZW4gb250byB0aGUgbG9naWMgc3RhY2tcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGxvZ2ljX3Rva2VuKTtcblxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcGVuICE9PSB1bmRlZmluZWQgJiYgb3Blbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRva19vdXRwdXQgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aWcudG9rZW4udHlwZS5sb2dpYyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGxvZ2ljX3Rva2VuXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTdGFuZGFsb25lIHRva2VuIChsaWtlIHslIHNldCAuLi4gJX1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVfb3V0cHV0LnB1c2godG9rX291dHB1dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rX291dHB1dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgIHByZXZfb3V0cHV0ID0gb3V0cHV0W291dHB1dC5sZW5ndGggLSAxXTtcblx0ICAgICAgICAgICAgICAgIHByZXZfaW50ZXJtZWRpYXRlX291dHB1dCA9IGludGVybWVkaWF0ZV9vdXRwdXRbaW50ZXJtZWRpYXRlX291dHB1dC5sZW5ndGggLSAxXTtcblx0ICAgICAgICAgICAgICAgIG5leHRfdG9rZW4gPSB0b2tlbnNbMF07XG5cdCAgICAgICAgICAgICAgICBUd2lnLmxvZy50cmFjZShcIkNvbXBpbGluZyB0b2tlbiBcIiwgdG9rZW4pO1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUucmF3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlX291dHB1dC5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmxvZ2ljOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21waWxlX2xvZ2ljLmNhbGwodGhpcywgdG9rZW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcsIGNvbW1lbnRzIHNob3VsZCBiZSBpZ25vcmVkXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUuY29tbWVudDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5vdXRwdXQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGVfb3V0cHV0LmNhbGwodGhpcywgdG9rZW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vS2lsbCB3aGl0ZXNwYWNlIGFoZWFkIGFuZCBiZWhpbmQgdGhpcyB0b2tlblxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmxvZ2ljX3doaXRlc3BhY2VfcHJlOlxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmxvZ2ljX3doaXRlc3BhY2VfcG9zdDpcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5sb2dpY193aGl0ZXNwYWNlX2JvdGg6XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUub3V0cHV0X3doaXRlc3BhY2VfcHJlOlxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLm91dHB1dF93aGl0ZXNwYWNlX3Bvc3Q6XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUub3V0cHV0X3doaXRlc3BhY2VfYm90aDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFR3aWcudG9rZW4udHlwZS5vdXRwdXRfd2hpdGVzcGFjZV9wb3N0ICYmIHRva2VuLnR5cGUgIT09IFR3aWcudG9rZW4udHlwZS5sb2dpY193aGl0ZXNwYWNlX3Bvc3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X291dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIHByZXZpb3VzIG91dHB1dCBpcyByYXcsIHBvcCBpdCBvZmZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldl9vdXRwdXQudHlwZSA9PT0gVHdpZy50b2tlbi50eXBlLnJhdykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucG9wKCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgcHJldmlvdXMgb3V0cHV0IGlzIG5vdCBqdXN0IHdoaXRlc3BhY2UsIHRyaW0gaXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZfb3V0cHV0LnZhbHVlLm1hdGNoKC9eXFxzKiQvKSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldl9vdXRwdXQudmFsdWUgPSBwcmV2X291dHB1dC52YWx1ZS50cmltKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1JlcHVzaCB0aGUgcHJldmlvdXMgb3V0cHV0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChwcmV2X291dHB1dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X2ludGVybWVkaWF0ZV9vdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZSBwcmV2aW91cyBpbnRlcm1lZGlhdGUgb3V0cHV0IGlzIHJhdywgcG9wIGl0IG9mZlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X2ludGVybWVkaWF0ZV9vdXRwdXQudHlwZSA9PT0gVHdpZy50b2tlbi50eXBlLnJhdykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVfb3V0cHV0LnBvcCgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIHByZXZpb3VzIG91dHB1dCBpcyBub3QganVzdCB3aGl0ZXNwYWNlLCB0cmltIGl0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X2ludGVybWVkaWF0ZV9vdXRwdXQudmFsdWUubWF0Y2goL15cXHMqJC8pID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2X2ludGVybWVkaWF0ZV9vdXRwdXQudmFsdWUgPSBwcmV2X2ludGVybWVkaWF0ZV9vdXRwdXQudmFsdWUudHJpbSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9SZXB1c2ggdGhlIHByZXZpb3VzIGludGVybWVkaWF0ZSBvdXRwdXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZV9vdXRwdXQucHVzaChwcmV2X2ludGVybWVkaWF0ZV9vdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9Db21waWxlIHRoaXMgdG9rZW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5vdXRwdXRfd2hpdGVzcGFjZV9wcmU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5vdXRwdXRfd2hpdGVzcGFjZV9wb3N0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUub3V0cHV0X3doaXRlc3BhY2VfYm90aDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21waWxlX291dHB1dC5jYWxsKHRoaXMsIHRva2VuKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmxvZ2ljX3doaXRlc3BhY2VfcHJlOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUubG9naWNfd2hpdGVzcGFjZV9wb3N0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUubG9naWNfd2hpdGVzcGFjZV9ib3RoOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGVfbG9naWMuY2FsbCh0aGlzLCB0b2tlbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVHdpZy50b2tlbi50eXBlLm91dHB1dF93aGl0ZXNwYWNlX3ByZSAmJiB0b2tlbi50eXBlICE9PSBUd2lnLnRva2VuLnR5cGUubG9naWNfd2hpdGVzcGFjZV9wcmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgbmV4dCB0b2tlbiBpcyByYXcsIHNoaWZ0IGl0IG91dFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuLnR5cGUgPT09IFR3aWcudG9rZW4udHlwZS5yYXcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnNoaWZ0KCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgbmV4dCB0b2tlbiBpcyBub3QganVzdCB3aGl0ZXNwYWNlLCB0cmltIGl0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuLnZhbHVlLm1hdGNoKC9eXFxzKiQvKSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dF90b2tlbi52YWx1ZSA9IG5leHRfdG9rZW4udmFsdWUudHJpbSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9VbnNoaWZ0IHRoZSBuZXh0IHRva2VuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMudW5zaGlmdChuZXh0X3Rva2VuKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBUd2lnLmxvZy50cmFjZShcIlR3aWcuY29tcGlsZTogXCIsIFwiIE91dHB1dDogXCIsIG91dHB1dCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIExvZ2ljIFN0YWNrOiBcIiwgc3RhY2ssXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBQZW5kaW5nIE91dHB1dDogXCIsIGludGVybWVkaWF0ZV9vdXRwdXQgKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGFyZSBubyBsb2dpYyB0b2tlbnMgbGVmdCBpbiB0aGUgc3RhY2suXG5cdCAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB1bmNsb3NlZF90b2tlbiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgYW4gZW5kIHRhZyBmb3IgXCIgKyB1bmNsb3NlZF90b2tlbi50eXBlICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiwgZXhwZWN0aW5nIG9uZSBvZiBcIiArIHVuY2xvc2VkX3Rva2VuLm5leHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG5cdCAgICAgICAgfSBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXRocm93KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXgudHlwZSA9PSAnVHdpZ0V4Y2VwdGlvbicgJiYgIWV4LmZpbGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBleC5maWxlID0gdGhpcy5pZDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXhcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIFR3aWcubG9nLmVycm9yKFwiRXJyb3IgY29tcGlsaW5nIHR3aWcgdGVtcGxhdGUgXCIgKyB0aGlzLmlkICsgXCI6IFwiKTtcblx0ICAgICAgICAgICAgICAgIGlmIChleC5zdGFjaykge1xuXHQgICAgICAgICAgICAgICAgICAgIFR3aWcubG9nLmVycm9yKGV4LnN0YWNrKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgVHdpZy5sb2cuZXJyb3IoZXgudG9TdHJpbmcoKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBhcnNlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRoZSBjb21waWxlZCB0b2tlbnMuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgcmVuZGVyIGNvbnRleHQuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGFyc2VkIHRlbXBsYXRlLlxuXHQgICAgICovXG5cdCAgICBUd2lnLnBhcnNlID0gZnVuY3Rpb24gKHRva2VucywgY29udGV4dCwgYWxsb3dfYXN5bmMpIHtcblx0ICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgIG91dHB1dCA9IFtdLFxuXG5cdCAgICAgICAgICAgIC8vIFN0b3JlIGFueSBlcnJvciB0aGF0IG1pZ2h0IGJlIHRocm93biBieSB0aGUgcHJvbWlzZSBjaGFpbi5cblx0ICAgICAgICAgICAgZXJyID0gbnVsbCxcblxuXHQgICAgICAgICAgICAvLyBUaGlzIHdpbGwgYmUgc2V0IHRvIGlzX2FzeW5jIGlmIHRlbXBsYXRlIHJlbmRlcnMgc3luY2hyb25vdXNseVxuXHQgICAgICAgICAgICBpc19hc3luYyA9IHRydWUsXG5cdCAgICAgICAgICAgIHByb21pc2UgPSBudWxsLFxuXG5cdCAgICAgICAgICAgIC8vIFRyYWNrIGxvZ2ljIGNoYWluc1xuXHQgICAgICAgICAgICBjaGFpbiA9IHRydWU7XG5cblxuXHQgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUV4Y2VwdGlvbihleCkge1xuXHQgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnJldGhyb3cpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXggPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXggPSBuZXcgVHdpZy5FcnJvcihleClcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGV4LnR5cGUgPT0gJ1R3aWdFeGNlcHRpb24nICYmICFleC5maWxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXguZmlsZSA9IHRoYXQuaWQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHRocm93IGV4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgVHdpZy5sb2cuZXJyb3IoXCJFcnJvciBwYXJzaW5nIHR3aWcgdGVtcGxhdGUgXCIgKyB0aGF0LmlkICsgXCI6IFwiKTtcblx0ICAgICAgICAgICAgICAgIGlmIChleC5zdGFjaykge1xuXHQgICAgICAgICAgICAgICAgICAgIFR3aWcubG9nLmVycm9yKGV4LnN0YWNrKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgVHdpZy5sb2cuZXJyb3IoZXgudG9TdHJpbmcoKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChUd2lnLmRlYnVnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwcm9taXNlID0gVHdpZy5hc3luYy5mb3JFYWNoKHRva2VucywgZnVuY3Rpb24gcGFyc2VUb2tlbih0b2tlbikge1xuXHQgICAgICAgICAgICBUd2lnLmxvZy5kZWJ1ZyhcIlR3aWcucGFyc2U6IFwiLCBcIlBhcnNpbmcgdG9rZW46IFwiLCB0b2tlbik7XG5cblx0ICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5yYXc6XG5cdCAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goVHdpZy5maWx0ZXJzLnJhdyh0b2tlbi52YWx1ZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5sb2dpYzpcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbG9naWNfdG9rZW4gPSB0b2tlbi50b2tlbjtcblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLmxvZ2ljLnBhcnNlQXN5bmMuYXBwbHkodGhhdCwgW2xvZ2ljX3Rva2VuLCBjb250ZXh0LCBjaGFpbl0pXG5cdCAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24obG9naWMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2ljLmNoYWluICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gbG9naWMuY2hhaW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2ljLmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGxvZ2ljLmNvbnRleHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2ljLm91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChsb2dpYy5vdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmNvbW1lbnQ6XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZywgY29tbWVudHMgc2hvdWxkIGJlIGlnbm9yZWRcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICAgICAgLy9GYWxsIHRocm91Z2ggd2hpdGVzcGFjZSB0byBvdXRwdXRcblx0ICAgICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLm91dHB1dF93aGl0ZXNwYWNlX3ByZTpcblx0ICAgICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLm91dHB1dF93aGl0ZXNwYWNlX3Bvc3Q6XG5cdCAgICAgICAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5vdXRwdXRfd2hpdGVzcGFjZV9ib3RoOlxuXHQgICAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUub3V0cHV0OlxuXHQgICAgICAgICAgICAgICAgICAgIFR3aWcubG9nLmRlYnVnKFwiVHdpZy5wYXJzZTogXCIsIFwiT3V0cHV0IHRva2VuOiBcIiwgdG9rZW4uc3RhY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBnaXZlbiBleHByZXNzaW9uIGluIHRoZSBnaXZlbiBjb250ZXh0XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmFwcGx5KHRoYXQsIFt0b2tlbi5zdGFjaywgY29udGV4dF0pXG5cdCAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24obykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pXG5cdCAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIG91dHB1dCA9IFR3aWcub3V0cHV0LmFwcGx5KHRoYXQsIFtvdXRwdXRdKTtcblx0ICAgICAgICAgICAgaXNfYXN5bmMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgICAgICB9KVxuXHQgICAgICAgIC5jYXRjaChmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgIGlmIChhbGxvd19hc3luYylcblx0ICAgICAgICAgICAgICAgIGhhbmRsZUV4Y2VwdGlvbihlKTtcblxuXHQgICAgICAgICAgICBlcnIgPSBlO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLy8gSWYgYGFsbG93X2FzeW5jYCB3ZSB3aWxsIGFsd2F5cyByZXR1cm4gYSBwcm9taXNlIHNpbmNlIHdlIGRvIG5vdFxuXHQgICAgICAgIC8vIGtub3cgaW4gYWR2YW5jZSBpZiB3ZSBhcmUgZ29pbmcgdG8gcnVuIGFzeW5jaHJvbm91c2x5IG9yIG5vdC5cblx0ICAgICAgICBpZiAoYWxsb3dfYXN5bmMpXG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXG5cdCAgICAgICAgLy8gSGFuZGxlIGVycm9ycyBoZXJlIGlmIHdlIGZhaWwgc3luY2hyb25vdXNseS5cblx0ICAgICAgICBpZiAoZXJyICE9PSBudWxsKVxuXHQgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXhjZXB0aW9uKGVycik7XG5cblx0ICAgICAgICAvLyBJZiBgYWxsb3dfYXN5bmNgIGlzIG5vdCB0cnVlIHdlIHNob3VsZCBub3QgYWxsb3cgdGhlIHVzZXJcblx0ICAgICAgICAvLyB0byB1c2UgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyBvciBmaWx0ZXJzLlxuXHQgICAgICAgIGlmIChpc19hc3luYylcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1lvdSBhcmUgdXNpbmcgVHdpZy5qcyBpbiBzeW5jIG1vZGUgaW4gY29tYmluYXRpb24gd2l0aCBhc3luYyBleHRlbnNpb25zLicpO1xuXG5cdCAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVG9rZW5pemUgYW5kIGNvbXBpbGUgYSBzdHJpbmcgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgVGhlIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgY29tcGlsZWQgdG9rZW5zLlxuXHQgICAgICovXG5cdCAgICBUd2lnLnByZXBhcmUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgdmFyIHRva2VucywgcmF3X3Rva2VucztcblxuXHQgICAgICAgIC8vIFRva2VuaXplXG5cdCAgICAgICAgVHdpZy5sb2cuZGVidWcoXCJUd2lnLnByZXBhcmU6IFwiLCBcIlRva2VuaXppbmcgXCIsIGRhdGEpO1xuXHQgICAgICAgIHJhd190b2tlbnMgPSBUd2lnLnRva2VuaXplLmFwcGx5KHRoaXMsIFtkYXRhXSk7XG5cblx0ICAgICAgICAvLyBDb21waWxlXG5cdCAgICAgICAgVHdpZy5sb2cuZGVidWcoXCJUd2lnLnByZXBhcmU6IFwiLCBcIkNvbXBpbGluZyBcIiwgcmF3X3Rva2Vucyk7XG5cdCAgICAgICAgdG9rZW5zID0gVHdpZy5jb21waWxlLmFwcGx5KHRoaXMsIFtyYXdfdG9rZW5zXSk7XG5cblx0ICAgICAgICBUd2lnLmxvZy5kZWJ1ZyhcIlR3aWcucHJlcGFyZTogXCIsIFwiQ29tcGlsZWQgXCIsIHRva2Vucyk7XG5cblx0ICAgICAgICByZXR1cm4gdG9rZW5zO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBKb2luIHRoZSBvdXRwdXQgdG9rZW4ncyBzdGFjayBhbmQgZXNjYXBlIGl0IGlmIG5lZWRlZFxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IE91dHB1dCB0b2tlbidzIHN0YWNrXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7c3RyaW5nfFN0cmluZ30gQXV0b2VzY2FwZWQgb3V0cHV0XG5cdCAgICAgKi9cblx0ICAgIFR3aWcub3V0cHV0ID0gZnVuY3Rpb24ob3V0cHV0KSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXV0b2VzY2FwZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHN0cmF0ZWd5ID0gJ2h0bWwnO1xuXHQgICAgICAgIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMuYXV0b2VzY2FwZSA9PSAnc3RyaW5nJylcblx0ICAgICAgICAgICAgc3RyYXRlZ3kgPSB0aGlzLm9wdGlvbnMuYXV0b2VzY2FwZTtcblxuXHQgICAgICAgIC8vIFtdLm1hcCB3b3VsZCBiZSBiZXR0ZXIgYnV0IGl0J3Mgbm90IHN1cHBvcnRlZCBieSBJRTgtXG5cdCAgICAgICAgdmFyIGVzY2FwZWRfb3V0cHV0ID0gW107XG5cdCAgICAgICAgVHdpZy5mb3JFYWNoKG91dHB1dCwgZnVuY3Rpb24gKHN0cikge1xuXHQgICAgICAgICAgICBpZiAoc3RyICYmIChzdHIudHdpZ19tYXJrdXAgIT09IHRydWUgJiYgc3RyLnR3aWdfbWFya3VwICE9IHN0cmF0ZWd5KSkge1xuXHQgICAgICAgICAgICAgICAgc3RyID0gVHdpZy5maWx0ZXJzLmVzY2FwZShzdHIsIFsgc3RyYXRlZ3kgXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZXNjYXBlZF9vdXRwdXQucHVzaChzdHIpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBUd2lnLk1hcmt1cChlc2NhcGVkX291dHB1dC5qb2luKFwiXCIpKTtcblx0ICAgIH1cblxuXHQgICAgLy8gTmFtZXNwYWNlIGZvciB0ZW1wbGF0ZSBzdG9yYWdlIGFuZCByZXRyaWV2YWxcblx0ICAgIFR3aWcuVGVtcGxhdGVzID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlZ2lzdGVyZWQgdGVtcGxhdGUgbG9hZGVycyAtIHVzZSBUd2lnLlRlbXBsYXRlcy5yZWdpc3RlckxvYWRlciB0byBhZGQgc3VwcG9ydGVkIGxvYWRlcnNcblx0ICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGxvYWRlcnM6IHt9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVnaXN0ZXJlZCB0ZW1wbGF0ZSBwYXJzZXJzIC0gdXNlIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdGVyUGFyc2VyIHRvIGFkZCBzdXBwb3J0ZWQgcGFyc2Vyc1xuXHQgICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2Vyczoge30sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDYWNoZWQgLyBsb2FkZWQgdGVtcGxhdGVzXG5cdCAgICAgICAgICogQHR5cGUge09iamVjdH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZWdpc3RyeToge31cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogSXMgdGhpcyBpZCB2YWxpZCBmb3IgYSB0d2lnIHRlbXBsYXRlP1xuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgdG8gY2hlY2suXG5cdCAgICAgKlxuXHQgICAgICogQHRocm93cyB7VHdpZy5FcnJvcn0gSWYgdGhlIElEIGlzIGludmFsaWQgb3IgdXNlZC5cblx0ICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIElEIGlzIHZhbGlkLlxuXHQgICAgICovXG5cdCAgICBUd2lnLnZhbGlkYXRlSWQgPSBmdW5jdGlvbihpZCkge1xuXHQgICAgICAgIGlmIChpZCA9PT0gXCJwcm90b3R5cGVcIikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihpZCArIFwiIGlzIG5vdCBhIHZhbGlkIHR3aWcgaWRlbnRpZmllclwiKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFR3aWcuY2FjaGUgJiYgVHdpZy5UZW1wbGF0ZXMucmVnaXN0cnkuaGFzT3duUHJvcGVydHkoaWQpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiVGhlcmUgaXMgYWxyZWFkeSBhIHRlbXBsYXRlIHdpdGggdGhlIElEIFwiICsgaWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZWdpc3RlciBhIHRlbXBsYXRlIGxvYWRlclxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBUd2lnLmV4dGVuZChmdW5jdGlvbihUd2lnKSB7XG5cdCAgICAgKiAgICBUd2lnLlRlbXBsYXRlcy5yZWdpc3RlckxvYWRlcignY3VzdG9tX2xvYWRlcicsIGZ1bmN0aW9uKGxvY2F0aW9uLCBwYXJhbXMsIGNhbGxiYWNrLCBlcnJvcl9jYWxsYmFjaykge1xuXHQgICAgICogICAgICAgIC8vIC4uLiBsb2FkIHRoZSB0ZW1wbGF0ZSAuLi5cblx0ICAgICAqICAgICAgICBwYXJhbXMuZGF0YSA9IGxvYWRlZFRlbXBsYXRlRGF0YTtcblx0ICAgICAqICAgICAgICAvLyBjcmVhdGUgYW5kIHJldHVybiB0aGUgdGVtcGxhdGVcblx0ICAgICAqICAgICAgICB2YXIgdGVtcGxhdGUgPSBuZXcgVHdpZy5UZW1wbGF0ZShwYXJhbXMpO1xuXHQgICAgICogICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAqICAgICAgICAgICAgY2FsbGJhY2sodGVtcGxhdGUpO1xuXHQgICAgICogICAgICAgIH1cblx0ICAgICAqICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG5cdCAgICAgKiAgICB9KTtcblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RfbmFtZSBUaGUgbWV0aG9kIHRoaXMgbG9hZGVyIGlzIGludGVuZGVkIGZvciAoYWpheCwgZnMpXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gbG9hZGluZyB0aGUgdGVtcGxhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gc2NvcGUgT3B0aW9uYWwgc2NvcGUgcGFyYW1ldGVyIHRvIGJpbmQgZnVuYyB0b1xuXHQgICAgICpcblx0ICAgICAqIEB0aHJvd3MgVHdpZy5FcnJvclxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge3ZvaWR9XG5cdCAgICAgKi9cblx0ICAgIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdGVyTG9hZGVyID0gZnVuY3Rpb24obWV0aG9kX25hbWUsIGZ1bmMsIHNjb3BlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdVbmFibGUgdG8gYWRkIGxvYWRlciBmb3IgJyArIG1ldGhvZF9uYW1lICsgJzogSW52YWxpZCBmdW5jdGlvbiByZWZlcmVuY2UgZ2l2ZW4uJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChzY29wZSkge1xuXHQgICAgICAgICAgICBmdW5jID0gZnVuYy5iaW5kKHNjb3BlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5sb2FkZXJzW21ldGhvZF9uYW1lXSA9IGZ1bmM7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZSBhIHJlZ2lzdGVyZWQgbG9hZGVyXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZF9uYW1lIFRoZSBtZXRob2QgbmFtZSBmb3IgdGhlIGxvYWRlciB5b3Ugd2lzaCB0byByZW1vdmVcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHt2b2lkfVxuXHQgICAgICovXG5cdCAgICBUd2lnLlRlbXBsYXRlcy51blJlZ2lzdGVyTG9hZGVyID0gZnVuY3Rpb24obWV0aG9kX25hbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc1JlZ2lzdGVyZWRMb2FkZXIobWV0aG9kX25hbWUpKSB7XG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbbWV0aG9kX25hbWVdO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2VlIGlmIGEgbG9hZGVyIGlzIHJlZ2lzdGVyZWQgYnkgaXRzIG1ldGhvZCBuYW1lXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBsb2FkZXIgeW91IGFyZSBsb29raW5nIGZvclxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAgICAgKi9cblx0ICAgIFR3aWcuVGVtcGxhdGVzLmlzUmVnaXN0ZXJlZExvYWRlciA9IGZ1bmN0aW9uKG1ldGhvZF9uYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVycy5oYXNPd25Qcm9wZXJ0eShtZXRob2RfbmFtZSk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJlZ2lzdGVyIGEgdGVtcGxhdGUgcGFyc2VyXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIFR3aWcuZXh0ZW5kKGZ1bmN0aW9uKFR3aWcpIHtcblx0ICAgICAqICAgIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdGVyUGFyc2VyKCdjdXN0b21fcGFyc2VyJywgZnVuY3Rpb24ocGFyYW1zKSB7XG5cdCAgICAgKiAgICAgICAgLy8gdGhpcyB0ZW1wbGF0ZSBzb3VyY2UgY2FuIGJlIGFjY2Vzc2VkIGluIHBhcmFtcy5kYXRhXG5cdCAgICAgKiAgICAgICAgdmFyIHRlbXBsYXRlID0gcGFyYW1zLmRhdGFcblx0ICAgICAqXG5cdCAgICAgKiAgICAgICAgLy8gLi4uIGN1c3RvbSBwcm9jZXNzIHRoYXQgbW9kaWZpZXMgdGhlIHRlbXBsYXRlXG5cdCAgICAgKlxuXHQgICAgICogICAgICAgIC8vIHJldHVybiB0aGUgcGFyc2VkIHRlbXBsYXRlXG5cdCAgICAgKiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuXHQgICAgICogICAgfSk7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kX25hbWUgVGhlIG1ldGhvZCB0aGlzIHBhcnNlciBpcyBpbnRlbmRlZCBmb3IgKHR3aWcsIHNvdXJjZSlcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBwYXJzaW5nIHRoZSB0ZW1wbGF0ZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBzY29wZSBPcHRpb25hbCBzY29wZSBwYXJhbWV0ZXIgdG8gYmluZCBmdW5jIHRvXG5cdCAgICAgKlxuXHQgICAgICogQHRocm93cyBUd2lnLkVycm9yXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7dm9pZH1cblx0ICAgICAqL1xuXHQgICAgVHdpZy5UZW1wbGF0ZXMucmVnaXN0ZXJQYXJzZXIgPSBmdW5jdGlvbihtZXRob2RfbmFtZSwgZnVuYywgc2NvcGUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1VuYWJsZSB0byBhZGQgcGFyc2VyIGZvciAnICsgbWV0aG9kX25hbWUgKyAnOiBJbnZhbGlkIGZ1bmN0aW9uIHJlZ2VyZW5jZSBnaXZlbi4nKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoc2NvcGUpIHtcblx0ICAgICAgICAgICAgZnVuYyA9IGZ1bmMuYmluZChzY29wZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5wYXJzZXJzW21ldGhvZF9uYW1lXSA9IGZ1bmM7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZSBhIHJlZ2lzdGVyZWQgcGFyc2VyXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZF9uYW1lIFRoZSBtZXRob2QgbmFtZSBmb3IgdGhlIHBhcnNlciB5b3Ugd2lzaCB0byByZW1vdmVcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHt2b2lkfVxuXHQgICAgICovXG5cdCAgICBUd2lnLlRlbXBsYXRlcy51blJlZ2lzdGVyUGFyc2VyID0gZnVuY3Rpb24obWV0aG9kX25hbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc1JlZ2lzdGVyZWRQYXJzZXIobWV0aG9kX25hbWUpKSB7XG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcnNlcnNbbWV0aG9kX25hbWVdO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2VlIGlmIGEgcGFyc2VyIGlzIHJlZ2lzdGVyZWQgYnkgaXRzIG1ldGhvZCBuYW1lXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJzZXIgeW91IGFyZSBsb29raW5nIGZvclxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAgICAgKi9cblx0ICAgIFR3aWcuVGVtcGxhdGVzLmlzUmVnaXN0ZXJlZFBhcnNlciA9IGZ1bmN0aW9uKG1ldGhvZF9uYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2Vycy5oYXNPd25Qcm9wZXJ0eShtZXRob2RfbmFtZSk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNhdmUgYSB0ZW1wbGF0ZSBvYmplY3QgdG8gdGhlIHN0b3JlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7VHdpZy5UZW1wbGF0ZX0gdGVtcGxhdGUgICBUaGUgdHdpZy5qcyB0ZW1wbGF0ZSB0byBzdG9yZS5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5UZW1wbGF0ZXMuc2F2ZSA9IGZ1bmN0aW9uKHRlbXBsYXRlKSB7XG5cdCAgICAgICAgaWYgKHRlbXBsYXRlLmlkID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJVbmFibGUgdG8gc2F2ZSB0ZW1wbGF0ZSB3aXRoIG5vIGlkXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUd2lnLlRlbXBsYXRlcy5yZWdpc3RyeVt0ZW1wbGF0ZS5pZF0gPSB0ZW1wbGF0ZTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTG9hZCBhIHByZXZpb3VzbHkgc2F2ZWQgdGVtcGxhdGUgZnJvbSB0aGUgc3RvcmUuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkICAgVGhlIElEIG9mIHRoZSB0ZW1wbGF0ZSB0byBsb2FkLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1R3aWcuVGVtcGxhdGV9IEEgdHdpZy5qcyB0ZW1wbGF0ZSBzdG9yZWQgd2l0aCB0aGUgcHJvdmlkZWQgSUQuXG5cdCAgICAgKi9cblx0ICAgIFR3aWcuVGVtcGxhdGVzLmxvYWQgPSBmdW5jdGlvbihpZCkge1xuXHQgICAgICAgIGlmICghVHdpZy5UZW1wbGF0ZXMucmVnaXN0cnkuaGFzT3duUHJvcGVydHkoaWQpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gVHdpZy5UZW1wbGF0ZXMucmVnaXN0cnlbaWRdO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMb2FkIGEgdGVtcGxhdGUgZnJvbSBhIHJlbW90ZSBsb2NhdGlvbiB1c2luZyBBSkFYIGFuZCBzYXZlcyBpbiB3aXRoIHRoZSBnaXZlbiBJRC5cblx0ICAgICAqXG5cdCAgICAgKiBBdmFpbGFibGUgcGFyYW1ldGVyczpcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGFzeW5jOiAgICAgICBTaG91bGQgdGhlIEhUVFAgcmVxdWVzdCBiZSBwZXJmb3JtZWQgYXN5bmNocm9ub3VzbHkuXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB0cnVlLlxuXHQgICAgICogICAgICBtZXRob2Q6ICAgICAgV2hhdCBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gbG9hZCB0aGUgdGVtcGxhdGVcblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgIChmcyBvciBhamF4KVxuXHQgICAgICogICAgICBwYXJzZXI6ICAgICAgV2hhdCBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gcGFyc2UgdGhlIHRlbXBsYXRlXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgICAgICAodHdpZyBvciBzb3VyY2UpXG5cdCAgICAgKiAgICAgIHByZWNvbXBpbGVkOiBIYXMgdGhlIHRlbXBsYXRlIGFscmVhZHkgYmVlbiBjb21waWxlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gIFRoZSByZW1vdGUgVVJMIHRvIGxvYWQgYXMgYSB0ZW1wbGF0ZS5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHRlbXBsYXRlIHBhcmFtZXRlcnMuXG5cdCAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgQSBjYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiB0aGUgdGVtcGxhdGUgZmluaXNoZXMgbG9hZGluZy5cblx0ICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVycm9yX2NhbGxiYWNrICBBIGNhbGxiYWNrIHRyaWdnZXJlZCBpZiBhbiBlcnJvciBvY2N1cnMgbG9hZGluZyB0aGUgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICpcblx0ICAgICAqL1xuXHQgICAgVHdpZy5UZW1wbGF0ZXMubG9hZFJlbW90ZSA9IGZ1bmN0aW9uKGxvY2F0aW9uLCBwYXJhbXMsIGNhbGxiYWNrLCBlcnJvcl9jYWxsYmFjaykge1xuXHQgICAgICAgIHZhciBsb2FkZXI7XG5cblx0ICAgICAgICAvLyBEZWZhdWx0IHRvIGFzeW5jXG5cdCAgICAgICAgaWYgKHBhcmFtcy5hc3luYyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHBhcmFtcy5hc3luYyA9IHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gRGVmYXVsdCB0byB0aGUgVVJMIHNvIHRoZSB0ZW1wbGF0ZSBpcyBjYWNoZWQuXG5cdCAgICAgICAgaWYgKHBhcmFtcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHBhcmFtcy5pZCA9IGxvY2F0aW9uO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENoZWNrIGZvciBleGlzdGluZyB0ZW1wbGF0ZVxuXHQgICAgICAgIGlmIChUd2lnLmNhY2hlICYmIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdHJ5Lmhhc093blByb3BlcnR5KHBhcmFtcy5pZCkpIHtcblx0ICAgICAgICAgICAgLy8gQSB0ZW1wbGF0ZSBpcyBhbHJlYWR5IHNhdmVkIHdpdGggdGhlIGdpdmVuIGlkLlxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayhUd2lnLlRlbXBsYXRlcy5yZWdpc3RyeVtwYXJhbXMuaWRdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBUT0RPOiBpZiBhc3luYywgcmV0dXJuIGRlZmVycmVkIHByb21pc2Vcblx0ICAgICAgICAgICAgcmV0dXJuIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdHJ5W3BhcmFtcy5pZF07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy9pZiB0aGUgcGFyc2VyIG5hbWUgaGFzbid0IGJlZW4gc2V0LCBkZWZhdWx0IGl0IHRvIHR3aWdcblx0ICAgICAgICBwYXJhbXMucGFyc2VyID0gcGFyYW1zLnBhcnNlciB8fCAndHdpZyc7XG5cblx0ICAgICAgICAvLyBBc3N1bWUgJ2ZzJyBpZiB0aGUgbG9hZGVyIGlzIG5vdCBkZWZpbmVkXG5cdCAgICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3BhcmFtcy5tZXRob2RdIHx8IHRoaXMubG9hZGVycy5mcztcblx0ICAgICAgICByZXR1cm4gbG9hZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBEZXRlcm1pbmUgb2JqZWN0IHR5cGVcblx0ICAgIGZ1bmN0aW9uIGlzKHR5cGUsIG9iaikge1xuXHQgICAgICAgIHZhciBjbGFzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpO1xuXHQgICAgICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgJiYgY2xhcyA9PT0gdHlwZTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGUgYSBuZXcgdHdpZy5qcyB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBQYXJhbWV0ZXJzOiB7XG5cdCAgICAgKiAgICAgIGRhdGE6ICAgVGhlIHRlbXBsYXRlLCBlaXRoZXIgcHJlLWNvbXBpbGVkIHRva2VucyBvciBhIHN0cmluZyB0ZW1wbGF0ZVxuXHQgICAgICogICAgICBpZDogICAgIFRoZSBuYW1lIG9mIHRoaXMgdGVtcGxhdGVcblx0ICAgICAqICAgICAgYmxvY2tzOiBBbnkgcHJlLWV4aXN0aW5nIGJsb2NrIGZyb20gYSBjaGlsZCB0ZW1wbGF0ZVxuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHRlbXBsYXRlIHBhcmFtZXRlcnMuXG5cdCAgICAgKi9cblx0ICAgIFR3aWcuVGVtcGxhdGUgPSBmdW5jdGlvbiAoIHBhcmFtcyApIHtcblx0ICAgICAgICB2YXIgZGF0YSA9IHBhcmFtcy5kYXRhLFxuXHQgICAgICAgICAgICBpZCA9IHBhcmFtcy5pZCxcblx0ICAgICAgICAgICAgYmxvY2tzID0gcGFyYW1zLmJsb2Nrcyxcblx0ICAgICAgICAgICAgbWFjcm9zID0gcGFyYW1zLm1hY3JvcyB8fCB7fSxcblx0ICAgICAgICAgICAgYmFzZSA9IHBhcmFtcy5iYXNlLFxuXHQgICAgICAgICAgICBwYXRoID0gcGFyYW1zLnBhdGgsXG5cdCAgICAgICAgICAgIHVybCA9IHBhcmFtcy51cmwsXG5cdCAgICAgICAgICAgIG5hbWUgPSBwYXJhbXMubmFtZSxcblx0ICAgICAgICAgICAgbWV0aG9kID0gcGFyYW1zLm1ldGhvZCxcblx0ICAgICAgICAgICAgLy8gcGFyc2VyIG9wdGlvbnNcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuXG5cdCAgICAgICAgLy8gIyBXaGF0IGlzIHN0b3JlZCBpbiBhIFR3aWcuVGVtcGxhdGVcblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vIFRoZSBUd2lnIFRlbXBsYXRlIGhvbGQgc2V2ZXJhbCBjaHVja3Mgb2YgZGF0YS5cblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vICAgICB7XG5cdCAgICAgICAgLy8gICAgICAgICAgaWQ6ICAgICBUaGUgdG9rZW4gSUQgKGlmIGFueSlcblx0ICAgICAgICAvLyAgICAgICAgICB0b2tlbnM6IFRoZSBsaXN0IG9mIHRva2VucyB0aGF0IG1ha2VzIHVwIHRoaXMgdGVtcGxhdGUuXG5cdCAgICAgICAgLy8gICAgICAgICAgYmxvY2tzOiBUaGUgbGlzdCBvZiBibG9jayB0aGlzIHRlbXBsYXRlIGNvbnRhaW5zLlxuXHQgICAgICAgIC8vICAgICAgICAgIGJhc2U6ICAgVGhlIGJhc2UgdGVtcGxhdGUgKGlmIGFueSlcblx0ICAgICAgICAvLyAgICAgICAgICAgIG9wdGlvbnM6ICB7XG5cdCAgICAgICAgLy8gICAgICAgICAgICAgICAgQ29tcGlsZXIvcGFyc2VyIG9wdGlvbnNcblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vICAgICAgICAgICAgICAgIHN0cmljdF92YXJpYWJsZXM6IHRydWUvZmFsc2Vcblx0ICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgU2hvdWxkIG1pc3NpbmcgdmFyaWFibGUva2V5cyBlbWl0IGFuIGVycm9yIG1lc3NhZ2UuIElmIGZhbHNlLCB0aGV5IGRlZmF1bHQgdG8gbnVsbC5cblx0ICAgICAgICAvLyAgICAgICAgICAgIH1cblx0ICAgICAgICAvLyAgICAgfVxuXHQgICAgICAgIC8vXG5cblx0ICAgICAgICB0aGlzLmlkICAgICA9IGlkO1xuXHQgICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuXHQgICAgICAgIHRoaXMuYmFzZSAgID0gYmFzZTtcblx0ICAgICAgICB0aGlzLnBhdGggICA9IHBhdGg7XG5cdCAgICAgICAgdGhpcy51cmwgICAgPSB1cmw7XG5cdCAgICAgICAgdGhpcy5uYW1lICAgPSBuYW1lO1xuXHQgICAgICAgIHRoaXMubWFjcm9zID0gbWFjcm9zO1xuXHQgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0ICAgICAgICB0aGlzLnJlc2V0KGJsb2Nrcyk7XG5cblx0ICAgICAgICBpZiAoaXMoJ1N0cmluZycsIGRhdGEpKSB7XG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zID0gVHdpZy5wcmVwYXJlLmFwcGx5KHRoaXMsIFtkYXRhXSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMgPSBkYXRhO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIFR3aWcuVGVtcGxhdGVzLnNhdmUodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgVHdpZy5UZW1wbGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihibG9ja3MpIHtcblx0ICAgICAgICBUd2lnLmxvZy5kZWJ1ZyhcIlR3aWcuVGVtcGxhdGUucmVzZXRcIiwgXCJSZXNldGluZyB0ZW1wbGF0ZSBcIiArIHRoaXMuaWQpO1xuXHQgICAgICAgIHRoaXMuYmxvY2tzID0ge307XG5cdCAgICAgICAgdGhpcy5pbXBvcnRlZEJsb2NrcyA9IFtdO1xuXHQgICAgICAgIHRoaXMub3JpZ2luYWxCbG9ja1Rva2VucyA9IHt9O1xuXHQgICAgICAgIHRoaXMuY2hpbGQgPSB7XG5cdCAgICAgICAgICAgIGJsb2NrczogYmxvY2tzIHx8IHt9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLmV4dGVuZCA9IG51bGw7XG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLlRlbXBsYXRlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY29udGV4dCwgcGFyYW1zLCBhbGxvd19hc3luYykge1xuXHQgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuXHQgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblxuXHQgICAgICAgICAgICAvLyBTdG9yZSBhbnkgZXJyb3IgdGhhdCBtaWdodCBiZSB0aHJvd24gYnkgdGhlIHByb21pc2UgY2hhaW4uXG5cdCAgICAgICAgICAgIGVyciA9IG51bGwsXG5cblx0ICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHNldCB0byBpc19hc3luYyBpZiB0ZW1wbGF0ZSByZW5kZXJzIHN5bmNocm9ub3VzbHlcblx0ICAgICAgICAgICAgaXNfYXN5bmMgPSB0cnVlLFxuXHQgICAgICAgICAgICBwcm9taXNlID0gbnVsbCxcblxuXHQgICAgICAgICAgICByZXN1bHQsXG5cdCAgICAgICAgICAgIHVybDtcblxuXHQgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwge307XG5cblx0ICAgICAgICAvLyBDbGVhciBhbnkgcHJldmlvdXMgc3RhdGVcblx0ICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgaWYgKHBhcmFtcy5ibG9ja3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5ibG9ja3MgPSBwYXJhbXMuYmxvY2tzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocGFyYW1zLm1hY3Jvcykge1xuXHQgICAgICAgICAgICB0aGlzLm1hY3JvcyA9IHBhcmFtcy5tYWNyb3M7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24ob3V0cHV0KSB7XG5cdCAgICAgICAgICAgIC8vIERvZXMgdGhpcyB0ZW1wbGF0ZSBleHRlbmQgYW5vdGhlclxuXHQgICAgICAgICAgICBpZiAodGhhdC5leHRlbmQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBleHRfdGVtcGxhdGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSB0ZW1wbGF0ZSBpcyBwcm92aWRlZCBpbmxpbmVcblx0ICAgICAgICAgICAgICAgIGlmICggdGhhdC5vcHRpb25zLmFsbG93SW5saW5lSW5jbHVkZXMgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXh0X3RlbXBsYXRlID0gVHdpZy5UZW1wbGF0ZXMubG9hZCh0aGF0LmV4dGVuZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCBleHRfdGVtcGxhdGUgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4dF90ZW1wbGF0ZS5vcHRpb25zID0gdGhhdC5vcHRpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSB0ZW1wbGF0ZSBmaWxlIHZpYSBpbmNsdWRlXG5cdCAgICAgICAgICAgICAgICBpZiAoIWV4dF90ZW1wbGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHVybCA9IFR3aWcucGF0aC5wYXJzZVBhdGgodGhhdCwgdGhhdC5leHRlbmQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgZXh0X3RlbXBsYXRlID0gVHdpZy5UZW1wbGF0ZXMubG9hZFJlbW90ZSh1cmwsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB0aGF0LmdldExvYWRlck1ldGhvZCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBiYXNlOiB0aGF0LmJhc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiAgZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAgICAgdXJsLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGF0Lm9wdGlvbnNcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQgPSBleHRfdGVtcGxhdGU7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnBhcmVudC5yZW5kZXJBc3luYyh0aGF0LmNvbnRleHQsIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9ja3M6IHRoYXQuYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChwYXJhbXMub3V0cHV0ID09ICdibG9ja3MnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5ibG9ja3M7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLm91dHB1dCA9PSAnbWFjcm9zJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQubWFjcm9zO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBwcm9taXNlID0gVHdpZy5wYXJzZUFzeW5jLmFwcGx5KHRoaXMsIFt0aGlzLnRva2VucywgdGhpcy5jb250ZXh0XSlcblx0ICAgICAgICAudGhlbihjYilcblx0ICAgICAgICAudGhlbihmdW5jdGlvbih2KSB7XG5cdCAgICAgICAgICAgIGlzX2FzeW5jID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IHY7XG5cdCAgICAgICAgICAgIHJldHVybiB2O1xuXHQgICAgICAgIH0pXG5cdCAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgaWYgKGFsbG93X2FzeW5jKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgZTtcblxuXHQgICAgICAgICAgICBlcnIgPSBlO1xuXHQgICAgICAgIH0pXG5cblx0ICAgICAgICAvLyBJZiBgYWxsb3dfYXN5bmNgIHdlIHdpbGwgYWx3YXlzIHJldHVybiBhIHByb21pc2Ugc2luY2Ugd2UgZG8gbm90XG5cdCAgICAgICAgLy8ga25vdyBpbiBhZHZhbmNlIGlmIHdlIGFyZSBnb2luZyB0byBydW4gYXN5bmNocm9ub3VzbHkgb3Igbm90LlxuXHQgICAgICAgIGlmIChhbGxvd19hc3luYylcblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cblx0ICAgICAgICAvLyBIYW5kbGUgZXJyb3JzIGhlcmUgaWYgd2UgZmFpbCBzeW5jaHJvbm91c2x5LlxuXHQgICAgICAgIGlmIChlcnIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IGVycjtcblxuXHQgICAgICAgIC8vIElmIGBhbGxvd19hc3luY2AgaXMgbm90IHRydWUgd2Ugc2hvdWxkIG5vdCBhbGxvdyB0aGUgdXNlclxuXHQgICAgICAgIC8vIHRvIHVzZSBhc3luY2hyb25vdXMgZnVuY3Rpb25zIG9yIGZpbHRlcnMuXG5cdCAgICAgICAgaWYgKGlzX2FzeW5jKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignWW91IGFyZSB1c2luZyBUd2lnLmpzIGluIHN5bmMgbW9kZSBpbiBjb21iaW5hdGlvbiB3aXRoIGFzeW5jIGV4dGVuc2lvbnMuJyk7XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXHQgICAgVHdpZy5UZW1wbGF0ZS5wcm90b3R5cGUuaW1wb3J0RmlsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcblx0ICAgICAgICB2YXIgdXJsLCBzdWJfdGVtcGxhdGU7XG5cdCAgICAgICAgaWYgKCF0aGlzLnVybCAmJiB0aGlzLm9wdGlvbnMuYWxsb3dJbmxpbmVJbmNsdWRlcykge1xuXHQgICAgICAgICAgICBmaWxlID0gdGhpcy5wYXRoID8gVHdpZy5wYXRoLnBhcnNlUGF0aCh0aGlzLCBmaWxlKSA6IGZpbGU7XG5cdCAgICAgICAgICAgIHN1Yl90ZW1wbGF0ZSA9IFR3aWcuVGVtcGxhdGVzLmxvYWQoZmlsZSk7XG5cblx0ICAgICAgICAgICAgaWYgKCFzdWJfdGVtcGxhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHN1Yl90ZW1wbGF0ZSA9IFR3aWcuVGVtcGxhdGVzLmxvYWRSZW1vdGUodXJsLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGUsXG5cdCAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB0aGlzLmdldExvYWRlck1ldGhvZCgpLFxuXHQgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICBwYXRoOiBmaWxlLFxuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIGlmICghc3ViX3RlbXBsYXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJVbmFibGUgdG8gZmluZCB0aGUgdGVtcGxhdGUgXCIgKyBmaWxlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHN1Yl90ZW1wbGF0ZS5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJfdGVtcGxhdGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdXJsID0gVHdpZy5wYXRoLnBhcnNlUGF0aCh0aGlzLCBmaWxlKTtcblxuXHQgICAgICAgIC8vIExvYWQgYmxvY2tzIGZyb20gYW4gZXh0ZXJuYWwgZmlsZVxuXHQgICAgICAgIHN1Yl90ZW1wbGF0ZSA9IFR3aWcuVGVtcGxhdGVzLmxvYWRSZW1vdGUodXJsLCB7XG5cdCAgICAgICAgICAgIG1ldGhvZDogdGhpcy5nZXRMb2FkZXJNZXRob2QoKSxcblx0ICAgICAgICAgICAgYmFzZTogdGhpcy5iYXNlLFxuXHQgICAgICAgICAgICBhc3luYzogZmFsc2UsXG5cdCAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcblx0ICAgICAgICAgICAgaWQ6IHVybFxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgcmV0dXJuIHN1Yl90ZW1wbGF0ZTtcblx0ICAgIH07XG5cblx0ICAgIFR3aWcuVGVtcGxhdGUucHJvdG90eXBlLmltcG9ydEJsb2NrcyA9IGZ1bmN0aW9uKGZpbGUsIG92ZXJyaWRlKSB7XG5cdCAgICAgICAgdmFyIHN1Yl90ZW1wbGF0ZSA9IHRoaXMuaW1wb3J0RmlsZShmaWxlKSxcblx0ICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcblx0ICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgIGtleTtcblxuXHQgICAgICAgIG92ZXJyaWRlID0gb3ZlcnJpZGUgfHwgZmFsc2U7XG5cblx0ICAgICAgICBzdWJfdGVtcGxhdGUucmVuZGVyKGNvbnRleHQpO1xuXG5cdCAgICAgICAgLy8gTWl4aW4gYmxvY2tzXG5cdCAgICAgICAgVHdpZy5mb3JFYWNoKE9iamVjdC5rZXlzKHN1Yl90ZW1wbGF0ZS5ibG9ja3MpLCBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgaWYgKG92ZXJyaWRlIHx8IHRoYXQuYmxvY2tzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5ibG9ja3Nba2V5XSA9IHN1Yl90ZW1wbGF0ZS5ibG9ja3Nba2V5XTtcblx0ICAgICAgICAgICAgICAgIHRoYXQuaW1wb3J0ZWRCbG9ja3MucHVzaChrZXkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLlRlbXBsYXRlLnByb3RvdHlwZS5pbXBvcnRNYWNyb3MgPSBmdW5jdGlvbihmaWxlKSB7XG5cdCAgICAgICAgdmFyIHVybCA9IFR3aWcucGF0aC5wYXJzZVBhdGgodGhpcywgZmlsZSk7XG5cblx0ICAgICAgICAvLyBsb2FkIHJlbW90ZSB0ZW1wbGF0ZVxuXHQgICAgICAgIHZhciByZW1vdGVUZW1wbGF0ZSA9IFR3aWcuVGVtcGxhdGVzLmxvYWRSZW1vdGUodXJsLCB7XG5cdCAgICAgICAgICAgIG1ldGhvZDogdGhpcy5nZXRMb2FkZXJNZXRob2QoKSxcblx0ICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxuXHQgICAgICAgICAgICBpZDogdXJsXG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICByZXR1cm4gcmVtb3RlVGVtcGxhdGU7XG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLlRlbXBsYXRlLnByb3RvdHlwZS5nZXRMb2FkZXJNZXRob2QgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICBpZiAodGhpcy5wYXRoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAnZnMnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy51cmwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICdhamF4Jztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kIHx8ICdmcyc7XG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLlRlbXBsYXRlLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgIC8vIGNvbXBpbGUgdGhlIHRlbXBsYXRlIGludG8gcmF3IEpTXG5cdCAgICAgICAgcmV0dXJuIFR3aWcuY29tcGlsZXIuY29tcGlsZSh0aGlzLCBvcHRpb25zKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlIHNhZmUgb3V0cHV0XG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IENvbnRlbnQgc2FmZSB0byBvdXRwdXRcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IENvbnRlbnQgd3JhcHBlZCBpbnRvIGEgU3RyaW5nXG5cdCAgICAgKi9cblxuXHQgICAgVHdpZy5NYXJrdXAgPSBmdW5jdGlvbihjb250ZW50LCBzdHJhdGVneSkge1xuXHQgICAgICAgIGlmKHR5cGVvZiBzdHJhdGVneSA9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgICBzdHJhdGVneSA9IHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJyAmJiBjb250ZW50Lmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgY29udGVudCA9IG5ldyBTdHJpbmcoY29udGVudCk7XG5cdCAgICAgICAgICAgIGNvbnRlbnQudHdpZ19tYXJrdXAgPSBzdHJhdGVneTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gVHdpZztcblxuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyAjIyB0d2lnLmNvbXBpbGVyLmpzXG5cdC8vXG5cdC8vIFRoaXMgZmlsZSBoYW5kbGVzIGNvbXBpbGluZyB0ZW1wbGF0ZXMgaW50byBKU1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG5cdCAgICAvKipcblx0ICAgICAqIE5hbWVzcGFjZSBmb3IgY29tcGlsYXRpb24uXG5cdCAgICAgKi9cblx0ICAgIFR3aWcuY29tcGlsZXIgPSB7XG5cdCAgICAgICAgbW9kdWxlOiB7fVxuXHQgICAgfTtcblxuXHQgICAgLy8gQ29tcGlsZSBhIFR3aWcgVGVtcGxhdGUgdG8gb3V0cHV0LlxuXHQgICAgVHdpZy5jb21waWxlci5jb21waWxlID0gZnVuY3Rpb24odGVtcGxhdGUsIG9wdGlvbnMpIHtcblx0ICAgICAgICAvLyBHZXQgdG9rZW5zXG5cdCAgICAgICAgdmFyIHRva2VucyA9IEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlLnRva2Vucylcblx0ICAgICAgICAgICAgLCBpZCA9IHRlbXBsYXRlLmlkXG5cdCAgICAgICAgICAgICwgb3V0cHV0O1xuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlKSB7XG5cdCAgICAgICAgICAgIGlmIChUd2lnLmNvbXBpbGVyLm1vZHVsZVtvcHRpb25zLm1vZHVsZV0gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJVbmFibGUgdG8gZmluZCBtb2R1bGUgdHlwZSBcIiArIG9wdGlvbnMubW9kdWxlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvdXRwdXQgPSBUd2lnLmNvbXBpbGVyLm1vZHVsZVtvcHRpb25zLm1vZHVsZV0oaWQsIHRva2Vucywgb3B0aW9ucy50d2lnKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBvdXRwdXQgPSBUd2lnLmNvbXBpbGVyLndyYXAoaWQsIHRva2Vucyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBvdXRwdXQ7XG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLmNvbXBpbGVyLm1vZHVsZSA9IHtcblx0ICAgICAgICBhbWQ6IGZ1bmN0aW9uKGlkLCB0b2tlbnMsIHBhdGhUb1R3aWcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICdkZWZpbmUoW1wiJyArIHBhdGhUb1R3aWcgKyAnXCJdLCBmdW5jdGlvbiAoVHdpZykge1xcblxcdHZhciB0d2lnLCB0ZW1wbGF0ZXM7XFxudHdpZyA9IFR3aWcudHdpZztcXG50ZW1wbGF0ZXMgPSAnICsgVHdpZy5jb21waWxlci53cmFwKGlkLCB0b2tlbnMpICsgJ1xcblxcdHJldHVybiB0ZW1wbGF0ZXM7XFxufSk7Jztcblx0ICAgICAgICB9XG5cdCAgICAgICAgLCBub2RlOiBmdW5jdGlvbihpZCwgdG9rZW5zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAndmFyIHR3aWcgPSByZXF1aXJlKFwidHdpZ1wiKS50d2lnO1xcbidcblx0ICAgICAgICAgICAgICAgICsgJ2V4cG9ydHMudGVtcGxhdGUgPSAnICsgVHdpZy5jb21waWxlci53cmFwKGlkLCB0b2tlbnMpXG5cdCAgICAgICAgfVxuXHQgICAgICAgICwgY2pzMjogZnVuY3Rpb24oaWQsIHRva2VucywgcGF0aFRvVHdpZykge1xuXHQgICAgICAgICAgICByZXR1cm4gJ21vZHVsZS5kZWNsYXJlKFt7IHR3aWc6IFwiJyArIHBhdGhUb1R3aWcgKyAnXCIgfV0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG4nXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICsgJ1xcdHZhciB0d2lnID0gcmVxdWlyZShcInR3aWdcIikudHdpZztcXG4nXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICsgJ1xcdGV4cG9ydHMudGVtcGxhdGUgPSAnICsgVHdpZy5jb21waWxlci53cmFwKGlkLCB0b2tlbnMpXG5cdCAgICAgICAgICAgICAgICAgICAgKyAnXFxufSk7J1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIFR3aWcuY29tcGlsZXIud3JhcCA9IGZ1bmN0aW9uKGlkLCB0b2tlbnMpIHtcblx0ICAgICAgICByZXR1cm4gJ3R3aWcoe2lkOlwiJytpZC5yZXBsYWNlKCdcIicsICdcXFxcXCInKSsnXCIsIGRhdGE6Jyt0b2tlbnMrJywgcHJlY29tcGlsZWQ6IHRydWV9KTtcXG4nO1xuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIFR3aWc7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vICMjIHR3aWcuZXhwcmVzc2lvbi5qc1xuXHQvL1xuXHQvLyBUaGlzIGZpbGUgaGFuZGxlcyB0b2tlbml6aW5nLCBjb21waWxpbmcgYW5kIHBhcnNpbmcgZXhwcmVzc2lvbnMuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFR3aWcpIHtcblx0ICAgIFwidXNlIHN0cmljdFwiO1xuXG5cdCAgICBmdW5jdGlvbiBwYXJzZVBhcmFtcyh0aGlzQXJnLCBwYXJhbXMsIGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAocGFyYW1zKVxuXHQgICAgICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuYXBwbHkodGhpc0FyZywgW3BhcmFtcywgY29udGV4dF0pO1xuXG5cdCAgICAgICAgcmV0dXJuIFR3aWcuUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBOYW1lc3BhY2UgZm9yIGV4cHJlc3Npb24gaGFuZGxpbmcuXG5cdCAgICAgKi9cblx0ICAgIFR3aWcuZXhwcmVzc2lvbiA9IHsgfTtcblxuXHQgICAgX193ZWJwYWNrX3JlcXVpcmVfXyg0KShUd2lnKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXNlcnZlZCB3b3JkIHRoYXQgY2FuJ3QgYmUgdXNlZCBhcyB2YXJpYWJsZSBuYW1lcy5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5leHByZXNzaW9uLnJlc2VydmVkV29yZHMgPSBbXG5cdCAgICAgICAgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJudWxsXCIsIFwiVFJVRVwiLCBcIkZBTFNFXCIsIFwiTlVMTFwiLCBcIl9jb250ZXh0XCIsIFwiYW5kXCIsIFwiYi1hbmRcIiwgXCJvclwiLCBcImItb3JcIiwgXCJiLXhvclwiLCBcImluXCIsIFwibm90IGluXCIsIFwiaWZcIlxuXHQgICAgXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgdHlwZSBvZiB0b2tlbnMgdXNlZCBpbiBleHByZXNzaW9ucy5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5leHByZXNzaW9uLnR5cGUgPSB7XG5cdCAgICAgICAgY29tbWE6ICAgICAgJ1R3aWcuZXhwcmVzc2lvbi50eXBlLmNvbW1hJyxcblx0ICAgICAgICBvcGVyYXRvcjoge1xuXHQgICAgICAgICAgICB1bmFyeTogICdUd2lnLmV4cHJlc3Npb24udHlwZS5vcGVyYXRvci51bmFyeScsXG5cdCAgICAgICAgICAgIGJpbmFyeTogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLmJpbmFyeSdcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN0cmluZzogICAgICdUd2lnLmV4cHJlc3Npb24udHlwZS5zdHJpbmcnLFxuXHQgICAgICAgIGJvb2w6ICAgICAgICdUd2lnLmV4cHJlc3Npb24udHlwZS5ib29sJyxcblx0ICAgICAgICBzbGljZTogICAgICAnVHdpZy5leHByZXNzaW9uLnR5cGUuc2xpY2UnLFxuXHQgICAgICAgIGFycmF5OiB7XG5cdCAgICAgICAgICAgIHN0YXJ0OiAgJ1R3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LnN0YXJ0Jyxcblx0ICAgICAgICAgICAgZW5kOiAgICAnVHdpZy5leHByZXNzaW9uLnR5cGUuYXJyYXkuZW5kJ1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgb2JqZWN0OiB7XG5cdCAgICAgICAgICAgIHN0YXJ0OiAgJ1R3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5zdGFydCcsXG5cdCAgICAgICAgICAgIGVuZDogICAgJ1R3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5lbmQnXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwYXJhbWV0ZXI6IHtcblx0ICAgICAgICAgICAgc3RhcnQ6ICAnVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLnN0YXJ0Jyxcblx0ICAgICAgICAgICAgZW5kOiAgICAnVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLmVuZCdcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN1YmV4cHJlc3Npb246IHtcblx0ICAgICAgICAgICAgc3RhcnQ6ICAnVHdpZy5leHByZXNzaW9uLnR5cGUuc3ViZXhwcmVzc2lvbi5zdGFydCcsXG5cdCAgICAgICAgICAgIGVuZDogICAgJ1R3aWcuZXhwcmVzc2lvbi50eXBlLnN1YmV4cHJlc3Npb24uZW5kJ1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAga2V5OiB7XG5cdCAgICAgICAgICAgIHBlcmlvZDogICAnVHdpZy5leHByZXNzaW9uLnR5cGUua2V5LnBlcmlvZCcsXG5cdCAgICAgICAgICAgIGJyYWNrZXRzOiAnVHdpZy5leHByZXNzaW9uLnR5cGUua2V5LmJyYWNrZXRzJ1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmlsdGVyOiAgICAgJ1R3aWcuZXhwcmVzc2lvbi50eXBlLmZpbHRlcicsXG5cdCAgICAgICAgX2Z1bmN0aW9uOiAgJ1R3aWcuZXhwcmVzc2lvbi50eXBlLl9mdW5jdGlvbicsXG5cdCAgICAgICAgdmFyaWFibGU6ICAgJ1R3aWcuZXhwcmVzc2lvbi50eXBlLnZhcmlhYmxlJyxcblx0ICAgICAgICBudW1iZXI6ICAgICAnVHdpZy5leHByZXNzaW9uLnR5cGUubnVtYmVyJyxcblx0ICAgICAgICBfbnVsbDogICAgICdUd2lnLmV4cHJlc3Npb24udHlwZS5udWxsJyxcblx0ICAgICAgICBjb250ZXh0OiAgICAnVHdpZy5leHByZXNzaW9uLnR5cGUuY29udGV4dCcsXG5cdCAgICAgICAgdGVzdDogICAgICAgJ1R3aWcuZXhwcmVzc2lvbi50eXBlLnRlc3QnXG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLmV4cHJlc3Npb24uc2V0ID0ge1xuXHQgICAgICAgIC8vIFdoYXQgY2FuIGZvbGxvdyBhbiBleHByZXNzaW9uIChpbiBnZW5lcmFsKVxuXHQgICAgICAgIG9wZXJhdGlvbnM6IFtcblx0ICAgICAgICAgICAgVHdpZy5leHByZXNzaW9uLnR5cGUuZmlsdGVyLFxuXHQgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5vcGVyYXRvci51bmFyeSxcblx0ICAgICAgICAgICAgVHdpZy5leHByZXNzaW9uLnR5cGUub3BlcmF0b3IuYmluYXJ5LFxuXHQgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5hcnJheS5lbmQsXG5cdCAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5lbmQsXG5cdCAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5lbmQsXG5cdCAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLnN1YmV4cHJlc3Npb24uZW5kLFxuXHQgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5jb21tYSxcblx0ICAgICAgICAgICAgVHdpZy5leHByZXNzaW9uLnR5cGUudGVzdFxuXHQgICAgICAgIF0sXG5cdCAgICAgICAgZXhwcmVzc2lvbnM6IFtcblx0ICAgICAgICAgICAgVHdpZy5leHByZXNzaW9uLnR5cGUuX2Z1bmN0aW9uLFxuXHQgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5ib29sLFxuXHQgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5zdHJpbmcsXG5cdCAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLnZhcmlhYmxlLFxuXHQgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5udW1iZXIsXG5cdCAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLl9udWxsLFxuXHQgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5jb250ZXh0LFxuXHQgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnQsXG5cdCAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LnN0YXJ0LFxuXHQgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5vYmplY3Quc3RhcnQsXG5cdCAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLnN1YmV4cHJlc3Npb24uc3RhcnQsXG5cdCAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLnVuYXJ5XG5cdCAgICAgICAgXVxuXHQgICAgfTtcblxuXHQgICAgLy8gTW9zdCBleHByZXNzaW9ucyBhbGxvdyBhICcuJyBvciAnWycgYWZ0ZXIgdGhlbSwgc28gd2UgcHJvdmlkZSBhIGNvbnZlbmllbmNlIHNldFxuXHQgICAgVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zX2V4dGVuZGVkID0gVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zLmNvbmNhdChbXG5cdCAgICAgICAgICAgICAgICAgICAgVHdpZy5leHByZXNzaW9uLnR5cGUua2V5LnBlcmlvZCxcblx0ICAgICAgICAgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5rZXkuYnJhY2tldHMsXG5cdCAgICAgICAgICAgICAgICAgICAgVHdpZy5leHByZXNzaW9uLnR5cGUuc2xpY2VdKTtcblxuXHQgICAgLy8gU29tZSBjb21tb25seSB1c2VkIGNvbXBpbGUgYW5kIHBhcnNlIGZ1bmN0aW9ucy5cblx0ICAgIFR3aWcuZXhwcmVzc2lvbi5mbiA9IHtcblx0ICAgICAgICBjb21waWxlOiB7XG5cdCAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG5cdCAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHB1c2hfYm90aDogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwYXJzZToge1xuXHQgICAgICAgICAgICBwdXNoOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwdXNoX3ZhbHVlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4udmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYW5kIGNvbXBpbGUvcGFyc2UgbG9naWMgdXNlZCB0byBtYXRjaCB0b2tlbnMgaW4gZXhwcmVzc2lvbnMuXG5cdCAgICAvL1xuXHQgICAgLy8gUHJvcGVydGllczpcblx0ICAgIC8vXG5cdCAgICAvLyAgICAgIHR5cGU6ICBUaGUgdHlwZSBvZiBleHByZXNzaW9uIHRoaXMgbWF0Y2hlc1xuXHQgICAgLy9cblx0ICAgIC8vICAgICAgcmVnZXg6IE9uZSBvciBtb3JlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaGUgdGhlIGZvcm1hdCBvZiB0aGUgdG9rZW4uXG5cdCAgICAvL1xuXHQgICAgLy8gICAgICBuZXh0OiAgVmFsaWQgdG9rZW5zIHRoYXQgY2FuIG9jY3VyIG5leHQgaW4gdGhlIGV4cHJlc3Npb24uXG5cdCAgICAvL1xuXHQgICAgLy8gRnVuY3Rpb25zOlxuXHQgICAgLy9cblx0ICAgIC8vICAgICAgY29tcGlsZTogQSBmdW5jdGlvbiB0aGF0IGNvbXBpbGVzIHRoZSByYXcgcmVndWxhciBleHByZXNzaW9uIG1hdGNoIGludG8gYSB0b2tlbi5cblx0ICAgIC8vXG5cdCAgICAvLyAgICAgIHBhcnNlOiAgIEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgdGhlIGNvbXBpbGVkIHRva2VuIGludG8gb3V0cHV0LlxuXHQgICAgLy9cblx0ICAgIFR3aWcuZXhwcmVzc2lvbi5kZWZpbml0aW9ucyA9IFtcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLnRlc3QsXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXmlzXFxzKyhub3QpP1xccyooW2EtekEtWl9dW2EtekEtWjAtOV9dKihcXHM/YXMpPykvLFxuXHQgICAgICAgICAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnMuY29uY2F0KFtUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnRdKSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmZpbHRlciAgID0gdG9rZW4ubWF0Y2hbMl07XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5tb2RpZmllciA9IHRva2VuLm1hdGNoWzFdO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW1zKHRoaXMsIHRva2VuLnBhcmFtcywgY29udGV4dClcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHBhcmFtcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBUd2lnLnRlc3QodG9rZW4uZmlsdGVyLCB2YWx1ZSwgcGFyYW1zKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5tb2RpZmllciA9PSAnbm90Jykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCFyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5jb21tYSxcblx0ICAgICAgICAgICAgLy8gTWF0Y2ggYSBjb21tYVxuXHQgICAgICAgICAgICByZWdleDogL14sLyxcblx0ICAgICAgICAgICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5leHByZXNzaW9ucy5jb25jYXQoW1R3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LmVuZCwgVHdpZy5leHByZXNzaW9uLnR5cGUub2JqZWN0LmVuZF0pLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGkgPSBzdGFjay5sZW5ndGggLSAxLFxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrX3Rva2VuO1xuXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW4udmFsdWU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIHBvcCB0b2tlbnMgb2ZmIHRoZSBzdGFjayB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgZm9yKDtpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrX3Rva2VuID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrX3Rva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5zdGFydFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgc3RhY2tfdG9rZW4udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLnN0YXJ0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBzdGFja190b2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5hcnJheS5zdGFydCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN0YWNrX3Rva2VuKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0YWNrX3Rva2VuKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogTWF0Y2ggYSBudW1iZXIgKGludGVnZXIgb3IgZGVjaW1hbClcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLm51bWJlcixcblx0ICAgICAgICAgICAgLy8gbWF0Y2ggYSBudW1iZXJcblx0ICAgICAgICAgICAgcmVnZXg6IC9eXFwtP1xcZCsoXFwuXFxkKyk/Lyxcblx0ICAgICAgICAgICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSBOdW1iZXIodG9rZW4udmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogVHdpZy5leHByZXNzaW9uLmZuLnBhcnNlLnB1c2hfdmFsdWVcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUub3BlcmF0b3IuYmluYXJ5LFxuXHQgICAgICAgICAgICAvLyBNYXRjaCBhbnkgb2YgPzosICssICosIC8sIC0sICUsIH4sIDwsIDw9LCA+LCA+PSwgIT0sID09LCAqKiwgPywgOiwgYW5kLCBiLWFuZCwgb3IsIGItb3IsIGIteG9yLCBpbiwgbm90IGluXG5cdCAgICAgICAgICAgIC8vIGFuZCwgb3IsIGluLCBub3QgaW4gY2FuIGJlIGZvbGxvd2VkIGJ5IGEgc3BhY2Ugb3IgcGFyZW50aGVzaXNcblx0ICAgICAgICAgICAgcmVnZXg6IC8oXlxcP1xcOnxeKGJcXC1hbmQpfF4oYlxcLW9yKXxeKGJcXC14b3IpfF5bXFwrXFwtfiVcXD9dfF5bXFw6XSg/IVxcZFxcXSl8XlshPV09PT98XlshPD5dPT98XlxcKlxcKj98XlxcL1xcLz98XihhbmQpW1xcKHxcXHMrXXxeKG9yKVtcXCh8XFxzK118XihpbilbXFwofFxccytdfF4obm90IGluKVtcXCh8XFxzK118XlxcLlxcLikvLFxuXHQgICAgICAgICAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0LmV4cHJlc3Npb25zLFxuXHQgICAgICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdGNoLCB0b2tlbnMpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaChtYXRjaFswXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FuZCgnOlxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29yKCc6XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW4oJzpcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdub3QgaW4oJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9TdHJpcCBvZmYgdGhlICggaWYgaXQgZXhpc3RzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXRjaFsyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG5cblx0ICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4udmFsdWUudHJpbSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdG9rZW4udmFsdWUsXG5cdCAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubG9va3VwKHZhbHVlLCB0b2tlbik7XG5cblx0ICAgICAgICAgICAgICAgIFR3aWcubG9nLnRyYWNlKFwiVHdpZy5leHByZXNzaW9uLmNvbXBpbGU6IFwiLCBcIk9wZXJhdG9yOiBcIiwgb3BlcmF0b3IsIFwiIGZyb20gXCIsIHZhbHVlKTtcblxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAoc3RhY2tbc3RhY2subGVuZ3RoLTFdLnR5cGUgPT0gVHdpZy5leHByZXNzaW9uLnR5cGUub3BlcmF0b3IudW5hcnkgfHwgc3RhY2tbc3RhY2subGVuZ3RoLTFdLnR5cGUgPT0gVHdpZy5leHByZXNzaW9uLnR5cGUub3BlcmF0b3IuYmluYXJ5KSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcGVyYXRvci5hc3NvY2lhdGl2aXR5ID09PSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IucHJlY2lkZW5jZSAgICA+PSBzdGFja1tzdGFjay5sZW5ndGgtMV0ucHJlY2lkZW5jZSkgfHxcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcGVyYXRvci5hc3NvY2lhdGl2aXR5ID09PSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IucmlnaHRUb0xlZnQgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IucHJlY2lkZW5jZSAgICA+ICBzdGFja1tzdGFjay5sZW5ndGgtMV0ucHJlY2lkZW5jZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblx0ICAgICAgICAgICAgICAgICAgICAgICApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godGVtcCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCI6XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgdGVybmFyeSBvciBvYmplY3Qga2V5IGJlaW5nIHNldFxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSAmJiBzdGFja1tzdGFjay5sZW5ndGgtMV0udmFsdWUgPT09IFwiP1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGFzIG5vcm1hbCBmb3IgYSB0ZXJuYXJ5XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSB0ZXJuYXJ5IHNvIHdlIHB1c2ggdGhlIHRva2VuIHRvIHRoZSBvdXRwdXQgd2hlcmUgaXQgY2FuIGJlIGhhbmRsZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3aGVuIHRoZSBhc3NvY2F0ZWQgb2JqZWN0IGlzIGNsb3NlZC5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleV90b2tlbiA9IG91dHB1dC5wb3AoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5X3Rva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnN0cmluZyB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleV90b2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS52YXJpYWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ua2V5ID0ga2V5X3Rva2VuLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleV90b2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5udW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgaW50ZWdlciBrZXlzIGludG8gc3RyaW5nIGtleXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmtleSA9IGtleV90b2tlbi52YWx1ZS50b1N0cmluZygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleV90b2tlbi5leHByZXNzaW9uICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAoa2V5X3Rva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5lbmQgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleV90b2tlbi50eXBlID09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnN1YmV4cHJlc3Npb24uZW5kKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ucGFyYW1zID0ga2V5X3Rva2VuLnBhcmFtcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSBiZWZvcmUgJzonIG9mIFwiICsga2V5X3Rva2VuLnR5cGUgKyBcIiA9IFwiICsga2V5X3Rva2VuLnZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChvcGVyYXRvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi5rZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGVybmFyeSAnOicgb3BlcmF0b3Jcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIFwieyhleHByZXNzaW9uKTp2YWx1ZX1cIlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5hcHBseSh0aGlzLCBbdG9rZW4ucGFyYW1zLCBjb250ZXh0XSlcblx0ICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ua2V5ID0ga2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHdlJ3JlIGluIGEgbG9vcCwgd2UgbWlnaHQgbmVlZCB0b2tlbi5wYXJhbXMgbGF0ZXIsIGVzcGVjaWFsbHkgaW4gdGhpcyBmb3JtIG9mIFwiKGV4cHJlc3Npb24pOnZhbHVlXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0Lmxvb3ApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSh0b2tlbi5wYXJhbXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5wYXJzZSh0b2tlbi52YWx1ZSwgc3RhY2spO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLnVuYXJ5LFxuXHQgICAgICAgICAgICAvLyBNYXRjaCBhbnkgb2Ygbm90XG5cdCAgICAgICAgICAgIHJlZ2V4OiAvKF5ub3RcXHMrKS8sXG5cdCAgICAgICAgICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQuZXhwcmVzc2lvbnMsXG5cdCAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG5cblx0ICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4udmFsdWUudHJpbSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdG9rZW4udmFsdWUsXG5cdCAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubG9va3VwKHZhbHVlLCB0b2tlbik7XG5cblx0ICAgICAgICAgICAgICAgIFR3aWcubG9nLnRyYWNlKFwiVHdpZy5leHByZXNzaW9uLmNvbXBpbGU6IFwiLCBcIk9wZXJhdG9yOiBcIiwgb3BlcmF0b3IsIFwiIGZyb20gXCIsIHZhbHVlKTtcblxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAoc3RhY2tbc3RhY2subGVuZ3RoLTFdLnR5cGUgPT0gVHdpZy5leHByZXNzaW9uLnR5cGUub3BlcmF0b3IudW5hcnkgfHwgc3RhY2tbc3RhY2subGVuZ3RoLTFdLnR5cGUgPT0gVHdpZy5leHByZXNzaW9uLnR5cGUub3BlcmF0b3IuYmluYXJ5KSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcGVyYXRvci5hc3NvY2lhdGl2aXR5ID09PSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IucHJlY2lkZW5jZSAgICA+PSBzdGFja1tzdGFjay5sZW5ndGgtMV0ucHJlY2lkZW5jZSkgfHxcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcGVyYXRvci5hc3NvY2lhdGl2aXR5ID09PSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IucmlnaHRUb0xlZnQgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IucHJlY2lkZW5jZSAgICA+ICBzdGFja1tzdGFjay5sZW5ndGgtMV0ucHJlY2lkZW5jZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblx0ICAgICAgICAgICAgICAgICAgICAgICApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godGVtcCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gob3BlcmF0b3IpO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IucGFyc2UodG9rZW4udmFsdWUsIHN0YWNrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogTWF0Y2ggYSBzdHJpbmcuIFRoaXMgaXMgYW55dGhpbmcgYmV0d2VlbiBhIHBhaXIgb2Ygc2luZ2xlIG9yIGRvdWJsZSBxdW90ZXMuXG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5zdHJpbmcsXG5cdCAgICAgICAgICAgIC8vIFNlZTogaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL21hdGNoLXF1b3RlZC1zdHJpbmdcblx0ICAgICAgICAgICAgcmVnZXg6IC9eKFtcIiddKSg/Oig/PShcXFxcPykpXFwyW1xcc1xcU10pKj9cXDEvLFxuXHQgICAgICAgICAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnNfZXh0ZW5kZWQsXG5cdCAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaFxuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHF1b3RlcyBmcm9tIHRoZSBzdHJpbmdcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdWJzdHJpbmcoMCwgMSkgPT09ICdcIicpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJ1xcXFxcIicsICdcIicpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXCJcXFxcJ1wiLCBcIidcIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGgtMSkucmVwbGFjZSggL1xcXFxuL2csIFwiXFxuXCIgKS5yZXBsYWNlKCAvXFxcXHIvZywgXCJcXHJcIiApO1xuXHQgICAgICAgICAgICAgICAgVHdpZy5sb2cudHJhY2UoXCJUd2lnLmV4cHJlc3Npb24uY29tcGlsZTogXCIsIFwiU3RyaW5nIHZhbHVlOiBcIiwgdG9rZW4udmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogVHdpZy5leHByZXNzaW9uLmZuLnBhcnNlLnB1c2hfdmFsdWVcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIE1hdGNoIGEgc3ViZXhwcmVzc2lvbiBzZXQgc3RhcnQuXG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLnN0YXJ0LFxuXHQgICAgICAgICAgICByZWdleDogL15cXCgvLFxuXHQgICAgICAgICAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0LmV4cHJlc3Npb25zLmNvbmNhdChbVHdpZy5leHByZXNzaW9uLnR5cGUuc3ViZXhwcmVzc2lvbi5lbmRdKSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gJygnO1xuXHQgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBUd2lnLmV4cHJlc3Npb24uZm4ucGFyc2UucHVzaFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogTWF0Y2ggYSBzdWJleHByZXNzaW9uIHNldCBlbmQuXG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLmVuZCxcblx0ICAgICAgICAgICAgcmVnZXg6IC9eXFwpLyxcblx0ICAgICAgICAgICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zX2V4dGVuZGVkLFxuXHQgICAgICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24obWF0Y2gsIHRva2Vucykge1xuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSBiYWNrIHRocm91Z2ggcHJldmlvdXMgdG9rZW5zIHRvIGVuc3VyZSB3ZSBmb2xsb3cgYSBzdWJleHByZXNzaW9uIHN0YXJ0XG5cdCAgICAgICAgICAgICAgICB2YXIgaSA9IHRva2Vucy5sZW5ndGggLSAxLFxuXHQgICAgICAgICAgICAgICAgICAgIGZvdW5kX3N1YmV4cHJlc3Npb25fc3RhcnQgPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0X3N1YmV4cHJlc3Npb25fc3RhcnRfaW52YWxpZCA9IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkX3BhcmFtZXRlcl9jb3VudCA9IDA7XG5cblx0ICAgICAgICAgICAgICAgIHdoaWxlKCFmb3VuZF9zdWJleHByZXNzaW9uX3N0YXJ0ICYmIGkgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGZvdW5kX3N1YmV4cHJlc3Npb25fc3RhcnQgPSB0b2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLnN0YXJ0O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBwcmV2aW91c2x5IGZvdW5kIGEgc3ViZXhwcmVzc2lvbiBlbmQsIHRoZW4gdGhpcyBzdWJleHByZXNzaW9uIHN0YXJ0IGlzIHRoZSBzdGFydCBvZlxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgc3ViZXhwcmVzc2lvbiwgbm90IHRoZSBzdWJleHByZXNzaW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kX3N1YmV4cHJlc3Npb25fc3RhcnQgJiYgbmV4dF9zdWJleHByZXNzaW9uX3N0YXJ0X2ludmFsaWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV4dF9zdWJleHByZXNzaW9uX3N0YXJ0X2ludmFsaWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRfc3ViZXhwcmVzc2lvbl9zdGFydCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENvdW50IHBhcmFtZXRlciB0b2tlbnMgdG8gZW5zdXJlIHdlIGRvbnQgcmV0dXJuIHRydXRoeSBmb3IgYSBwYXJhbWV0ZXIgb3BlbmVyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5zdGFydCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1bmNsb3NlZF9wYXJhbWV0ZXJfY291bnQrKztcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5lbmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdW5jbG9zZWRfcGFyYW1ldGVyX2NvdW50LS07XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLmVuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXh0X3N1YmV4cHJlc3Npb25fc3RhcnRfaW52YWxpZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaS0tO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCB1bmNsb3NlZCBwYXJhbWV0ZXJzLCByZXR1cm4gZmFsc2Vcblx0ICAgICAgICAgICAgICAgIC8vIElmIHdlIGRpZG50IGZpbmQgc3ViZXhwcmVzc2lvbiBzdGFydCwgcmV0dXJuIGZhbHNlXG5cdCAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRydWVcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChmb3VuZF9zdWJleHByZXNzaW9uX3N0YXJ0ICYmICh1bmNsb3NlZF9wYXJhbWV0ZXJfY291bnQgPT09IDApKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYmFzaWNhbGx5IGEgY29weSBvZiBwYXJhbWV0ZXIgZW5kIGNvbXBpbGF0aW9uXG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhY2tfdG9rZW4sXG5cdCAgICAgICAgICAgICAgICAgICAgZW5kX3Rva2VuID0gdG9rZW47XG5cblx0ICAgICAgICAgICAgICAgIHN0YWNrX3Rva2VuID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgICAgICB3aGlsZShzdGFjay5sZW5ndGggPiAwICYmIHN0YWNrX3Rva2VuLnR5cGUgIT0gVHdpZy5leHByZXNzaW9uLnR5cGUuc3ViZXhwcmVzc2lvbi5zdGFydCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0YWNrX3Rva2VuKTtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFja190b2tlbiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBNb3ZlIGNvbnRlbnRzIG9mIHBhcmVucyBpbnRvIHByZWNlZGluZyBmaWx0ZXJcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJhbV9zdGFjayA9IFtdO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUodG9rZW4udHlwZSAhPT0gVHdpZy5leHByZXNzaW9uLnR5cGUuc3ViZXhwcmVzc2lvbi5zdGFydCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0b2tlbiB0byBhcmd1bWVudHMgc3RhY2tcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbV9zdGFjay51bnNoaWZ0KHRva2VuKTtcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IG91dHB1dC5wb3AoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcGFyYW1fc3RhY2sudW5zaGlmdCh0b2tlbik7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBpc19leHByZXNzaW9uID0gZmFsc2U7XG5cblx0ICAgICAgICAgICAgICAgIC8vSWYgdGhlIHRva2VuIGF0IHRoZSB0b3Agb2YgdGhlICpzdGFjayogaXMgYSBmdW5jdGlvbiB0b2tlbiwgcG9wIGl0IG9udG8gdGhlIG91dHB1dCBxdWV1ZS5cblx0ICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG9rZW4gcHJlY2VkaW5nIHRoZSBwYXJhbWV0ZXJzXG5cdCAgICAgICAgICAgICAgICBzdGFja190b2tlbiA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHN0YWNrX3Rva2VuID09PSB1bmRlZmluZWQgfHxcblx0ICAgICAgICAgICAgICAgICAgICAoc3RhY2tfdG9rZW4udHlwZSAhPT0gVHdpZy5leHByZXNzaW9uLnR5cGUuX2Z1bmN0aW9uICYmXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2tfdG9rZW4udHlwZSAhPT0gVHdpZy5leHByZXNzaW9uLnR5cGUuZmlsdGVyICYmXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2tfdG9rZW4udHlwZSAhPT0gVHdpZy5leHByZXNzaW9uLnR5cGUudGVzdCAmJlxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrX3Rva2VuLnR5cGUgIT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLmtleS5icmFja2V0cykpIHtcblxuXHQgICAgICAgICAgICAgICAgICAgIGVuZF90b2tlbi5leHByZXNzaW9uID0gdHJ1ZTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzdGFydCBhbmQgZW5kIHRva2VuIGZyb20gc3RhY2tcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbV9zdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbV9zdGFjay5zaGlmdCgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgZW5kX3Rva2VuLnBhcmFtcyA9IHBhcmFtX3N0YWNrO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZW5kX3Rva2VuKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgYmUgaGl0XG5cdCAgICAgICAgICAgICAgICAgICAgZW5kX3Rva2VuLmV4cHJlc3Npb24gPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFja190b2tlbi5wYXJhbXMgPSBwYXJhbV9zdGFjaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHRva2VuLCBzdGFjaywgY29udGV4dCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5ld19hcnJheSA9IFtdLFxuXHQgICAgICAgICAgICAgICAgICAgIGFycmF5X2VuZGVkID0gZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXhwcmVzc2lvbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5hcHBseSh0aGlzLCBbdG9rZW4ucGFyYW1zLCBjb250ZXh0XSlcblx0ICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJVbmV4cGVjdGVkIHN1YmV4cHJlc3Npb24gZW5kIHdoZW4gdG9rZW4gaXMgbm90IG1hcmtlZCBhcyBhbiBleHByZXNzaW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBNYXRjaCBhIHBhcmFtZXRlciBzZXQgc3RhcnQuXG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnQsXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXlxcKC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQuZXhwcmVzc2lvbnMuY29uY2F0KFtUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuZW5kXSksXG5cdCAgICAgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbihtYXRjaCwgdG9rZW5zKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbGFzdF90b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCB1c2UgdGhlIHJlZ2V4IHRvIHRlc3QgaWYgd2UgZm9sbG93IGEgc3BhY2UgYmVjYXVzZSBleHByZXNzaW9uIGlzIHRyaW1tZWRcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsYXN0X3Rva2VuICYmIChUd2lnLmluZGV4T2YoVHdpZy5leHByZXNzaW9uLnJlc2VydmVkV29yZHMsIGxhc3RfdG9rZW4udmFsdWUudHJpbSgpKSA8IDApO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBjb21waWxlOiBUd2lnLmV4cHJlc3Npb24uZm4uY29tcGlsZS5wdXNoX2JvdGgsXG5cdCAgICAgICAgICAgIHBhcnNlOiBUd2lnLmV4cHJlc3Npb24uZm4ucGFyc2UucHVzaFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogTWF0Y2ggYSBwYXJhbWV0ZXIgc2V0IGVuZC5cblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5lbmQsXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXlxcKS8sXG5cdCAgICAgICAgICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQub3BlcmF0aW9uc19leHRlbmRlZCxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdGFja190b2tlbixcblx0ICAgICAgICAgICAgICAgICAgICBlbmRfdG9rZW4gPSB0b2tlbjtcblxuXHQgICAgICAgICAgICAgICAgc3RhY2tfdG9rZW4gPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tfdG9rZW4udHlwZSAhPSBUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdGFja190b2tlbik7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2tfdG9rZW4gPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gTW92ZSBjb250ZW50cyBvZiBwYXJlbnMgaW50byBwcmVjZWRpbmcgZmlsdGVyXG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyYW1fc3RhY2sgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlKHRva2VuLnR5cGUgIT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5zdGFydCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0b2tlbiB0byBhcmd1bWVudHMgc3RhY2tcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbV9zdGFjay51bnNoaWZ0KHRva2VuKTtcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IG91dHB1dC5wb3AoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHBhcmFtX3N0YWNrLnVuc2hpZnQodG9rZW4pO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgaXNfZXhwcmVzc2lvbiA9IGZhbHNlO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIHByZWNlZGluZyB0aGUgcGFyYW1ldGVyc1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBvdXRwdXRbb3V0cHV0Lmxlbmd0aC0xXTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQgfHxcblx0ICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSAhPT0gVHdpZy5leHByZXNzaW9uLnR5cGUuX2Z1bmN0aW9uICYmXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gVHdpZy5leHByZXNzaW9uLnR5cGUuZmlsdGVyICYmXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gVHdpZy5leHByZXNzaW9uLnR5cGUudGVzdCAmJlxuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgIT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLmtleS5icmFja2V0cykpIHtcblxuXHQgICAgICAgICAgICAgICAgICAgIGVuZF90b2tlbi5leHByZXNzaW9uID0gdHJ1ZTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzdGFydCBhbmQgZW5kIHRva2VuIGZyb20gc3RhY2tcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbV9zdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbV9zdGFjay5zaGlmdCgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgZW5kX3Rva2VuLnBhcmFtcyA9IHBhcmFtX3N0YWNrO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZW5kX3Rva2VuKTtcblxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmRfdG9rZW4uZXhwcmVzc2lvbiA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuLnBhcmFtcyA9IHBhcmFtX3N0YWNrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmV3X2FycmF5ID0gW10sXG5cdCAgICAgICAgICAgICAgICAgICAgYXJyYXlfZW5kZWQgPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi5leHByZXNzaW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmFwcGx5KHRoaXMsIFt0b2tlbi5wYXJhbXMsIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggdmFsdWVzIGludG8gdGhlIGFycmF5IHVudGlsIHRoZSBzdGFydCBvZiB0aGUgYXJyYXlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgJiYgdmFsdWUudHlwZSA9PSBUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X2VuZGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ld19hcnJheS51bnNoaWZ0KHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFycmF5X2VuZGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHBhcmFtZXRlciBzZXQuXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3X2FycmF5KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5zbGljZSxcblx0ICAgICAgICAgICAgcmVnZXg6IC9eXFxbKFxcZCpcXDpcXGQqKVxcXS8sXG5cdCAgICAgICAgICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQub3BlcmF0aW9uc19leHRlbmRlZCxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzbGljZVJhbmdlID0gdG9rZW4ubWF0Y2hbMV0uc3BsaXQoJzonKTtcblxuXHQgICAgICAgICAgICAgICAgLy9zbGljZVN0YXJ0IGNhbiBiZSB1bmRlZmluZWQgd2hlbiB3ZSBwYXNzIHBhcmFtZXRlcnMgdG8gdGhlIHNsaWNlIGZpbHRlciBsYXRlclxuXHQgICAgICAgICAgICAgICAgdmFyIHNsaWNlU3RhcnQgPSAoc2xpY2VSYW5nZVswXSkgPyBwYXJzZUludChzbGljZVJhbmdlWzBdKSA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgIHZhciBzbGljZUVuZCA9IChzbGljZVJhbmdlWzFdKSA/IHBhcnNlSW50KHNsaWNlUmFuZ2VbMV0pIDogdW5kZWZpbmVkO1xuXG5cdCAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9ICdzbGljZSc7XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5wYXJhbXMgPSBbc2xpY2VTdGFydCwgc2xpY2VFbmRdO1xuXG5cdCAgICAgICAgICAgICAgICAvL3NsaWNlRW5kIGNhbid0IGJlIHVuZGVmaW5lZCBhcyB0aGUgc2xpY2UgZmlsdGVyIGRvZXNuJ3QgY2hlY2sgZm9yIHRoaXMsIGJ1dCBpdCBkb2VzIGNoZWNrIHRoZSBsZW5ndGhcblx0ICAgICAgICAgICAgICAgIC8vb2YgdGhlIHBhcmFtcyBhcnJheSwgc28ganVzdCBzaG9ydGVuIGl0LlxuXHQgICAgICAgICAgICAgICAgaWYgKCFzbGljZUVuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuLnBhcmFtcyA9IFtzbGljZVN0YXJ0XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBzdGFjay5wb3AoKSxcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB0b2tlbi5wYXJhbXM7XG5cblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goVHdpZy5maWx0ZXIuYXBwbHkodGhpcywgW3Rva2VuLnZhbHVlLCBpbnB1dCwgcGFyYW1zXSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBNYXRjaCBhbiBhcnJheSBzdGFydC5cblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LnN0YXJ0LFxuXHQgICAgICAgICAgICByZWdleDogL15cXFsvLFxuXHQgICAgICAgICAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0LmV4cHJlc3Npb25zLmNvbmNhdChbVHdpZy5leHByZXNzaW9uLnR5cGUuYXJyYXkuZW5kXSksXG5cdCAgICAgICAgICAgIGNvbXBpbGU6IFR3aWcuZXhwcmVzc2lvbi5mbi5jb21waWxlLnB1c2hfYm90aCxcblx0ICAgICAgICAgICAgcGFyc2U6IFR3aWcuZXhwcmVzc2lvbi5mbi5wYXJzZS5wdXNoXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBNYXRjaCBhbiBhcnJheSBlbmQuXG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5hcnJheS5lbmQsXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXlxcXS8sXG5cdCAgICAgICAgICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQub3BlcmF0aW9uc19leHRlbmRlZCxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoIC0gMSxcblx0ICAgICAgICAgICAgICAgICAgICBzdGFja190b2tlbjtcblx0ICAgICAgICAgICAgICAgIC8vIHBvcCB0b2tlbnMgb2ZmIHRoZSBzdGFjayB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgZm9yKDtpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrX3Rva2VuID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrX3Rva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LnN0YXJ0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdGFja190b2tlbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuZXdfYXJyYXkgPSBbXSxcblx0ICAgICAgICAgICAgICAgICAgICBhcnJheV9lbmRlZCA9IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcblxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggdmFsdWVzIGludG8gdGhlIGFycmF5IHVudGlsIHRoZSBzdGFydCBvZiB0aGUgYXJyYXlcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSAmJiB2YWx1ZS50eXBlID09IFR3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LnN0YXJ0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X2VuZGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIG5ld19hcnJheS51bnNoaWZ0KHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICghYXJyYXlfZW5kZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiBhcnJheS5cIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3X2FycmF5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy8gVG9rZW4gdGhhdCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhIGhhc2ggbWFwICd9J1xuXHQgICAgICAgIC8vXG5cdCAgICAgICAgLy8gSGFzaCBtYXBzIHRha2UgdGhlIGZvcm06XG5cdCAgICAgICAgLy8gICAgeyBcImtleVwiOiAndmFsdWUnLCBcImFub3RoZXJfa2V5XCI6IGl0ZW0gfVxuXHQgICAgICAgIC8vXG5cdCAgICAgICAgLy8gS2V5cyBtdXN0IGJlIHF1b3RlZCAoZWl0aGVyIHNpbmdsZSBvciBkb3VibGUpIGFuZCB2YWx1ZXMgY2FuIGJlIGFueSBleHByZXNzaW9uLlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUub2JqZWN0LnN0YXJ0LFxuXHQgICAgICAgICAgICByZWdleDogL15cXHsvLFxuXHQgICAgICAgICAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0LmV4cHJlc3Npb25zLmNvbmNhdChbVHdpZy5leHByZXNzaW9uLnR5cGUub2JqZWN0LmVuZF0pLFxuXHQgICAgICAgICAgICBjb21waWxlOiBUd2lnLmV4cHJlc3Npb24uZm4uY29tcGlsZS5wdXNoX2JvdGgsXG5cdCAgICAgICAgICAgIHBhcnNlOiBUd2lnLmV4cHJlc3Npb24uZm4ucGFyc2UucHVzaFxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvLyBUb2tlbiB0aGF0IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhIEhhc2ggTWFwICd9J1xuXHQgICAgICAgIC8vXG5cdCAgICAgICAgLy8gVGhpcyBpcyB3aGVyZSB0aGUgbG9naWMgZm9yIGJ1aWxkaW5nIHRoZSBpbnRlcm5hbFxuXHQgICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIG9mIGEgaGFzaCBtYXAgaXMgZGVmaW5lZC5cblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5lbmQsXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXlxcfS8sXG5cdCAgICAgICAgICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQub3BlcmF0aW9uc19leHRlbmRlZCxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoLTEsXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2tfdG9rZW47XG5cblx0ICAgICAgICAgICAgICAgIC8vIHBvcCB0b2tlbnMgb2ZmIHRoZSBzdGFjayB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgZm9yKDtpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrX3Rva2VuID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrX3Rva2VuICYmIHN0YWNrX3Rva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5zdGFydCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RhY2tfdG9rZW4pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24oZW5kX3Rva2VuLCBzdGFjaywgY29udGV4dCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5ld19vYmplY3QgPSB7fSxcblx0ICAgICAgICAgICAgICAgICAgICBvYmplY3RfZW5kZWQgPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IG51bGwsXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW5fa2V5ID0gbnVsbCxcblx0ICAgICAgICAgICAgICAgICAgICBoYXNfdmFsdWUgPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQdXNoIHZhbHVlcyBpbnRvIHRoZSBhcnJheSB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi50eXBlICYmIHRva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5zdGFydCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RfZW5kZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnR5cGUgJiYgKHRva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLmJpbmFyeSB8fCB0b2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5vcGVyYXRvci51bmFyeSkgJiYgdG9rZW4ua2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzX3ZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIGtleSAnXCIgKyB0b2tlbi5rZXkgKyBcIicgaW4gb2JqZWN0IGRlZmluaXRpb24uXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ld19vYmplY3RbdG9rZW4ua2V5XSA9IHZhbHVlO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBvcmRlciB0aGF0IGVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGUgbWFwXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHNpbmNlIEphdmFTY3JpcHQgb2JqZWN0cyBkb24ndFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBndWFyYW50ZWUgdGhlIG9yZGVyIG9mIGtleXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld19vYmplY3QuX2tleXMgPT09IHVuZGVmaW5lZCkgbmV3X29iamVjdC5fa2V5cyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXdfb2JqZWN0Ll9rZXlzLnVuc2hpZnQodG9rZW4ua2V5KTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB2YWx1ZSBjaGVja1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc192YWx1ZSA9IGZhbHNlO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzX3ZhbHVlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlbjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoIW9iamVjdF9lbmRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2Ygb2JqZWN0LlwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXdfb2JqZWN0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvLyBUb2tlbiByZXByZXNlbnRpbmcgYSBmaWx0ZXJcblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vIEZpbHRlcnMgY2FuIGZvbGxvdyBhbnkgZXhwcmVzc2lvbiBhbmQgdGFrZSB0aGUgZm9ybTpcblx0ICAgICAgICAvLyAgICBleHByZXNzaW9ufGZpbHRlcihvcHRpb25hbCwgYXJncylcblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vIEZpbHRlciBwYXJzaW5nIGlzIGRvbmUgaW4gdGhlIFR3aWcuZmlsdGVycyBuYW1lc3BhY2UuXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5maWx0ZXIsXG5cdCAgICAgICAgICAgIC8vIG1hdGNoIGEgfCB0aGVuIGEgbGV0dGVyIG9yIF8sIHRoZW4gYW55IG51bWJlciBvZiBsZXR0ZXJzLCBudW1iZXJzLCBfIG9yIC1cblx0ICAgICAgICAgICAgcmVnZXg6IC9eXFx8XFxzPyhbYS16QS1aX11bYS16QS1aMC05X1xcLV0qKS8sXG5cdCAgICAgICAgICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQub3BlcmF0aW9uc19leHRlbmRlZC5jb25jYXQoW1xuXHQgICAgICAgICAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5zdGFydF0pLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi5tYXRjaFsxXTtcblx0ICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHRva2VuLCBzdGFjaywgY29udGV4dCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gc3RhY2sucG9wKCk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtcyh0aGlzLCB0b2tlbi5wYXJhbXMsIGNvbnRleHQpXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihwYXJhbXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5maWx0ZXIuYXBwbHkodGhhdCwgW3Rva2VuLnZhbHVlLCBpbnB1dCwgcGFyYW1zXSk7XG5cdCAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLl9mdW5jdGlvbixcblx0ICAgICAgICAgICAgLy8gbWF0Y2ggYW55IGxldHRlciBvciBfLCB0aGVuIGFueSBudW1iZXIgb2YgbGV0dGVycywgbnVtYmVycywgXyBvciAtIGZvbGxvd2VkIGJ5IChcblx0ICAgICAgICAgICAgcmVnZXg6IC9eKFthLXpBLVpfXVthLXpBLVowLTlfXSopXFxzKlxcKC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5zdGFydCxcblx0ICAgICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKG1hdGNoLCB0b2tlbnMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBhIHJlc2VydmVkIHdvcmRcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaFsxXSAmJiAoVHdpZy5pbmRleE9mKFR3aWcuZXhwcmVzc2lvbi5yZXNlcnZlZFdvcmRzLCBtYXRjaFsxXSkgPCAwKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRjaCwgdG9rZW5zKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJygnO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZuID0gdG9rZW4ubWF0Y2hbMV07XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5mbiA9IGZuO1xuXHQgICAgICAgICAgICAgICAgLy8gY2xlYW51cCB0b2tlblxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLnZhbHVlO1xuXG5cdCAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIGNvbnRleHQpIHtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgICAgIGZuID0gdG9rZW4uZm4sXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtcyh0aGlzLCB0b2tlbi5wYXJhbXMsIGNvbnRleHQpXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihwYXJhbXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoVHdpZy5mdW5jdGlvbnNbZm5dKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZnVuY3Rpb24gZnJvbSB0aGUgYnVpbHQtaW4gZnVuY3Rpb25zXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gVHdpZy5mdW5jdGlvbnNbZm5dLmFwcGx5KHRoYXQsIHBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0W2ZuXSA9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZnVuY3Rpb24gZnJvbSB0aGUgdXNlci9jb250ZXh0IGRlZmluZWQgZnVuY3Rpb25zXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29udGV4dFtmbl0uYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKGZuICsgJyBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCBhbmQgaXMgbm90IGRlZmluZWQgaW4gdGhlIGNvbnRleHQnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLy8gVG9rZW4gcmVwcmVzZW50aW5nIGEgdmFyaWFibGUuXG5cdCAgICAgICAgLy9cblx0ICAgICAgICAvLyBWYXJpYWJsZXMgY2FuIGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgdW5kZXJzY29yZXMgYW5kXG5cdCAgICAgICAgLy8gZGFzaGVzLCBidXQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyIG9yIHVuZGVyc2NvcmUuXG5cdCAgICAgICAgLy9cblx0ICAgICAgICAvLyBWYXJpYWJsZXMgYXJlIHJldHJpZXZlZCBmcm9tIHRoZSByZW5kZXIgY29udGV4dCBhbmQgdGFrZVxuXHQgICAgICAgIC8vIHRoZSB2YWx1ZSBvZiAndW5kZWZpbmVkJyBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgZG9lc24ndFxuXHQgICAgICAgIC8vIGV4aXN0IGluIHRoZSBjb250ZXh0LlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUudmFyaWFibGUsXG5cdCAgICAgICAgICAgIC8vIG1hdGNoIGFueSBsZXR0ZXIgb3IgXywgdGhlbiBhbnkgbnVtYmVyIG9mIGxldHRlcnMsIG51bWJlcnMsIF8gb3IgLVxuXHQgICAgICAgICAgICByZWdleDogL15bYS16QS1aX11bYS16QS1aMC05X10qLyxcblx0ICAgICAgICAgICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zX2V4dGVuZGVkLmNvbmNhdChbXG5cdCAgICAgICAgICAgICAgICAgICAgVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLnN0YXJ0XSksXG5cdCAgICAgICAgICAgIGNvbXBpbGU6IFR3aWcuZXhwcmVzc2lvbi5mbi5jb21waWxlLnB1c2gsXG5cdCAgICAgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbihtYXRjaCwgdG9rZW5zKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKFR3aWcuaW5kZXhPZihUd2lnLmV4cHJlc3Npb24ucmVzZXJ2ZWRXb3JkcywgbWF0Y2hbMF0pIDwgMCk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdmFyaWFibGUgZnJvbSB0aGUgY29udGV4dFxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5yZXNvbHZlQXN5bmMuYXBwbHkodGhpcywgW2NvbnRleHRbdG9rZW4udmFsdWVdLCBjb250ZXh0XSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5rZXkucGVyaW9kLFxuXHQgICAgICAgICAgICByZWdleDogL15cXC4oW2EtekEtWjAtOV9dKykvLFxuXHQgICAgICAgICAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnNfZXh0ZW5kZWQuY29uY2F0KFtcblx0ICAgICAgICAgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnRdKSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmtleSA9IHRva2VuLm1hdGNoWzFdO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLnZhbHVlO1xuXG5cdCAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIGNvbnRleHQsIG5leHRfdG9rZW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0b2tlbi5rZXksXG5cdCAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gc3RhY2sucG9wKCksXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtcyh0aGlzLCB0b2tlbi5wYXJhbXMsIGNvbnRleHQpXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihwYXJhbXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuc3RyaWN0X3ZhcmlhYmxlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJDYW4ndCBhY2Nlc3MgYSBrZXkgXCIgKyBrZXkgKyBcIiBvbiBhbiBudWxsIG9yIHVuZGVmaW5lZCBvYmplY3QuXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc3Vic3RyKDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdmFyaWFibGUgZnJvbSB0aGUgY29udGV4dFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYga2V5IGluIG9iamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3RbXCJnZXRcIiArIGNhcGl0YWxpemUoa2V5KV0gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbXCJnZXRcIiArIGNhcGl0YWxpemUoa2V5KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0W1wiaXNcIiArIGNhcGl0YWxpemUoa2V5KV0gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbXCJpc1wiICsgY2FwaXRhbGl6ZShrZXkpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiByZXNvbHZpbmcgYW4gZXhwcmVzc2lvbiB3ZSBuZWVkIHRvIHBhc3MgbmV4dF90b2tlbiBpbiBjYXNlIHRoZSBleHByZXNzaW9uIGlzIGEgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnJlc29sdmVBc3luYy5hcHBseSh0aGF0LCBbdmFsdWUsIGNvbnRleHQsIHBhcmFtcywgbmV4dF90b2tlbiwgb2JqZWN0XSk7XG5cdCAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUua2V5LmJyYWNrZXRzLFxuXHQgICAgICAgICAgICByZWdleDogL15cXFsoW15cXF1cXDpdKilcXF0vLFxuXHQgICAgICAgICAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnNfZXh0ZW5kZWQuY29uY2F0KFtcblx0ICAgICAgICAgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnRdKSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRva2VuLm1hdGNoWzFdO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiBzdGFjayBmb3IgdGhlIGtleVxuXHQgICAgICAgICAgICAgICAgdG9rZW4uc3RhY2sgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoXG5cdCAgICAgICAgICAgICAgICB9KS5zdGFjaztcblxuXHQgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBjb250ZXh0LCBuZXh0X3Rva2VuKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSBrZXlcblx0ICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsLFxuXHQgICAgICAgICAgICAgICAgICAgIG9iamVjdCxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW1zKHRoaXMsIHRva2VuLnBhcmFtcywgY29udGV4dClcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJhbWV0ZXJzO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5hcHBseSh0aGF0LCBbdG9rZW4uc3RhY2ssIGNvbnRleHRdKTtcblx0ICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zdHJpY3RfdmFyaWFibGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcIkNhbid0IGFjY2VzcyBhIGtleSBcIiArIGtleSArIFwiIG9uIGFuIG51bGwgb3IgdW5kZWZpbmVkIG9iamVjdC5cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdmFyaWFibGUgZnJvbSB0aGUgY29udGV4dFxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBrZXkgaW4gb2JqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcmVzb2x2aW5nIGFuIGV4cHJlc3Npb24gd2UgbmVlZCB0byBwYXNzIG5leHRfdG9rZW4gaW4gY2FzZSB0aGUgZXhwcmVzc2lvbiBpcyBhIGZ1bmN0aW9uXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5yZXNvbHZlQXN5bmMuYXBwbHkodGhhdCwgW3ZhbHVlLCBvYmplY3QsIHBhcmFtcywgbmV4dF90b2tlbl0pO1xuXHQgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBNYXRjaCBhIG51bGwgdmFsdWUuXG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5fbnVsbCxcblx0ICAgICAgICAgICAgLy8gbWF0Y2ggYSBudW1iZXJcblx0ICAgICAgICAgICAgcmVnZXg6IC9eKG51bGx8TlVMTHxub25lfE5PTkUpLyxcblx0ICAgICAgICAgICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXHQgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogVHdpZy5leHByZXNzaW9uLmZuLnBhcnNlLnB1c2hfdmFsdWVcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIE1hdGNoIHRoZSBjb250ZXh0XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5jb250ZXh0LFxuXHQgICAgICAgICAgICByZWdleDogL15fY29udGV4dC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQub3BlcmF0aW9uc19leHRlbmRlZC5jb25jYXQoW1xuXHQgICAgICAgICAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5zdGFydF0pLFxuXHQgICAgICAgICAgICBjb21waWxlOiBUd2lnLmV4cHJlc3Npb24uZm4uY29tcGlsZS5wdXNoLFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24odG9rZW4sIHN0YWNrLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGNvbnRleHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBNYXRjaCBhIGJvb2xlYW5cblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmJvb2wsXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXih0cnVlfFRSVUV8ZmFsc2V8RkFMU0UpLyxcblx0ICAgICAgICAgICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSAodG9rZW4ubWF0Y2hbMF0udG9Mb3dlckNhc2UoICkgPT09IFwidHJ1ZVwiKTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcblx0ICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGFyc2U6IFR3aWcuZXhwcmVzc2lvbi5mbi5wYXJzZS5wdXNoX3ZhbHVlXG5cdCAgICAgICAgfVxuXHQgICAgXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXNvbHZlIGEgY29udGV4dCB2YWx1ZS5cblx0ICAgICAqXG5cdCAgICAgKiBJZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaXQgaXMgZXhlY3V0ZWQgd2l0aCBhIGNvbnRleHQgcGFyYW1ldGVyLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGNvbnRleHQgb2JqZWN0IGtleS5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSByZW5kZXIgY29udGV4dC5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5leHByZXNzaW9uLnJlc29sdmVBc3luYyA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBwYXJhbXMsIG5leHRfdG9rZW4sIG9iamVjdCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IFR3aWcuUHJvbWlzZS5yZXNvbHZlKHBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgLypcblx0ICAgICAgICAgICAgSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBoYXZlIGJlZW4gaW1wb3NzaWJsZSBkdXJpbmcgdGhlIGNvbXBpbGUgc3RhZ2UgdG8gZGV0ZXJtaW5lIHRoYXQgYSBmb2xsb3dpbmdcblx0ICAgICAgICAgICAgc2V0IG9mIHBhcmVudGhlc2VzIHdlcmUgcGFyYW1ldGVycyBmb3IgdGhpcyBmdW5jdGlvbi5cblxuXHQgICAgICAgICAgICBUaG9zZSBwYXJlbnRoZXNlcyB3aWxsIGhhdmUgdGhlcmVmb3JlIGJlZW4gbWFya2VkIGFzIGFuIGV4cHJlc3Npb24sIHdpdGggdGhlaXIgb3duIHBhcmFtZXRlcnMsIHdoaWNoIHJlYWxseVxuXHQgICAgICAgICAgICBiZWxvbmcgdG8gdGhpcyBmdW5jdGlvbi5cblxuXHQgICAgICAgICAgICBUaG9zZSBwYXJhbWV0ZXJzIHdpbGwgYWxzbyBuZWVkIHBhcnNpbmcgaW4gY2FzZSB0aGV5IGFyZSBhY3R1YWxseSBhbiBleHByZXNzaW9uIHRvIHBhc3MgYXMgcGFyYW1ldGVycy5cblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuICYmIG5leHRfdG9rZW4udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLmVuZCkge1xuXHQgICAgICAgICAgICAgICAgLy9XaGVuIHBhcnNpbmcgdGhlc2UgcGFyYW1ldGVycywgd2UgbmVlZCB0byBnZXQgdGhlbSBhbGwgYmFjaywgbm90IGp1c3QgdGhlIGxhc3QgaXRlbSBvbiB0aGUgc3RhY2suXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW5zX2FyZV9wYXJhbWV0ZXJzID0gdHJ1ZTtcblxuXHQgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dF90b2tlbi5wYXJhbXMgJiYgVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuYXBwbHkodGhpcywgW25leHRfdG9rZW4ucGFyYW1zLCBjb250ZXh0LCB0b2tlbnNfYXJlX3BhcmFtZXRlcnNdKTtcblx0ICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9DbGVhbiB1cCB0aGUgcGFyZW50aGVzZXMgdG9rZW5zIG9uIHRoZSBuZXh0IGxvb3Bcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0X3Rva2VuLmNsZWFudXAgPSB0cnVlO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkob2JqZWN0IHx8IGNvbnRleHQsIHBhcmFtcyB8fCBbXSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUd2lnLlByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgVHdpZy5leHByZXNzaW9uLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgcGFyYW1zLCBuZXh0X3Rva2VuLCBvYmplY3QpIHtcblx0ICAgICAgICB2YXIgaXNfYXN5bmMgPSB0cnVlLFxuXHQgICAgICAgICAgICByZXN1bHQ7XG5cblx0ICAgICAgICBUd2lnLmV4cHJlc3Npb24ucmVzb2x2ZUFzeW5jLmFwcGx5KHRoaXMsIFt2YWx1ZSwgY29udGV4dCwgcGFyYW1zLCBuZXh0X3Rva2VuLCBvYmplY3RdKVxuXHQgICAgICAgIC50aGVuKGZ1bmN0aW9uKHIpIHtcblx0ICAgICAgICAgICAgaXNfYXN5bmMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gcjtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGlmIChpc19hc3luYylcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1lvdSBhcmUgdXNpbmcgVHdpZy5qcyBpbiBzeW5jIG1vZGUgaW4gY29tYmluYXRpb24gd2l0aCBhc3luYyBleHRlbnNpb25zLicpO1xuXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZWdpc3RyeSBmb3IgbG9naWMgaGFuZGxlcnMuXG5cdCAgICAgKi9cblx0ICAgIFR3aWcuZXhwcmVzc2lvbi5oYW5kbGVyID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVmaW5lIGEgbmV3IGV4cHJlc3Npb24gdHlwZSwgYXZhaWxhYmxlIGF0IFR3aWcubG9naWMudHlwZS57dHlwZX1cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgbmV3IHR5cGUuXG5cdCAgICAgKi9cblx0ICAgIFR3aWcuZXhwcmVzc2lvbi5leHRlbmRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICBUd2lnLmV4cHJlc3Npb24udHlwZVt0eXBlXSA9IFwiVHdpZy5leHByZXNzaW9uLnR5cGUuXCIgKyB0eXBlO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFeHRlbmQgdGhlIGV4cHJlc3Npb24gcGFyc2luZyBmdW5jdGlvbmFsaXR5IHdpdGggYSBuZXcgZGVmaW5pdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBUb2tlbiBkZWZpbml0aW9ucyBmb2xsb3cgdGhpcyBmb3JtYXQ6XG5cdCAgICAgKiAge1xuXHQgICAgICogICAgICB0eXBlOiAgICAgT25lIG9mIFR3aWcuZXhwcmVzc2lvbi50eXBlLlt0eXBlXSwgZWl0aGVyIHByZS1kZWZpbmVkIG9yIGFkZGVkIHVzaW5nXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgICAgVHdpZy5leHByZXNzaW9uLmV4dGVuZFR5cGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIG5leHQ6ICAgICBBcnJheSBvZiB0eXBlcyBmcm9tIFR3aWcuZXhwcmVzc2lvbi50eXBlIHRoYXQgY2FuIGZvbGxvdyB0aGlzIHRva2VuLFxuXHQgICAgICpcblx0ICAgICAqICAgICAgcmVnZXg6ICAgIEEgcmVnZXggb3IgYXJyYXkgb2YgcmVnZXgncyB0aGF0IHNob3VsZCBtYXRjaCB0aGUgdG9rZW4uXG5cdCAgICAgKlxuXHQgICAgICogICAgICBjb21waWxlOiBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIG91dHB1dCkgY2FsbGVkIHdoZW4gdGhpcyB0b2tlbiBpcyBiZWluZyBjb21waWxlZC5cblx0ICAgICAqICAgICAgICAgICAgICAgICAgIFNob3VsZCByZXR1cm4gYW4gb2JqZWN0IHdpdGggc3RhY2sgYW5kIG91dHB1dCBzZXQuXG5cdCAgICAgKlxuXHQgICAgICogICAgICBwYXJzZTogICBmdW5jdGlvbih0b2tlbiwgc3RhY2ssIGNvbnRleHQpIGNhbGxlZCB3aGVuIHRoaXMgdG9rZW4gaXMgYmVpbmcgcGFyc2VkLlxuXHQgICAgICogICAgICAgICAgICAgICAgICAgU2hvdWxkIHJldHVybiBhbiBvYmplY3Qgd2l0aCBzdGFjayBhbmQgY29udGV4dCBzZXQuXG5cdCAgICAgKiAgfVxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIEEgdG9rZW4gZGVmaW5pdGlvbi5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5leHByZXNzaW9uLmV4dGVuZCA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG5cdCAgICAgICAgaWYgKCFkZWZpbml0aW9uLnR5cGUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJVbmFibGUgdG8gZXh0ZW5kIGxvZ2ljIGRlZmluaXRpb24uIE5vIHR5cGUgcHJvdmlkZWQgZm9yIFwiICsgZGVmaW5pdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFR3aWcuZXhwcmVzc2lvbi5oYW5kbGVyW2RlZmluaXRpb24udHlwZV0gPSBkZWZpbml0aW9uO1xuXHQgICAgfTtcblxuXHQgICAgLy8gRXh0ZW5kIHdpdGggYnVpbHQtaW4gZXhwcmVzc2lvbnNcblx0ICAgIHdoaWxlIChUd2lnLmV4cHJlc3Npb24uZGVmaW5pdGlvbnMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIFR3aWcuZXhwcmVzc2lvbi5leHRlbmQoVHdpZy5leHByZXNzaW9uLmRlZmluaXRpb25zLnNoaWZ0KCkpO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIEJyZWFrIGFuIGV4cHJlc3Npb24gaW50byB0b2tlbnMgZGVmaW5lZCBpbiBUd2lnLmV4cHJlc3Npb24uZGVmaW5pdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gVGhlIHN0cmluZyB0byB0b2tlbml6ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdG9rZW5zLlxuXHQgICAgICovXG5cdCAgICBUd2lnLmV4cHJlc3Npb24udG9rZW5pemUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuXHQgICAgICAgIHZhciB0b2tlbnMgPSBbXSxcblx0ICAgICAgICAgICAgLy8gS2VlcCBhbiBvZmZzZXQgb2YgdGhlIGxvY2F0aW9uIGluIHRoZSBleHByZXNzaW9uIGZvciBlcnJvciBtZXNzYWdlcy5cblx0ICAgICAgICAgICAgZXhwX29mZnNldCA9IDAsXG5cdCAgICAgICAgICAgIC8vIFRoZSB2YWxpZCBuZXh0IHRva2VucyBvZiB0aGUgcHJldmlvdXMgdG9rZW5cblx0ICAgICAgICAgICAgbmV4dCA9IG51bGwsXG5cdCAgICAgICAgICAgIC8vIE1hdGNoIGluZm9ybWF0aW9uXG5cdCAgICAgICAgICAgIHR5cGUsIHJlZ2V4LCByZWdleF9hcnJheSxcblx0ICAgICAgICAgICAgLy8gVGhlIHBvc3NpYmxlIG5leHQgdG9rZW4gZm9yIHRoZSBtYXRjaFxuXHQgICAgICAgICAgICB0b2tlbl9uZXh0LFxuXHQgICAgICAgICAgICAvLyBIYXMgYSBtYXRjaCBiZWVuIGZvdW5kIGZyb20gdGhlIGRlZmluaXRpb25zXG5cdCAgICAgICAgICAgIG1hdGNoX2ZvdW5kLCBpbnZhbGlkX21hdGNoZXMgPSBbXSwgbWF0Y2hfZnVuY3Rpb247XG5cblx0ICAgICAgICBtYXRjaF9mdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG1hdGNoID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cyksXG5cdCAgICAgICAgICAgICAgICBzdHJpbmcgPSBtYXRjaC5wb3AoKSxcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IG1hdGNoLnBvcCgpO1xuXG5cdCAgICAgICAgICAgIFR3aWcubG9nLnRyYWNlKFwiVHdpZy5leHByZXNzaW9uLnRva2VuaXplXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTWF0Y2hlZCBhIFwiLCB0eXBlLCBcIiByZWd1bGFyIGV4cHJlc3Npb24gb2YgXCIsIG1hdGNoKTtcblxuXHQgICAgICAgICAgICBpZiAobmV4dCAmJiBUd2lnLmluZGV4T2YobmV4dCwgdHlwZSkgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICBpbnZhbGlkX21hdGNoZXMucHVzaChcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlICsgXCIgY2Fubm90IGZvbGxvdyBhIFwiICsgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgdGVtcGxhdGU6XCIgKyBleHBfb2Zmc2V0ICsgXCIgbmVhciAnXCIgKyBtYXRjaFswXS5zdWJzdHJpbmcoMCwgMjApICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuLi4nXCJcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICAvLyBOb3QgYSBtYXRjaCwgZG9uJ3QgY2hhbmdlIHRoZSBleHByZXNzaW9uXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgdG9rZW4gaWYgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIHByb3ZpZGVkXG5cdCAgICAgICAgICAgIGlmIChUd2lnLmV4cHJlc3Npb24uaGFuZGxlclt0eXBlXS52YWxpZGF0ZSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICFUd2lnLmV4cHJlc3Npb24uaGFuZGxlclt0eXBlXS52YWxpZGF0ZShtYXRjaCwgdG9rZW5zKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaW52YWxpZF9tYXRjaGVzID0gW107XG5cblx0ICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgdHlwZTogIHR5cGUsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hbMF0sXG5cdCAgICAgICAgICAgICAgICBtYXRjaDogbWF0Y2hcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgbWF0Y2hfZm91bmQgPSB0cnVlO1xuXHQgICAgICAgICAgICBuZXh0ID0gdG9rZW5fbmV4dDtcblx0ICAgICAgICAgICAgZXhwX29mZnNldCArPSBtYXRjaFswXS5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gRG9lcyB0aGUgdG9rZW4gbmVlZCB0byByZXR1cm4gb3V0cHV0IGJhY2sgdG8gdGhlIGV4cHJlc3Npb24gc3RyaW5nXG5cdCAgICAgICAgICAgIC8vIGUuZy4gYSBmdW5jdGlvbiBtYXRjaCBvZiBjeWNsZSggbWlnaHQgcmV0dXJuIHRoZSAnKCcgYmFjayB0byB0aGUgZXhwcmVzc2lvblxuXHQgICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBsb29rLWFoZWFkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0b2tlbiB0eXBlcyAoZS5nLiBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlIG5hbWVzKVxuXHQgICAgICAgICAgICBpZiAoVHdpZy5leHByZXNzaW9uLmhhbmRsZXJbdHlwZV0udHJhbnNmb3JtKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLmhhbmRsZXJbdHlwZV0udHJhbnNmb3JtKG1hdGNoLCB0b2tlbnMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgVHdpZy5sb2cuZGVidWcoXCJUd2lnLmV4cHJlc3Npb24udG9rZW5pemVcIiwgXCJUb2tlbml6aW5nIGV4cHJlc3Npb24gXCIsIGV4cHJlc3Npb24pO1xuXG5cdCAgICAgICAgd2hpbGUgKGV4cHJlc3Npb24ubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi50cmltKCk7XG5cdCAgICAgICAgICAgIGZvciAodHlwZSBpbiBUd2lnLmV4cHJlc3Npb24uaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKFR3aWcuZXhwcmVzc2lvbi5oYW5kbGVyLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW5fbmV4dCA9IFR3aWcuZXhwcmVzc2lvbi5oYW5kbGVyW3R5cGVdLm5leHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBUd2lnLmV4cHJlc3Npb24uaGFuZGxlclt0eXBlXS5yZWdleDtcblx0ICAgICAgICAgICAgICAgICAgICBUd2lnLmxvZy50cmFjZShcIkNoZWNraW5nIHR5cGUgXCIsIHR5cGUsIFwiIG9uIFwiLCBleHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXggaW5zdGFuY2VvZiBBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWdleF9hcnJheSA9IHJlZ2V4O1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4X2FycmF5ID0gW3JlZ2V4XTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBtYXRjaF9mb3VuZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWdleF9hcnJheS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gcmVnZXhfYXJyYXkucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2UocmVnZXgsIG1hdGNoX2Z1bmN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQW4gZXhwcmVzc2lvbiB0b2tlbiBoYXMgYmVlbiBtYXRjaGVkLiBCcmVhayB0aGUgZm9yIGxvb3AgYW5kIHN0YXJ0IHRyeWluZyB0b1xuXHQgICAgICAgICAgICAgICAgICAgIC8vICBtYXRjaCB0aGUgbmV4dCB0ZW1wbGF0ZSAoaWYgZXhwcmVzc2lvbiBpc24ndCBlbXB0eS4pXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoX2ZvdW5kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIW1hdGNoX2ZvdW5kKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW52YWxpZF9tYXRjaGVzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihpbnZhbGlkX21hdGNoZXMuam9pbihcIiBPUiBcIikpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcIlVuYWJsZSB0byBwYXJzZSAnXCIgKyBleHByZXNzaW9uICsgXCInIGF0IHRlbXBsYXRlIHBvc2l0aW9uXCIgKyBleHBfb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIFR3aWcubG9nLnRyYWNlKFwiVHdpZy5leHByZXNzaW9uLnRva2VuaXplXCIsIFwiVG9rZW5pemVkIHRvIFwiLCB0b2tlbnMpO1xuXHQgICAgICAgIHJldHVybiB0b2tlbnM7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIENvbXBpbGUgYW4gZXhwcmVzc2lvbiB0b2tlbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gcmF3X3Rva2VuIFRoZSB1bmNvbXBpbGVkIHRva2VuLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbXBpbGVkIHRva2VuLlxuXHQgICAgICovXG5cdCAgICBUd2lnLmV4cHJlc3Npb24uY29tcGlsZSA9IGZ1bmN0aW9uIChyYXdfdG9rZW4pIHtcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJhd190b2tlbi52YWx1ZSxcblx0ICAgICAgICAgICAgLy8gVG9rZW5pemUgZXhwcmVzc2lvblxuXHQgICAgICAgICAgICB0b2tlbnMgPSBUd2lnLmV4cHJlc3Npb24udG9rZW5pemUoZXhwcmVzc2lvbiksXG5cdCAgICAgICAgICAgIHRva2VuID0gbnVsbCxcblx0ICAgICAgICAgICAgb3V0cHV0ID0gW10sXG5cdCAgICAgICAgICAgIHN0YWNrID0gW10sXG5cdCAgICAgICAgICAgIHRva2VuX3RlbXBsYXRlID0gbnVsbDtcblxuXHQgICAgICAgIFR3aWcubG9nLnRyYWNlKFwiVHdpZy5leHByZXNzaW9uLmNvbXBpbGU6IFwiLCBcIkNvbXBpbGluZyBcIiwgZXhwcmVzc2lvbik7XG5cblx0ICAgICAgICAvLyBQdXNoIHRva2VucyBpbnRvIFJQTiBzdGFjayB1c2luZyB0aGUgU2h1bnRpbmcteWFyZCBhbGdvcml0aG1cblx0ICAgICAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaHVudGluZ195YXJkX2FsZ29yaXRobVxuXG5cdCAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgIHRva2VuX3RlbXBsYXRlID0gVHdpZy5leHByZXNzaW9uLmhhbmRsZXJbdG9rZW4udHlwZV07XG5cblx0ICAgICAgICAgICAgVHdpZy5sb2cudHJhY2UoXCJUd2lnLmV4cHJlc3Npb24uY29tcGlsZTogXCIsIFwiQ29tcGlsaW5nIFwiLCB0b2tlbik7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGVcblx0ICAgICAgICAgICAgdG9rZW5fdGVtcGxhdGUuY29tcGlsZSAmJiB0b2tlbl90ZW1wbGF0ZS5jb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KTtcblxuXHQgICAgICAgICAgICBUd2lnLmxvZy50cmFjZShcIlR3aWcuZXhwcmVzc2lvbi5jb21waWxlOiBcIiwgXCJTdGFjayBpc1wiLCBzdGFjayk7XG5cdCAgICAgICAgICAgIFR3aWcubG9nLnRyYWNlKFwiVHdpZy5leHByZXNzaW9uLmNvbXBpbGU6IFwiLCBcIk91dHB1dCBpc1wiLCBvdXRwdXQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHdoaWxlKHN0YWNrLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RhY2sucG9wKCkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIFR3aWcubG9nLnRyYWNlKFwiVHdpZy5leHByZXNzaW9uLmNvbXBpbGU6IFwiLCBcIkZpbmFsIG91dHB1dCBpc1wiLCBvdXRwdXQpO1xuXG5cdCAgICAgICAgcmF3X3Rva2VuLnN0YWNrID0gb3V0cHV0O1xuXHQgICAgICAgIGRlbGV0ZSByYXdfdG9rZW4udmFsdWU7XG5cblx0ICAgICAgICByZXR1cm4gcmF3X3Rva2VuO1xuXHQgICAgfTtcblxuXG5cdCAgICAvKipcblx0ICAgICAqIFBhcnNlIGFuIFJQTiBleHByZXNzaW9uIHN0YWNrIHdpdGhpbiBhIGNvbnRleHQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIEFuIGFycmF5IG9mIGNvbXBpbGVkIGV4cHJlc3Npb24gdG9rZW5zLlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIHJlbmRlciBjb250ZXh0IHRvIHBhcnNlIHRoZSB0b2tlbnMgd2l0aC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHQgb2YgcGFyc2luZyBhbGwgdGhlIHRva2Vucy4gVGhlIHJlc3VsdFxuXHQgICAgICogICAgICAgICAgICAgICAgICBjYW4gYmUgYW55dGhpbmcsIFN0cmluZywgQXJyYXksIE9iamVjdCwgZXRjLi4uIGJhc2VkIG9uXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgIHRoZSBnaXZlbiBleHByZXNzaW9uLlxuXHQgICAgICovXG5cdCAgICBUd2lnLmV4cHJlc3Npb24ucGFyc2UgPSBmdW5jdGlvbiAodG9rZW5zLCBjb250ZXh0LCB0b2tlbnNfYXJlX3BhcmFtZXRlcnMsIGFsbG93X2FzeW5jKSB7XG5cdCAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdCAgICAgICAgLy8gSWYgdGhlIHRva2VuIGlzbid0IGFuIGFycmF5LCBtYWtlIGl0IG9uZS5cblx0ICAgICAgICBpZiAoISh0b2tlbnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgICAgICAgICAgdG9rZW5zID0gW3Rva2Vuc107XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gVGhlIG91dHB1dCBzdGFja1xuXHQgICAgICAgIHZhciBzdGFjayA9IFtdLFxuXHQgICAgICAgICAgICBuZXh0X3Rva2VuLFxuXHQgICAgICAgICAgICBvdXRwdXQgPSBudWxsLFxuXHQgICAgICAgICAgICBwcm9taXNlID0gbnVsbCxcblx0ICAgICAgICAgICAgaXNfYXN5bmMgPSB0cnVlLFxuXHQgICAgICAgICAgICB0b2tlbl90ZW1wbGF0ZSA9IG51bGwsXG5cdCAgICAgICAgICAgIGxvb3BfdG9rZW5fZml4dXBzID0gW107XG5cblx0ICAgICAgICBwcm9taXNlID0gVHdpZy5hc3luYy5mb3JFYWNoKHRva2VucywgZnVuY3Rpb24gKHRva2VuLCBpbmRleCkge1xuXHQgICAgICAgICAgICAvL0lmIHRoZSB0b2tlbiBpcyBtYXJrZWQgZm9yIGNsZWFudXAsIHdlIGRvbid0IG5lZWQgdG8gcGFyc2UgaXRcblx0ICAgICAgICAgICAgaWYgKHRva2VuLmNsZWFudXApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIC8vRGV0ZXJtaW5lIHRoZSB0b2tlbiB0aGF0IGZvbGxvd3MgdGhpcyBvbmUgc28gdGhhdCB3ZSBjYW4gcGFzcyBpdCB0byB0aGUgcGFyc2VyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gaW5kZXggKyAxKSB7XG5cdCAgICAgICAgICAgICAgICBuZXh0X3Rva2VuID0gdG9rZW5zW2luZGV4ICsgMV07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0b2tlbl90ZW1wbGF0ZSA9IFR3aWcuZXhwcmVzc2lvbi5oYW5kbGVyW3Rva2VuLnR5cGVdO1xuXG5cdCAgICAgICAgICAgIGlmICh0b2tlbl90ZW1wbGF0ZS5wYXJzZSlcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRva2VuX3RlbXBsYXRlLnBhcnNlLmFwcGx5KHRoYXQsIFt0b2tlbiwgc3RhY2ssIGNvbnRleHQsIG5leHRfdG9rZW5dKTtcblxuXHQgICAgICAgICAgICAvL1N0b3JlIGFueSBiaW5hcnkgdG9rZW5zIGZvciBsYXRlciBpZiB3ZSBhcmUgaW4gYSBsb29wLlxuXHQgICAgICAgICAgICBpZiAoY29udGV4dC5sb29wICYmIHRva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLmJpbmFyeSkge1xuXHQgICAgICAgICAgICAgICAgbG9vcF90b2tlbl9maXh1cHMucHVzaCh0b2tlbik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0pXG5cdCAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIC8vQ2hlY2sgZXZlcnkgZml4dXAgYW5kIHJlbW92ZSBcImtleVwiIGFzIGxvbmcgYXMgdGhleSBzdGlsbCBoYXZlIFwicGFyYW1zXCIuIFRoaXMgY292ZXJzIHRoZSB1c2UgY2FzZSB3aGVyZVxuXHQgICAgICAgICAgICAvL2EgXCI6XCIgb3BlcmF0b3IgaXMgdXNlZCBpbiBhIGxvb3Agd2l0aCBhIFwiKGV4cHJlc3Npb24pOlwiIHN0YXRlbWVudC4gV2UgbmVlZCB0byBiZSBhYmxlIHRvIGV2YWx1YXRlIHRoZSBleHByZXNzaW9uXG5cdCAgICAgICAgICAgIFR3aWcuZm9yRWFjaChsb29wX3Rva2VuX2ZpeHVwcywgZnVuY3Rpb24gKGxvb3BfdG9rZW5fZml4dXApIHtcblx0ICAgICAgICAgICAgICAgIGlmIChsb29wX3Rva2VuX2ZpeHVwLnBhcmFtcyAmJiBsb29wX3Rva2VuX2ZpeHVwLmtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb29wX3Rva2VuX2ZpeHVwW1wia2V5XCJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAvL0lmIHBhcnNlIGhhcyBiZWVuIGNhbGxlZCB3aXRoIGEgc2V0IG9mIHRva2VucyB0aGF0IGFyZSBwYXJhbWV0ZXJzLCB3ZSBuZWVkIHRvIHJldHVybiB0aGUgd2hvbGUgc3RhY2ssXG5cdCAgICAgICAgICAgIC8vd3JhcHBlZCBpbiBhbiBBcnJheS5cblx0ICAgICAgICAgICAgaWYgKHRva2Vuc19hcmVfcGFyYW1ldGVycykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXMudW5zaGlmdChzdGFjay5wb3AoKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocGFyYW1zKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChhbGxvd19hc3luYylcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLlByb21pc2UucmVzb2x2ZShzdGFjay5wb3AoKSk7XG5cdCAgICAgICAgfSlcblx0ICAgICAgICAudGhlbihmdW5jdGlvbih2KSB7XG5cdCAgICAgICAgICAgIGlzX2FzeW5jID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHJldHVybiB2O1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgaWYgKGFsbG93X2FzeW5jKVxuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblxuXHQgICAgICAgIGlmIChpc19hc3luYylcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1lvdSBhcmUgdXNpbmcgVHdpZy5qcyBpbiBzeW5jIG1vZGUgaW4gY29tYmluYXRpb24gd2l0aCBhc3luYyBleHRlbnNpb25zLicpO1xuXG5cdCAgICAgICAgLy8gUG9wIHRoZSBmaW5hbCB2YWx1ZSBvZmYgdGhlIHN0YWNrXG5cdCAgICAgICAgcmV0dXJuIHN0YWNrLnBvcCgpO1xuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIFR3aWc7XG5cblx0fTtcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gIyMgdHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmpzXG5cdC8vXG5cdC8vIFRoaXMgZmlsZSBoYW5kbGVzIG9wZXJhdG9yIGxvb2t1cHMgYW5kIHBhcnNpbmcuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFR3aWcpIHtcblx0ICAgIFwidXNlIHN0cmljdFwiO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZXJhdG9yIGFzc29jaWF0aXZpdHkgY29uc3RhbnRzLlxuXHQgICAgICovXG5cdCAgICBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IgPSB7XG5cdCAgICAgICAgbGVmdFRvUmlnaHQ6ICdsZWZ0VG9SaWdodCcsXG5cdCAgICAgICAgcmlnaHRUb0xlZnQ6ICdyaWdodFRvTGVmdCdcblx0ICAgIH07XG5cblx0ICAgIHZhciBjb250YWlubWVudCA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfSBlbHNlIGlmIChiLmluZGV4T2YgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAvLyBTdHJpbmdcblx0ICAgICAgICAgICAgcmV0dXJuIGEgPT09IGIgfHwgYSAhPT0gJycgJiYgYi5pbmRleE9mKGEpID4gLTE7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGVsO1xuXHQgICAgICAgICAgICBmb3IgKGVsIGluIGIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KGVsKSAmJiBiW2VsXSA9PT0gYSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEdldCB0aGUgcHJlY2lkZW5jZSBhbmQgYXNzb2NpYXRpdml0eSBvZiBhbiBvcGVyYXRvci4gVGhlc2UgZm9sbG93IHRoZSBvcmRlciB0aGF0IEMvQysrIHVzZS5cblx0ICAgICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdG9yc19pbl9DX2FuZF9DKysgZm9yIHRoZSB0YWJsZSBvZiB2YWx1ZXMuXG5cdCAgICAgKi9cblx0ICAgIFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5sb29rdXAgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHRva2VuKSB7XG5cdCAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuXHQgICAgICAgICAgICBjYXNlIFwiLi5cIjpcblx0ICAgICAgICAgICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSAyMDtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmFzc29jaWF0aXZpdHkgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQ7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICcsJzpcblx0ICAgICAgICAgICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSAxODtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmFzc29jaWF0aXZpdHkgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQ7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICAvLyBUZXJuYXJ5XG5cdCAgICAgICAgICAgIGNhc2UgJz86Jzpcblx0ICAgICAgICAgICAgY2FzZSAnPyc6XG5cdCAgICAgICAgICAgIGNhc2UgJzonOlxuXHQgICAgICAgICAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDE2O1xuXHQgICAgICAgICAgICAgICAgdG9rZW4uYXNzb2NpYXRpdml0eSA9IFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5yaWdodFRvTGVmdDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJ29yJzpcblx0ICAgICAgICAgICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSAxNDtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmFzc29jaWF0aXZpdHkgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQ7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICdhbmQnOlxuXHQgICAgICAgICAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDEzO1xuXHQgICAgICAgICAgICAgICAgdG9rZW4uYXNzb2NpYXRpdml0eSA9IFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5sZWZ0VG9SaWdodDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJ2Itb3InOlxuXHQgICAgICAgICAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDEyO1xuXHQgICAgICAgICAgICAgICAgdG9rZW4uYXNzb2NpYXRpdml0eSA9IFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5sZWZ0VG9SaWdodDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJ2IteG9yJzpcblx0ICAgICAgICAgICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSAxMTtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmFzc29jaWF0aXZpdHkgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQ7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICdiLWFuZCc6XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5wcmVjaWRlbmNlID0gMTA7XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnPT0nOlxuXHQgICAgICAgICAgICBjYXNlICchPSc6XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5wcmVjaWRlbmNlID0gOTtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmFzc29jaWF0aXZpdHkgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQ7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICc8Jzpcblx0ICAgICAgICAgICAgY2FzZSAnPD0nOlxuXHQgICAgICAgICAgICBjYXNlICc+Jzpcblx0ICAgICAgICAgICAgY2FzZSAnPj0nOlxuXHQgICAgICAgICAgICBjYXNlICdub3QgaW4nOlxuXHQgICAgICAgICAgICBjYXNlICdpbic6XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5wcmVjaWRlbmNlID0gODtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmFzc29jaWF0aXZpdHkgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQ7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICd+JzogLy8gU3RyaW5nIGNvbmNhdGluYXRpb25cblx0ICAgICAgICAgICAgY2FzZSAnKyc6XG5cdCAgICAgICAgICAgIGNhc2UgJy0nOlxuXHQgICAgICAgICAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDY7XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnLy8nOlxuXHQgICAgICAgICAgICBjYXNlICcqKic6XG5cdCAgICAgICAgICAgIGNhc2UgJyonOlxuXHQgICAgICAgICAgICBjYXNlICcvJzpcblx0ICAgICAgICAgICAgY2FzZSAnJSc6XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5wcmVjaWRlbmNlID0gNTtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmFzc29jaWF0aXZpdHkgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQ7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICdub3QnOlxuXHQgICAgICAgICAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDM7XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLnJpZ2h0VG9MZWZ0O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiRmFpbGVkIHRvIGxvb2t1cCBvcGVyYXRvcjogXCIgKyBvcGVyYXRvciArIFwiIGlzIGFuIHVua25vd24gb3BlcmF0b3IuXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0b2tlbi5vcGVyYXRvciA9IG9wZXJhdG9yO1xuXHQgICAgICAgIHJldHVybiB0b2tlbjtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGFuZGxlIG9wZXJhdGlvbnMgb24gdGhlIFJQTiBzdGFjay5cblx0ICAgICAqXG5cdCAgICAgKiBSZXR1cm5zIHRoZSB1cGRhdGVkIHN0YWNrLlxuXHQgICAgICovXG5cdCAgICBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IucGFyc2UgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHN0YWNrKSB7XG5cdCAgICAgICAgVHdpZy5sb2cudHJhY2UoXCJUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IucGFyc2U6IFwiLCBcIkhhbmRsaW5nIFwiLCBvcGVyYXRvcik7XG5cdCAgICAgICAgdmFyIGEsIGIsIGM7XG5cblx0ICAgICAgICBpZiAob3BlcmF0b3IgPT09ICc/Jykge1xuXHQgICAgICAgICAgICBjID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgIGlmIChvcGVyYXRvciAhPT0gJ25vdCcpIHtcblx0ICAgICAgICAgICAgYSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChvcGVyYXRvciAhPT0gJ2luJyAmJiBvcGVyYXRvciAhPT0gJ25vdCBpbicpIHtcblx0ICAgICAgICAgICAgaWYgKGEgJiYgQXJyYXkuaXNBcnJheShhKSkge1xuXHQgICAgICAgICAgICAgICAgYSA9IGEubGVuZ3RoO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGIgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuXHQgICAgICAgICAgICAgICAgYiA9IGIubGVuZ3RoO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuXHQgICAgICAgICAgICBjYXNlICc6Jzpcblx0ICAgICAgICAgICAgICAgIC8vIElnbm9yZVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnPzonOlxuXHQgICAgICAgICAgICAgICAgaWYgKFR3aWcubGliLmJvb2x2YWwoYSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGEpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJz8nOlxuXHQgICAgICAgICAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vQW4gZXh0ZW5kZWQgdGVybmFyeS5cblx0ICAgICAgICAgICAgICAgICAgICBhID0gYjtcblx0ICAgICAgICAgICAgICAgICAgICBiID0gYztcblx0ICAgICAgICAgICAgICAgICAgICBjID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoVHdpZy5saWIuYm9vbHZhbChhKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYik7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICcrJzpcblx0ICAgICAgICAgICAgICAgIGIgPSBwYXJzZUZsb2F0KGIpO1xuXHQgICAgICAgICAgICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGEgKyBiKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJy0nOlxuXHQgICAgICAgICAgICAgICAgYiA9IHBhcnNlRmxvYXQoYik7XG5cdCAgICAgICAgICAgICAgICBhID0gcGFyc2VGbG9hdChhKTtcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYSAtIGIpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnKic6XG5cdCAgICAgICAgICAgICAgICBiID0gcGFyc2VGbG9hdChiKTtcblx0ICAgICAgICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhICogYik7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICcvJzpcblx0ICAgICAgICAgICAgICAgIGIgPSBwYXJzZUZsb2F0KGIpO1xuXHQgICAgICAgICAgICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGEgLyBiKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJy8vJzpcblx0ICAgICAgICAgICAgICAgIGIgPSBwYXJzZUZsb2F0KGIpO1xuXHQgICAgICAgICAgICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKE1hdGguZmxvb3IoYSAvIGIpKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJyUnOlxuXHQgICAgICAgICAgICAgICAgYiA9IHBhcnNlRmxvYXQoYik7XG5cdCAgICAgICAgICAgICAgICBhID0gcGFyc2VGbG9hdChhKTtcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYSAlIGIpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnfic6XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCAoYSAhPSBudWxsID8gYS50b1N0cmluZygpIDogXCJcIilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICArIChiICE9IG51bGwgPyBiLnRvU3RyaW5nKCkgOiBcIlwiKSApO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnbm90Jzpcblx0ICAgICAgICAgICAgY2FzZSAnISc6XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCFUd2lnLmxpYi5ib29sdmFsKGIpKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJzwnOlxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhIDwgYik7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICc8PSc6XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGEgPD0gYik7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICc+Jzpcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYSA+IGIpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnPj0nOlxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhID49IGIpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnPT09Jzpcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYSA9PT0gYik7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICc9PSc6XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGEgPT0gYik7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICchPT0nOlxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhICE9PSBiKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJyE9Jzpcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYSAhPSBiKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJ29yJzpcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYSB8fCBiKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJ2Itb3InOlxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhIHwgYik7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICdiLXhvcic6XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGEgXiBiKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJ2FuZCc6XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGEgJiYgYik7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlICdiLWFuZCc6XG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGEgJiBiKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJyoqJzpcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goTWF0aC5wb3coYSwgYikpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnbm90IGluJzpcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goICFjb250YWlubWVudChhLCBiKSApO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSAnaW4nOlxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaCggY29udGFpbm1lbnQoYSwgYikgKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgJy4uJzpcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goIFR3aWcuZnVuY3Rpb25zLnJhbmdlKGEsIGIpICk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgZGVidWdnZXI7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcIkZhaWxlZCB0byBwYXJzZSBvcGVyYXRvcjogXCIgKyBvcGVyYXRvciArIFwiIGlzIGFuIHVua25vd24gb3BlcmF0b3IuXCIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBUd2lnO1xuXG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vICMjIHR3aWcuZmlsdGVycy5qc1xuXHQvL1xuXHQvLyBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZpbHRlcnMuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFR3aWcpIHtcblxuXHQgICAgLy8gRGV0ZXJtaW5lIG9iamVjdCB0eXBlXG5cdCAgICBmdW5jdGlvbiBpcyh0eXBlLCBvYmopIHtcblx0ICAgICAgICB2YXIgY2xhcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopLnNsaWNlKDgsIC0xKTtcblx0ICAgICAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsICYmIGNsYXMgPT09IHR5cGU7XG5cdCAgICB9XG5cblx0ICAgIFR3aWcuZmlsdGVycyA9IHtcblx0ICAgICAgICAvLyBTdHJpbmcgRmlsdGVyc1xuXHQgICAgICAgIHVwcGVyOiAgZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgKSB7XG5cdCAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgbG93ZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICkge1xuXHQgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGNhcGl0YWxpemU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICkge1xuXHQgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHZhbHVlLnRvTG93ZXJDYXNlKCkuc3Vic3RyKDEpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdGl0bGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICkge1xuXHQgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCAvKF58XFxzKShbYS16XSkvZyAsIGZ1bmN0aW9uKG0sIHAxLCBwMil7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcDEgKyBwMi50b1VwcGVyQ2FzZSgpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGxlbmd0aDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKFR3aWcubGliLmlzKFwiQXJyYXlcIiwgdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUd2lnLmxpYi5pcyhcIk9iamVjdFwiLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5fa2V5cyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5fa2V5cy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvLyBBcnJheS9PYmplY3QgRmlsdGVyc1xuXHQgICAgICAgIHJldmVyc2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmIChpcyhcIkFycmF5XCIsIHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJldmVyc2UoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhcIlN0cmluZ1wiLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhcIk9iamVjdFwiLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdmFsdWUuX2tleXMgfHwgT2JqZWN0LmtleXModmFsdWUpLnJldmVyc2UoKTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlLl9rZXlzID0ga2V5cztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc29ydDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKGlzKFwiQXJyYXlcIiwgdmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc29ydCgpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGlzKCdPYmplY3QnLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNvcnRpbmcgb2JqZWN0cyBpc24ndCBvYnZpb3VzIHNpbmNlIHRoZSBvcmRlciBvZlxuXHQgICAgICAgICAgICAgICAgLy8gcmV0dXJuZWQga2V5cyBpc24ndCBndWFyYW50ZWVkIGluIEphdmFTY3JpcHQuXG5cdCAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIG9mIHRoaXMgd2UgdXNlIGEgXCJoaWRkZW5cIiBrZXkgY2FsbGVkIF9rZXlzIHRvXG5cdCAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUga2V5cyBpbiB0aGUgb3JkZXIgd2Ugd2FudCB0byByZXR1cm4gdGhlbS5cblxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlLl9rZXlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSksXG5cdCAgICAgICAgICAgICAgICAgICAgc29ydGVkX2tleXMgPSBrZXlzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEsIGEyO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgYW5kIGIgYXJlIGNvbXBhcmFibGUsIHdlJ3JlIGZpbmUgOi0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmKCh2YWx1ZVthXSA+IHZhbHVlW2JdKSA9PSAhKHZhbHVlW2FdIDw9IHZhbHVlW2JdKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2FdID4gdmFsdWVbYl0gPyAxIDpcblx0XHRcdFx0ICAgICAgICAgICB2YWx1ZVthXSA8IHZhbHVlW2JdID8gLTEgOlxuXHRcdFx0XHRcdCAgIDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBhbmQgYiBjYW4gYmUgcGFyc2VkIGFzIG51bWJlcnMsIHdlIGNhbiBjb21wYXJlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZWlyIG51bWVyaWMgdmFsdWVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZighaXNOYU4oYTEgPSBwYXJzZUZsb2F0KHZhbHVlW2FdKSkgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNOYU4oYjEgPSBwYXJzZUZsb2F0KHZhbHVlW2JdKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhMSA+IGIxID8gMSA6XG5cdFx0XHRcdCAgICAgICAgICAgYTEgPCBiMSA/IC0xIDpcblx0XHRcdFx0XHQgICAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgdmFsdWVzIGlzIGEgc3RyaW5nLCB3ZSBjb252ZXJ0IHRoZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciB2YWx1ZSB0byBzdHJpbmcgYXMgd2VsbFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHR5cGVvZiB2YWx1ZVthXSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2FdID4gdmFsdWVbYl0udG9TdHJpbmcoKSA/IDEgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2FdIDwgdmFsdWVbYl0udG9TdHJpbmcoKSA/IC0xIDpcblx0XHRcdFx0XHQgICAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodHlwZW9mIHZhbHVlW2JdID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbYV0udG9TdHJpbmcoKSA+IHZhbHVlW2JdID8gMSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYV0udG9TdHJpbmcoKSA8IHZhbHVlW2JdID8gLTEgOlxuXHRcdFx0XHRcdCAgIDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBmYWlsZWQgLSByZXR1cm4gJ251bGwnIGFzIHNpZ24sIHRoYXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlcyBhcmUgbm90IGNvbXBhcmFibGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUuX2tleXMgPSBzb3J0ZWRfa2V5cztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAga2V5czogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpe1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIga2V5c2V0ID0gdmFsdWUuX2tleXMgfHwgT2JqZWN0LmtleXModmFsdWUpLFxuXHQgICAgICAgICAgICAgICAgb3V0cHV0ID0gW107XG5cblx0ICAgICAgICAgICAgVHdpZy5mb3JFYWNoKGtleXNldCwgZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIl9rZXlzXCIpIHJldHVybjsgLy8gSWdub3JlIHRoZSBfa2V5cyBwcm9wZXJ0eVxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChrZXkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybF9lbmNvZGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKXtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHQgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShcIidcIiwgXCIlMjdcIik7XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBqb2luOiBmdW5jdGlvbih2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKXtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBqb2luX3N0ciA9IFwiXCIsXG5cdCAgICAgICAgICAgICAgICBvdXRwdXQgPSBbXSxcblx0ICAgICAgICAgICAgICAgIGtleXNldCA9IG51bGw7XG5cblx0ICAgICAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXNbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGpvaW5fc3RyID0gcGFyYW1zWzBdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChpcyhcIkFycmF5XCIsIHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgb3V0cHV0ID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBrZXlzZXQgPSB2YWx1ZS5fa2V5cyB8fCBPYmplY3Qua2V5cyh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICBUd2lnLmZvckVhY2goa2V5c2V0LCBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIl9rZXlzXCIpIHJldHVybjsgLy8gSWdub3JlIHRoZSBfa2V5cyBwcm9wZXJ0eVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlW2tleV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBvdXRwdXQuam9pbihqb2luX3N0cik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24odmFsdWUsIHBhcmFtcykge1xuXHQgICAgICAgICAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiZGVmYXVsdCBmaWx0ZXIgZXhwZWN0cyBvbmUgYXJndW1lbnRcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnICkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zWzBdO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBqc29uX2VuY29kZTogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpICYmIChpcyhcIkFycmF5XCIsIHZhbHVlKSkpIHtcblx0ICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuXG5cdCAgICAgICAgICAgICAgICBUd2lnLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChUd2lnLmZpbHRlcnMuanNvbl9lbmNvZGUodikpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBcIltcIiArIG91dHB1dC5qb2luKFwiLFwiKSArIFwiXVwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleXNldCA9IHZhbHVlLl9rZXlzIHx8IE9iamVjdC5rZXlzKHZhbHVlKSxcblx0ICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuXG5cdCAgICAgICAgICAgICAgICBUd2lnLmZvckVhY2goa2V5c2V0LCBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChKU09OLnN0cmluZ2lmeShrZXkpICsgXCI6XCIgKyBUd2lnLmZpbHRlcnMuanNvbl9lbmNvZGUodmFsdWVba2V5XSkpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBcIntcIiArIG91dHB1dC5qb2luKFwiLFwiKSArIFwifVwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgdmFyIG9iaiA9IFtdLFxuXHQgICAgICAgICAgICAgICAgYXJyX2luZGV4ID0gMCxcblx0ICAgICAgICAgICAgICAgIGtleXNldCA9IFtdO1xuXG5cdCAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBhbGwgdGhlIG9iamVjdHMgYmVpbmcgbWVyZ2VkIGFyZSBhcnJheXNcblx0ICAgICAgICAgICAgaWYgKCFpcyhcIkFycmF5XCIsIHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9iaiBhcyBhbiBPYmplY3Rcblx0ICAgICAgICAgICAgICAgIG9iaiA9IHsgfTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIFR3aWcuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uKHBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpcyhcIkFycmF5XCIsIHBhcmFtKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFpcyhcIkFycmF5XCIsIG9iaikpIHtcblx0ICAgICAgICAgICAgICAgIG9iai5fa2V5cyA9IFtdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGlzKFwiQXJyYXlcIiwgdmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICBUd2lnLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvYmouX2tleXMpIG9iai5fa2V5cy5wdXNoKGFycl9pbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgb2JqW2Fycl9pbmRleF0gPSB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJyX2luZGV4Kys7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGtleXNldCA9IHZhbHVlLl9rZXlzIHx8IE9iamVjdC5rZXlzKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIFR3aWcuZm9yRWFjaChrZXlzZXQsIGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICBvYmouX2tleXMucHVzaChrZXkpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGVkZ2UgY2FzZSB3aGVyZSBhIG51bWJlciBpbmRleCBpbiBhbiBvYmplY3QgaXMgZ3JlYXRlciB0aGFuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gICB0aGUgYXJyYXkgY291bnRlci4gSW4gc3VjaCBhIGNhc2UsIHRoZSBhcnJheSBjb3VudGVyIGlzIGluY3JlYXNlZFxuXHQgICAgICAgICAgICAgICAgICAgIC8vICAgb25lIHBhc3QgdGhlIGluZGV4LlxuXHQgICAgICAgICAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRXhhbXBsZSB7eyBbXCJhXCIsIFwiYlwiXXxtZXJnZSh7XCI0XCI6XCJ2YWx1ZVwifSwgW1wiY1wiLCBcImRcIl0pXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gV2l0aG91dCB0aGlzLCBkIHdvdWxkIGhhdmUgYW4gaW5kZXggb2YgXCI0XCIgYW5kIG92ZXJ3cml0ZSB0aGUgdmFsdWVcblx0ICAgICAgICAgICAgICAgICAgICAvLyAgIG9mIFwidmFsdWVcIlxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnRfa2V5ID0gcGFyc2VJbnQoa2V5LCAxMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihpbnRfa2V5KSAmJiBpbnRfa2V5ID49IGFycl9pbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcnJfaW5kZXggPSBpbnRfa2V5ICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIG1peGluIHRoZSBtZXJnZSBhcnJheXNcblx0ICAgICAgICAgICAgVHdpZy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24ocGFyYW0pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpcyhcIkFycmF5XCIsIHBhcmFtKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIFR3aWcuZm9yRWFjaChwYXJhbSwgZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouX2tleXMpIG9iai5fa2V5cy5wdXNoKGFycl9pbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9ialthcnJfaW5kZXhdID0gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcnJfaW5kZXgrKztcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5c2V0ID0gcGFyYW0uX2tleXMgfHwgT2JqZWN0LmtleXMocGFyYW0pO1xuXHQgICAgICAgICAgICAgICAgICAgIFR3aWcuZm9yRWFjaChrZXlzZXQsIGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ialtrZXldKSBvYmouX2tleXMucHVzaChrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHBhcmFtW2tleV07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludF9rZXkgPSBwYXJzZUludChrZXksIDEwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihpbnRfa2V5KSAmJiBpbnRfa2V5ID49IGFycl9pbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyX2luZGV4ID0gaW50X2tleSArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcIkZpbHRlciBtZXJnZSBleHBlY3RzIGF0IGxlYXN0IG9uZSBwYXJhbWV0ZXJcIik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZGF0ZTogZnVuY3Rpb24odmFsdWUsIHBhcmFtcykge1xuXHQgICAgICAgICAgICB2YXIgZGF0ZSA9IFR3aWcuZnVuY3Rpb25zLmRhdGUodmFsdWUpO1xuXHQgICAgICAgICAgICB2YXIgZm9ybWF0ID0gcGFyYW1zICYmIHBhcmFtcy5sZW5ndGggPyBwYXJhbXNbMF0gOiAnRiBqLCBZIEg6aSc7XG5cdCAgICAgICAgICAgIHJldHVybiBUd2lnLmxpYi5kYXRlKGZvcm1hdCwgZGF0ZSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRhdGVfbW9kaWZ5OiBmdW5jdGlvbih2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5sZW5ndGggIT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiZGF0ZV9tb2RpZnkgZmlsdGVyIGV4cGVjdHMgMSBhcmd1bWVudFwiKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBtb2RpZnlUZXh0ID0gcGFyYW1zWzBdLCB0aW1lO1xuXG5cdCAgICAgICAgICAgIGlmIChUd2lnLmxpYi5pcyhcIkRhdGVcIiwgdmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICB0aW1lID0gVHdpZy5saWIuc3RydG90aW1lKG1vZGlmeVRleHQsIHZhbHVlLmdldFRpbWUoKSAvIDEwMDApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChUd2lnLmxpYi5pcyhcIlN0cmluZ1wiLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRpbWUgPSBUd2lnLmxpYi5zdHJ0b3RpbWUobW9kaWZ5VGV4dCwgVHdpZy5saWIuc3RydG90aW1lKHZhbHVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKFR3aWcubGliLmlzKFwiTnVtYmVyXCIsIHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgdGltZSA9IFR3aWcubGliLnN0cnRvdGltZShtb2RpZnlUZXh0LCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGltZSAqIDEwMDApO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICByZXBsYWNlOiBmdW5jdGlvbih2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkfHx2YWx1ZSA9PT0gbnVsbCl7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgcGFpcnMgPSBwYXJhbXNbMF0sXG5cdCAgICAgICAgICAgICAgICB0YWc7XG5cdCAgICAgICAgICAgIGZvciAodGFnIGluIHBhaXJzKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFpcnMuaGFzT3duUHJvcGVydHkodGFnKSAmJiB0YWcgIT09IFwiX2tleXNcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gVHdpZy5saWIucmVwbGFjZUFsbCh2YWx1ZSwgdGFnLCBwYWlyc1t0YWddKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHBhcmFtcykge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCl7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gVHdpZy5saWIudnNwcmludGYodmFsdWUsIHBhcmFtcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHN0cmlwdGFnczogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpe1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFR3aWcubGliLnN0cmlwX3RhZ3ModmFsdWUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlc2NhcGU6IGZ1bmN0aW9uKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWR8fCB2YWx1ZSA9PT0gbnVsbCl7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgc3RyYXRlZ3kgPSBcImh0bWxcIjtcblx0ICAgICAgICAgICAgaWYocGFyYW1zICYmIHBhcmFtcy5sZW5ndGggJiYgcGFyYW1zWzBdICE9PSB0cnVlKVxuXHQgICAgICAgICAgICAgICAgc3RyYXRlZ3kgPSBwYXJhbXNbMF07XG5cblx0ICAgICAgICAgICAgaWYoc3RyYXRlZ3kgPT0gXCJodG1sXCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByYXdfdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCImIzAzOTtcIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5NYXJrdXAocmF3X3ZhbHVlLCAnaHRtbCcpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYoc3RyYXRlZ3kgPT0gXCJqc1wiKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3X3ZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcmF3X3ZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYocmF3X3ZhbHVlW2ldLm1hdGNoKC9eW2EtekEtWjAtOSxcXC5fXSQvKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHJhd192YWx1ZVtpXTtcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJfY29kZSA9IHJhd192YWx1ZS5jaGFyQ29kZUF0KGkpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoYXJfY29kZSA8IDB4ODApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXFxceFwiICsgY2hhcl9jb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gVHdpZy5saWIuc3ByaW50ZihcIlxcXFx1JTA0c1wiLCBjaGFyX2NvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuTWFya3VwKHJlc3VsdCwgJ2pzJyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZihzdHJhdGVneSA9PSBcImNzc1wiKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3X3ZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcmF3X3ZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYocmF3X3ZhbHVlW2ldLm1hdGNoKC9eW2EtekEtWjAtOV0kLykpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSByYXdfdmFsdWVbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyX2NvZGUgPSByYXdfdmFsdWUuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcXFwiICsgY2hhcl9jb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIgXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5NYXJrdXAocmVzdWx0LCAnY3NzJyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZihzdHJhdGVneSA9PSBcInVybFwiKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gVHdpZy5maWx0ZXJzLnVybF9lbmNvZGUodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuTWFya3VwKHJlc3VsdCwgJ3VybCcpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYoc3RyYXRlZ3kgPT0gXCJodG1sX2F0dHJcIikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJhd192YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcblxuXHQgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHJhd192YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmKHJhd192YWx1ZVtpXS5tYXRjaCgvXlthLXpBLVowLTksXFwuXFwtX10kLykpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSByYXdfdmFsdWVbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihyYXdfdmFsdWVbaV0ubWF0Y2goL15bJjw+XCJdJC8pKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcmF3X3ZhbHVlW2ldLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJfY29kZSA9IHJhd192YWx1ZS5jaGFyQ29kZUF0KGkpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVwbGFjZXMgY2hhcmFjdGVycyB1bmRlZmluZWQgaW4gSFRNTCB3aXRoXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBoZXggZW50aXR5IGZvciB0aGUgVW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoYXJfY29kZSA8PSAweDFmICYmIGNoYXJfY29kZSAhPSAweDA5ICYmIGNoYXJfY29kZSAhPSAweDBhICYmIGNoYXJfY29kZSAhPSAweDBkKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJiN4RkZGRDtcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjaGFyX2NvZGUgPCAweDgwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFR3aWcubGliLnNwcmludGYoXCImI3glMDJzO1wiLCBjaGFyX2NvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gVHdpZy5saWIuc3ByaW50ZihcIiYjeCUwNHM7XCIsIGNoYXJfY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5NYXJrdXAocmVzdWx0LCAnaHRtbF9hdHRyJyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcImVzY2FwZSBzdHJhdGVneSB1bnN1cHBvcnRlZFwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKiBBbGlhcyBvZiBlc2NhcGUgKi9cblx0ICAgICAgICBcImVcIjogZnVuY3Rpb24odmFsdWUsIHBhcmFtcykge1xuXHQgICAgICAgICAgICByZXR1cm4gVHdpZy5maWx0ZXJzLmVzY2FwZSh2YWx1ZSwgcGFyYW1zKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgbmwyYnI6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKXtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgbGluZWJyZWFrX3RhZyA9IFwiQkFDS1NMQVNIX25fcmVwbGFjZVwiLFxuXHQgICAgICAgICAgICAgICAgYnIgPSBcIjxiciAvPlwiICsgbGluZWJyZWFrX3RhZztcblxuXHQgICAgICAgICAgICB2YWx1ZSA9IFR3aWcuZmlsdGVycy5lc2NhcGUodmFsdWUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgYnIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgYnIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgYnIpO1xuXG5cdCAgICAgICAgICAgIHZhbHVlID0gVHdpZy5saWIucmVwbGFjZUFsbCh2YWx1ZSwgbGluZWJyZWFrX3RhZywgXCJcXG5cIik7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFR3aWcuTWFya3VwKHZhbHVlKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRhcHRlZCBmcm9tOiBodHRwOi8vcGhwanMub3JnL2Z1bmN0aW9ucy9udW1iZXJfZm9ybWF0OjQ4MVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG51bWJlcl9mb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgdmFyIG51bWJlciA9IHZhbHVlLFxuXHQgICAgICAgICAgICAgICAgZGVjaW1hbHMgPSAocGFyYW1zICYmIHBhcmFtc1swXSkgPyBwYXJhbXNbMF0gOiB1bmRlZmluZWQsXG5cdCAgICAgICAgICAgICAgICBkZWMgICAgICA9IChwYXJhbXMgJiYgcGFyYW1zWzFdICE9PSB1bmRlZmluZWQpID8gcGFyYW1zWzFdIDogXCIuXCIsXG5cdCAgICAgICAgICAgICAgICBzZXAgICAgICA9IChwYXJhbXMgJiYgcGFyYW1zWzJdICE9PSB1bmRlZmluZWQpID8gcGFyYW1zWzJdIDogXCIsXCI7XG5cblx0ICAgICAgICAgICAgbnVtYmVyID0gKG51bWJlciArICcnKS5yZXBsYWNlKC9bXjAtOStcXC1FZS5dL2csICcnKTtcblx0ICAgICAgICAgICAgdmFyIG4gPSAhaXNGaW5pdGUoK251bWJlcikgPyAwIDogK251bWJlcixcblx0ICAgICAgICAgICAgICAgIHByZWMgPSAhaXNGaW5pdGUoK2RlY2ltYWxzKSA/IDAgOiBNYXRoLmFicyhkZWNpbWFscyksXG5cdCAgICAgICAgICAgICAgICBzID0gJycsXG5cdCAgICAgICAgICAgICAgICB0b0ZpeGVkRml4ID0gZnVuY3Rpb24gKG4sIHByZWMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGgucG93KDEwLCBwcmVjKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKG4gKiBrKSAvIGs7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAvLyBGaXggZm9yIElFIHBhcnNlRmxvYXQoMC41NSkudG9GaXhlZCgwKSA9IDA7XG5cdCAgICAgICAgICAgIHMgPSAocHJlYyA/IHRvRml4ZWRGaXgobiwgcHJlYykgOiAnJyArIE1hdGgucm91bmQobikpLnNwbGl0KCcuJyk7XG5cdCAgICAgICAgICAgIGlmIChzWzBdLmxlbmd0aCA+IDMpIHtcblx0ICAgICAgICAgICAgICAgIHNbMF0gPSBzWzBdLnJlcGxhY2UoL1xcQig/PSg/OlxcZHszfSkrKD8hXFxkKSkvZywgc2VwKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoKHNbMV0gfHwgJycpLmxlbmd0aCA8IHByZWMpIHtcblx0ICAgICAgICAgICAgICAgIHNbMV0gPSBzWzFdIHx8ICcnO1xuXHQgICAgICAgICAgICAgICAgc1sxXSArPSBuZXcgQXJyYXkocHJlYyAtIHNbMV0ubGVuZ3RoICsgMSkuam9pbignMCcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBzLmpvaW4oZGVjKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdHJpbTogZnVuY3Rpb24odmFsdWUsIHBhcmFtcykge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZHx8IHZhbHVlID09PSBudWxsKXtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBzdHIgPSBUd2lnLmZpbHRlcnMuZXNjYXBlKCAnJyArIHZhbHVlICksXG5cdCAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlO1xuXHQgICAgICAgICAgICBpZiAoIHBhcmFtcyAmJiBwYXJhbXNbMF0gKSB7XG5cdCAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gJycgKyBwYXJhbXNbMF07XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gJyBcXG5cXHJcXHRcXGZcXHgwYlxceGEwXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDBiXFx1MjAyOFxcdTIwMjlcXHUzMDAwJztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdoaXRlc3BhY2UuaW5kZXhPZihzdHIuY2hhckF0KGkpKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKGkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZvciAoaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdoaXRlc3BhY2UuaW5kZXhPZihzdHIuY2hhckF0KGkpKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkgKyAxKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gd2hpdGVzcGFjZS5pbmRleE9mKHN0ci5jaGFyQXQoMCkpID09PSAtMSA/IHN0ciA6ICcnO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICB0cnVuY2F0ZTogZnVuY3Rpb24gKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgdmFyIGxlbmd0aCA9IDMwLFxuXHQgICAgICAgICAgICAgICAgcHJlc2VydmUgPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9ICcuLi4nO1xuXG5cdCAgICAgICAgICAgIHZhbHVlID0gIHZhbHVlICsgJyc7XG5cdCAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbXNbMF0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBwYXJhbXNbMF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW1zWzFdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJlc2VydmUgPSBwYXJhbXNbMV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW1zWzJdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gcGFyYW1zWzJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IGxlbmd0aCkge1xuXG5cdCAgICAgICAgICAgICAgICBpZiAocHJlc2VydmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5pbmRleE9mKCcgJywgbGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9ICB2YWx1ZS5zdWJzdHIoMCwgbGVuZ3RoKSArIHNlcGFyYXRvcjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc2xpY2U6IGZ1bmN0aW9uKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmxlbmd0aCA8IDEpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwic2xpY2UgZmlsdGVyIGV4cGVjdHMgYXQgbGVhc3QgMSBhcmd1bWVudFwiKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gc3RhcnQgb2Ygc3RyaW5nXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHBhcmFtc1swXSB8fCAwO1xuXHQgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGxlbmd0aCBvZiBzdHJpbmdcblx0ICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHBhcmFtcy5sZW5ndGggPiAxID8gcGFyYW1zWzFdIDogdmFsdWUubGVuZ3RoO1xuXHQgICAgICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgc3RhcnQgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnQgPj0gMCA/IHN0YXJ0IDogTWF0aC5tYXgoIHZhbHVlLmxlbmd0aCArIHN0YXJ0LCAwICk7XG5cblx0ICAgICAgICAgICAgaWYgKFR3aWcubGliLmlzKFwiQXJyYXlcIiwgdmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHN0YXJ0SW5kZXggKyBsZW5ndGggJiYgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWVbaV0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUd2lnLmxpYi5pcyhcIlN0cmluZ1wiLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHIoc3RhcnRJbmRleCwgbGVuZ3RoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwic2xpY2UgZmlsdGVyIGV4cGVjdHMgdmFsdWUgdG8gYmUgYW4gYXJyYXkgb3Igc3RyaW5nXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGFiczogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGZpcnN0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAoaXMoXCJBcnJheVwiLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVswXTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhcIk9iamVjdFwiLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgnX2tleXMnIGluIHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW3ZhbHVlLl9rZXlzWzBdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cigwLCAxKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc3BsaXQ6IGZ1bmN0aW9uKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmxlbmd0aCA8IDEgfHwgcGFyYW1zLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwic3BsaXQgZmlsdGVyIGV4cGVjdHMgMSBvciAyIGFyZ3VtZW50XCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChUd2lnLmxpYi5pcyhcIlN0cmluZ1wiLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkZWxpbWl0ZXIgPSBwYXJhbXNbMF0sXG5cdCAgICAgICAgICAgICAgICAgICAgbGltaXQgPSBwYXJhbXNbMV0sXG5cdCAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSB2YWx1ZS5zcGxpdChkZWxpbWl0ZXIpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwbGl0O1xuXG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbWl0IDwgMCkge1xuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNwbGl0KGRlbGltaXRlciwgc3BsaXQubGVuZ3RoICsgbGltaXQpO1xuXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxpbWl0ZWRTcGxpdCA9IFtdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGltaXRlciA9PSAnJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSBkZWxpbWl0ZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJhYWJiY2NcInxzcGxpdCgnJywgMilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIC0+IFsnYWEnLCAnYmInLCAnY2MnXVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHNwbGl0Lmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxsaW1pdCAmJiBzcGxpdC5sZW5ndGggPiAwOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wICs9IHNwbGl0LnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdGVkU3BsaXQucHVzaCh0ZW1wKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9uLWVtcHR5IGRlbGltaXRlclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIm9uZSx0d28sdGhyZWUsZm91cixmaXZlXCJ8c3BsaXQoJywnLCAzKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgLT4gWydvbmUnLCAndHdvJywgJ3RocmVlLGZvdXIsZml2ZSddXG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGxpbWl0LTEgJiYgc3BsaXQubGVuZ3RoID4gMDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdGVkU3BsaXQucHVzaChzcGxpdC5zaGlmdCgpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdGVkU3BsaXQucHVzaChzcGxpdC5qb2luKGRlbGltaXRlcikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbWl0ZWRTcGxpdDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJzcGxpdCBmaWx0ZXIgZXhwZWN0cyB2YWx1ZSB0byBiZSBhIHN0cmluZ1wiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgbGFzdDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKFR3aWcubGliLmlzKCdPYmplY3QnLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlzO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUuX2tleXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleXMgPSB2YWx1ZS5fa2V5cztcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2tleXNba2V5cy5sZW5ndGggLSAxXV07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBzdHJpbmd8YXJyYXlcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcmF3OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gVHdpZy5NYXJrdXAodmFsdWUpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgYmF0Y2g6IGZ1bmN0aW9uKGl0ZW1zLCBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgdmFyIHNpemUgPSBwYXJhbXMuc2hpZnQoKSxcblx0ICAgICAgICAgICAgICAgIGZpbGwgPSBwYXJhbXMuc2hpZnQoKSxcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCxcblx0ICAgICAgICAgICAgICAgIGxhc3QsXG5cdCAgICAgICAgICAgICAgICBtaXNzaW5nO1xuXG5cdCAgICAgICAgICAgIGlmICghVHdpZy5saWIuaXMoXCJBcnJheVwiLCBpdGVtcykpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiYmF0Y2ggZmlsdGVyIGV4cGVjdHMgaXRlbXMgdG8gYmUgYW4gYXJyYXlcIik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIVR3aWcubGliLmlzKFwiTnVtYmVyXCIsIHNpemUpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcImJhdGNoIGZpbHRlciBleHBlY3RzIHNpemUgdG8gYmUgYSBudW1iZXJcIik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBzaXplID0gTWF0aC5jZWlsKHNpemUpO1xuXG5cdCAgICAgICAgICAgIHJlc3VsdCA9IFR3aWcubGliLmNodW5rQXJyYXkoaXRlbXMsIHNpemUpO1xuXG5cdCAgICAgICAgICAgIGlmIChmaWxsICYmIGl0ZW1zLmxlbmd0aCAlIHNpemUgIT0gMCkge1xuXHQgICAgICAgICAgICAgICAgbGFzdCA9IHJlc3VsdC5wb3AoKTtcblx0ICAgICAgICAgICAgICAgIG1pc3NpbmcgPSBzaXplIC0gbGFzdC5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgICAgIHdoaWxlIChtaXNzaW5nLS0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBsYXN0LnB1c2goZmlsbCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhc3QpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHJvdW5kOiBmdW5jdGlvbih2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCBbXTtcblxuXHQgICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gcGFyYW1zLmxlbmd0aCA+IDAgPyBwYXJhbXNbMF0gOiAwLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kID0gcGFyYW1zLmxlbmd0aCA+IDEgPyBwYXJhbXNbMV0gOiBcImNvbW1vblwiO1xuXG5cdCAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cblx0ICAgICAgICAgICAgaWYocHJlY2lzaW9uICYmICFUd2lnLmxpYi5pcyhcIk51bWJlclwiLCBwcmVjaXNpb24pKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcInJvdW5kIGZpbHRlciBleHBlY3RzIHByZWNpc2lvbiB0byBiZSBhIG51bWJlclwiKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY29tbW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLmxpYi5yb3VuZCh2YWx1ZSwgcHJlY2lzaW9uKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmKCFUd2lnLmxpYi5pcyhcIkZ1bmN0aW9uXCIsIE1hdGhbbWV0aG9kXSkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwicm91bmQgZmlsdGVyIGV4cGVjdHMgbWV0aG9kIHRvIGJlICdmbG9vcicsICdjZWlsJywgb3IgJ2NvbW1vbidcIik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gTWF0aFttZXRob2RdKHZhbHVlICogTWF0aC5wb3coMTAsIHByZWNpc2lvbikpIC8gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgVHdpZy5maWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIsIHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgICAgICBpZiAoIVR3aWcuZmlsdGVyc1tmaWx0ZXJdKSB7XG5cdCAgICAgICAgICAgIHRocm93IFwiVW5hYmxlIHRvIGZpbmQgZmlsdGVyIFwiICsgZmlsdGVyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gVHdpZy5maWx0ZXJzW2ZpbHRlcl0uYXBwbHkodGhpcywgW3ZhbHVlLCBwYXJhbXNdKTtcblx0ICAgIH07XG5cblx0ICAgIFR3aWcuZmlsdGVyLmV4dGVuZCA9IGZ1bmN0aW9uKGZpbHRlciwgZGVmaW5pdGlvbikge1xuXHQgICAgICAgIFR3aWcuZmlsdGVyc1tmaWx0ZXJdID0gZGVmaW5pdGlvbjtcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBUd2lnO1xuXG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vICMjIHR3aWcuZnVuY3Rpb25zLmpzXG5cdC8vXG5cdC8vIFRoaXMgZmlsZSBoYW5kbGVzIHBhcnNpbmcgZmlsdGVycy5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVHdpZykge1xuXHQgICAgLyoqXG5cdCAgICAgKiBAY29uc3RhbnRcblx0ICAgICAqIEB0eXBlIHtzdHJpbmd9XG5cdCAgICAgKi9cblx0ICAgIHZhciBURU1QTEFURV9OT1RfRk9VTkRfTUVTU0FHRSA9ICdUZW1wbGF0ZSBcIntuYW1lfVwiIGlzIG5vdCBkZWZpbmVkLic7XG5cblx0ICAgIC8vIERldGVybWluZSBvYmplY3QgdHlwZVxuXHQgICAgZnVuY3Rpb24gaXModHlwZSwgb2JqKSB7XG5cdCAgICAgICAgdmFyIGNsYXMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5zbGljZSg4LCAtMSk7XG5cdCAgICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCAmJiBjbGFzID09PSB0eXBlO1xuXHQgICAgfVxuXG5cdCAgICBUd2lnLmZ1bmN0aW9ucyA9IHtcblx0ICAgICAgICAvLyAgYXR0cmlidXRlLCBibG9jaywgY29uc3RhbnQsIGRhdGUsIGR1bXAsIHBhcmVudCwgcmFuZG9tLC5cblxuXHQgICAgICAgIC8vIFJhbmdlIGZ1bmN0aW9uIGZyb20gaHR0cDovL3BocGpzLm9yZy9mdW5jdGlvbnMvcmFuZ2U6NDk5XG5cdCAgICAgICAgLy8gVXNlZCB1bmRlciBhbiBNSVQgTGljZW5zZVxuXHQgICAgICAgIHJhbmdlOiBmdW5jdGlvbiAobG93LCBoaWdoLCBzdGVwKSB7XG5cdCAgICAgICAgICAgIC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG5cdCAgICAgICAgICAgIC8vICsgICBvcmlnaW5hbCBieTogV2FsZG8gTWFscXVpIFNpbHZhXG5cdCAgICAgICAgICAgIC8vICogICAgIGV4YW1wbGUgMTogcmFuZ2UgKCAwLCAxMiApO1xuXHQgICAgICAgICAgICAvLyAqICAgICByZXR1cm5zIDE6IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyXVxuXHQgICAgICAgICAgICAvLyAqICAgICBleGFtcGxlIDI6IHJhbmdlKCAwLCAxMDAsIDEwICk7XG5cdCAgICAgICAgICAgIC8vICogICAgIHJldHVybnMgMjogWzAsIDEwLCAyMCwgMzAsIDQwLCA1MCwgNjAsIDcwLCA4MCwgOTAsIDEwMF1cblx0ICAgICAgICAgICAgLy8gKiAgICAgZXhhbXBsZSAzOiByYW5nZSggJ2EnLCAnaScgKTtcblx0ICAgICAgICAgICAgLy8gKiAgICAgcmV0dXJucyAzOiBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJ11cblx0ICAgICAgICAgICAgLy8gKiAgICAgZXhhbXBsZSA0OiByYW5nZSggJ2MnLCAnYScgKTtcblx0ICAgICAgICAgICAgLy8gKiAgICAgcmV0dXJucyA0OiBbJ2MnLCAnYicsICdhJ11cblx0ICAgICAgICAgICAgdmFyIG1hdHJpeCA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgaW5pdmFsLCBlbmR2YWwsIHBsdXM7XG5cdCAgICAgICAgICAgIHZhciB3YWxrZXIgPSBzdGVwIHx8IDE7XG5cdCAgICAgICAgICAgIHZhciBjaGFycyA9IGZhbHNlO1xuXG5cdCAgICAgICAgICAgIGlmICghaXNOYU4obG93KSAmJiAhaXNOYU4oaGlnaCkpIHtcblx0ICAgICAgICAgICAgICAgIGluaXZhbCA9IHBhcnNlSW50KGxvdywgMTApO1xuXHQgICAgICAgICAgICAgICAgZW5kdmFsID0gcGFyc2VJbnQoaGlnaCwgMTApO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGxvdykgJiYgaXNOYU4oaGlnaCkpIHtcblx0ICAgICAgICAgICAgICAgIGNoYXJzID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGluaXZhbCA9IGxvdy5jaGFyQ29kZUF0KDApO1xuXHQgICAgICAgICAgICAgICAgZW5kdmFsID0gaGlnaC5jaGFyQ29kZUF0KDApO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaW5pdmFsID0gKGlzTmFOKGxvdykgPyAwIDogbG93KTtcblx0ICAgICAgICAgICAgICAgIGVuZHZhbCA9IChpc05hTihoaWdoKSA/IDAgOiBoaWdoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHBsdXMgPSAoKGluaXZhbCA+IGVuZHZhbCkgPyBmYWxzZSA6IHRydWUpO1xuXHQgICAgICAgICAgICBpZiAocGx1cykge1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGluaXZhbCA8PSBlbmR2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtYXRyaXgucHVzaCgoKGNoYXJzKSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoaW5pdmFsKSA6IGluaXZhbCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGluaXZhbCArPSB3YWxrZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoaW5pdmFsID49IGVuZHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5wdXNoKCgoY2hhcnMpID8gU3RyaW5nLmZyb21DaGFyQ29kZShpbml2YWwpIDogaW5pdmFsKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdmFsIC09IHdhbGtlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBjeWNsZTogZnVuY3Rpb24oYXJyLCBpKSB7XG5cdCAgICAgICAgICAgIHZhciBwb3MgPSBpICUgYXJyLmxlbmd0aDtcblx0ICAgICAgICAgICAgcmV0dXJuIGFycltwb3NdO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZHVtcDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBFT0wgPSAnXFxuJyxcblx0ICAgICAgICAgICAgICAgIGluZGVudENoYXIgPSAnICAnLFxuXHQgICAgICAgICAgICAgICAgaW5kZW50VGltZXMgPSAwLFxuXHQgICAgICAgICAgICAgICAgb3V0ID0gJycsXG5cdCAgICAgICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcblx0ICAgICAgICAgICAgICAgIGluZGVudCA9IGZ1bmN0aW9uKHRpbWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZCAgPSAnJztcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGltZXMgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzLS07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluZCArPSBpbmRlbnRDaGFyO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGRpc3BsYXlWYXIgPSBmdW5jdGlvbih2YXJpYWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG91dCArPSBpbmRlbnQoaW5kZW50VGltZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YodmFyaWFibGUpID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdW1wVmFyKHZhcmlhYmxlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZih2YXJpYWJsZSkgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICdmdW5jdGlvbigpJyArIEVPTDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZih2YXJpYWJsZSkgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnc3RyaW5nKCcgKyB2YXJpYWJsZS5sZW5ndGggKyAnKSBcIicgKyB2YXJpYWJsZSArICdcIicgKyBFT0w7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YodmFyaWFibGUpID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ251bWJlcignICsgdmFyaWFibGUgKyAnKScgKyBFT0w7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YodmFyaWFibGUpID09PSAnYm9vbGVhbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICdib29sKCcgKyB2YXJpYWJsZSArICcpJyArIEVPTDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZHVtcFZhciA9IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnTlVMTCcgKyBFT0w7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YXJpYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAndW5kZWZpbmVkJyArIEVPTDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IGluZGVudChpbmRlbnRUaW1lcykgKyB0eXBlb2YodmFyaWFibGUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnRUaW1lcysrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJygnICsgKGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSAwLCBrZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSh2YXJpYWJsZSkgKyAnKSB7JyArIEVPTDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIHZhcmlhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gaW5kZW50KGluZGVudFRpbWVzKSArICdbJyArIGkgKyAnXT0+ICcgKyBFT0w7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VmFyKHZhcmlhYmxlW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnRUaW1lcy0tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gaW5kZW50KGluZGVudFRpbWVzKSArICd9JyArIEVPTDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VmFyKHZhcmlhYmxlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIC8vIGhhbmRsZSBubyBhcmd1bWVudCBjYXNlIGJ5IGR1bXBpbmcgdGhlIGVudGlyZSByZW5kZXIgY29udGV4dFxuXHQgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT0gMCkgYXJncy5wdXNoKHRoaXMuY29udGV4dCk7XG5cblx0ICAgICAgICAgICAgVHdpZy5mb3JFYWNoKGFyZ3MsIGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICBkdW1wVmFyKHZhcmlhYmxlKTtcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG91dDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGRhdGU6IGZ1bmN0aW9uKGRhdGUsIHRpbWUpIHtcblx0ICAgICAgICAgICAgdmFyIGRhdGVPYmo7XG5cdCAgICAgICAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQgfHwgZGF0ZSA9PT0gbnVsbCB8fCBkYXRlID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRlT2JqID0gbmV3IERhdGUoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUd2lnLmxpYi5pcyhcIkRhdGVcIiwgZGF0ZSkpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGVPYmogPSBkYXRlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFR3aWcubGliLmlzKFwiU3RyaW5nXCIsIGRhdGUpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGF0ZS5tYXRjaCgvXlswLTldKyQvKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGVPYmogPSBuZXcgRGF0ZShkYXRlICogMTAwMCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBkYXRlT2JqID0gbmV3IERhdGUoVHdpZy5saWIuc3RydG90aW1lKGRhdGUpICogMTAwMCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoVHdpZy5saWIuaXMoXCJOdW1iZXJcIiwgZGF0ZSkpIHtcblx0ICAgICAgICAgICAgICAgIC8vIHRpbWVzdGFtcFxuXHQgICAgICAgICAgICAgICAgZGF0ZU9iaiA9IG5ldyBEYXRlKGRhdGUgKiAxMDAwKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIGRhdGUgXCIgKyBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZGF0ZU9iajtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGJsb2NrOiBmdW5jdGlvbihibG9jaykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEJsb2NrVG9rZW5zW2Jsb2NrXSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcubG9naWMucGFyc2UuYXBwbHkodGhpcywgW3RoaXMub3JpZ2luYWxCbG9ja1Rva2Vuc1tibG9ja10sIHRoaXMuY29udGV4dF0pLm91dHB1dDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2Nrc1tibG9ja107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHBhcmVudDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIC8vIEFkZCBhIHBsYWNlaG9sZGVyXG5cdCAgICAgICAgICAgIHJldHVybiBUd2lnLnBsYWNlaG9sZGVycy5wYXJlbnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBhdHRyaWJ1dGU6IGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgaWYgKFR3aWcubGliLmlzKCdPYmplY3QnLCBvYmplY3QpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KG1ldGhvZCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdFttZXRob2RdLmFwcGx5KHVuZGVmaW5lZCwgcGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RbbWV0aG9kXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gQXJyYXkgd2lsbCByZXR1cm4gZWxlbWVudCAwLWluZGV4XG5cdCAgICAgICAgICAgIHJldHVybiBvYmplY3RbbWV0aG9kXSB8fCB1bmRlZmluZWQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBtYXg6IGZ1bmN0aW9uKHZhbHVlcykge1xuXHQgICAgICAgICAgICBpZihUd2lnLmxpYi5pcyhcIk9iamVjdFwiLCB2YWx1ZXMpKSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVzW1wiX2tleXNcIl07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5saWIubWF4KHZhbHVlcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gVHdpZy5saWIubWF4LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBtaW46IGZ1bmN0aW9uKHZhbHVlcykge1xuXHQgICAgICAgICAgICBpZihUd2lnLmxpYi5pcyhcIk9iamVjdFwiLCB2YWx1ZXMpKSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVzW1wiX2tleXNcIl07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5saWIubWluKHZhbHVlcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gVHdpZy5saWIubWluLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB0ZW1wbGF0ZV9mcm9tX3N0cmluZzogZnVuY3Rpb24odGVtcGxhdGUpIHtcblx0ICAgICAgICAgICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gJyc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFR3aWcuVGVtcGxhdGVzLnBhcnNlcnMudHdpZyh7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG5cdCAgICAgICAgICAgICAgICBkYXRhOiB0ZW1wbGF0ZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgdmFyIExJTUlUX0lOVDMxID0gMHg4MDAwMDAwMDtcblxuXHQgICAgICAgICAgICBmdW5jdGlvbiBnZXRSYW5kb21OdW1iZXIobikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIExJTUlUX0lOVDMxKTtcblx0ICAgICAgICAgICAgICAgIHZhciBsaW1pdHMgPSBbMCwgbl07XG5cdCAgICAgICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgbGltaXRzKSxcblx0ICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBsaW1pdHMpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbiArIDEpICogcmFuZG9tIC8gTElNSVRfSU5UMzEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYoVHdpZy5saWIuaXMoXCJOdW1iZXJcIiwgdmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFuZG9tTnVtYmVyKHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmKFR3aWcubGliLmlzKFwiU3RyaW5nXCIsIHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNoYXJBdChnZXRSYW5kb21OdW1iZXIodmFsdWUubGVuZ3RoLTEpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmKFR3aWcubGliLmlzKFwiQXJyYXlcIiwgdmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbZ2V0UmFuZG9tTnVtYmVyKHZhbHVlLmxlbmd0aC0xKV07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZihUd2lnLmxpYi5pcyhcIk9iamVjdFwiLCB2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2tleXNbZ2V0UmFuZG9tTnVtYmVyKGtleXMubGVuZ3RoLTEpXV07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZ2V0UmFuZG9tTnVtYmVyKExJTUlUX0lOVDMxLTEpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IG9mIGEgdGVtcGxhdGUgd2l0aG91dCByZW5kZXJpbmcgaXRcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZV9taXNzaW5nPWZhbHNlXVxuXHQgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc291cmNlOiBmdW5jdGlvbihuYW1lLCBpZ25vcmVfbWlzc2luZykge1xuXHQgICAgICAgICAgICB2YXIgdGVtcGxhdGVTb3VyY2U7XG5cdCAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUZvdW5kID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciBpc05vZGVFbnZpcm9ubWVudCA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cdCAgICAgICAgICAgIHZhciBsb2FkZXI7XG5cdCAgICAgICAgICAgIHZhciBwYXRoO1xuXG5cdCAgICAgICAgICAgIC8vaWYgd2UgYXJlIHJ1bm5pbmcgaW4gYSBub2RlLmpzIGVudmlyb25tZW50LCBzZXQgdGhlIGxvYWRlciB0byAnZnMnIGFuZCBlbnN1cmUgdGhlXG5cdCAgICAgICAgICAgIC8vIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIENXRCBvZiB0aGUgcnVubmluZyBzY3JpcHRcblx0ICAgICAgICAgICAgLy9lbHNlLCBzZXQgdGhlIGxvYWRlciB0byAnYWpheCcgYW5kIHNldCB0aGUgcGF0aCB0byB0aGUgdmFsdWUgb2YgbmFtZVxuXHQgICAgICAgICAgICBpZiAoaXNOb2RlRW52aXJvbm1lbnQpIHtcblx0ICAgICAgICAgICAgICAgIGxvYWRlciA9ICdmcyc7XG5cdCAgICAgICAgICAgICAgICBwYXRoID0gX19kaXJuYW1lICsgJy8nICsgbmFtZTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGxvYWRlciA9ICdhamF4Jztcblx0ICAgICAgICAgICAgICAgIHBhdGggPSBuYW1lO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy9idWlsZCB0aGUgcGFyYW1zIG9iamVjdFxuXHQgICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuXHQgICAgICAgICAgICAgICAgaWQ6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBsb2FkZXIsXG5cdCAgICAgICAgICAgICAgICBwYXJzZXI6ICdzb3VyY2UnLFxuXHQgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgZmV0Y2hUZW1wbGF0ZVNvdXJjZTogdHJ1ZVxuXHQgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIC8vZGVmYXVsdCBpZ25vcmVfbWlzc2luZyB0byBmYWxzZVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGlnbm9yZV9taXNzaW5nID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgICAgICAgaWdub3JlX21pc3NpbmcgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vdHJ5IHRvIGxvYWQgdGhlIHJlbW90ZSB0ZW1wbGF0ZVxuXHQgICAgICAgICAgICAvL1xuXHQgICAgICAgICAgICAvL29uIGV4Y2VwdGlvbiwgbG9nIGl0XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB0ZW1wbGF0ZVNvdXJjZSA9IFR3aWcuVGVtcGxhdGVzLmxvYWRSZW1vdGUobmFtZSwgcGFyYW1zKTtcblxuXHQgICAgICAgICAgICAgICAgLy9pZiB0aGUgdGVtcGxhdGUgaXMgdW5kZWZpbmVkIG9yIG51bGwsIHNldCB0aGUgdGVtcGxhdGUgdG8gYW4gZW1wdHkgc3RyaW5nIGFuZCBkbyBOT1QgZmxpcCB0aGVcblx0ICAgICAgICAgICAgICAgIC8vIGJvb2xlYW4gaW5kaWNhdGluZyB3ZSBmb3VuZCB0aGUgdGVtcGxhdGVcblx0ICAgICAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgICAgICAvL2Vsc2UsIGFsbCBpcyBnb29kISBmbGlwIHRoZSBib29sZWFuIGluZGljYXRpbmcgd2UgZm91bmQgdGhlIHRlbXBsYXRlXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlU291cmNlID09PSAndW5kZWZpbmVkJyB8fCB0ZW1wbGF0ZVNvdXJjZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlU291cmNlID0gJyc7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlRm91bmQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICBUd2lnLmxvZy5kZWJ1ZygnVHdpZy5mdW5jdGlvbnMuc291cmNlOiAnLCAnUHJvYmxlbSBsb2FkaW5nIHRlbXBsYXRlICAnLCBlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vaWYgdGhlIHRlbXBsYXRlIHdhcyBOT1QgZm91bmQgQU5EIHdlIGFyZSBub3QgaWdub3JpbmcgbWlzc2luZyB0ZW1wbGF0ZXMsIHJldHVybiB0aGUgc2FtZSBtZXNzYWdlXG5cdCAgICAgICAgICAgIC8vIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhlIFBIUCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdHdpZyBzb3VyY2UoKSBmdW5jdGlvblxuXHQgICAgICAgICAgICAvL1xuXHQgICAgICAgICAgICAvL2Vsc2UsIHJldHVybiB0aGUgdGVtcGxhdGUgc291cmNlXG5cdCAgICAgICAgICAgIGlmICghdGVtcGxhdGVGb3VuZCAmJiAhaWdub3JlX21pc3NpbmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBURU1QTEFURV9OT1RfRk9VTkRfTUVTU0FHRS5yZXBsYWNlKCd7bmFtZX0nLCBuYW1lKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZVNvdXJjZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIFR3aWcuX2Z1bmN0aW9uID0gZnVuY3Rpb24oX2Z1bmN0aW9uLCB2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKCFUd2lnLmZ1bmN0aW9uc1tfZnVuY3Rpb25dKSB7XG5cdCAgICAgICAgICAgIHRocm93IFwiVW5hYmxlIHRvIGZpbmQgZnVuY3Rpb24gXCIgKyBfZnVuY3Rpb247XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBUd2lnLmZ1bmN0aW9uc1tfZnVuY3Rpb25dKHZhbHVlLCBwYXJhbXMpO1xuXHQgICAgfTtcblxuXHQgICAgVHdpZy5fZnVuY3Rpb24uZXh0ZW5kID0gZnVuY3Rpb24oX2Z1bmN0aW9uLCBkZWZpbml0aW9uKSB7XG5cdCAgICAgICAgVHdpZy5mdW5jdGlvbnNbX2Z1bmN0aW9uXSA9IGRlZmluaXRpb247XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gVHdpZztcblxuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyAjIyB0d2lnLmxpYi5qc1xuXHQvL1xuXHQvLyBUaGlzIGZpbGUgY29udGFpbnMgM3JkIHBhcnR5IGxpYnJhcmllcyB1c2VkIHdpdGhpbiB0d2lnLlxuXHQvL1xuXHQvLyBDb3BpZXMgb2YgdGhlIGxpY2Vuc2VzIGZvciB0aGUgY29kZSBpbmNsdWRlZCBoZXJlIGNhbiBiZSBmb3VuZCBpbiB0aGVcblx0Ly8gTElDRU5TRVMubWQgZmlsZS5cblx0Ly9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFR3aWcpIHtcblxuXHQgICAgLy8gTmFtZXNwYWNlIGZvciBsaWJyYXJpZXNcblx0ICAgIFR3aWcubGliID0geyB9O1xuXG5cdCAgICBUd2lnLmxpYi5zcHJpbnRmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0ICAgIFR3aWcubGliLnZzcHJpbnRmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0ICAgIFR3aWcubGliLnJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdCAgICBUd2lnLmxpYi5tYXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0ICAgIFR3aWcubGliLm1pbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHQgICAgVHdpZy5saWIuc3RyaXBfdGFncyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXHQgICAgVHdpZy5saWIuc3RydG90aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdCAgICBUd2lnLmxpYi5kYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdCAgICBUd2lnLmxpYi5ib29sdmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cblx0ICAgIFR3aWcubGliLmlzID0gZnVuY3Rpb24odHlwZSwgb2JqKSB7XG5cdCAgICAgICAgdmFyIGNsYXMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5zbGljZSg4LCAtMSk7XG5cdCAgICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCAmJiBjbGFzID09PSB0eXBlO1xuXHQgICAgfTtcblxuXHQgICAgLy8gc2hhbGxvdy1jb3B5IGFuIG9iamVjdFxuXHQgICAgVHdpZy5saWIuY29weSA9IGZ1bmN0aW9uKHNyYykge1xuXHQgICAgICAgIHZhciB0YXJnZXQgPSB7fSxcblx0ICAgICAgICAgICAga2V5O1xuXHQgICAgICAgIGZvciAoa2V5IGluIHNyYylcblx0ICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcblxuXHQgICAgICAgIHJldHVybiB0YXJnZXQ7XG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLmxpYi5leHRlbmQgPSBmdW5jdGlvbiAoc3JjLCBhZGQpIHtcblx0ICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCksXG5cdCAgICAgICAgICAgIGk7XG5cblx0ICAgICAgICBpID0ga2V5cy5sZW5ndGg7XG5cblx0ICAgICAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgICAgICAgIHNyY1trZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gc3JjO1xuXHQgICAgfTtcblxuXHQgICAgVHdpZy5saWIucmVwbGFjZUFsbCA9IGZ1bmN0aW9uKHN0cmluZywgc2VhcmNoLCByZXBsYWNlKSB7XG5cdCAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChzZWFyY2gpLmpvaW4ocmVwbGFjZSk7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBjaHVuayBhbiBhcnJheSAoYXJyKSBpbnRvIGFycmF5cyBvZiAoc2l6ZSkgaXRlbXMsIHJldHVybnMgYW4gYXJyYXkgb2YgYXJyYXlzLCBvciBhbiBlbXB0eSBhcnJheSBvbiBpbnZhbGlkIGlucHV0XG5cdCAgICBUd2lnLmxpYi5jaHVua0FycmF5ID0gZnVuY3Rpb24gKGFyciwgc2l6ZSkge1xuXHQgICAgICAgIHZhciByZXR1cm5WYWwgPSBbXSxcblx0ICAgICAgICAgICAgeCA9IDAsXG5cdCAgICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGg7XG5cblx0ICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgIVR3aWcubGliLmlzKFwiQXJyYXlcIiwgYXJyKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgd2hpbGUgKHggPCBsZW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuVmFsLnB1c2goYXJyLnNsaWNlKHgsIHggKz0gc2l6ZSkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiByZXR1cm5WYWw7XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gVHdpZztcblx0fTtcblxuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByaW50ZigpIHtcblx0ICAvLyAgZGlzY3VzcyBhdDogaHR0cDovL2xvY3V0dXMuaW8vcGhwL3NwcmludGYvXG5cdCAgLy8gb3JpZ2luYWwgYnk6IEFzaCBTZWFybGUgKGh0dHA6Ly9oZXhtZW4uY29tL2Jsb2cvKVxuXHQgIC8vIGltcHJvdmVkIGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vZ2V0c3ByaW5rLmNvbSlcblx0ICAvLyBpbXByb3ZlZCBieTogSmFja1xuXHQgIC8vIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va3Z6LmlvKVxuXHQgIC8vIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va3Z6LmlvKVxuXHQgIC8vIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va3Z6LmlvKVxuXHQgIC8vIGltcHJvdmVkIGJ5OiBEalxuXHQgIC8vIGltcHJvdmVkIGJ5OiBBbGxpZHlsbHNcblx0ICAvLyAgICBpbnB1dCBieTogUGF1bG8gRnJlaXRhc1xuXHQgIC8vICAgIGlucHV0IGJ5OiBCcmV0dCBaYW1pciAoaHR0cDovL2JyZXR0LXphbWlyLm1lKVxuXHQgIC8vICAgZXhhbXBsZSAxOiBzcHJpbnRmKFwiJTAxLjJmXCIsIDEyMy4xKVxuXHQgIC8vICAgcmV0dXJucyAxOiAnMTIzLjEwJ1xuXHQgIC8vICAgZXhhbXBsZSAyOiBzcHJpbnRmKFwiWyUxMHNdXCIsICdtb25rZXknKVxuXHQgIC8vICAgcmV0dXJucyAyOiAnWyAgICBtb25rZXldJ1xuXHQgIC8vICAgZXhhbXBsZSAzOiBzcHJpbnRmKFwiWyUnIzEwc11cIiwgJ21vbmtleScpXG5cdCAgLy8gICByZXR1cm5zIDM6ICdbIyMjI21vbmtleV0nXG5cdCAgLy8gICBleGFtcGxlIDQ6IHNwcmludGYoXCIlZFwiLCAxMjM0NTY3ODkwMTIzNDUpXG5cdCAgLy8gICByZXR1cm5zIDQ6ICcxMjM0NTY3ODkwMTIzNDUnXG5cdCAgLy8gICBleGFtcGxlIDU6IHNwcmludGYoJyUtMDNzJywgJ0UnKVxuXHQgIC8vICAgcmV0dXJucyA1OiAnRTAwJ1xuXG5cdCAgdmFyIHJlZ2V4ID0gLyUlfCUoXFxkK1xcJCk/KFstKycjMCBdKikoXFwqXFxkK1xcJHxcXCp8XFxkKyk/KD86XFwuKFxcKlxcZCtcXCR8XFwqfFxcZCspKT8oW3NjYm94WHVpZGVFZkZnR10pL2c7XG5cdCAgdmFyIGEgPSBhcmd1bWVudHM7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHZhciBmb3JtYXQgPSBhW2krK107XG5cblx0ICB2YXIgX3BhZCA9IGZ1bmN0aW9uIF9wYWQoc3RyLCBsZW4sIGNociwgbGVmdEp1c3RpZnkpIHtcblx0ICAgIGlmICghY2hyKSB7XG5cdCAgICAgIGNociA9ICcgJztcblx0ICAgIH1cblx0ICAgIHZhciBwYWRkaW5nID0gc3RyLmxlbmd0aCA+PSBsZW4gPyAnJyA6IG5ldyBBcnJheSgxICsgbGVuIC0gc3RyLmxlbmd0aCA+Pj4gMCkuam9pbihjaHIpO1xuXHQgICAgcmV0dXJuIGxlZnRKdXN0aWZ5ID8gc3RyICsgcGFkZGluZyA6IHBhZGRpbmcgKyBzdHI7XG5cdCAgfTtcblxuXHQgIHZhciBqdXN0aWZ5ID0gZnVuY3Rpb24ganVzdGlmeSh2YWx1ZSwgcHJlZml4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHplcm9QYWQsIGN1c3RvbVBhZENoYXIpIHtcblx0ICAgIHZhciBkaWZmID0gbWluV2lkdGggLSB2YWx1ZS5sZW5ndGg7XG5cdCAgICBpZiAoZGlmZiA+IDApIHtcblx0ICAgICAgaWYgKGxlZnRKdXN0aWZ5IHx8ICF6ZXJvUGFkKSB7XG5cdCAgICAgICAgdmFsdWUgPSBfcGFkKHZhbHVlLCBtaW5XaWR0aCwgY3VzdG9tUGFkQ2hhciwgbGVmdEp1c3RpZnkpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhbHVlID0gW3ZhbHVlLnNsaWNlKDAsIHByZWZpeC5sZW5ndGgpLCBfcGFkKCcnLCBkaWZmLCAnMCcsIHRydWUpLCB2YWx1ZS5zbGljZShwcmVmaXgubGVuZ3RoKV0uam9pbignJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9O1xuXG5cdCAgdmFyIF9mb3JtYXRCYXNlWCA9IGZ1bmN0aW9uIF9mb3JtYXRCYXNlWCh2YWx1ZSwgYmFzZSwgcHJlZml4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCkge1xuXHQgICAgLy8gTm90ZTogY2FzdHMgbmVnYXRpdmUgbnVtYmVycyB0byBwb3NpdGl2ZSBvbmVzXG5cdCAgICB2YXIgbnVtYmVyID0gdmFsdWUgPj4+IDA7XG5cdCAgICBwcmVmaXggPSBwcmVmaXggJiYgbnVtYmVyICYmIHtcblx0ICAgICAgJzInOiAnMGInLFxuXHQgICAgICAnOCc6ICcwJyxcblx0ICAgICAgJzE2JzogJzB4J1xuXHQgICAgfVtiYXNlXSB8fCAnJztcblx0ICAgIHZhbHVlID0gcHJlZml4ICsgX3BhZChudW1iZXIudG9TdHJpbmcoYmFzZSksIHByZWNpc2lvbiB8fCAwLCAnMCcsIGZhbHNlKTtcblx0ICAgIHJldHVybiBqdXN0aWZ5KHZhbHVlLCBwcmVmaXgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgemVyb1BhZCk7XG5cdCAgfTtcblxuXHQgIC8vIF9mb3JtYXRTdHJpbmcoKVxuXHQgIHZhciBfZm9ybWF0U3RyaW5nID0gZnVuY3Rpb24gX2Zvcm1hdFN0cmluZyh2YWx1ZSwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQsIGN1c3RvbVBhZENoYXIpIHtcblx0ICAgIGlmIChwcmVjaXNpb24gIT09IG51bGwgJiYgcHJlY2lzaW9uICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBwcmVjaXNpb24pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGp1c3RpZnkodmFsdWUsICcnLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHplcm9QYWQsIGN1c3RvbVBhZENoYXIpO1xuXHQgIH07XG5cblx0ICAvLyBkb0Zvcm1hdCgpXG5cdCAgdmFyIGRvRm9ybWF0ID0gZnVuY3Rpb24gZG9Gb3JtYXQoc3Vic3RyaW5nLCB2YWx1ZUluZGV4LCBmbGFncywgbWluV2lkdGgsIHByZWNpc2lvbiwgdHlwZSkge1xuXHQgICAgdmFyIG51bWJlciwgcHJlZml4LCBtZXRob2QsIHRleHRUcmFuc2Zvcm0sIHZhbHVlO1xuXG5cdCAgICBpZiAoc3Vic3RyaW5nID09PSAnJSUnKSB7XG5cdCAgICAgIHJldHVybiAnJSc7XG5cdCAgICB9XG5cblx0ICAgIC8vIHBhcnNlIGZsYWdzXG5cdCAgICB2YXIgbGVmdEp1c3RpZnkgPSBmYWxzZTtcblx0ICAgIHZhciBwb3NpdGl2ZVByZWZpeCA9ICcnO1xuXHQgICAgdmFyIHplcm9QYWQgPSBmYWxzZTtcblx0ICAgIHZhciBwcmVmaXhCYXNlWCA9IGZhbHNlO1xuXHQgICAgdmFyIGN1c3RvbVBhZENoYXIgPSAnICc7XG5cdCAgICB2YXIgZmxhZ3NsID0gZmxhZ3MubGVuZ3RoO1xuXHQgICAgdmFyIGo7XG5cdCAgICBmb3IgKGogPSAwOyBqIDwgZmxhZ3NsOyBqKyspIHtcblx0ICAgICAgc3dpdGNoIChmbGFncy5jaGFyQXQoaikpIHtcblx0ICAgICAgICBjYXNlICcgJzpcblx0ICAgICAgICAgIHBvc2l0aXZlUHJlZml4ID0gJyAnO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAnKyc6XG5cdCAgICAgICAgICBwb3NpdGl2ZVByZWZpeCA9ICcrJztcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgJy0nOlxuXHQgICAgICAgICAgbGVmdEp1c3RpZnkgPSB0cnVlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBcIidcIjpcblx0ICAgICAgICAgIGN1c3RvbVBhZENoYXIgPSBmbGFncy5jaGFyQXQoaiArIDEpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAnMCc6XG5cdCAgICAgICAgICB6ZXJvUGFkID0gdHJ1ZTtcblx0ICAgICAgICAgIGN1c3RvbVBhZENoYXIgPSAnMCc7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlICcjJzpcblx0ICAgICAgICAgIHByZWZpeEJhc2VYID0gdHJ1ZTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIHBhcmFtZXRlcnMgbWF5IGJlIG51bGwsIHVuZGVmaW5lZCwgZW1wdHktc3RyaW5nIG9yIHJlYWwgdmFsdWVkXG5cdCAgICAvLyB3ZSB3YW50IHRvIGlnbm9yZSBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5LXN0cmluZyB2YWx1ZXNcblx0ICAgIGlmICghbWluV2lkdGgpIHtcblx0ICAgICAgbWluV2lkdGggPSAwO1xuXHQgICAgfSBlbHNlIGlmIChtaW5XaWR0aCA9PT0gJyonKSB7XG5cdCAgICAgIG1pbldpZHRoID0gK2FbaSsrXTtcblx0ICAgIH0gZWxzZSBpZiAobWluV2lkdGguY2hhckF0KDApID09PSAnKicpIHtcblx0ICAgICAgbWluV2lkdGggPSArYVttaW5XaWR0aC5zbGljZSgxLCAtMSldO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbWluV2lkdGggPSArbWluV2lkdGg7XG5cdCAgICB9XG5cblx0ICAgIC8vIE5vdGU6IHVuZG9jdW1lbnRlZCBwZXJsIGZlYXR1cmU6XG5cdCAgICBpZiAobWluV2lkdGggPCAwKSB7XG5cdCAgICAgIG1pbldpZHRoID0gLW1pbldpZHRoO1xuXHQgICAgICBsZWZ0SnVzdGlmeSA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICghaXNGaW5pdGUobWluV2lkdGgpKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignc3ByaW50ZjogKG1pbmltdW0tKXdpZHRoIG11c3QgYmUgZmluaXRlJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghcHJlY2lzaW9uKSB7XG5cdCAgICAgIHByZWNpc2lvbiA9ICdmRmVFJy5pbmRleE9mKHR5cGUpID4gLTEgPyA2IDogdHlwZSA9PT0gJ2QnID8gMCA6IHVuZGVmaW5lZDtcblx0ICAgIH0gZWxzZSBpZiAocHJlY2lzaW9uID09PSAnKicpIHtcblx0ICAgICAgcHJlY2lzaW9uID0gK2FbaSsrXTtcblx0ICAgIH0gZWxzZSBpZiAocHJlY2lzaW9uLmNoYXJBdCgwKSA9PT0gJyonKSB7XG5cdCAgICAgIHByZWNpc2lvbiA9ICthW3ByZWNpc2lvbi5zbGljZSgxLCAtMSldO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcHJlY2lzaW9uID0gK3ByZWNpc2lvbjtcblx0ICAgIH1cblxuXHQgICAgLy8gZ3JhYiB2YWx1ZSB1c2luZyB2YWx1ZUluZGV4IGlmIHJlcXVpcmVkP1xuXHQgICAgdmFsdWUgPSB2YWx1ZUluZGV4ID8gYVt2YWx1ZUluZGV4LnNsaWNlKDAsIC0xKV0gOiBhW2krK107XG5cblx0ICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICBjYXNlICdzJzpcblx0ICAgICAgICByZXR1cm4gX2Zvcm1hdFN0cmluZyh2YWx1ZSArICcnLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCwgY3VzdG9tUGFkQ2hhcik7XG5cdCAgICAgIGNhc2UgJ2MnOlxuXHQgICAgICAgIHJldHVybiBfZm9ybWF0U3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoK3ZhbHVlKSwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuXHQgICAgICBjYXNlICdiJzpcblx0ICAgICAgICByZXR1cm4gX2Zvcm1hdEJhc2VYKHZhbHVlLCAyLCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuXHQgICAgICBjYXNlICdvJzpcblx0ICAgICAgICByZXR1cm4gX2Zvcm1hdEJhc2VYKHZhbHVlLCA4LCBwcmVmaXhCYXNlWCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHplcm9QYWQpO1xuXHQgICAgICBjYXNlICd4Jzpcblx0ICAgICAgICByZXR1cm4gX2Zvcm1hdEJhc2VYKHZhbHVlLCAxNiwgcHJlZml4QmFzZVgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCB6ZXJvUGFkKTtcblx0ICAgICAgY2FzZSAnWCc6XG5cdCAgICAgICAgcmV0dXJuIF9mb3JtYXRCYXNlWCh2YWx1ZSwgMTYsIHByZWZpeEJhc2VYLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCkudG9VcHBlckNhc2UoKTtcblx0ICAgICAgY2FzZSAndSc6XG5cdCAgICAgICAgcmV0dXJuIF9mb3JtYXRCYXNlWCh2YWx1ZSwgMTAsIHByZWZpeEJhc2VYLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgemVyb1BhZCk7XG5cdCAgICAgIGNhc2UgJ2knOlxuXHQgICAgICBjYXNlICdkJzpcblx0ICAgICAgICBudW1iZXIgPSArdmFsdWUgfHwgMDtcblx0ICAgICAgICAvLyBQbGFpbiBNYXRoLnJvdW5kIGRvZXNuJ3QganVzdCB0cnVuY2F0ZVxuXHQgICAgICAgIG51bWJlciA9IE1hdGgucm91bmQobnVtYmVyIC0gbnVtYmVyICUgMSk7XG5cdCAgICAgICAgcHJlZml4ID0gbnVtYmVyIDwgMCA/ICctJyA6IHBvc2l0aXZlUHJlZml4O1xuXHQgICAgICAgIHZhbHVlID0gcHJlZml4ICsgX3BhZChTdHJpbmcoTWF0aC5hYnMobnVtYmVyKSksIHByZWNpc2lvbiwgJzAnLCBmYWxzZSk7XG5cdCAgICAgICAgcmV0dXJuIGp1c3RpZnkodmFsdWUsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCB6ZXJvUGFkKTtcblx0ICAgICAgY2FzZSAnZSc6XG5cdCAgICAgIGNhc2UgJ0UnOlxuXHQgICAgICBjYXNlICdmJzogLy8gQHRvZG86IFNob3VsZCBoYW5kbGUgbG9jYWxlcyAoYXMgcGVyIHNldGxvY2FsZSlcblx0ICAgICAgY2FzZSAnRic6XG5cdCAgICAgIGNhc2UgJ2cnOlxuXHQgICAgICBjYXNlICdHJzpcblx0ICAgICAgICBudW1iZXIgPSArdmFsdWU7XG5cdCAgICAgICAgcHJlZml4ID0gbnVtYmVyIDwgMCA/ICctJyA6IHBvc2l0aXZlUHJlZml4O1xuXHQgICAgICAgIG1ldGhvZCA9IFsndG9FeHBvbmVudGlhbCcsICd0b0ZpeGVkJywgJ3RvUHJlY2lzaW9uJ11bJ2VmZycuaW5kZXhPZih0eXBlLnRvTG93ZXJDYXNlKCkpXTtcblx0ICAgICAgICB0ZXh0VHJhbnNmb3JtID0gWyd0b1N0cmluZycsICd0b1VwcGVyQ2FzZSddWydlRWZGZ0cnLmluZGV4T2YodHlwZSkgJSAyXTtcblx0ICAgICAgICB2YWx1ZSA9IHByZWZpeCArIE1hdGguYWJzKG51bWJlcilbbWV0aG9kXShwcmVjaXNpb24pO1xuXHQgICAgICAgIHJldHVybiBqdXN0aWZ5KHZhbHVlLCBwcmVmaXgsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgemVyb1BhZClbdGV4dFRyYW5zZm9ybV0oKTtcblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICByZXR1cm4gc3Vic3RyaW5nO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gZm9ybWF0LnJlcGxhY2UocmVnZXgsIGRvRm9ybWF0KTtcblx0fTtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaW50Zi5qcy5tYXBcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZzcHJpbnRmKGZvcm1hdCwgYXJncykge1xuXHQgIC8vICBkaXNjdXNzIGF0OiBodHRwOi8vbG9jdXR1cy5pby9waHAvdnNwcmludGYvXG5cdCAgLy8gb3JpZ2luYWwgYnk6IGVqc2FuZGVyc1xuXHQgIC8vICAgZXhhbXBsZSAxOiB2c3ByaW50ZignJTA0ZC0lMDJkLSUwMmQnLCBbMTk4OCwgOCwgMV0pXG5cdCAgLy8gICByZXR1cm5zIDE6ICcxOTg4LTA4LTAxJ1xuXG5cdCAgdmFyIHNwcmludGYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG5cdCAgcmV0dXJuIHNwcmludGYuYXBwbHkodGhpcywgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcblx0fTtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9dnNwcmludGYuanMubWFwXG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcm91bmQodmFsdWUsIHByZWNpc2lvbiwgbW9kZSkge1xuXHQgIC8vICBkaXNjdXNzIGF0OiBodHRwOi8vbG9jdXR1cy5pby9waHAvcm91bmQvXG5cdCAgLy8gb3JpZ2luYWwgYnk6IFBoaWxpcCBQZXRlcnNvblxuXHQgIC8vICByZXZpc2VkIGJ5OiBPbm5vIE1hcnNtYW4gKGh0dHBzOi8vdHdpdHRlci5jb20vb25ub21hcnNtYW4pXG5cdCAgLy8gIHJldmlzZWQgYnk6IFQuV2lsZFxuXHQgIC8vICByZXZpc2VkIGJ5OiBSYWZhxYIgS3VrYXdza2kgKGh0dHA6Ly9ibG9nLmt1a2F3c2tpLnBsKVxuXHQgIC8vICAgIGlucHV0IGJ5OiBHcmVlbnNlZWRcblx0ICAvLyAgICBpbnB1dCBieTogbWVvXG5cdCAgLy8gICAgaW5wdXQgYnk6IFdpbGxpYW1cblx0ICAvLyAgICBpbnB1dCBieTogSm9zZXAgU2FueiAoaHR0cDovL3d3dy53czMuZXMvKVxuXHQgIC8vIGJ1Z2ZpeGVkIGJ5OiBCcmV0dCBaYW1pciAoaHR0cDovL2JyZXR0LXphbWlyLm1lKVxuXHQgIC8vICAgICAgbm90ZSAxOiBHcmVhdCB3b3JrLiBJZGVhcyBmb3IgaW1wcm92ZW1lbnQ6XG5cdCAgLy8gICAgICBub3RlIDE6IC0gY29kZSBtb3JlIGNvbXBsaWFudCB3aXRoIGRldmVsb3BlciBndWlkZWxpbmVzXG5cdCAgLy8gICAgICBub3RlIDE6IC0gZm9yIGltcGxlbWVudGluZyBQSFAgY29uc3RhbnQgYXJndW1lbnRzIGxvb2sgYXRcblx0ICAvLyAgICAgIG5vdGUgMTogdGhlIHBhdGhpbmZvKCkgZnVuY3Rpb24sIGl0IG9mZmVycyB0aGUgZ3JlYXRlc3Rcblx0ICAvLyAgICAgIG5vdGUgMTogZmxleGliaWxpdHkgJiBjb21wYXRpYmlsaXR5IHBvc3NpYmxlXG5cdCAgLy8gICBleGFtcGxlIDE6IHJvdW5kKDEyNDE3NTcsIC0zKVxuXHQgIC8vICAgcmV0dXJucyAxOiAxMjQyMDAwXG5cdCAgLy8gICBleGFtcGxlIDI6IHJvdW5kKDMuNilcblx0ICAvLyAgIHJldHVybnMgMjogNFxuXHQgIC8vICAgZXhhbXBsZSAzOiByb3VuZCgyLjgzNSwgMilcblx0ICAvLyAgIHJldHVybnMgMzogMi44NFxuXHQgIC8vICAgZXhhbXBsZSA0OiByb3VuZCgxLjE3NDk5OTk5OTk5OTksIDIpXG5cdCAgLy8gICByZXR1cm5zIDQ6IDEuMTdcblx0ICAvLyAgIGV4YW1wbGUgNTogcm91bmQoNTg1NTEuNzk5OTk5OTk5OTk2LCAyKVxuXHQgIC8vICAgcmV0dXJucyA1OiA1ODU1MS44XG5cblx0ICB2YXIgbSwgZiwgaXNIYWxmLCBzZ247IC8vIGhlbHBlciB2YXJpYWJsZXNcblx0ICAvLyBtYWtpbmcgc3VyZSBwcmVjaXNpb24gaXMgaW50ZWdlclxuXHQgIHByZWNpc2lvbiB8PSAwO1xuXHQgIG0gPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcblx0ICB2YWx1ZSAqPSBtO1xuXHQgIC8vIHNpZ24gb2YgdGhlIG51bWJlclxuXHQgIHNnbiA9IHZhbHVlID4gMCB8IC0odmFsdWUgPCAwKTtcblx0ICBpc0hhbGYgPSB2YWx1ZSAlIDEgPT09IDAuNSAqIHNnbjtcblx0ICBmID0gTWF0aC5mbG9vcih2YWx1ZSk7XG5cblx0ICBpZiAoaXNIYWxmKSB7XG5cdCAgICBzd2l0Y2ggKG1vZGUpIHtcblx0ICAgICAgY2FzZSAnUEhQX1JPVU5EX0hBTEZfRE9XTic6XG5cdCAgICAgICAgLy8gcm91bmRzIC41IHRvd2FyZCB6ZXJvXG5cdCAgICAgICAgdmFsdWUgPSBmICsgKHNnbiA8IDApO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlICdQSFBfUk9VTkRfSEFMRl9FVkVOJzpcblx0ICAgICAgICAvLyByb3VkcyAuNSB0b3dhcmRzIHRoZSBuZXh0IGV2ZW4gaW50ZWdlclxuXHQgICAgICAgIHZhbHVlID0gZiArIGYgJSAyICogc2duO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlICdQSFBfUk9VTkRfSEFMRl9PREQnOlxuXHQgICAgICAgIC8vIHJvdW5kcyAuNSB0b3dhcmRzIHRoZSBuZXh0IG9kZCBpbnRlZ2VyXG5cdCAgICAgICAgdmFsdWUgPSBmICsgIShmICUgMik7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgLy8gcm91bmRzIC41IGF3YXkgZnJvbSB6ZXJvXG5cdCAgICAgICAgdmFsdWUgPSBmICsgKHNnbiA+IDApO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiAoaXNIYWxmID8gdmFsdWUgOiBNYXRoLnJvdW5kKHZhbHVlKSkgLyBtO1xuXHR9O1xuXHQvLyMgc291cmNlTWFwcGluZ1VSTD1yb3VuZC5qcy5tYXBcblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF4KCkge1xuXHQgIC8vICBkaXNjdXNzIGF0OiBodHRwOi8vbG9jdXR1cy5pby9waHAvbWF4L1xuXHQgIC8vIG9yaWdpbmFsIGJ5OiBPbm5vIE1hcnNtYW4gKGh0dHBzOi8vdHdpdHRlci5jb20vb25ub21hcnNtYW4pXG5cdCAgLy8gIHJldmlzZWQgYnk6IE9ubm8gTWFyc21hbiAoaHR0cHM6Ly90d2l0dGVyLmNvbS9vbm5vbWFyc21hbilcblx0ICAvLyBpbXByb3ZlZCBieTogSmFja1xuXHQgIC8vICAgICAgbm90ZSAxOiBMb25nIGNvZGUgY2F1c2Ugd2UncmUgYWltaW5nIGZvciBtYXhpbXVtIFBIUCBjb21wYXRpYmlsaXR5XG5cdCAgLy8gICBleGFtcGxlIDE6IG1heCgxLCAzLCA1LCA2LCA3KVxuXHQgIC8vICAgcmV0dXJucyAxOiA3XG5cdCAgLy8gICBleGFtcGxlIDI6IG1heChbMiwgNCwgNV0pXG5cdCAgLy8gICByZXR1cm5zIDI6IDVcblx0ICAvLyAgIGV4YW1wbGUgMzogbWF4KDAsICdoZWxsbycpXG5cdCAgLy8gICByZXR1cm5zIDM6IDBcblx0ICAvLyAgIGV4YW1wbGUgNDogbWF4KCdoZWxsbycsIDApXG5cdCAgLy8gICByZXR1cm5zIDQ6ICdoZWxsbydcblx0ICAvLyAgIGV4YW1wbGUgNTogbWF4KC0xLCAnaGVsbG8nKVxuXHQgIC8vICAgcmV0dXJucyA1OiAnaGVsbG8nXG5cdCAgLy8gICBleGFtcGxlIDY6IG1heChbMiwgNCwgOF0sIFsyLCA1LCA3XSlcblx0ICAvLyAgIHJldHVybnMgNjogWzIsIDUsIDddXG5cblx0ICB2YXIgYXI7XG5cdCAgdmFyIHJldFZhbDtcblx0ICB2YXIgaSA9IDA7XG5cdCAgdmFyIG4gPSAwO1xuXHQgIHZhciBhcmd2ID0gYXJndW1lbnRzO1xuXHQgIHZhciBhcmdjID0gYXJndi5sZW5ndGg7XG5cdCAgdmFyIF9vYmoyQXJyYXkgPSBmdW5jdGlvbiBfb2JqMkFycmF5KG9iaikge1xuXHQgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cdCAgICAgIHJldHVybiBvYmo7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgYXIgPSBbXTtcblx0ICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcblx0ICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdCAgICAgICAgICBhci5wdXNoKG9ialtpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhcjtcblx0ICAgIH1cblx0ICB9O1xuXHQgIHZhciBfY29tcGFyZSA9IGZ1bmN0aW9uIF9jb21wYXJlKGN1cnJlbnQsIG5leHQpIHtcblx0ICAgIHZhciBpID0gMDtcblx0ICAgIHZhciBuID0gMDtcblx0ICAgIHZhciB0bXAgPSAwO1xuXHQgICAgdmFyIG5sID0gMDtcblx0ICAgIHZhciBjbCA9IDA7XG5cblx0ICAgIGlmIChjdXJyZW50ID09PSBuZXh0KSB7XG5cdCAgICAgIHJldHVybiAwO1xuXHQgICAgfSBlbHNlIGlmICgodHlwZW9mIGN1cnJlbnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGN1cnJlbnQpKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgaWYgKCh0eXBlb2YgbmV4dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmV4dCkpID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIGN1cnJlbnQgPSBfb2JqMkFycmF5KGN1cnJlbnQpO1xuXHQgICAgICAgIG5leHQgPSBfb2JqMkFycmF5KG5leHQpO1xuXHQgICAgICAgIGNsID0gY3VycmVudC5sZW5ndGg7XG5cdCAgICAgICAgbmwgPSBuZXh0Lmxlbmd0aDtcblx0ICAgICAgICBpZiAobmwgPiBjbCkge1xuXHQgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgfSBlbHNlIGlmIChubCA8IGNsKSB7XG5cdCAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvciAoaSA9IDAsIG4gPSBjbDsgaSA8IG47ICsraSkge1xuXHQgICAgICAgICAgdG1wID0gX2NvbXBhcmUoY3VycmVudFtpXSwgbmV4dFtpXSk7XG5cdCAgICAgICAgICBpZiAodG1wID09PSAxKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICh0bXAgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIC0xO1xuXHQgICAgfSBlbHNlIGlmICgodHlwZW9mIG5leHQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5leHQpKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgcmV0dXJuIDE7XG5cdCAgICB9IGVsc2UgaWYgKGlzTmFOKG5leHQpICYmICFpc05hTihjdXJyZW50KSkge1xuXHQgICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBjdXJyZW50IDwgMCA/IDEgOiAtMTtcblx0ICAgIH0gZWxzZSBpZiAoaXNOYU4oY3VycmVudCkgJiYgIWlzTmFOKG5leHQpKSB7XG5cdCAgICAgIGlmIChuZXh0ID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG5leHQgPiAwID8gMSA6IC0xO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobmV4dCA9PT0gY3VycmVudCkge1xuXHQgICAgICByZXR1cm4gMDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5leHQgPiBjdXJyZW50ID8gMSA6IC0xO1xuXHQgIH07XG5cblx0ICBpZiAoYXJnYyA9PT0gMCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgdmFsdWUgc2hvdWxkIGJlIHBhc3NlZCB0byBtYXgoKScpO1xuXHQgIH0gZWxzZSBpZiAoYXJnYyA9PT0gMSkge1xuXHQgICAgaWYgKF90eXBlb2YoYXJndlswXSkgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIGFyID0gX29iajJBcnJheShhcmd2WzBdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgcGFyYW1ldGVyIGNvdW50IGZvciBtYXgoKScpO1xuXHQgICAgfVxuXHQgICAgaWYgKGFyLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgZWxlbWVudCBmb3IgbWF4KCknKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgYXIgPSBhcmd2O1xuXHQgIH1cblxuXHQgIHJldFZhbCA9IGFyWzBdO1xuXHQgIGZvciAoaSA9IDEsIG4gPSBhci5sZW5ndGg7IGkgPCBuOyArK2kpIHtcblx0ICAgIGlmIChfY29tcGFyZShyZXRWYWwsIGFyW2ldKSA9PT0gMSkge1xuXHQgICAgICByZXRWYWwgPSBhcltpXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcmV0VmFsO1xuXHR9O1xuXHQvLyMgc291cmNlTWFwcGluZ1VSTD1tYXguanMubWFwXG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1pbigpIHtcblx0ICAvLyAgZGlzY3VzcyBhdDogaHR0cDovL2xvY3V0dXMuaW8vcGhwL21pbi9cblx0ICAvLyBvcmlnaW5hbCBieTogT25ubyBNYXJzbWFuIChodHRwczovL3R3aXR0ZXIuY29tL29ubm9tYXJzbWFuKVxuXHQgIC8vICByZXZpc2VkIGJ5OiBPbm5vIE1hcnNtYW4gKGh0dHBzOi8vdHdpdHRlci5jb20vb25ub21hcnNtYW4pXG5cdCAgLy8gaW1wcm92ZWQgYnk6IEphY2tcblx0ICAvLyAgICAgIG5vdGUgMTogTG9uZyBjb2RlIGNhdXNlIHdlJ3JlIGFpbWluZyBmb3IgbWF4aW11bSBQSFAgY29tcGF0aWJpbGl0eVxuXHQgIC8vICAgZXhhbXBsZSAxOiBtaW4oMSwgMywgNSwgNiwgNylcblx0ICAvLyAgIHJldHVybnMgMTogMVxuXHQgIC8vICAgZXhhbXBsZSAyOiBtaW4oWzIsIDQsIDVdKVxuXHQgIC8vICAgcmV0dXJucyAyOiAyXG5cdCAgLy8gICBleGFtcGxlIDM6IG1pbigwLCAnaGVsbG8nKVxuXHQgIC8vICAgcmV0dXJucyAzOiAwXG5cdCAgLy8gICBleGFtcGxlIDQ6IG1pbignaGVsbG8nLCAwKVxuXHQgIC8vICAgcmV0dXJucyA0OiAnaGVsbG8nXG5cdCAgLy8gICBleGFtcGxlIDU6IG1pbigtMSwgJ2hlbGxvJylcblx0ICAvLyAgIHJldHVybnMgNTogLTFcblx0ICAvLyAgIGV4YW1wbGUgNjogbWluKFsyLCA0LCA4XSwgWzIsIDUsIDddKVxuXHQgIC8vICAgcmV0dXJucyA2OiBbMiwgNCwgOF1cblxuXHQgIHZhciBhcjtcblx0ICB2YXIgcmV0VmFsO1xuXHQgIHZhciBpID0gMDtcblx0ICB2YXIgbiA9IDA7XG5cdCAgdmFyIGFyZ3YgPSBhcmd1bWVudHM7XG5cdCAgdmFyIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcblx0ICB2YXIgX29iajJBcnJheSA9IGZ1bmN0aW9uIF9vYmoyQXJyYXkob2JqKSB7XG5cdCAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblx0ICAgICAgcmV0dXJuIG9iajtcblx0ICAgIH1cblx0ICAgIHZhciBhciA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcblx0ICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICAgIGFyLnB1c2gob2JqW2ldKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFyO1xuXHQgIH07XG5cblx0ICB2YXIgX2NvbXBhcmUgPSBmdW5jdGlvbiBfY29tcGFyZShjdXJyZW50LCBuZXh0KSB7XG5cdCAgICB2YXIgaSA9IDA7XG5cdCAgICB2YXIgbiA9IDA7XG5cdCAgICB2YXIgdG1wID0gMDtcblx0ICAgIHZhciBubCA9IDA7XG5cdCAgICB2YXIgY2wgPSAwO1xuXG5cdCAgICBpZiAoY3VycmVudCA9PT0gbmV4dCkge1xuXHQgICAgICByZXR1cm4gMDtcblx0ICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBjdXJyZW50ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjdXJyZW50KSkgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIGlmICgodHlwZW9mIG5leHQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5leHQpKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICBjdXJyZW50ID0gX29iajJBcnJheShjdXJyZW50KTtcblx0ICAgICAgICBuZXh0ID0gX29iajJBcnJheShuZXh0KTtcblx0ICAgICAgICBjbCA9IGN1cnJlbnQubGVuZ3RoO1xuXHQgICAgICAgIG5sID0gbmV4dC5sZW5ndGg7XG5cdCAgICAgICAgaWYgKG5sID4gY2wpIHtcblx0ICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobmwgPCBjbCkge1xuXHQgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKGkgPSAwLCBuID0gY2w7IGkgPCBuOyArK2kpIHtcblx0ICAgICAgICAgIHRtcCA9IF9jb21wYXJlKGN1cnJlbnRbaV0sIG5leHRbaV0pO1xuXHQgICAgICAgICAgaWYgKHRtcCA9PT0gMSkge1xuXHQgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAodG1wID09PSAtMSkge1xuXHQgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAtMTtcblx0ICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBuZXh0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuZXh0KSkgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIHJldHVybiAxO1xuXHQgICAgfSBlbHNlIGlmIChpc05hTihuZXh0KSAmJiAhaXNOYU4oY3VycmVudCkpIHtcblx0ICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gY3VycmVudCA8IDAgPyAxIDogLTE7XG5cdCAgICB9IGVsc2UgaWYgKGlzTmFOKGN1cnJlbnQpICYmICFpc05hTihuZXh0KSkge1xuXHQgICAgICBpZiAobmV4dCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBuZXh0ID4gMCA/IDEgOiAtMTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG5leHQgPT09IGN1cnJlbnQpIHtcblx0ICAgICAgcmV0dXJuIDA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXh0ID4gY3VycmVudCA/IDEgOiAtMTtcblx0ICB9O1xuXG5cdCAgaWYgKGFyZ2MgPT09IDApIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIHZhbHVlIHNob3VsZCBiZSBwYXNzZWQgdG8gbWluKCknKTtcblx0ICB9IGVsc2UgaWYgKGFyZ2MgPT09IDEpIHtcblx0ICAgIGlmIChfdHlwZW9mKGFyZ3ZbMF0pID09PSAnb2JqZWN0Jykge1xuXHQgICAgICBhciA9IF9vYmoyQXJyYXkoYXJndlswXSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHBhcmFtZXRlciBjb3VudCBmb3IgbWluKCknKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGFyLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgZWxlbWVudCBmb3IgbWluKCknKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgYXIgPSBhcmd2O1xuXHQgIH1cblxuXHQgIHJldFZhbCA9IGFyWzBdO1xuXG5cdCAgZm9yIChpID0gMSwgbiA9IGFyLmxlbmd0aDsgaSA8IG47ICsraSkge1xuXHQgICAgaWYgKF9jb21wYXJlKHJldFZhbCwgYXJbaV0pID09PSAtMSkge1xuXHQgICAgICByZXRWYWwgPSBhcltpXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcmV0VmFsO1xuXHR9O1xuXHQvLyMgc291cmNlTWFwcGluZ1VSTD1taW4uanMubWFwXG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaXBfdGFncyhpbnB1dCwgYWxsb3dlZCkge1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cdCAgLy8gIGRpc2N1c3MgYXQ6IGh0dHA6Ly9sb2N1dHVzLmlvL3BocC9zdHJpcF90YWdzL1xuXHQgIC8vIG9yaWdpbmFsIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va3Z6LmlvKVxuXHQgIC8vIGltcHJvdmVkIGJ5OiBMdWtlIEdvZGZyZXlcblx0ICAvLyBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcblx0ICAvLyAgICBpbnB1dCBieTogUHVsXG5cdCAgLy8gICAgaW5wdXQgYnk6IEFsZXhcblx0ICAvLyAgICBpbnB1dCBieTogTWFyYyBQYWxhdVxuXHQgIC8vICAgIGlucHV0IGJ5OiBCcmV0dCBaYW1pciAoaHR0cDovL2JyZXR0LXphbWlyLm1lKVxuXHQgIC8vICAgIGlucHV0IGJ5OiBCb2JieSBEcmFrZVxuXHQgIC8vICAgIGlucHV0IGJ5OiBFdmVydGphbiBHYXJyZXRzZW5cblx0ICAvLyBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcblx0ICAvLyBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuIChodHRwczovL3R3aXR0ZXIuY29tL29ubm9tYXJzbWFuKVxuXHQgIC8vIGJ1Z2ZpeGVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va3Z6LmlvKVxuXHQgIC8vIGJ1Z2ZpeGVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va3Z6LmlvKVxuXHQgIC8vIGJ1Z2ZpeGVkIGJ5OiBFcmljIE5hZ2VsXG5cdCAgLy8gYnVnZml4ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rdnouaW8pXG5cdCAgLy8gYnVnZml4ZWQgYnk6IFRvbWFzeiBXZXNvbG93c2tpXG5cdCAgLy8gIHJldmlzZWQgYnk6IFJhZmHFgiBLdWthd3NraSAoaHR0cDovL2Jsb2cua3VrYXdza2kucGwpXG5cdCAgLy8gICBleGFtcGxlIDE6IHN0cmlwX3RhZ3MoJzxwPktldmluPC9wPiA8YnIgLz48Yj52YW48L2I+IDxpPlpvbm5ldmVsZDwvaT4nLCAnPGk+PGI+Jylcblx0ICAvLyAgIHJldHVybnMgMTogJ0tldmluIDxiPnZhbjwvYj4gPGk+Wm9ubmV2ZWxkPC9pPidcblx0ICAvLyAgIGV4YW1wbGUgMjogc3RyaXBfdGFncygnPHA+S2V2aW4gPGltZyBzcmM9XCJzb21laW1hZ2UucG5nXCIgb25tb3VzZW92ZXI9XCJzb21lRnVuY3Rpb24oKVwiPnZhbiA8aT5ab25uZXZlbGQ8L2k+PC9wPicsICc8cD4nKVxuXHQgIC8vICAgcmV0dXJucyAyOiAnPHA+S2V2aW4gdmFuIFpvbm5ldmVsZDwvcD4nXG5cdCAgLy8gICBleGFtcGxlIDM6IHN0cmlwX3RhZ3MoXCI8YSBocmVmPSdodHRwOi8va3Z6LmlvJz5LZXZpbiB2YW4gWm9ubmV2ZWxkPC9hPlwiLCBcIjxhPlwiKVxuXHQgIC8vICAgcmV0dXJucyAzOiBcIjxhIGhyZWY9J2h0dHA6Ly9rdnouaW8nPktldmluIHZhbiBab25uZXZlbGQ8L2E+XCJcblx0ICAvLyAgIGV4YW1wbGUgNDogc3RyaXBfdGFncygnMSA8IDUgNSA+IDEnKVxuXHQgIC8vICAgcmV0dXJucyA0OiAnMSA8IDUgNSA+IDEnXG5cdCAgLy8gICBleGFtcGxlIDU6IHN0cmlwX3RhZ3MoJzEgPGJyLz4gMScpXG5cdCAgLy8gICByZXR1cm5zIDU6ICcxICAxJ1xuXHQgIC8vICAgZXhhbXBsZSA2OiBzdHJpcF90YWdzKCcxIDxici8+IDEnLCAnPGJyPicpXG5cdCAgLy8gICByZXR1cm5zIDY6ICcxIDxici8+IDEnXG5cdCAgLy8gICBleGFtcGxlIDc6IHN0cmlwX3RhZ3MoJzEgPGJyLz4gMScsICc8YnI+PGJyLz4nKVxuXHQgIC8vICAgcmV0dXJucyA3OiAnMSA8YnIvPiAxJ1xuXG5cdCAgLy8gbWFraW5nIHN1cmUgdGhlIGFsbG93ZWQgYXJnIGlzIGEgc3RyaW5nIGNvbnRhaW5pbmcgb25seSB0YWdzIGluIGxvd2VyY2FzZSAoPGE+PGI+PGM+KVxuXHQgIGFsbG93ZWQgPSAoKChhbGxvd2VkIHx8ICcnKSArICcnKS50b0xvd2VyQ2FzZSgpLm1hdGNoKC88W2Etel1bYS16MC05XSo+L2cpIHx8IFtdKS5qb2luKCcnKTtcblxuXHQgIHZhciB0YWdzID0gLzxcXC8/KFthLXpdW2EtejAtOV0qKVxcYltePl0qPi9naTtcblx0ICB2YXIgY29tbWVudHNBbmRQaHBUYWdzID0gLzwhLS1bXFxzXFxTXSo/LS0+fDxcXD8oPzpwaHApP1tcXHNcXFNdKj9cXD8+L2dpO1xuXG5cdCAgcmV0dXJuIGlucHV0LnJlcGxhY2UoY29tbWVudHNBbmRQaHBUYWdzLCAnJykucmVwbGFjZSh0YWdzLCBmdW5jdGlvbiAoJDAsICQxKSB7XG5cdCAgICByZXR1cm4gYWxsb3dlZC5pbmRleE9mKCc8JyArICQxLnRvTG93ZXJDYXNlKCkgKyAnPicpID4gLTEgPyAkMCA6ICcnO1xuXHQgIH0pO1xuXHR9O1xuXHQvLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpcF90YWdzLmpzLm1hcFxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cnRvdGltZSh0ZXh0LCBub3cpIHtcblx0ICAvLyAgZGlzY3VzcyBhdDogaHR0cDovL2xvY3V0dXMuaW8vcGhwL3N0cnRvdGltZS9cblx0ICAvLyBvcmlnaW5hbCBieTogQ2FpbyBBcmllZGUgKGh0dHA6Ly9jYWlvYXJpZWRlLmNvbSlcblx0ICAvLyBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcblx0ICAvLyBpbXByb3ZlZCBieTogQ2FpbyBBcmllZGUgKGh0dHA6Ly9jYWlvYXJpZWRlLmNvbSlcblx0ICAvLyBpbXByb3ZlZCBieTogQS4gTWF0w61hcyBRdWV6YWRhIChodHRwOi8vYW1hdGlhc3EuY29tKVxuXHQgIC8vIGltcHJvdmVkIGJ5OiBwcmV1dGVyXG5cdCAgLy8gaW1wcm92ZWQgYnk6IEJyZXR0IFphbWlyIChodHRwOi8vYnJldHQtemFtaXIubWUpXG5cdCAgLy8gaW1wcm92ZWQgYnk6IE1pcmtvIEZhYmVyXG5cdCAgLy8gICAgaW5wdXQgYnk6IERhdmlkXG5cdCAgLy8gYnVnZml4ZWQgYnk6IFdhZ25lciBCLiBTb2FyZXNcblx0ICAvLyBidWdmaXhlZCBieTogQXJ0dXIgVGNoZXJueWNoZXZcblx0ICAvLyBidWdmaXhlZCBieTogU3RlcGhhbiBCw7ZzY2gtUGxlcGVsaXRzIChodHRwOi8vZ2l0aHViLmNvbS9wbGVwZSlcblx0ICAvLyAgICAgIG5vdGUgMTogRXhhbXBsZXMgYWxsIGhhdmUgYSBmaXhlZCB0aW1lc3RhbXAgdG8gcHJldmVudFxuXHQgIC8vICAgICAgbm90ZSAxOiB0ZXN0cyB0byBmYWlsIGJlY2F1c2Ugb2YgdmFyaWFibGUgdGltZSh6b25lcylcblx0ICAvLyAgIGV4YW1wbGUgMTogc3RydG90aW1lKCcrMSBkYXknLCAxMTI5NjMzMjAwKVxuXHQgIC8vICAgcmV0dXJucyAxOiAxMTI5NzE5NjAwXG5cdCAgLy8gICBleGFtcGxlIDI6IHN0cnRvdGltZSgnKzEgd2VlayAyIGRheXMgNCBob3VycyAyIHNlY29uZHMnLCAxMTI5NjMzMjAwKVxuXHQgIC8vICAgcmV0dXJucyAyOiAxMTMwNDI1MjAyXG5cdCAgLy8gICBleGFtcGxlIDM6IHN0cnRvdGltZSgnbGFzdCBtb250aCcsIDExMjk2MzMyMDApXG5cdCAgLy8gICByZXR1cm5zIDM6IDExMjcwNDEyMDBcblx0ICAvLyAgIGV4YW1wbGUgNDogc3RydG90aW1lKCcyMDA5LTA1LTA0IDA4OjMwOjAwIEdNVCcpXG5cdCAgLy8gICByZXR1cm5zIDQ6IDEyNDE0MjU4MDBcblx0ICAvLyAgIGV4YW1wbGUgNTogc3RydG90aW1lKCcyMDA5LTA1LTA0IDA4OjMwOjAwKzAwJylcblx0ICAvLyAgIHJldHVybnMgNTogMTI0MTQyNTgwMFxuXHQgIC8vICAgZXhhbXBsZSA2OiBzdHJ0b3RpbWUoJzIwMDktMDUtMDQgMDg6MzA6MDArMDI6MDAnKVxuXHQgIC8vICAgcmV0dXJucyA2OiAxMjQxNDE4NjAwXG5cdCAgLy8gICBleGFtcGxlIDc6IHN0cnRvdGltZSgnMjAwOS0wNS0wNFQwODozMDowMFonKVxuXHQgIC8vICAgcmV0dXJucyA3OiAxMjQxNDI1ODAwXG5cblx0ICB2YXIgcGFyc2VkO1xuXHQgIHZhciBtYXRjaDtcblx0ICB2YXIgdG9kYXk7XG5cdCAgdmFyIHllYXI7XG5cdCAgdmFyIGRhdGU7XG5cdCAgdmFyIGRheXM7XG5cdCAgdmFyIHJhbmdlcztcblx0ICB2YXIgbGVuO1xuXHQgIHZhciB0aW1lcztcblx0ICB2YXIgcmVnZXg7XG5cdCAgdmFyIGk7XG5cdCAgdmFyIGZhaWwgPSBmYWxzZTtcblxuXHQgIGlmICghdGV4dCkge1xuXHQgICAgcmV0dXJuIGZhaWw7XG5cdCAgfVxuXG5cdCAgLy8gVW5lY2Vzc2FyeSBzcGFjZXNcblx0ICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykucmVwbGFjZSgvXFxzezIsfS9nLCAnICcpLnJlcGxhY2UoL1tcXHRcXHJcXG5dL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG5cdCAgLy8gaW4gY29udHJhc3QgdG8gcGhwLCBqcyBEYXRlLnBhcnNlIGZ1bmN0aW9uIGludGVycHJldHM6XG5cdCAgLy8gZGF0ZXMgZ2l2ZW4gYXMgeXl5eS1tbS1kZCBhcyBpbiB0aW1lem9uZTogVVRDLFxuXHQgIC8vIGRhdGVzIHdpdGggXCIuXCIgb3IgXCItXCIgYXMgTURZIGluc3RlYWQgb2YgRE1ZXG5cdCAgLy8gZGF0ZXMgd2l0aCB0d28tZGlnaXQgeWVhcnMgZGlmZmVyZW50bHlcblx0ICAvLyBldGMuLi5ldGMuLi5cblx0ICAvLyAuLi50aGVyZWZvcmUgd2UgbWFudWFsbHkgcGFyc2UgbG90cyBvZiBjb21tb24gZGF0ZSBmb3JtYXRzXG5cdCAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKFsnXihcXFxcZHsxLDR9KScsICcoW1xcXFwtXFxcXC5cXFxcLzpdKScsICcoXFxcXGR7MSwyfSknLCAnKFtcXFxcLVxcXFwuXFxcXC86XSknLCAnKFxcXFxkezEsNH0pJywgJyg/OlxcXFxzKFxcXFxkezEsMn0pOihcXFxcZHsyfSk/Oj8oXFxcXGR7Mn0pPyk/JywgJyg/OlxcXFxzKFtBLVpdKyk/KT8kJ10uam9pbignJykpO1xuXHQgIG1hdGNoID0gdGV4dC5tYXRjaChwYXR0ZXJuKTtcblxuXHQgIGlmIChtYXRjaCAmJiBtYXRjaFsyXSA9PT0gbWF0Y2hbNF0pIHtcblx0ICAgIGlmIChtYXRjaFsxXSA+IDE5MDEpIHtcblx0ICAgICAgc3dpdGNoIChtYXRjaFsyXSkge1xuXHQgICAgICAgIGNhc2UgJy0nOlxuXHQgICAgICAgICAgLy8gWVlZWS1NLURcblx0ICAgICAgICAgIGlmIChtYXRjaFszXSA+IDEyIHx8IG1hdGNoWzVdID4gMzEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhaWw7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtYXRjaFsxXSwgcGFyc2VJbnQobWF0Y2hbM10sIDEwKSAtIDEsIG1hdGNoWzVdLCBtYXRjaFs2XSB8fCAwLCBtYXRjaFs3XSB8fCAwLCBtYXRjaFs4XSB8fCAwLCBtYXRjaFs5XSB8fCAwKSAvIDEwMDA7XG5cdCAgICAgICAgY2FzZSAnLic6XG5cdCAgICAgICAgICAvLyBZWVlZLk0uRCBpcyBub3QgcGFyc2VkIGJ5IHN0cnRvdGltZSgpXG5cdCAgICAgICAgICByZXR1cm4gZmFpbDtcblx0ICAgICAgICBjYXNlICcvJzpcblx0ICAgICAgICAgIC8vIFlZWVkvTS9EXG5cdCAgICAgICAgICBpZiAobWF0Y2hbM10gPiAxMiB8fCBtYXRjaFs1XSA+IDMxKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWlsO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gbmV3IERhdGUobWF0Y2hbMV0sIHBhcnNlSW50KG1hdGNoWzNdLCAxMCkgLSAxLCBtYXRjaFs1XSwgbWF0Y2hbNl0gfHwgMCwgbWF0Y2hbN10gfHwgMCwgbWF0Y2hbOF0gfHwgMCwgbWF0Y2hbOV0gfHwgMCkgLyAxMDAwO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG1hdGNoWzVdID4gMTkwMSkge1xuXHQgICAgICBzd2l0Y2ggKG1hdGNoWzJdKSB7XG5cdCAgICAgICAgY2FzZSAnLSc6XG5cdCAgICAgICAgICAvLyBELU0tWVlZWVxuXHQgICAgICAgICAgaWYgKG1hdGNoWzNdID4gMTIgfHwgbWF0Y2hbMV0gPiAzMSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFpbDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1hdGNoWzVdLCBwYXJzZUludChtYXRjaFszXSwgMTApIC0gMSwgbWF0Y2hbMV0sIG1hdGNoWzZdIHx8IDAsIG1hdGNoWzddIHx8IDAsIG1hdGNoWzhdIHx8IDAsIG1hdGNoWzldIHx8IDApIC8gMTAwMDtcblx0ICAgICAgICBjYXNlICcuJzpcblx0ICAgICAgICAgIC8vIEQuTS5ZWVlZXG5cdCAgICAgICAgICBpZiAobWF0Y2hbM10gPiAxMiB8fCBtYXRjaFsxXSA+IDMxKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWlsO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gbmV3IERhdGUobWF0Y2hbNV0sIHBhcnNlSW50KG1hdGNoWzNdLCAxMCkgLSAxLCBtYXRjaFsxXSwgbWF0Y2hbNl0gfHwgMCwgbWF0Y2hbN10gfHwgMCwgbWF0Y2hbOF0gfHwgMCwgbWF0Y2hbOV0gfHwgMCkgLyAxMDAwO1xuXHQgICAgICAgIGNhc2UgJy8nOlxuXHQgICAgICAgICAgLy8gTS9EL1lZWVlcblx0ICAgICAgICAgIGlmIChtYXRjaFsxXSA+IDEyIHx8IG1hdGNoWzNdID4gMzEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhaWw7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtYXRjaFs1XSwgcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSAtIDEsIG1hdGNoWzNdLCBtYXRjaFs2XSB8fCAwLCBtYXRjaFs3XSB8fCAwLCBtYXRjaFs4XSB8fCAwLCBtYXRjaFs5XSB8fCAwKSAvIDEwMDA7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHN3aXRjaCAobWF0Y2hbMl0pIHtcblx0ICAgICAgICBjYXNlICctJzpcblx0ICAgICAgICAgIC8vIFlZLU0tRFxuXHQgICAgICAgICAgaWYgKG1hdGNoWzNdID4gMTIgfHwgbWF0Y2hbNV0gPiAzMSB8fCBtYXRjaFsxXSA8IDcwICYmIG1hdGNoWzFdID4gMzgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhaWw7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHllYXIgPSBtYXRjaFsxXSA+PSAwICYmIG1hdGNoWzFdIDw9IDM4ID8gK21hdGNoWzFdICsgMjAwMCA6IG1hdGNoWzFdO1xuXHQgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIHBhcnNlSW50KG1hdGNoWzNdLCAxMCkgLSAxLCBtYXRjaFs1XSwgbWF0Y2hbNl0gfHwgMCwgbWF0Y2hbN10gfHwgMCwgbWF0Y2hbOF0gfHwgMCwgbWF0Y2hbOV0gfHwgMCkgLyAxMDAwO1xuXHQgICAgICAgIGNhc2UgJy4nOlxuXHQgICAgICAgICAgLy8gRC5NLllZIG9yIEguTU0uU1Ncblx0ICAgICAgICAgIGlmIChtYXRjaFs1XSA+PSA3MCkge1xuXHQgICAgICAgICAgICAvLyBELk0uWVlcblx0ICAgICAgICAgICAgaWYgKG1hdGNoWzNdID4gMTIgfHwgbWF0Y2hbMV0gPiAzMSkge1xuXHQgICAgICAgICAgICAgIHJldHVybiBmYWlsO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1hdGNoWzVdLCBwYXJzZUludChtYXRjaFszXSwgMTApIC0gMSwgbWF0Y2hbMV0sIG1hdGNoWzZdIHx8IDAsIG1hdGNoWzddIHx8IDAsIG1hdGNoWzhdIHx8IDAsIG1hdGNoWzldIHx8IDApIC8gMTAwMDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmIChtYXRjaFs1XSA8IDYwICYmICFtYXRjaFs2XSkge1xuXHQgICAgICAgICAgICAvLyBILk1NLlNTXG5cdCAgICAgICAgICAgIGlmIChtYXRjaFsxXSA+IDIzIHx8IG1hdGNoWzNdID4gNTkpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gZmFpbDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRvZGF5ID0gbmV3IERhdGUoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRvZGF5LmdldEZ1bGxZZWFyKCksIHRvZGF5LmdldE1vbnRoKCksIHRvZGF5LmdldERhdGUoKSwgbWF0Y2hbMV0gfHwgMCwgbWF0Y2hbM10gfHwgMCwgbWF0Y2hbNV0gfHwgMCwgbWF0Y2hbOV0gfHwgMCkgLyAxMDAwO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAvLyBpbnZhbGlkIGZvcm1hdCwgY2Fubm90IGJlIHBhcnNlZFxuXHQgICAgICAgICAgcmV0dXJuIGZhaWw7XG5cdCAgICAgICAgY2FzZSAnLyc6XG5cdCAgICAgICAgICAvLyBNL0QvWVlcblx0ICAgICAgICAgIGlmIChtYXRjaFsxXSA+IDEyIHx8IG1hdGNoWzNdID4gMzEgfHwgbWF0Y2hbNV0gPCA3MCAmJiBtYXRjaFs1XSA+IDM4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWlsO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB5ZWFyID0gbWF0Y2hbNV0gPj0gMCAmJiBtYXRjaFs1XSA8PSAzOCA/ICttYXRjaFs1XSArIDIwMDAgOiBtYXRjaFs1XTtcblx0ICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBwYXJzZUludChtYXRjaFsxXSwgMTApIC0gMSwgbWF0Y2hbM10sIG1hdGNoWzZdIHx8IDAsIG1hdGNoWzddIHx8IDAsIG1hdGNoWzhdIHx8IDAsIG1hdGNoWzldIHx8IDApIC8gMTAwMDtcblx0ICAgICAgICBjYXNlICc6Jzpcblx0ICAgICAgICAgIC8vIEhIOk1NOlNTXG5cdCAgICAgICAgICBpZiAobWF0Y2hbMV0gPiAyMyB8fCBtYXRjaFszXSA+IDU5IHx8IG1hdGNoWzVdID4gNTkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhaWw7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHRvZGF5ID0gbmV3IERhdGUoKTtcblx0ICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0b2RheS5nZXRGdWxsWWVhcigpLCB0b2RheS5nZXRNb250aCgpLCB0b2RheS5nZXREYXRlKCksIG1hdGNoWzFdIHx8IDAsIG1hdGNoWzNdIHx8IDAsIG1hdGNoWzVdIHx8IDApIC8gMTAwMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIG90aGVyIGZvcm1hdHMgYW5kIFwibm93XCIgc2hvdWxkIGJlIHBhcnNlZCBieSBEYXRlLnBhcnNlKClcblx0ICBpZiAodGV4dCA9PT0gJ25vdycpIHtcblx0ICAgIHJldHVybiBub3cgPT09IG51bGwgfHwgaXNOYU4obm93KSA/IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCB8IDAgOiBub3cgfCAwO1xuXHQgIH1cblx0ICBpZiAoIWlzTmFOKHBhcnNlZCA9IERhdGUucGFyc2UodGV4dCkpKSB7XG5cdCAgICByZXR1cm4gcGFyc2VkIC8gMTAwMCB8IDA7XG5cdCAgfVxuXHQgIC8vIEJyb3dzZXJzICE9PSBDaHJvbWUgaGF2ZSBwcm9ibGVtcyBwYXJzaW5nIElTTyA4NjAxIGRhdGUgc3RyaW5ncywgYXMgdGhleSBkb1xuXHQgIC8vIG5vdCBhY2NlcHQgbG93ZXIgY2FzZSBjaGFyYWN0ZXJzLCBzcGFjZSwgb3Igc2hvcnRlbmVkIHRpbWUgem9uZXMuXG5cdCAgLy8gVGhlcmVmb3JlLCBmaXggdGhlc2UgcHJvYmxlbXMgYW5kIHRyeSBhZ2Fpbi5cblx0ICAvLyBFeGFtcGxlczpcblx0ICAvLyAgIDIwMTUtMDQtMTUgMjA6MzM6NTkrMDJcblx0ICAvLyAgIDIwMTUtMDQtMTUgMjA6MzM6NTl6XG5cdCAgLy8gICAyMDE1LTA0LTE1dDIwOjMzOjU5KzAyOjAwXG5cdCAgcGF0dGVybiA9IG5ldyBSZWdFeHAoWydeKFswLTldezR9LVswLTldezJ9LVswLTldezJ9KScsICdbIHRdJywgJyhbMC05XXsyfTpbMC05XXsyfTpbMC05XXsyfShcXFxcLlswLTldKyk/KScsICcoW1xcXFwrLV1bMC05XXsyfSg6WzAtOV17Mn0pP3x6KSddLmpvaW4oJycpKTtcblx0ICBtYXRjaCA9IHRleHQubWF0Y2gocGF0dGVybik7XG5cdCAgaWYgKG1hdGNoKSB7XG5cdCAgICAvLyBAdG9kbzogdGltZSB6b25lIGluZm9ybWF0aW9uXG5cdCAgICBpZiAobWF0Y2hbNF0gPT09ICd6Jykge1xuXHQgICAgICBtYXRjaFs0XSA9ICdaJztcblx0ICAgIH0gZWxzZSBpZiAobWF0Y2hbNF0ubWF0Y2goL14oWystXVswLTldezJ9KSQvKSkge1xuXHQgICAgICBtYXRjaFs0XSA9IG1hdGNoWzRdICsgJzowMCc7XG5cdCAgICB9XG5cblx0ICAgIGlmICghaXNOYU4ocGFyc2VkID0gRGF0ZS5wYXJzZShtYXRjaFsxXSArICdUJyArIG1hdGNoWzJdICsgbWF0Y2hbNF0pKSkge1xuXHQgICAgICByZXR1cm4gcGFyc2VkIC8gMTAwMCB8IDA7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZGF0ZSA9IG5vdyA/IG5ldyBEYXRlKG5vdyAqIDEwMDApIDogbmV3IERhdGUoKTtcblx0ICBkYXlzID0ge1xuXHQgICAgJ3N1bic6IDAsXG5cdCAgICAnbW9uJzogMSxcblx0ICAgICd0dWUnOiAyLFxuXHQgICAgJ3dlZCc6IDMsXG5cdCAgICAndGh1JzogNCxcblx0ICAgICdmcmknOiA1LFxuXHQgICAgJ3NhdCc6IDZcblx0ICB9O1xuXHQgIHJhbmdlcyA9IHtcblx0ICAgICd5ZWEnOiAnRnVsbFllYXInLFxuXHQgICAgJ21vbic6ICdNb250aCcsXG5cdCAgICAnZGF5JzogJ0RhdGUnLFxuXHQgICAgJ2hvdSc6ICdIb3VycycsXG5cdCAgICAnbWluJzogJ01pbnV0ZXMnLFxuXHQgICAgJ3NlYyc6ICdTZWNvbmRzJ1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBsYXN0TmV4dCh0eXBlLCByYW5nZSwgbW9kaWZpZXIpIHtcblx0ICAgIHZhciBkaWZmO1xuXHQgICAgdmFyIGRheSA9IGRheXNbcmFuZ2VdO1xuXG5cdCAgICBpZiAodHlwZW9mIGRheSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgZGlmZiA9IGRheSAtIGRhdGUuZ2V0RGF5KCk7XG5cblx0ICAgICAgaWYgKGRpZmYgPT09IDApIHtcblx0ICAgICAgICBkaWZmID0gNyAqIG1vZGlmaWVyO1xuXHQgICAgICB9IGVsc2UgaWYgKGRpZmYgPiAwICYmIHR5cGUgPT09ICdsYXN0Jykge1xuXHQgICAgICAgIGRpZmYgLT0gNztcblx0ICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCAmJiB0eXBlID09PSAnbmV4dCcpIHtcblx0ICAgICAgICBkaWZmICs9IDc7XG5cdCAgICAgIH1cblxuXHQgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBkaWZmKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBwcm9jZXNzKHZhbCkge1xuXHQgICAgLy8gQHRvZG86IFJlY29uY2lsZSB0aGlzIHdpdGggcmVnZXggdXNpbmcgXFxzLCB0YWtpbmcgaW50byBhY2NvdW50XG5cdCAgICAvLyBicm93c2VyIGlzc3VlcyB3aXRoIHNwbGl0IGFuZCByZWdleGVzXG5cdCAgICB2YXIgc3BsdCA9IHZhbC5zcGxpdCgnICcpO1xuXHQgICAgdmFyIHR5cGUgPSBzcGx0WzBdO1xuXHQgICAgdmFyIHJhbmdlID0gc3BsdFsxXS5zdWJzdHJpbmcoMCwgMyk7XG5cdCAgICB2YXIgdHlwZUlzTnVtYmVyID0gL1xcZCsvLnRlc3QodHlwZSk7XG5cdCAgICB2YXIgYWdvID0gc3BsdFsyXSA9PT0gJ2Fnbyc7XG5cdCAgICB2YXIgbnVtID0gKHR5cGUgPT09ICdsYXN0JyA/IC0xIDogMSkgKiAoYWdvID8gLTEgOiAxKTtcblxuXHQgICAgaWYgKHR5cGVJc051bWJlcikge1xuXHQgICAgICBudW0gKj0gcGFyc2VJbnQodHlwZSwgMTApO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocmFuZ2VzLmhhc093blByb3BlcnR5KHJhbmdlKSAmJiAhc3BsdFsxXS5tYXRjaCgvXm1vbihkYXl8XFwuKT8kL2kpKSB7XG5cdCAgICAgIHJldHVybiBkYXRlWydzZXQnICsgcmFuZ2VzW3JhbmdlXV0oZGF0ZVsnZ2V0JyArIHJhbmdlc1tyYW5nZV1dKCkgKyBudW0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocmFuZ2UgPT09ICd3ZWUnKSB7XG5cdCAgICAgIHJldHVybiBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBudW0gKiA3KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGUgPT09ICduZXh0JyB8fCB0eXBlID09PSAnbGFzdCcpIHtcblx0ICAgICAgbGFzdE5leHQodHlwZSwgcmFuZ2UsIG51bSk7XG5cdCAgICB9IGVsc2UgaWYgKCF0eXBlSXNOdW1iZXIpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cblx0ICB0aW1lcyA9ICcoeWVhcnM/fG1vbnRocz98d2Vla3M/fGRheXM/fGhvdXJzP3xtaW51dGVzP3xtaW58c2Vjb25kcz98c2VjJyArICd8c3VuZGF5fHN1blxcXFwuP3xtb25kYXl8bW9uXFxcXC4/fHR1ZXNkYXl8dHVlXFxcXC4/fHdlZG5lc2RheXx3ZWRcXFxcLj8nICsgJ3x0aHVyc2RheXx0aHVcXFxcLj98ZnJpZGF5fGZyaVxcXFwuP3xzYXR1cmRheXxzYXRcXFxcLj8pJztcblx0ICByZWdleCA9ICcoWystXT9cXFxcZCtcXFxccycgKyB0aW1lcyArICd8JyArICcobGFzdHxuZXh0KVxcXFxzJyArIHRpbWVzICsgJykoXFxcXHNhZ28pPyc7XG5cblx0ICBtYXRjaCA9IHRleHQubWF0Y2gobmV3IFJlZ0V4cChyZWdleCwgJ2dpJykpO1xuXHQgIGlmICghbWF0Y2gpIHtcblx0ICAgIHJldHVybiBmYWlsO1xuXHQgIH1cblxuXHQgIGZvciAoaSA9IDAsIGxlbiA9IG1hdGNoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICBpZiAoIXByb2Nlc3MobWF0Y2hbaV0pKSB7XG5cdCAgICAgIHJldHVybiBmYWlsO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7XG5cdH07XG5cdC8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cnRvdGltZS5qcy5tYXBcblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkYXRlKGZvcm1hdCwgdGltZXN0YW1wKSB7XG5cdCAgLy8gIGRpc2N1c3MgYXQ6IGh0dHA6Ly9sb2N1dHVzLmlvL3BocC9kYXRlL1xuXHQgIC8vIG9yaWdpbmFsIGJ5OiBDYXJsb3MgUi4gTC4gUm9kcmlndWVzIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuXHQgIC8vIG9yaWdpbmFsIGJ5OiBnZXR0aW1lb2ZkYXlcblx0ICAvLyAgICBwYXJ0cyBieTogUGV0ZXItUGF1bCBLb2NoIChodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2JlYXQuaHRtbClcblx0ICAvLyBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcblx0ICAvLyBpbXByb3ZlZCBieTogTWVFdGMgKGh0dHA6Ly95YXNzLm1lZXRjd2ViLmNvbSlcblx0ICAvLyBpbXByb3ZlZCBieTogQnJhZCBUb3Vlc25hcmRcblx0ICAvLyBpbXByb3ZlZCBieTogVGltIFdpZWxcblx0ICAvLyBpbXByb3ZlZCBieTogQnJ5YW4gRWxsaW90dFxuXHQgIC8vIGltcHJvdmVkIGJ5OiBEYXZpZCBSYW5kYWxsXG5cdCAgLy8gaW1wcm92ZWQgYnk6IFRoZXJpYXVsdCAoaHR0cHM6Ly9naXRodWIuY29tL1RoZXJpYXVsdClcblx0ICAvLyBpbXByb3ZlZCBieTogVGhlcmlhdWx0IChodHRwczovL2dpdGh1Yi5jb20vVGhlcmlhdWx0KVxuXHQgIC8vIGltcHJvdmVkIGJ5OiBCcmV0dCBaYW1pciAoaHR0cDovL2JyZXR0LXphbWlyLm1lKVxuXHQgIC8vIGltcHJvdmVkIGJ5OiBUaGVyaWF1bHQgKGh0dHBzOi8vZ2l0aHViLmNvbS9UaGVyaWF1bHQpXG5cdCAgLy8gaW1wcm92ZWQgYnk6IFRob21hcyBCZWF1Y291cnQgKGh0dHA6Ly93d3cud2ViYXBwLmZyKVxuXHQgIC8vIGltcHJvdmVkIGJ5OiBKVFxuXHQgIC8vIGltcHJvdmVkIGJ5OiBUaGVyaWF1bHQgKGh0dHBzOi8vZ2l0aHViLmNvbS9UaGVyaWF1bHQpXG5cdCAgLy8gaW1wcm92ZWQgYnk6IFJhZmHFgiBLdWthd3NraSAoaHR0cDovL2Jsb2cua3VrYXdza2kucGwpXG5cdCAgLy8gaW1wcm92ZWQgYnk6IFRoZXJpYXVsdCAoaHR0cHM6Ly9naXRodWIuY29tL1RoZXJpYXVsdClcblx0ICAvLyAgICBpbnB1dCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcblx0ICAvLyAgICBpbnB1dCBieTogbWFqYWtcblx0ICAvLyAgICBpbnB1dCBieTogQWxleFxuXHQgIC8vICAgIGlucHV0IGJ5OiBNYXJ0aW5cblx0ICAvLyAgICBpbnB1dCBieTogQWxleCBXaWxzb25cblx0ICAvLyAgICBpbnB1dCBieTogSGFyYXZpa2tcblx0ICAvLyBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcblx0ICAvLyBidWdmaXhlZCBieTogbWFqYWtcblx0ICAvLyBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcblx0ICAvLyBidWdmaXhlZCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcblx0ICAvLyBidWdmaXhlZCBieTogb21pZCAoaHR0cDovL2xvY3V0dXMuaW8vcGhwLzM4MDozODAjY29tbWVudF8xMzcxMjIpXG5cdCAgLy8gYnVnZml4ZWQgYnk6IENocmlzIChodHRwOi8vd3d3LmRldm90aXMubmwvKVxuXHQgIC8vICAgICAgbm90ZSAxOiBVc2VzIGdsb2JhbDogbG9jdXR1cyB0byBzdG9yZSB0aGUgZGVmYXVsdCB0aW1lem9uZVxuXHQgIC8vICAgICAgbm90ZSAxOiBBbHRob3VnaCB0aGUgZnVuY3Rpb24gcG90ZW50aWFsbHkgYWxsb3dzIHRpbWV6b25lIGluZm9cblx0ICAvLyAgICAgIG5vdGUgMTogKHNlZSBub3RlcyksIGl0IGN1cnJlbnRseSBkb2VzIG5vdCBzZXRcblx0ICAvLyAgICAgIG5vdGUgMTogcGVyIGEgdGltZXpvbmUgc3BlY2lmaWVkIGJ5IGRhdGVfZGVmYXVsdF90aW1lem9uZV9zZXQoKS4gSW1wbGVtZW50ZXJzIG1pZ2h0IHVzZVxuXHQgIC8vICAgICAgbm90ZSAxOiAkbG9jdXR1cy5jdXJyZW50VGltZXpvbmVPZmZzZXQgYW5kXG5cdCAgLy8gICAgICBub3RlIDE6ICRsb2N1dHVzLmN1cnJlbnRUaW1lem9uZURTVCBzZXQgYnkgdGhhdCBmdW5jdGlvblxuXHQgIC8vICAgICAgbm90ZSAxOiBpbiBvcmRlciB0byBhZGp1c3QgdGhlIGRhdGVzIGluIHRoaXMgZnVuY3Rpb25cblx0ICAvLyAgICAgIG5vdGUgMTogKG9yIG91ciBvdGhlciBkYXRlIGZ1bmN0aW9ucyEpIGFjY29yZGluZ2x5XG5cdCAgLy8gICBleGFtcGxlIDE6IGRhdGUoJ0g6bTpzIFxcXFxtIFxcXFxpXFxcXHMgXFxcXG1cXFxcb1xcXFxuXFxcXHRcXFxcaCcsIDEwNjI0MDI0MDApXG5cdCAgLy8gICByZXR1cm5zIDE6ICcwNzowOTo0MCBtIGlzIG1vbnRoJ1xuXHQgIC8vICAgZXhhbXBsZSAyOiBkYXRlKCdGIGosIFksIGc6aSBhJywgMTA2MjQ2MjQwMClcblx0ICAvLyAgIHJldHVybnMgMjogJ1NlcHRlbWJlciAyLCAyMDAzLCAxMjoyNiBhbSdcblx0ICAvLyAgIGV4YW1wbGUgMzogZGF0ZSgnWSBXIG8nLCAxMDYyNDYyNDAwKVxuXHQgIC8vICAgcmV0dXJucyAzOiAnMjAwMyAzNiAyMDAzJ1xuXHQgIC8vICAgZXhhbXBsZSA0OiB2YXIgJHggPSBkYXRlKCdZIG0gZCcsIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwKVxuXHQgIC8vICAgZXhhbXBsZSA0OiAkeCA9ICR4ICsgJydcblx0ICAvLyAgIGV4YW1wbGUgNDogdmFyICRyZXN1bHQgPSAkeC5sZW5ndGggLy8gMjAwOSAwMSAwOVxuXHQgIC8vICAgcmV0dXJucyA0OiAxMFxuXHQgIC8vICAgZXhhbXBsZSA1OiBkYXRlKCdXJywgMTEwNDUzNDAwMClcblx0ICAvLyAgIHJldHVybnMgNTogJzUyJ1xuXHQgIC8vICAgZXhhbXBsZSA2OiBkYXRlKCdCIHQnLCAxMTA0NTM0MDAwKVxuXHQgIC8vICAgcmV0dXJucyA2OiAnOTk5IDMxJ1xuXHQgIC8vICAgZXhhbXBsZSA3OiBkYXRlKCdXIFUnLCAxMjkzNzUwMDAwLjgyKTsgLy8gMjAxMC0xMi0zMVxuXHQgIC8vICAgcmV0dXJucyA3OiAnNTIgMTI5Mzc1MDAwMCdcblx0ICAvLyAgIGV4YW1wbGUgODogZGF0ZSgnVycsIDEyOTM4MzY0MDApOyAvLyAyMDExLTAxLTAxXG5cdCAgLy8gICByZXR1cm5zIDg6ICc1Midcblx0ICAvLyAgIGV4YW1wbGUgOTogZGF0ZSgnVyBZLW0tZCcsIDEyOTM5NzQwNTQpOyAvLyAyMDExLTAxLTAyXG5cdCAgLy8gICByZXR1cm5zIDk6ICc1MiAyMDExLTAxLTAyJ1xuXHQgIC8vICAgICAgICB0ZXN0OiBza2lwLTEgc2tpcC0yIHNraXAtNVxuXG5cdCAgdmFyIGpzZGF0ZSwgZjtcblx0ICAvLyBLZWVwIHRoaXMgaGVyZSAod29ya3MsIGJ1dCBmb3IgY29kZSBjb21tZW50ZWQtb3V0IGJlbG93IGZvciBmaWxlIHNpemUgcmVhc29ucylcblx0ICAvLyB2YXIgdGFsPSBbXTtcblx0ICB2YXIgdHh0V29yZHMgPSBbJ1N1bicsICdNb24nLCAnVHVlcycsICdXZWRuZXMnLCAnVGh1cnMnLCAnRnJpJywgJ1NhdHVyJywgJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXTtcblx0ICAvLyB0cmFpbGluZyBiYWNrc2xhc2ggLT4gKGRyb3BwZWQpXG5cdCAgLy8gYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgYW55IGNoYXJhY3RlciAoaW5jbHVkaW5nIGJhY2tzbGFzaCkgLT4gdGhlIGNoYXJhY3RlclxuXHQgIC8vIGVtcHR5IHN0cmluZyAtPiBlbXB0eSBzdHJpbmdcblx0ICB2YXIgZm9ybWF0Q2hyID0gL1xcXFw/KC4/KS9naTtcblx0ICB2YXIgZm9ybWF0Q2hyQ2IgPSBmdW5jdGlvbiBmb3JtYXRDaHJDYih0LCBzKSB7XG5cdCAgICByZXR1cm4gZlt0XSA/IGZbdF0oKSA6IHM7XG5cdCAgfTtcblx0ICB2YXIgX3BhZCA9IGZ1bmN0aW9uIF9wYWQobiwgYykge1xuXHQgICAgbiA9IFN0cmluZyhuKTtcblx0ICAgIHdoaWxlIChuLmxlbmd0aCA8IGMpIHtcblx0ICAgICAgbiA9ICcwJyArIG47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbjtcblx0ICB9O1xuXHQgIGYgPSB7XG5cdCAgICAvLyBEYXlcblx0ICAgIGQ6IGZ1bmN0aW9uIGQoKSB7XG5cdCAgICAgIC8vIERheSBvZiBtb250aCB3L2xlYWRpbmcgMDsgMDEuLjMxXG5cdCAgICAgIHJldHVybiBfcGFkKGYuaigpLCAyKTtcblx0ICAgIH0sXG5cdCAgICBEOiBmdW5jdGlvbiBEKCkge1xuXHQgICAgICAvLyBTaG9ydGhhbmQgZGF5IG5hbWU7IE1vbi4uLlN1blxuXHQgICAgICByZXR1cm4gZi5sKCkuc2xpY2UoMCwgMyk7XG5cdCAgICB9LFxuXHQgICAgajogZnVuY3Rpb24gaigpIHtcblx0ICAgICAgLy8gRGF5IG9mIG1vbnRoOyAxLi4zMVxuXHQgICAgICByZXR1cm4ganNkYXRlLmdldERhdGUoKTtcblx0ICAgIH0sXG5cdCAgICBsOiBmdW5jdGlvbiBsKCkge1xuXHQgICAgICAvLyBGdWxsIGRheSBuYW1lOyBNb25kYXkuLi5TdW5kYXlcblx0ICAgICAgcmV0dXJuIHR4dFdvcmRzW2YudygpXSArICdkYXknO1xuXHQgICAgfSxcblx0ICAgIE46IGZ1bmN0aW9uIE4oKSB7XG5cdCAgICAgIC8vIElTTy04NjAxIGRheSBvZiB3ZWVrOyAxW01vbl0uLjdbU3VuXVxuXHQgICAgICByZXR1cm4gZi53KCkgfHwgNztcblx0ICAgIH0sXG5cdCAgICBTOiBmdW5jdGlvbiBTKCkge1xuXHQgICAgICAvLyBPcmRpbmFsIHN1ZmZpeCBmb3IgZGF5IG9mIG1vbnRoOyBzdCwgbmQsIHJkLCB0aFxuXHQgICAgICB2YXIgaiA9IGYuaigpO1xuXHQgICAgICB2YXIgaSA9IGogJSAxMDtcblx0ICAgICAgaWYgKGkgPD0gMyAmJiBwYXJzZUludChqICUgMTAwIC8gMTAsIDEwKSA9PT0gMSkge1xuXHQgICAgICAgIGkgPSAwO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBbJ3N0JywgJ25kJywgJ3JkJ11baSAtIDFdIHx8ICd0aCc7XG5cdCAgICB9LFxuXHQgICAgdzogZnVuY3Rpb24gdygpIHtcblx0ICAgICAgLy8gRGF5IG9mIHdlZWs7IDBbU3VuXS4uNltTYXRdXG5cdCAgICAgIHJldHVybiBqc2RhdGUuZ2V0RGF5KCk7XG5cdCAgICB9LFxuXHQgICAgejogZnVuY3Rpb24geigpIHtcblx0ICAgICAgLy8gRGF5IG9mIHllYXI7IDAuLjM2NVxuXHQgICAgICB2YXIgYSA9IG5ldyBEYXRlKGYuWSgpLCBmLm4oKSAtIDEsIGYuaigpKTtcblx0ICAgICAgdmFyIGIgPSBuZXcgRGF0ZShmLlkoKSwgMCwgMSk7XG5cdCAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhIC0gYikgLyA4NjRlNSk7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBXZWVrXG5cdCAgICBXOiBmdW5jdGlvbiBXKCkge1xuXHQgICAgICAvLyBJU08tODYwMSB3ZWVrIG51bWJlclxuXHQgICAgICB2YXIgYSA9IG5ldyBEYXRlKGYuWSgpLCBmLm4oKSAtIDEsIGYuaigpIC0gZi5OKCkgKyAzKTtcblx0ICAgICAgdmFyIGIgPSBuZXcgRGF0ZShhLmdldEZ1bGxZZWFyKCksIDAsIDQpO1xuXHQgICAgICByZXR1cm4gX3BhZCgxICsgTWF0aC5yb3VuZCgoYSAtIGIpIC8gODY0ZTUgLyA3KSwgMik7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBNb250aFxuXHQgICAgRjogZnVuY3Rpb24gRigpIHtcblx0ICAgICAgLy8gRnVsbCBtb250aCBuYW1lOyBKYW51YXJ5Li4uRGVjZW1iZXJcblx0ICAgICAgcmV0dXJuIHR4dFdvcmRzWzYgKyBmLm4oKV07XG5cdCAgICB9LFxuXHQgICAgbTogZnVuY3Rpb24gbSgpIHtcblx0ICAgICAgLy8gTW9udGggdy9sZWFkaW5nIDA7IDAxLi4uMTJcblx0ICAgICAgcmV0dXJuIF9wYWQoZi5uKCksIDIpO1xuXHQgICAgfSxcblx0ICAgIE06IGZ1bmN0aW9uIE0oKSB7XG5cdCAgICAgIC8vIFNob3J0aGFuZCBtb250aCBuYW1lOyBKYW4uLi5EZWNcblx0ICAgICAgcmV0dXJuIGYuRigpLnNsaWNlKDAsIDMpO1xuXHQgICAgfSxcblx0ICAgIG46IGZ1bmN0aW9uIG4oKSB7XG5cdCAgICAgIC8vIE1vbnRoOyAxLi4uMTJcblx0ICAgICAgcmV0dXJuIGpzZGF0ZS5nZXRNb250aCgpICsgMTtcblx0ICAgIH0sXG5cdCAgICB0OiBmdW5jdGlvbiB0KCkge1xuXHQgICAgICAvLyBEYXlzIGluIG1vbnRoOyAyOC4uLjMxXG5cdCAgICAgIHJldHVybiBuZXcgRGF0ZShmLlkoKSwgZi5uKCksIDApLmdldERhdGUoKTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIFllYXJcblx0ICAgIEw6IGZ1bmN0aW9uIEwoKSB7XG5cdCAgICAgIC8vIElzIGxlYXAgeWVhcj87IDAgb3IgMVxuXHQgICAgICB2YXIgaiA9IGYuWSgpO1xuXHQgICAgICByZXR1cm4gaiAlIDQgPT09IDAgJiBqICUgMTAwICE9PSAwIHwgaiAlIDQwMCA9PT0gMDtcblx0ICAgIH0sXG5cdCAgICBvOiBmdW5jdGlvbiBvKCkge1xuXHQgICAgICAvLyBJU08tODYwMSB5ZWFyXG5cdCAgICAgIHZhciBuID0gZi5uKCk7XG5cdCAgICAgIHZhciBXID0gZi5XKCk7XG5cdCAgICAgIHZhciBZID0gZi5ZKCk7XG5cdCAgICAgIHJldHVybiBZICsgKG4gPT09IDEyICYmIFcgPCA5ID8gMSA6IG4gPT09IDEgJiYgVyA+IDkgPyAtMSA6IDApO1xuXHQgICAgfSxcblx0ICAgIFk6IGZ1bmN0aW9uIFkoKSB7XG5cdCAgICAgIC8vIEZ1bGwgeWVhcjsgZS5nLiAxOTgwLi4uMjAxMFxuXHQgICAgICByZXR1cm4ganNkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdCAgICB9LFxuXHQgICAgeTogZnVuY3Rpb24geSgpIHtcblx0ICAgICAgLy8gTGFzdCB0d28gZGlnaXRzIG9mIHllYXI7IDAwLi4uOTlcblx0ICAgICAgcmV0dXJuIGYuWSgpLnRvU3RyaW5nKCkuc2xpY2UoLTIpO1xuXHQgICAgfSxcblxuXHQgICAgLy8gVGltZVxuXHQgICAgYTogZnVuY3Rpb24gYSgpIHtcblx0ICAgICAgLy8gYW0gb3IgcG1cblx0ICAgICAgcmV0dXJuIGpzZGF0ZS5nZXRIb3VycygpID4gMTEgPyAncG0nIDogJ2FtJztcblx0ICAgIH0sXG5cdCAgICBBOiBmdW5jdGlvbiBBKCkge1xuXHQgICAgICAvLyBBTSBvciBQTVxuXHQgICAgICByZXR1cm4gZi5hKCkudG9VcHBlckNhc2UoKTtcblx0ICAgIH0sXG5cdCAgICBCOiBmdW5jdGlvbiBCKCkge1xuXHQgICAgICAvLyBTd2F0Y2ggSW50ZXJuZXQgdGltZTsgMDAwLi45OTlcblx0ICAgICAgdmFyIEggPSBqc2RhdGUuZ2V0VVRDSG91cnMoKSAqIDM2ZTI7XG5cdCAgICAgIC8vIEhvdXJzXG5cdCAgICAgIHZhciBpID0ganNkYXRlLmdldFVUQ01pbnV0ZXMoKSAqIDYwO1xuXHQgICAgICAvLyBNaW51dGVzXG5cdCAgICAgIC8vIFNlY29uZHNcblx0ICAgICAgdmFyIHMgPSBqc2RhdGUuZ2V0VVRDU2Vjb25kcygpO1xuXHQgICAgICByZXR1cm4gX3BhZChNYXRoLmZsb29yKChIICsgaSArIHMgKyAzNmUyKSAvIDg2LjQpICUgMWUzLCAzKTtcblx0ICAgIH0sXG5cdCAgICBnOiBmdW5jdGlvbiBnKCkge1xuXHQgICAgICAvLyAxMi1Ib3VyczsgMS4uMTJcblx0ICAgICAgcmV0dXJuIGYuRygpICUgMTIgfHwgMTI7XG5cdCAgICB9LFxuXHQgICAgRzogZnVuY3Rpb24gRygpIHtcblx0ICAgICAgLy8gMjQtSG91cnM7IDAuLjIzXG5cdCAgICAgIHJldHVybiBqc2RhdGUuZ2V0SG91cnMoKTtcblx0ICAgIH0sXG5cdCAgICBoOiBmdW5jdGlvbiBoKCkge1xuXHQgICAgICAvLyAxMi1Ib3VycyB3L2xlYWRpbmcgMDsgMDEuLjEyXG5cdCAgICAgIHJldHVybiBfcGFkKGYuZygpLCAyKTtcblx0ICAgIH0sXG5cdCAgICBIOiBmdW5jdGlvbiBIKCkge1xuXHQgICAgICAvLyAyNC1Ib3VycyB3L2xlYWRpbmcgMDsgMDAuLjIzXG5cdCAgICAgIHJldHVybiBfcGFkKGYuRygpLCAyKTtcblx0ICAgIH0sXG5cdCAgICBpOiBmdW5jdGlvbiBpKCkge1xuXHQgICAgICAvLyBNaW51dGVzIHcvbGVhZGluZyAwOyAwMC4uNTlcblx0ICAgICAgcmV0dXJuIF9wYWQoanNkYXRlLmdldE1pbnV0ZXMoKSwgMik7XG5cdCAgICB9LFxuXHQgICAgczogZnVuY3Rpb24gcygpIHtcblx0ICAgICAgLy8gU2Vjb25kcyB3L2xlYWRpbmcgMDsgMDAuLjU5XG5cdCAgICAgIHJldHVybiBfcGFkKGpzZGF0ZS5nZXRTZWNvbmRzKCksIDIpO1xuXHQgICAgfSxcblx0ICAgIHU6IGZ1bmN0aW9uIHUoKSB7XG5cdCAgICAgIC8vIE1pY3Jvc2Vjb25kczsgMDAwMDAwLTk5OTAwMFxuXHQgICAgICByZXR1cm4gX3BhZChqc2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwLCA2KTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIFRpbWV6b25lXG5cdCAgICBlOiBmdW5jdGlvbiBlKCkge1xuXHQgICAgICAvLyBUaW1lem9uZSBpZGVudGlmaWVyOyBlLmcuIEF0bGFudGljL0F6b3JlcywgLi4uXG5cdCAgICAgIC8vIFRoZSBmb2xsb3dpbmcgd29ya3MsIGJ1dCByZXF1aXJlcyBpbmNsdXNpb24gb2YgdGhlIHZlcnkgbGFyZ2Vcblx0ICAgICAgLy8gdGltZXpvbmVfYWJicmV2aWF0aW9uc19saXN0KCkgZnVuY3Rpb24uXG5cdCAgICAgIC8qICAgICAgICAgICAgICByZXR1cm4gdGhhdC5kYXRlX2RlZmF1bHRfdGltZXpvbmVfZ2V0KCk7XG5cdCAgICAgICAqL1xuXHQgICAgICB2YXIgbXNnID0gJ05vdCBzdXBwb3J0ZWQgKHNlZSBzb3VyY2UgY29kZSBvZiBkYXRlKCkgZm9yIHRpbWV6b25lIG9uIGhvdyB0byBhZGQgc3VwcG9ydCknO1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0ICAgIH0sXG5cdCAgICBJOiBmdW5jdGlvbiBJKCkge1xuXHQgICAgICAvLyBEU1Qgb2JzZXJ2ZWQ/OyAwIG9yIDFcblx0ICAgICAgLy8gQ29tcGFyZXMgSmFuIDEgbWludXMgSmFuIDEgVVRDIHRvIEp1bCAxIG1pbnVzIEp1bCAxIFVUQy5cblx0ICAgICAgLy8gSWYgdGhleSBhcmUgbm90IGVxdWFsLCB0aGVuIERTVCBpcyBvYnNlcnZlZC5cblx0ICAgICAgdmFyIGEgPSBuZXcgRGF0ZShmLlkoKSwgMCk7XG5cdCAgICAgIC8vIEphbiAxXG5cdCAgICAgIHZhciBjID0gRGF0ZS5VVEMoZi5ZKCksIDApO1xuXHQgICAgICAvLyBKYW4gMSBVVENcblx0ICAgICAgdmFyIGIgPSBuZXcgRGF0ZShmLlkoKSwgNik7XG5cdCAgICAgIC8vIEp1bCAxXG5cdCAgICAgIC8vIEp1bCAxIFVUQ1xuXHQgICAgICB2YXIgZCA9IERhdGUuVVRDKGYuWSgpLCA2KTtcblx0ICAgICAgcmV0dXJuIGEgLSBjICE9PSBiIC0gZCA/IDEgOiAwO1xuXHQgICAgfSxcblx0ICAgIE86IGZ1bmN0aW9uIE8oKSB7XG5cdCAgICAgIC8vIERpZmZlcmVuY2UgdG8gR01UIGluIGhvdXIgZm9ybWF0OyBlLmcuICswMjAwXG5cdCAgICAgIHZhciB0em8gPSBqc2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblx0ICAgICAgdmFyIGEgPSBNYXRoLmFicyh0em8pO1xuXHQgICAgICByZXR1cm4gKHR6byA+IDAgPyAnLScgOiAnKycpICsgX3BhZChNYXRoLmZsb29yKGEgLyA2MCkgKiAxMDAgKyBhICUgNjAsIDQpO1xuXHQgICAgfSxcblx0ICAgIFA6IGZ1bmN0aW9uIFAoKSB7XG5cdCAgICAgIC8vIERpZmZlcmVuY2UgdG8gR01UIHcvY29sb247IGUuZy4gKzAyOjAwXG5cdCAgICAgIHZhciBPID0gZi5PKCk7XG5cdCAgICAgIHJldHVybiBPLnN1YnN0cigwLCAzKSArICc6JyArIE8uc3Vic3RyKDMsIDIpO1xuXHQgICAgfSxcblx0ICAgIFQ6IGZ1bmN0aW9uIFQoKSB7XG5cdCAgICAgIC8vIFRoZSBmb2xsb3dpbmcgd29ya3MsIGJ1dCByZXF1aXJlcyBpbmNsdXNpb24gb2YgdGhlIHZlcnlcblx0ICAgICAgLy8gbGFyZ2UgdGltZXpvbmVfYWJicmV2aWF0aW9uc19saXN0KCkgZnVuY3Rpb24uXG5cdCAgICAgIC8qICAgICAgICAgICAgICB2YXIgYWJiciwgaSwgb3MsIF9kZWZhdWx0O1xuXHQgICAgICBpZiAoIXRhbC5sZW5ndGgpIHtcblx0ICAgICAgICB0YWwgPSB0aGF0LnRpbWV6b25lX2FiYnJldmlhdGlvbnNfbGlzdCgpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICgkbG9jdXR1cyAmJiAkbG9jdXR1cy5kZWZhdWx0X3RpbWV6b25lKSB7XG5cdCAgICAgICAgX2RlZmF1bHQgPSAkbG9jdXR1cy5kZWZhdWx0X3RpbWV6b25lO1xuXHQgICAgICAgIGZvciAoYWJiciBpbiB0YWwpIHtcblx0ICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWxbYWJicl0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKHRhbFthYmJyXVtpXS50aW1lem9uZV9pZCA9PT0gX2RlZmF1bHQpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gYWJici50b1VwcGVyQ2FzZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGZvciAoYWJiciBpbiB0YWwpIHtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFsW2FiYnJdLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBvcyA9IC1qc2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwO1xuXHQgICAgICAgICAgaWYgKHRhbFthYmJyXVtpXS5vZmZzZXQgPT09IG9zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhYmJyLnRvVXBwZXJDYXNlKCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgICovXG5cdCAgICAgIHJldHVybiAnVVRDJztcblx0ICAgIH0sXG5cdCAgICBaOiBmdW5jdGlvbiBaKCkge1xuXHQgICAgICAvLyBUaW1lem9uZSBvZmZzZXQgaW4gc2Vjb25kcyAoLTQzMjAwLi4uNTA0MDApXG5cdCAgICAgIHJldHVybiAtanNkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDtcblx0ICAgIH0sXG5cblx0ICAgIC8vIEZ1bGwgRGF0ZS9UaW1lXG5cdCAgICBjOiBmdW5jdGlvbiBjKCkge1xuXHQgICAgICAvLyBJU08tODYwMSBkYXRlLlxuXHQgICAgICByZXR1cm4gJ1ktbS1kXFxcXFRIOmk6c1AnLnJlcGxhY2UoZm9ybWF0Q2hyLCBmb3JtYXRDaHJDYik7XG5cdCAgICB9LFxuXHQgICAgcjogZnVuY3Rpb24gcigpIHtcblx0ICAgICAgLy8gUkZDIDI4MjJcblx0ICAgICAgcmV0dXJuICdELCBkIE0gWSBIOmk6cyBPJy5yZXBsYWNlKGZvcm1hdENociwgZm9ybWF0Q2hyQ2IpO1xuXHQgICAgfSxcblx0ICAgIFU6IGZ1bmN0aW9uIFUoKSB7XG5cdCAgICAgIC8vIFNlY29uZHMgc2luY2UgVU5JWCBlcG9jaFxuXHQgICAgICByZXR1cm4ganNkYXRlIC8gMTAwMCB8IDA7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHZhciBfZGF0ZSA9IGZ1bmN0aW9uIF9kYXRlKGZvcm1hdCwgdGltZXN0YW1wKSB7XG5cdCAgICBqc2RhdGUgPSB0aW1lc3RhbXAgPT09IHVuZGVmaW5lZCA/IG5ldyBEYXRlKCkgLy8gTm90IHByb3ZpZGVkXG5cdCAgICA6IHRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUgPyBuZXcgRGF0ZSh0aW1lc3RhbXApIC8vIEpTIERhdGUoKVxuXHQgICAgOiBuZXcgRGF0ZSh0aW1lc3RhbXAgKiAxMDAwKSAvLyBVTklYIHRpbWVzdGFtcCAoYXV0by1jb252ZXJ0IHRvIGludClcblx0ICAgIDtcblx0ICAgIHJldHVybiBmb3JtYXQucmVwbGFjZShmb3JtYXRDaHIsIGZvcm1hdENockNiKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIF9kYXRlKGZvcm1hdCwgdGltZXN0YW1wKTtcblx0fTtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZS5qcy5tYXBcblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBib29sdmFsKG1peGVkVmFyKSB7XG5cdCAgLy8gb3JpZ2luYWwgYnk6IFdpbGwgUm93ZVxuXHQgIC8vICAgZXhhbXBsZSAxOiBib29sdmFsKHRydWUpXG5cdCAgLy8gICByZXR1cm5zIDE6IHRydWVcblx0ICAvLyAgIGV4YW1wbGUgMjogYm9vbHZhbChmYWxzZSlcblx0ICAvLyAgIHJldHVybnMgMjogZmFsc2Vcblx0ICAvLyAgIGV4YW1wbGUgMzogYm9vbHZhbCgwKVxuXHQgIC8vICAgcmV0dXJucyAzOiBmYWxzZVxuXHQgIC8vICAgZXhhbXBsZSA0OiBib29sdmFsKDAuMClcblx0ICAvLyAgIHJldHVybnMgNDogZmFsc2Vcblx0ICAvLyAgIGV4YW1wbGUgNTogYm9vbHZhbCgnJylcblx0ICAvLyAgIHJldHVybnMgNTogZmFsc2Vcblx0ICAvLyAgIGV4YW1wbGUgNjogYm9vbHZhbCgnMCcpXG5cdCAgLy8gICByZXR1cm5zIDY6IGZhbHNlXG5cdCAgLy8gICBleGFtcGxlIDc6IGJvb2x2YWwoW10pXG5cdCAgLy8gICByZXR1cm5zIDc6IGZhbHNlXG5cdCAgLy8gICBleGFtcGxlIDg6IGJvb2x2YWwoJycpXG5cdCAgLy8gICByZXR1cm5zIDg6IGZhbHNlXG5cdCAgLy8gICBleGFtcGxlIDk6IGJvb2x2YWwobnVsbClcblx0ICAvLyAgIHJldHVybnMgOTogZmFsc2Vcblx0ICAvLyAgIGV4YW1wbGUgMTA6IGJvb2x2YWwodW5kZWZpbmVkKVxuXHQgIC8vICAgcmV0dXJucyAxMDogZmFsc2Vcblx0ICAvLyAgIGV4YW1wbGUgMTE6IGJvb2x2YWwoJ3RydWUnKVxuXHQgIC8vICAgcmV0dXJucyAxMTogdHJ1ZVxuXG5cdCAgaWYgKG1peGVkVmFyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmIChtaXhlZFZhciA9PT0gMCB8fCBtaXhlZFZhciA9PT0gMC4wKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgaWYgKG1peGVkVmFyID09PSAnJyB8fCBtaXhlZFZhciA9PT0gJzAnKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgaWYgKEFycmF5LmlzQXJyYXkobWl4ZWRWYXIpICYmIG1peGVkVmFyLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmIChtaXhlZFZhciA9PT0gbnVsbCB8fCBtaXhlZFZhciA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRydWU7XG5cdH07XG5cdC8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2x2YWwuanMubWFwXG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUd2lnKSB7XG5cdCAgICAndXNlIHN0cmljdCc7XG5cblx0ICAgIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdGVyTG9hZGVyKCdhamF4JywgZnVuY3Rpb24obG9jYXRpb24sIHBhcmFtcywgY2FsbGJhY2ssIGVycm9yX2NhbGxiYWNrKSB7XG5cdCAgICAgICAgdmFyIHRlbXBsYXRlLFxuXHQgICAgICAgICAgICB4bWxodHRwLFxuXHQgICAgICAgICAgICBwcmVjb21waWxlZCA9IHBhcmFtcy5wcmVjb21waWxlZCxcblx0ICAgICAgICAgICAgcGFyc2VyID0gdGhpcy5wYXJzZXJzW3BhcmFtcy5wYXJzZXJdIHx8IHRoaXMucGFyc2VyLnR3aWc7XG5cblx0ICAgICAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdVbnN1cHBvcnRlZCBwbGF0Zm9ybTogVW5hYmxlIHRvIGRvIGFqYXggcmVxdWVzdHMgJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdiZWNhdXNlIHRoZXJlIGlzIG5vIFwiWE1MSFRUUFJlcXVlc3RcIiBpbXBsZW1lbnRhdGlvbicpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHhtbGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0ICAgICAgICB4bWxodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgaWYoeG1saHR0cC5yZWFkeVN0YXRlID09PSA0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoeG1saHR0cC5zdGF0dXMgPT09IDIwMCB8fCAod2luZG93LmNvcmRvdmEgJiYgeG1saHR0cC5zdGF0dXMgPT0gMCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBUd2lnLmxvZy5kZWJ1ZyhcIkdvdCB0ZW1wbGF0ZSBcIiwgeG1saHR0cC5yZXNwb25zZVRleHQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByZWNvbXBpbGVkID09PSB0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0geG1saHR0cC5yZXNwb25zZVRleHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IGxvY2F0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5kYXRhID0gZGF0YTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gcGFyc2VyLmNhbGwodGhpcywgcGFyYW1zKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodGVtcGxhdGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvcl9jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9jYWxsYmFjayh4bWxodHRwKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIHhtbGh0dHAub3BlbihcIkdFVFwiLCBsb2NhdGlvbiwgISFwYXJhbXMuYXN5bmMpO1xuXHQgICAgICAgIHhtbGh0dHAuc2VuZCgpO1xuXG5cdCAgICAgICAgaWYgKHBhcmFtcy5hc3luYykge1xuXHQgICAgICAgICAgICAvLyBUT0RPOiByZXR1cm4gZGVmZXJyZWQgcHJvbWlzZVxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0fTtcblxuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVHdpZykge1xuXHQgICAgJ3VzZSBzdHJpY3QnO1xuXG5cdCAgICB2YXIgZnMsIHBhdGg7XG5cblx0ICAgIHRyeSB7XG5cdCAgICBcdC8vIHJlcXVpcmUgbGliIGRlcGVuZGVuY2llcyBhdCBydW50aW1lXG5cdCAgICBcdGZzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cdCAgICBcdHBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIFx0Ly8gTk9URTogdGhpcyBpcyBpbiBhIHRyeS9jYXRjaCB0byBhdm9pZCBlcnJvcnMgY3Jvc3MgcGxhdGZvcm1cblx0ICAgIH1cblxuXHQgICAgVHdpZy5UZW1wbGF0ZXMucmVnaXN0ZXJMb2FkZXIoJ2ZzJywgZnVuY3Rpb24obG9jYXRpb24sIHBhcmFtcywgY2FsbGJhY2ssIGVycm9yX2NhbGxiYWNrKSB7XG5cdCAgICAgICAgdmFyIHRlbXBsYXRlLFxuXHQgICAgICAgICAgICBkYXRhID0gbnVsbCxcblx0ICAgICAgICAgICAgcHJlY29tcGlsZWQgPSBwYXJhbXMucHJlY29tcGlsZWQsXG5cdCAgICAgICAgICAgIHBhcnNlciA9IHRoaXMucGFyc2Vyc1twYXJhbXMucGFyc2VyXSB8fCB0aGlzLnBhcnNlci50d2lnO1xuXG5cdCAgICAgICAgaWYgKCFmcyB8fCAhcGF0aCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVW5zdXBwb3J0ZWQgcGxhdGZvcm06IFVuYWJsZSB0byBsb2FkIGZyb20gZmlsZSAnICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JlY2F1c2UgdGhlcmUgaXMgbm8gXCJmc1wiIG9yIFwicGF0aFwiIGltcGxlbWVudGF0aW9uJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGxvYWRUZW1wbGF0ZUZuID0gZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG5cdCAgICAgICAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvcl9jYWxsYmFjayhlcnIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHByZWNvbXBpbGVkID09PSB0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHBhcmFtcy5kYXRhID0gZGF0YTtcblx0ICAgICAgICAgICAgcGFyYW1zLnBhdGggPSBwYXJhbXMucGF0aCB8fCBsb2NhdGlvbjtcblxuXHQgICAgICAgICAgICAvLyB0ZW1wbGF0ZSBpcyBpbiBkYXRhXG5cdCAgICAgICAgICAgIHRlbXBsYXRlID0gcGFyc2VyLmNhbGwodGhpcywgcGFyYW1zKTtcblxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayh0ZW1wbGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIHBhcmFtcy5wYXRoID0gcGFyYW1zLnBhdGggfHwgbG9jYXRpb247XG5cblx0ICAgICAgICBpZiAocGFyYW1zLmFzeW5jKSB7XG5cdCAgICAgICAgICAgIGZzLnN0YXQocGFyYW1zLnBhdGgsIGZ1bmN0aW9uIChlcnIsIHN0YXRzKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyIHx8ICFzdGF0cy5pc0ZpbGUoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfY2FsbGJhY2sobmV3IFR3aWcuRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHRlbXBsYXRlIGZpbGUgJyArIHBhcmFtcy5wYXRoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlKHBhcmFtcy5wYXRoLCAndXRmOCcsIGxvYWRUZW1wbGF0ZUZuKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIC8vIFRPRE86IHJldHVybiBkZWZlcnJlZCBwcm9taXNlXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWZzLnN0YXRTeW5jKHBhcmFtcy5wYXRoKS5pc0ZpbGUoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdVbmFibGUgdG8gZmluZCB0ZW1wbGF0ZSBmaWxlICcgKyBwYXJhbXMucGF0aCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHRlbXBsYXRlIGZpbGUgJyArIHBhcmFtcy5wYXRoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkYXRhID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtcy5wYXRoLCAndXRmOCcpO1xuXHQgICAgICAgICAgICBsb2FkVGVtcGxhdGVGbih1bmRlZmluZWQsIGRhdGEpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAxOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7XG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTtcblxuLyoqKi8gfSxcbi8qIDIxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyAjIyB0d2lnLmxvZ2ljLmpzXG5cdC8vXG5cdC8vIFRoaXMgZmlsZSBoYW5kbGVzIHRva2VuaXppbmcsIGNvbXBpbGluZyBhbmQgcGFyc2luZyBsb2dpYyB0b2tlbnMuIHslIC4uLiAlfVxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG5cdCAgICBcInVzZSBzdHJpY3RcIjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBOYW1lc3BhY2UgZm9yIGxvZ2ljIGhhbmRsaW5nLlxuXHQgICAgICovXG5cdCAgICBUd2lnLmxvZ2ljID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogTG9naWMgdG9rZW4gdHlwZXMuXG5cdCAgICAgKi9cblx0ICAgIFR3aWcubG9naWMudHlwZSA9IHtcblx0ICAgICAgICBpZl86ICAgICAgICdUd2lnLmxvZ2ljLnR5cGUuaWYnLFxuXHQgICAgICAgIGVuZGlmOiAgICAgJ1R3aWcubG9naWMudHlwZS5lbmRpZicsXG5cdCAgICAgICAgZm9yXzogICAgICAnVHdpZy5sb2dpYy50eXBlLmZvcicsXG5cdCAgICAgICAgZW5kZm9yOiAgICAnVHdpZy5sb2dpYy50eXBlLmVuZGZvcicsXG5cdCAgICAgICAgZWxzZV86ICAgICAnVHdpZy5sb2dpYy50eXBlLmVsc2UnLFxuXHQgICAgICAgIGVsc2VpZjogICAgJ1R3aWcubG9naWMudHlwZS5lbHNlaWYnLFxuXHQgICAgICAgIHNldDogICAgICAgJ1R3aWcubG9naWMudHlwZS5zZXQnLFxuXHQgICAgICAgIHNldGNhcHR1cmU6J1R3aWcubG9naWMudHlwZS5zZXRjYXB0dXJlJyxcblx0ICAgICAgICBlbmRzZXQ6ICAgICdUd2lnLmxvZ2ljLnR5cGUuZW5kc2V0Jyxcblx0ICAgICAgICBmaWx0ZXI6ICAgICdUd2lnLmxvZ2ljLnR5cGUuZmlsdGVyJyxcblx0ICAgICAgICBlbmRmaWx0ZXI6ICdUd2lnLmxvZ2ljLnR5cGUuZW5kZmlsdGVyJyxcblx0ICAgICAgICBzaG9ydGJsb2NrOiAnVHdpZy5sb2dpYy50eXBlLnNob3J0YmxvY2snLFxuXHQgICAgICAgIGJsb2NrOiAgICAgJ1R3aWcubG9naWMudHlwZS5ibG9jaycsXG5cdCAgICAgICAgZW5kYmxvY2s6ICAnVHdpZy5sb2dpYy50eXBlLmVuZGJsb2NrJyxcblx0ICAgICAgICBleHRlbmRzXzogICdUd2lnLmxvZ2ljLnR5cGUuZXh0ZW5kcycsXG5cdCAgICAgICAgdXNlOiAgICAgICAnVHdpZy5sb2dpYy50eXBlLnVzZScsXG5cdCAgICAgICAgaW5jbHVkZTogICAnVHdpZy5sb2dpYy50eXBlLmluY2x1ZGUnLFxuXHQgICAgICAgIHNwYWNlbGVzczogJ1R3aWcubG9naWMudHlwZS5zcGFjZWxlc3MnLFxuXHQgICAgICAgIGVuZHNwYWNlbGVzczogJ1R3aWcubG9naWMudHlwZS5lbmRzcGFjZWxlc3MnLFxuXHQgICAgICAgIG1hY3JvOiAgICAgJ1R3aWcubG9naWMudHlwZS5tYWNybycsXG5cdCAgICAgICAgZW5kbWFjcm86ICAnVHdpZy5sb2dpYy50eXBlLmVuZG1hY3JvJyxcblx0ICAgICAgICBpbXBvcnRfOiAgICdUd2lnLmxvZ2ljLnR5cGUuaW1wb3J0Jyxcblx0ICAgICAgICBmcm9tOiAgICAgICdUd2lnLmxvZ2ljLnR5cGUuZnJvbScsXG5cdCAgICAgICAgZW1iZWQ6ICAgICAnVHdpZy5sb2dpYy50eXBlLmVtYmVkJyxcblx0ICAgICAgICBlbmRlbWJlZDogICdUd2lnLmxvZ2ljLnR5cGUuZW5kZW1iZWQnXG5cdCAgICB9O1xuXG5cblx0ICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIGhhbmRsaW5nIGxvZ2ljIHRva2Vucy5cblx0ICAgIC8vXG5cdCAgICAvLyBQcm9wZXJ0aWVzOlxuXHQgICAgLy9cblx0ICAgIC8vICAgICAgdHlwZTogIFRoZSB0eXBlIG9mIGV4cHJlc3Npb24gdGhpcyBtYXRjaGVzXG5cdCAgICAvL1xuXHQgICAgLy8gICAgICByZWdleDogQSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIHRoZSBmb3JtYXQgb2YgdGhlIHRva2VuXG5cdCAgICAvL1xuXHQgICAgLy8gICAgICBuZXh0OiAgV2hhdCBsb2dpYyB0b2tlbnMgKGlmIGFueSkgcG9wIHRoaXMgdG9rZW4gb2ZmIHRoZSBsb2dpYyBzdGFjay4gSWYgZW1wdHksIHRoZVxuXHQgICAgLy8gICAgICAgICAgICAgbG9naWMgdG9rZW4gaXMgYXNzdW1lZCB0byBub3QgcmVxdWlyZSBhbiBlbmQgdGFnIGFuZCBpc24ndCBwdXNoIG9udG8gdGhlIHN0YWNrLlxuXHQgICAgLy9cblx0ICAgIC8vICAgICAgb3BlbjogIERvZXMgdGhpcyB0YWcgb3BlbiBhIGxvZ2ljIGV4cHJlc3Npb24gb3IgaXMgaXQgc3RhbmRhbG9uZS4gRm9yIGV4YW1wbGUsXG5cdCAgICAvLyAgICAgICAgICAgICB7JSBlbmRpZiAlfSBjYW5ub3QgZXhpc3Qgd2l0aG91dCBhbiBvcGVuaW5nIHslIGlmIC4uLiAlfSB0YWcsIHNvIG9wZW4gPSBmYWxzZS5cblx0ICAgIC8vXG5cdCAgICAvLyAgRnVuY3Rpb25zOlxuXHQgICAgLy9cblx0ICAgIC8vICAgICAgY29tcGlsZTogQSBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgY29tcGlsaW5nIHRoZSB0b2tlbiBpbnRvIGFuIG91dHB1dCB0b2tlbiByZWFkeSBmb3Jcblx0ICAgIC8vICAgICAgICAgICAgICAgcGFyc2luZyB3aXRoIHRoZSBwYXJzZSBmdW5jdGlvbi5cblx0ICAgIC8vXG5cdCAgICAvLyAgICAgIHBhcnNlOiAgIEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgdGhlIGNvbXBpbGVkIHRva2VuIGludG8gb3V0cHV0IChIVE1MIC8gd2hhdGV2ZXIgdGhlXG5cdCAgICAvLyAgICAgICAgICAgICAgIHRlbXBsYXRlIHJlcHJlc2VudHMpLlxuXHQgICAgVHdpZy5sb2dpYy5kZWZpbml0aW9ucyA9IFtcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBJZiB0eXBlIGxvZ2ljIHRva2Vucy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogIEZvcm1hdDogeyUgaWYgZXhwcmVzc2lvbiAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmlmXyxcblx0ICAgICAgICAgICAgcmVnZXg6IC9eaWZcXHMrKFtcXHNcXFNdKykkLyxcblx0ICAgICAgICAgICAgbmV4dDogW1xuXHQgICAgICAgICAgICAgICAgVHdpZy5sb2dpYy50eXBlLmVsc2VfLFxuXHQgICAgICAgICAgICAgICAgVHdpZy5sb2dpYy50eXBlLmVsc2VpZixcblx0ICAgICAgICAgICAgICAgIFR3aWcubG9naWMudHlwZS5lbmRpZlxuXHQgICAgICAgICAgICBdLFxuXHQgICAgICAgICAgICBvcGVuOiB0cnVlLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAodG9rZW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdG9rZW4ubWF0Y2hbMV07XG5cdCAgICAgICAgICAgICAgICAvLyBDb21waWxlIHRoZSBleHByZXNzaW9uLlxuXHQgICAgICAgICAgICAgICAgdG9rZW4uc3RhY2sgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5hcHBseSh0aGlzLCBbe1xuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6ICBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG5cdCAgICAgICAgICAgICAgICB9XSkuc3RhY2s7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5hcHBseSh0aGlzLCBbdG9rZW4uc3RhY2ssIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSB0cnVlO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFR3aWcubGliLmJvb2x2YWwocmVzdWx0KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9IGZhbHNlO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLnBhcnNlQXN5bmMuYXBwbHkodGhhdCwgW3Rva2VuLm91dHB1dCwgY29udGV4dF0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFbHNlIGlmIHR5cGUgbG9naWMgdG9rZW5zLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgRm9ybWF0OiB7JSBlbHNlaWYgZXhwcmVzc2lvbiAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmVsc2VpZixcblx0ICAgICAgICAgICAgcmVnZXg6IC9eZWxzZWlmXFxzKyhbXlxcc10uKikkLyxcblx0ICAgICAgICAgICAgbmV4dDogW1xuXHQgICAgICAgICAgICAgICAgVHdpZy5sb2dpYy50eXBlLmVsc2VfLFxuXHQgICAgICAgICAgICAgICAgVHdpZy5sb2dpYy50eXBlLmVsc2VpZixcblx0ICAgICAgICAgICAgICAgIFR3aWcubG9naWMudHlwZS5lbmRpZlxuXHQgICAgICAgICAgICBdLFxuXHQgICAgICAgICAgICBvcGVuOiBmYWxzZSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRva2VuKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRva2VuLm1hdGNoWzFdO1xuXHQgICAgICAgICAgICAgICAgLy8gQ29tcGlsZSB0aGUgZXhwcmVzc2lvbi5cblx0ICAgICAgICAgICAgICAgIHRva2VuLnN0YWNrID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuYXBwbHkodGhpcywgW3tcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiAgVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuXHQgICAgICAgICAgICAgICAgfV0pLnN0YWNrO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHRva2VuLCBjb250ZXh0LCBjaGFpbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuYXBwbHkodGhpcywgW3Rva2VuLnN0YWNrLCBjb250ZXh0XSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGFpbiAmJiBUd2lnLmxpYi5ib29sdmFsKHJlc3VsdCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSBmYWxzZTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5wYXJzZUFzeW5jLmFwcGx5KHRoYXQsIFt0b2tlbi5vdXRwdXQsIGNvbnRleHRdKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG5cdCAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ob3V0cHV0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFbHNlIGlmIHR5cGUgbG9naWMgdG9rZW5zLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgRm9ybWF0OiB7JSBlbHNlaWYgZXhwcmVzc2lvbiAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmVsc2VfLFxuXHQgICAgICAgICAgICByZWdleDogL15lbHNlJC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFtcblx0ICAgICAgICAgICAgICAgIFR3aWcubG9naWMudHlwZS5lbmRpZixcblx0ICAgICAgICAgICAgICAgIFR3aWcubG9naWMudHlwZS5lbmRmb3Jcblx0ICAgICAgICAgICAgXSxcblx0ICAgICAgICAgICAgb3BlbjogZmFsc2UsXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IFR3aWcuUHJvbWlzZS5yZXNvbHZlKCcnKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGNoYWluKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IFR3aWcucGFyc2VBc3luYy5hcHBseSh0aGlzLCBbdG9rZW4ub3V0cHV0LCBjb250ZXh0XSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ob3V0cHV0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRW5kIGlmIHR5cGUgbG9naWMgdG9rZW5zLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgRm9ybWF0OiB7JSBlbmRpZiAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmVuZGlmLFxuXHQgICAgICAgICAgICByZWdleDogL15lbmRpZiQvLFxuXHQgICAgICAgICAgICBuZXh0OiBbIF0sXG5cdCAgICAgICAgICAgIG9wZW46IGZhbHNlXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBGb3IgdHlwZSBsb2dpYyB0b2tlbnMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICBGb3JtYXQ6IHslIGZvciBleHByZXNzaW9uICV9XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZm9yXyxcblx0ICAgICAgICAgICAgcmVnZXg6IC9eZm9yXFxzKyhbYS16QS1aMC05XyxcXHNdKylcXHMraW5cXHMrKFteXFxzXS4qPykoPzpcXHMraWZcXHMrKFteXFxzXS4qKSk/JC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFtcblx0ICAgICAgICAgICAgICAgIFR3aWcubG9naWMudHlwZS5lbHNlXyxcblx0ICAgICAgICAgICAgICAgIFR3aWcubG9naWMudHlwZS5lbmRmb3Jcblx0ICAgICAgICAgICAgXSxcblx0ICAgICAgICAgICAgb3BlbjogdHJ1ZSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRva2VuKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5X3ZhbHVlID0gdG9rZW4ubWF0Y2hbMV0sXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRva2VuLm1hdGNoWzJdLFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsID0gdG9rZW4ubWF0Y2hbM10sXG5cdCAgICAgICAgICAgICAgICAgICAga3Zfc3BsaXQgPSBudWxsO1xuXG5cdCAgICAgICAgICAgICAgICB0b2tlbi5rZXlfdmFyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlX3ZhciA9IG51bGw7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChrZXlfdmFsdWUuaW5kZXhPZihcIixcIikgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGt2X3NwbGl0ID0ga2V5X3ZhbHVlLnNwbGl0KCcsJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGt2X3NwbGl0Lmxlbmd0aCA9PT0gMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5rZXlfdmFyID0ga3Zfc3BsaXRbMF0udHJpbSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZV92YXIgPSBrdl9zcGxpdFsxXS50cmltKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJJbnZhbGlkIGV4cHJlc3Npb24gaW4gZm9yIGxvb3A6IFwiICsga2V5X3ZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlX3ZhciA9IGtleV92YWx1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gVmFsaWQgZXhwcmVzc2lvbnMgZm9yIGEgZm9yIGxvb3Bcblx0ICAgICAgICAgICAgICAgIC8vICAgZm9yIGl0ZW0gICAgIGluIGV4cHJlc3Npb25cblx0ICAgICAgICAgICAgICAgIC8vICAgZm9yIGtleSxpdGVtIGluIGV4cHJlc3Npb25cblxuXHQgICAgICAgICAgICAgICAgLy8gQ29tcGlsZSB0aGUgZXhwcmVzc2lvbi5cblx0ICAgICAgICAgICAgICAgIHRva2VuLmV4cHJlc3Npb24gPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5hcHBseSh0aGlzLCBbe1xuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6ICBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG5cdCAgICAgICAgICAgICAgICB9XSkuc3RhY2s7XG5cblx0ICAgICAgICAgICAgICAgIC8vIENvbXBpbGUgdGhlIGNvbmRpdGlvbmFsIChpZiBhdmFpbGFibGUpXG5cdCAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uYWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbi5jb25kaXRpb25hbCA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmFwcGx5KHRoaXMsIFt7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29uZGl0aW9uYWxcblx0ICAgICAgICAgICAgICAgICAgICB9XSkuc3RhY2s7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh0b2tlbiwgY29udGV4dCwgY29udGludWVfY2hhaW4pIHtcblx0ICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cHJlc3Npb25cblx0ICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcblx0ICAgICAgICAgICAgICAgICAgICBsZW4sXG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuXHQgICAgICAgICAgICAgICAgICAgIGtleXNldCxcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25hbCA9IHRva2VuLmNvbmRpdGlvbmFsLFxuXHQgICAgICAgICAgICAgICAgICAgIGJ1aWxkTG9vcCA9IGZ1bmN0aW9uKGluZGV4LCBsZW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzQ29uZGl0aW9uYWwgPSBjb25kaXRpb25hbCAhPT0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4KzEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDA6IGluZGV4LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2aW5kZXg6IGlzQ29uZGl0aW9uYWw/dW5kZWZpbmVkOmxlbi1pbmRleCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmluZGV4MDogaXNDb25kaXRpb25hbD91bmRlZmluZWQ6bGVuLWluZGV4LTEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdDogKGluZGV4ID09PSAwKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Q6IGlzQ29uZGl0aW9uYWw/dW5kZWZpbmVkOihpbmRleCA9PT0gbGVuLTEpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBpc0NvbmRpdGlvbmFsP3VuZGVmaW5lZDpsZW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNvbnRleHRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHJ1biBvbmNlIGZvciBlYWNoIGl0ZXJhdGlvbiBvZiB0aGUgbG9vcFxuXHQgICAgICAgICAgICAgICAgICAgIGxvb3AgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lcl9jb250ZXh0ID0gVHdpZy5DaGlsZENvbnRleHQoY29udGV4dCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJfY29udGV4dFt0b2tlbi52YWx1ZV92YXJdID0gdmFsdWU7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLmtleV92YXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyX2NvbnRleHRbdG9rZW4ua2V5X3Zhcl0gPSBrZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29wIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbm5lcl9jb250ZXh0Lmxvb3AgPSBidWlsZExvb3AoaW5kZXgsIGxlbik7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBjb25kaXRpb25hbCA9PT0gdW5kZWZpbmVkID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFR3aWcuUHJvbWlzZS5yZXNvbHZlKHRydWUpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmFwcGx5KHRoYXQsIFtjb25kaXRpb25hbCwgaW5uZXJfY29udGV4dF0pO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbihjb25kaXRpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29uZGl0aW9uKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcucGFyc2VBc3luYy5hcHBseSh0aGF0LCBbdG9rZW4ub3V0cHV0LCBpbm5lcl9jb250ZXh0XSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKG8pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGxvb3AtcmVsYXRlZCB2YXJpYWJsZXMgZnJvbSB0aGUgY29udGV4dFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGlubmVyX2NvbnRleHRbJ2xvb3AnXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbm5lcl9jb250ZXh0W3Rva2VuLnZhbHVlX3Zhcl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaW5uZXJfY29udGV4dFt0b2tlbi5rZXlfdmFyXTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgaW4gdmFsdWVzIHRoYXQgZXhpc3QgaW4gY29udGV4dCBidXQgaGF2ZSBjaGFuZ2VkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBpbm5lcl9jb250ZXh0LlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHdpZy5tZXJnZShjb250ZXh0LCBpbm5lcl9jb250ZXh0LCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuYXBwbHkodGhpcywgW3Rva2VuLmV4cHJlc3Npb24sIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFR3aWcubGliLmlzKCdBcnJheScsIHJlc3VsdCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgVHdpZy5hc3luYy5mb3JFYWNoKHJlc3VsdCwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gaW5kZXg7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb29wKGtleSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFR3aWcubGliLmlzKCdPYmplY3QnLCByZXN1bHQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuX2tleXMgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c2V0ID0gcmVzdWx0Ll9rZXlzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c2V0ID0gT2JqZWN0LmtleXMocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBrZXlzZXQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBUd2lnLmZvckVhY2goa2V5c2V0LCBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgX2tleXMgcHJvcGVydHksIGl0J3MgaW50ZXJuYWwgdG8gdHdpZy5qc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJfa2V5c1wiKSByZXR1cm47XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3Aoa2V5LCAgcmVzdWx0W2tleV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFsbG93IGVsc2Ugc3RhdGVtZW50cyBpZiBubyBvdXRwdXQgd2FzIGdlbmVyYXRlZFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlX2NoYWluID0gKG91dHB1dC5sZW5ndGggPT09IDApO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNvbnRpbnVlX2NoYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IFR3aWcub3V0cHV0LmFwcGx5KHRoYXQsIFtvdXRwdXRdKVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRW5kIGlmIHR5cGUgbG9naWMgdG9rZW5zLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgRm9ybWF0OiB7JSBlbmRpZiAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmVuZGZvcixcblx0ICAgICAgICAgICAgcmVnZXg6IC9eZW5kZm9yJC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFsgXSxcblx0ICAgICAgICAgICAgb3BlbjogZmFsc2Vcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFNldCB0eXBlIGxvZ2ljIHRva2Vucy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogIEZvcm1hdDogeyUgc2V0IGtleSA9IGV4cHJlc3Npb24gJX1cblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5zZXQsXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXnNldFxccysoW2EtekEtWjAtOV8sXFxzXSspXFxzKj1cXHMqKFtcXHNcXFNdKykkLyxcblx0ICAgICAgICAgICAgbmV4dDogWyBdLFxuXHQgICAgICAgICAgICBvcGVuOiB0cnVlLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAodG9rZW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0b2tlbi5tYXRjaFsxXS50cmltKCksXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRva2VuLm1hdGNoWzJdLFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENvbXBpbGUgdGhlIGV4cHJlc3Npb24uXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbl9zdGFjayAgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5hcHBseSh0aGlzLCBbe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGV4cHJlc3Npb25cblx0ICAgICAgICAgICAgICAgICAgICB9XSkuc3RhY2s7XG5cblx0ICAgICAgICAgICAgICAgIHRva2VuLmtleSA9IGtleTtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmV4cHJlc3Npb24gPSBleHByZXNzaW9uX3N0YWNrO1xuXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodG9rZW4sIGNvbnRleHQsIGNvbnRpbnVlX2NoYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5ID0gdG9rZW4ua2V5O1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuYXBwbHkodGhpcywgW3Rva2VuLmV4cHJlc3Npb24sIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogIElmIHN0b3JpbmcgdGhlIGNvbnRleHQgaW4gYSB2YXJpYWJsZSwgaXQgbmVlZHMgdG8gYmUgYSBjbG9uZSBvZiB0aGUgY3VycmVudCBzdGF0ZSBvZiBjb250ZXh0LlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3RoZXJ3aXNlIHdlIGhhdmUgYSBjb250ZXh0IHdpdGggaW5maW5pdGUgcmVjdXJzaW9uLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgRml4ZXMgIzM0MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFR3aWcubGliLmNvcHkodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRleHRba2V5XSA9IHZhbHVlO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNvbnRpbnVlX2NoYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBTZXQgY2FwdHVyZSB0eXBlIGxvZ2ljIHRva2Vucy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogIEZvcm1hdDogeyUgc2V0IGtleSAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLnNldGNhcHR1cmUsXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXnNldFxccysoW2EtekEtWjAtOV8sXFxzXSspJC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFtcblx0ICAgICAgICAgICAgICAgIFR3aWcubG9naWMudHlwZS5lbmRzZXRcblx0ICAgICAgICAgICAgXSxcblx0ICAgICAgICAgICAgb3BlbjogdHJ1ZSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRva2VuKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5ID0gdG9rZW4ubWF0Y2hbMV0udHJpbSgpO1xuXG5cdCAgICAgICAgICAgICAgICB0b2tlbi5rZXkgPSBrZXk7XG5cblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh0b2tlbiwgY29udGV4dCwgY29udGludWVfY2hhaW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0b2tlbi5rZXk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLnBhcnNlQXN5bmMuYXBwbHkodGhpcywgW3Rva2VuLm91dHB1dCwgY29udGV4dF0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIHNldCBvbiBib3RoIHRoZSBnbG9iYWwgYW5kIGxvY2FsIGNvbnRleHRcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRleHRba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRleHRba2V5XSA9IHZhbHVlO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNvbnRpbnVlX2NoYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFbmQgc2V0IHR5cGUgYmxvY2sgbG9naWMgdG9rZW5zLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgRm9ybWF0OiB7JSBlbmRzZXQgJX1cblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5lbmRzZXQsXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXmVuZHNldCQvLFxuXHQgICAgICAgICAgICBuZXh0OiBbIF0sXG5cdCAgICAgICAgICAgIG9wZW46IGZhbHNlXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBGaWx0ZXIgbG9naWMgdG9rZW5zLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgRm9ybWF0OiB7JSBmaWx0ZXIgdXBwZXIgJX0gb3IgeyUgZmlsdGVyIGxvd2VyfGVzY2FwZSAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmZpbHRlcixcblx0ICAgICAgICAgICAgcmVnZXg6IC9eZmlsdGVyXFxzKyguKykkLyxcblx0ICAgICAgICAgICAgbmV4dDogW1xuXHQgICAgICAgICAgICAgICAgVHdpZy5sb2dpYy50eXBlLmVuZGZpbHRlclxuXHQgICAgICAgICAgICBdLFxuXHQgICAgICAgICAgICBvcGVuOiB0cnVlLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAodG9rZW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gXCJ8XCIgKyB0b2tlbi5tYXRjaFsxXS50cmltKCk7XG5cdCAgICAgICAgICAgICAgICAvLyBDb21waWxlIHRoZSBleHByZXNzaW9uLlxuXHQgICAgICAgICAgICAgICAgdG9rZW4uc3RhY2sgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5hcHBseSh0aGlzLCBbe1xuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6ICBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG5cdCAgICAgICAgICAgICAgICB9XSkuc3RhY2s7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5wYXJzZUFzeW5jLmFwcGx5KHRoaXMsIFt0b2tlbi5vdXRwdXQsIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odW5maWx0ZXJlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IFt7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLnN0cmluZyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZmlsdGVyZWRcblx0ICAgICAgICAgICAgICAgICAgICB9XS5jb25jYXQodG9rZW4uc3RhY2spO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmFwcGx5KHRoYXQsIFtzdGFjaywgY29udGV4dF0pO1xuXHQgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKG91dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiBjaGFpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXRcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRW5kIGZpbHRlciBsb2dpYyB0b2tlbnMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICBGb3JtYXQ6IHslIGVuZGZpbHRlciAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmVuZGZpbHRlcixcblx0ICAgICAgICAgICAgcmVnZXg6IC9eZW5kZmlsdGVyJC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFsgXSxcblx0ICAgICAgICAgICAgb3BlbjogZmFsc2Vcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEJsb2NrIGxvZ2ljIHRva2Vucy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogIEZvcm1hdDogeyUgYmxvY2sgdGl0bGUgJX1cblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5ibG9jayxcblx0ICAgICAgICAgICAgcmVnZXg6IC9eYmxvY2tcXHMrKFthLXpBLVowLTlfXSspJC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFtcblx0ICAgICAgICAgICAgICAgIFR3aWcubG9naWMudHlwZS5lbmRibG9ja1xuXHQgICAgICAgICAgICBdLFxuXHQgICAgICAgICAgICBvcGVuOiB0cnVlLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAodG9rZW4pIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuLmJsb2NrID0gdG9rZW4ubWF0Y2hbMV0udHJpbSgpO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHRva2VuLCBjb250ZXh0LCBjaGFpbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrX291dHB1dCxcblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQsXG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IFR3aWcuUHJvbWlzZS5yZXNvbHZlKCksXG5cdCAgICAgICAgICAgICAgICAgICAgaXNJbXBvcnRlZCA9IFR3aWcuaW5kZXhPZih0aGlzLmltcG9ydGVkQmxvY2tzLCB0b2tlbi5ibG9jaykgPiAtMSxcblx0ICAgICAgICAgICAgICAgICAgICBoYXNQYXJlbnQgPSB0aGlzLmJsb2Nrc1t0b2tlbi5ibG9ja10gJiYgVHdpZy5pbmRleE9mKHRoaXMuYmxvY2tzW3Rva2VuLmJsb2NrXSwgVHdpZy5wbGFjZWhvbGRlcnMucGFyZW50KSA+IC0xO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBEb24ndCBvdmVycmlkZSBwcmV2aW91cyBibG9ja3MgdW5sZXNzIHRoZXkncmUgaW1wb3J0ZWQgd2l0aCBcInVzZVwiXG5cdCAgICAgICAgICAgICAgICAvLyBMb29wcyBzaG91bGQgYmUgZXhlbXB0ZWQgYXMgd2VsbC5cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmJsb2Nrc1t0b2tlbi5ibG9ja10gPT09IHVuZGVmaW5lZCB8fCBpc0ltcG9ydGVkIHx8IGhhc1BhcmVudCB8fCBjb250ZXh0Lmxvb3AgfHwgdG9rZW4ub3ZlcndyaXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4cHJlc3Npb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmFwcGx5KHRoaXMsIFt0b2tlbi5vdXRwdXQsIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmFwcGx5KHRoYXQsIFt7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuc3RyaW5nLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29udGV4dF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gVHdpZy5wYXJzZUFzeW5jLmFwcGx5KHRoaXMsIFt0b2tlbi5vdXRwdXQsIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmFwcGx5KHRoYXQsIFt7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuc3RyaW5nLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29udGV4dF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGJsb2NrX291dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbXBvcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25jZSB0aGUgYmxvY2sgaXMgb3ZlcnJpZGRlbiwgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3Qgb2YgaW1wb3J0ZWQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmltcG9ydGVkQmxvY2tzLnNwbGljZSh0aGF0LmltcG9ydGVkQmxvY2tzLmluZGV4T2YodG9rZW4uYmxvY2spLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQYXJlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYmxvY2tzW3Rva2VuLmJsb2NrXSA9IFR3aWcuTWFya3VwKHRoYXQuYmxvY2tzW3Rva2VuLmJsb2NrXS5yZXBsYWNlKFR3aWcucGxhY2Vob2xkZXJzLnBhcmVudCwgYmxvY2tfb3V0cHV0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJsb2Nrc1t0b2tlbi5ibG9ja10gPSBibG9ja19vdXRwdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm9yaWdpbmFsQmxvY2tUb2tlbnNbdG9rZW4uYmxvY2tdID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9rZW4udHlwZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrOiB0b2tlbi5ibG9jayxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogdG9rZW4ub3V0cHV0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcndyaXRlOiB0cnVlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBjaGlsZCBibG9jayBoYXMgYmVlbiBzZXQgZnJvbSBhIHRlbXBsYXRlIGV4dGVuZGluZyB0aGlzIG9uZS5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5jaGlsZC5ibG9ja3NbdG9rZW4uYmxvY2tdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoYXQuY2hpbGQuYmxvY2tzW3Rva2VuLmJsb2NrXTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGF0LmJsb2Nrc1t0b2tlbi5ibG9ja107XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQmxvY2sgc2hvcnRoYW5kIGxvZ2ljIHRva2Vucy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogIEZvcm1hdDogeyUgYmxvY2sgdGl0bGUgZXhwcmVzc2lvbiAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLnNob3J0YmxvY2ssXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXmJsb2NrXFxzKyhbYS16QS1aMC05X10rKVxccysoLispJC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFsgXSxcblx0ICAgICAgICAgICAgb3BlbjogdHJ1ZSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRva2VuKSB7XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5leHByZXNzaW9uID0gdG9rZW4ubWF0Y2hbMl0udHJpbSgpO1xuXG5cdCAgICAgICAgICAgICAgICB0b2tlbi5vdXRwdXQgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4uZXhwcmVzc2lvblxuXHQgICAgICAgICAgICAgICAgfSkuc3RhY2s7XG5cblx0ICAgICAgICAgICAgICAgIHRva2VuLmJsb2NrID0gdG9rZW4ubWF0Y2hbMV0udHJpbSgpO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHRva2VuLCBjb250ZXh0LCBjaGFpbikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcubG9naWMuaGFuZGxlcltUd2lnLmxvZ2ljLnR5cGUuYmxvY2tdLnBhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEVuZCBibG9jayBsb2dpYyB0b2tlbnMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICBGb3JtYXQ6IHslIGVuZGJsb2NrICV9XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW5kYmxvY2ssXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXmVuZGJsb2NrKD86XFxzKyhbYS16QS1aMC05X10rKSk/JC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFsgXSxcblx0ICAgICAgICAgICAgb3BlbjogZmFsc2Vcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEJsb2NrIGxvZ2ljIHRva2Vucy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogIEZvcm1hdDogeyUgZXh0ZW5kcyBcInRlbXBsYXRlLnR3aWdcIiAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmV4dGVuZHNfLFxuXHQgICAgICAgICAgICByZWdleDogL15leHRlbmRzXFxzKyguKykkLyxcblx0ICAgICAgICAgICAgbmV4dDogWyBdLFxuXHQgICAgICAgICAgICBvcGVuOiB0cnVlLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAodG9rZW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdG9rZW4ubWF0Y2hbMV0udHJpbSgpO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXG5cdCAgICAgICAgICAgICAgICB0b2tlbi5zdGFjayAgID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuYXBwbHkodGhpcywgW3tcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiAgVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuXHQgICAgICAgICAgICAgICAgfV0pLnN0YWNrO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUsXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICAgICAgaW5uZXJDb250ZXh0ID0gVHdpZy5DaGlsZENvbnRleHQoY29udGV4dCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgZmlsZW5hbWVcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5hcHBseSh0aGlzLCBbdG9rZW4uc3RhY2ssIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZmlsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNldCBwYXJlbnQgdGVtcGxhdGVcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmV4dGVuZCA9IGZpbGU7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFR3aWcuVGVtcGxhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBmaWxlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEltcG9ydCBmaWxlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGhhdC5pbXBvcnRGaWxlKGZpbGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgdGVtcGxhdGUgaW4gY2FzZSBpdCBwdXRzIGFueXRoaW5nIGluIGl0cyBjb250ZXh0XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlbmRlckFzeW5jKGlubmVyQ29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBwYXJlbnQgY29udGV4dCB3aXRoIHRoZSBleHRlbmRlZCBjb250ZXh0XG5cdCAgICAgICAgICAgICAgICAgICAgVHdpZy5saWIuZXh0ZW5kKGNvbnRleHQsIGlubmVyQ29udGV4dCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogJydcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEJsb2NrIGxvZ2ljIHRva2Vucy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogIEZvcm1hdDogeyUgdXNlIFwidGVtcGxhdGUudHdpZ1wiICV9XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUudXNlLFxuXHQgICAgICAgICAgICByZWdleDogL151c2VcXHMrKC4rKSQvLFxuXHQgICAgICAgICAgICBuZXh0OiBbIF0sXG5cdCAgICAgICAgICAgIG9wZW46IHRydWUsXG5cdCAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICh0b2tlbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0b2tlbi5tYXRjaFsxXS50cmltKCk7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG5cblx0ICAgICAgICAgICAgICAgIHRva2VuLnN0YWNrID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuYXBwbHkodGhpcywgW3tcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiAgVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuXHQgICAgICAgICAgICAgICAgfV0pLnN0YWNrO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgZmlsZW5hbWVcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5hcHBseSh0aGlzLCBbdG9rZW4uc3RhY2ssIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZmlsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIEltcG9ydCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmltcG9ydEJsb2NrcyhmaWxlKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiBjaGFpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnJ1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQmxvY2sgbG9naWMgdG9rZW5zLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgRm9ybWF0OiB7JSBpbmNsdWRlcyBcInRlbXBsYXRlLnR3aWdcIiBbd2l0aCB7c29tZTogJ3ZhbHVlcyd9IG9ubHldICV9XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuaW5jbHVkZSxcblx0ICAgICAgICAgICAgcmVnZXg6IC9eaW5jbHVkZVxccysoLis/KSg/Olxcc3wkKShpZ25vcmUgbWlzc2luZyg/Olxcc3wkKSk/KD86d2l0aFxccysoW1xcU1xcc10rPykpPyg/Olxcc3wkKShvbmx5KT8kLyxcblx0ICAgICAgICAgICAgbmV4dDogWyBdLFxuXHQgICAgICAgICAgICBvcGVuOiB0cnVlLFxuXHQgICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAodG9rZW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRva2VuLm1hdGNoLFxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBtYXRjaFsxXS50cmltKCksXG5cdCAgICAgICAgICAgICAgICAgICAgaWdub3JlTWlzc2luZyA9IG1hdGNoWzJdICE9PSB1bmRlZmluZWQsXG5cdCAgICAgICAgICAgICAgICAgICAgd2l0aENvbnRleHQgPSBtYXRjaFszXSxcblx0ICAgICAgICAgICAgICAgICAgICBvbmx5ID0gKChtYXRjaFs0XSAhPT0gdW5kZWZpbmVkKSAmJiBtYXRjaFs0XS5sZW5ndGgpO1xuXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG5cblx0ICAgICAgICAgICAgICAgIHRva2VuLm9ubHkgPSBvbmx5O1xuXHQgICAgICAgICAgICAgICAgdG9rZW4uaWdub3JlTWlzc2luZyA9IGlnbm9yZU1pc3Npbmc7XG5cblx0ICAgICAgICAgICAgICAgIHRva2VuLnN0YWNrID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuYXBwbHkodGhpcywgW3tcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiAgVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuXHQgICAgICAgICAgICAgICAgfV0pLnN0YWNrO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAod2l0aENvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuLndpdGhTdGFjayA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmFwcGx5KHRoaXMsIFt7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogd2l0aENvbnRleHQudHJpbSgpXG5cdCAgICAgICAgICAgICAgICAgICAgfV0pLnN0YWNrO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIGZpbGVuYW1lXG5cdCAgICAgICAgICAgICAgICB2YXIgaW5uZXJDb250ZXh0ID0ge30sXG5cdCAgICAgICAgICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSxcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gVHdpZy5Qcm9taXNlLnJlc29sdmUoKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKCF0b2tlbi5vbmx5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5uZXJDb250ZXh0ID0gVHdpZy5DaGlsZENvbnRleHQoY29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi53aXRoU3RhY2sgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5hcHBseSh0aGlzLCBbdG9rZW4ud2l0aFN0YWNrLCBjb250ZXh0XSlcblx0ICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih3aXRoQ29udGV4dCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gd2l0aENvbnRleHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aXRoQ29udGV4dC5oYXNPd25Qcm9wZXJ0eShpKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRleHRbaV0gPSB3aXRoQ29udGV4dFtpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmFwcGx5KHRoYXQsIFt0b2tlbi5zdGFjaywgY29udGV4dF0pO1xuXHQgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGZpbGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFR3aWcuVGVtcGxhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBmaWxlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEltcG9ydCBmaWxlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IHRoYXQuaW1wb3J0RmlsZShmaWxlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4uaWdub3JlTWlzc2luZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlbmRlckFzeW5jKGlubmVyQ29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ob3V0cHV0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuc3BhY2VsZXNzLFxuXHQgICAgICAgICAgICByZWdleDogL15zcGFjZWxlc3MkLyxcblx0ICAgICAgICAgICAgbmV4dDogW1xuXHQgICAgICAgICAgICAgICAgVHdpZy5sb2dpYy50eXBlLmVuZHNwYWNlbGVzc1xuXHQgICAgICAgICAgICBdLFxuXHQgICAgICAgICAgICBvcGVuOiB0cnVlLFxuXG5cdCAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBodG1sIGFuZCByZXR1cm4gaXQgd2l0aG91dCBhbnkgc3BhY2VzIGJldHdlZW4gdGFnc1xuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHRva2VuLCBjb250ZXh0LCBjaGFpbikge1xuXHQgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIG91dHB1dCB3aXRob3V0IGFueSBmaWx0ZXJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLnBhcnNlQXN5bmMuYXBwbHkodGhpcywgW3Rva2VuLm91dHB1dCwgY29udGV4dF0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih1bmZpbHRlcmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIC8vIEEgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbmQgY2xvc2luZyBhbmQgb3BlbmluZyB0YWdzIHdpdGggc3BhY2VzIGJldHdlZW4gdGhlbVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByQmV0d2VlblRhZ1NwYWNlcyA9IC8+XFxzKzwvZyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBhbGwgc3BhY2UgYmV0d2VlbiBjbG9zaW5nIGFuZCBvcGVuaW5nIGh0bWwgdGFnc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bmZpbHRlcmVkLnJlcGxhY2UockJldHdlZW5UYWdTcGFjZXMsJz48JykudHJpbSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXdyYXAgb3V0cHV0IGFzIGEgVHdpZy5NYXJrdXBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gVHdpZy5NYXJrdXAob3V0cHV0KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8vIEFkZCB0aGUgeyUgZW5kc3BhY2VsZXNzICV9IHRva2VuXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW5kc3BhY2VsZXNzLFxuXHQgICAgICAgICAgICByZWdleDogL15lbmRzcGFjZWxlc3MkLyxcblx0ICAgICAgICAgICAgbmV4dDogWyBdLFxuXHQgICAgICAgICAgICBvcGVuOiBmYWxzZVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogTWFjcm8gbG9naWMgdG9rZW5zLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBGb3JtYXQ6IHslIG1hcm8gaW5wdXQobmFtZSwgdmFsdWUsIHR5cGUsIHNpemUpICV9XG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUubWFjcm8sXG5cdCAgICAgICAgICAgIHJlZ2V4OiAvXm1hY3JvXFxzKyhbYS16QS1aMC05X10rKVxccypcXChcXHMqKCg/OlthLXpBLVowLTlfXSsoPzosXFxzKik/KSopXFxzKlxcKSQvLFxuXHQgICAgICAgICAgICBuZXh0OiBbXG5cdCAgICAgICAgICAgICAgICBUd2lnLmxvZ2ljLnR5cGUuZW5kbWFjcm9cblx0ICAgICAgICAgICAgXSxcblx0ICAgICAgICAgICAgb3BlbjogdHJ1ZSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRva2VuKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFjcm9OYW1lID0gdG9rZW4ubWF0Y2hbMV0sXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycyA9IHRva2VuLm1hdGNoWzJdLnNwbGl0KC9bXFxzLF0rLyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vVE9ETzogQ2xlYW4gdXAgZHVwbGljYXRlIGNoZWNrXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxwYXJhbWV0ZXJzLmxlbmd0aDsgaisrKXtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnNbaV0gPT09IHBhcmFtZXRlcnNbal0gJiYgaSAhPT0gaikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJEdXBsaWNhdGUgYXJndW1lbnRzIGZvciBwYXJhbWV0ZXI6IFwiKyBwYXJhbWV0ZXJzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdG9rZW4ubWFjcm9OYW1lID0gbWFjcm9OYW1lO1xuXHQgICAgICAgICAgICAgICAgdG9rZW4ucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG5cblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm1hY3Jvc1t0b2tlbi5tYWNyb05hbWVdID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBnbG9iYWwgY29udGV4dCBhbmQgb3RoZXIgbWFjcm9zXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1hY3JvQ29udGV4dCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3NlbGY6IHRlbXBsYXRlLm1hY3Jvc1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcGFyYW1ldGVycyBmcm9tIGNvbnRleHQgdG8gbWFjcm9Db250ZXh0XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRva2VuLnBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSB0b2tlbi5wYXJhbWV0ZXJzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgYXJndW1lbnRzW2ldICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFjcm9Db250ZXh0W3Byb3BdID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFjcm9Db250ZXh0W3Byb3BdID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVuZGVyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcucGFyc2VBc3luYy5hcHBseSh0ZW1wbGF0ZSwgW3Rva2VuLm91dHB1dCwgbWFjcm9Db250ZXh0XSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoYWluOiBjaGFpbixcblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICcnXG5cdCAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEVuZCBtYWNybyBsb2dpYyB0b2tlbnMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEZvcm1hdDogeyUgZW5kbWFjcm8gJX1cblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW5kbWFjcm8sXG5cdCAgICAgICAgICAgICByZWdleDogL15lbmRtYWNybyQvLFxuXHQgICAgICAgICAgICAgbmV4dDogWyBdLFxuXHQgICAgICAgICAgICAgb3BlbjogZmFsc2Vcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgLypcblx0ICAgICAgICAgICAgKiBpbXBvcnQgbG9naWMgdG9rZW5zLlxuXHQgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICogRm9ybWF0OiB7JSBpbXBvcnQgXCJ0ZW1wbGF0ZS50d2lnXCIgYXMgZm9ybSAlfVxuXHQgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuaW1wb3J0Xyxcblx0ICAgICAgICAgICAgcmVnZXg6IC9eaW1wb3J0XFxzKyguKylcXHMrYXNcXHMrKFthLXpBLVowLTlfXSspJC8sXG5cdCAgICAgICAgICAgIG5leHQ6IFsgXSxcblx0ICAgICAgICAgICAgb3BlbjogdHJ1ZSxcblx0ICAgICAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRva2VuKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRva2VuLm1hdGNoWzFdLnRyaW0oKSxcblx0ICAgICAgICAgICAgICAgICAgICBjb250ZXh0TmFtZSA9IHRva2VuLm1hdGNoWzJdLnRyaW0oKTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcblxuXHQgICAgICAgICAgICAgICAgdG9rZW4uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5jb250ZXh0TmFtZSA9IGNvbnRleHROYW1lO1xuXG5cdCAgICAgICAgICAgICAgICB0b2tlbi5zdGFjayA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmFwcGx5KHRoaXMsIFt7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuXHQgICAgICAgICAgICAgICAgfV0pLnN0YWNrO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0geyBjaGFpbjogY2hhaW4sIG91dHB1dDogJycgfTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4cHJlc3Npb24gPT09ICdfc2VsZicpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb250ZXh0W3Rva2VuLmNvbnRleHROYW1lXSA9IHRoaXMubWFjcm9zO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBUd2lnLlByb21pc2UucmVzb2x2ZShvdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuYXBwbHkodGhpcywgW3Rva2VuLnN0YWNrLCBjb250ZXh0XSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGZpbGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5pbXBvcnRGaWxlKGZpbGUgfHwgdG9rZW4uZXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odGVtcGxhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb250ZXh0W3Rva2VuLmNvbnRleHROYW1lXSA9IHRlbXBsYXRlLnJlbmRlckFzeW5jKHt9LCB7b3V0cHV0OiAnbWFjcm9zJ30pO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qXG5cdCAgICAgICAgICAgICogZnJvbSBsb2dpYyB0b2tlbnMuXG5cdCAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgKiBGb3JtYXQ6IHslIGZyb20gXCJ0ZW1wbGF0ZS50d2lnXCIgaW1wb3J0IGZ1bmMgYXMgZm9ybSAlfVxuXHQgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZnJvbSxcblx0ICAgICAgICAgICAgcmVnZXg6IC9eZnJvbVxccysoLispXFxzK2ltcG9ydFxccysoW2EtekEtWjAtOV8sIF0rKSQvLFxuXHQgICAgICAgICAgICBuZXh0OiBbIF0sXG5cdCAgICAgICAgICAgIG9wZW46IHRydWUsXG5cdCAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICh0b2tlbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0b2tlbi5tYXRjaFsxXS50cmltKCksXG5cdCAgICAgICAgICAgICAgICAgICAgbWFjcm9FeHByZXNzaW9ucyA9IHRva2VuLm1hdGNoWzJdLnRyaW0oKS5zcGxpdCgvXFxzKixcXHMqLyksXG5cdCAgICAgICAgICAgICAgICAgICAgbWFjcm9OYW1lcyA9IHt9O1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8bWFjcm9FeHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBtYWNyb0V4cHJlc3Npb25zW2ldO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggZnVuY3Rpb24gYXMgdmFyaWFibGVcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWFjcm9NYXRjaCA9IHJlcy5tYXRjaCgvXihbYS16QS1aMC05X10rKVxccythc1xccysoW2EtekEtWjAtOV9dKykkLyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1hY3JvTWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWFjcm9OYW1lc1ttYWNyb01hdGNoWzFdLnRyaW0oKV0gPSBtYWNyb01hdGNoWzJdLnRyaW0oKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzLm1hdGNoKC9eKFthLXpBLVowLTlfXSspJC8pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1hY3JvTmFtZXNbcmVzXSA9IHJlcztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBpbXBvcnRcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuXG5cdCAgICAgICAgICAgICAgICB0b2tlbi5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcblx0ICAgICAgICAgICAgICAgIHRva2VuLm1hY3JvTmFtZXMgPSBtYWNyb05hbWVzO1xuXG5cdCAgICAgICAgICAgICAgICB0b2tlbi5zdGFjayA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmFwcGx5KHRoaXMsIFt7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuXHQgICAgICAgICAgICAgICAgfV0pLnN0YWNrO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IFR3aWcuUHJvbWlzZS5yZXNvbHZlKHRoaXMubWFjcm9zKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4cHJlc3Npb24gIT09IFwiX3NlbGZcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5hcHBseSh0aGlzLCBbdG9rZW4uc3RhY2ssIGNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGZpbGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW1wb3J0RmlsZShmaWxlIHx8IHRva2VuLmV4cHJlc3Npb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odGVtcGxhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlbmRlckFzeW5jKHt9LCB7b3V0cHV0OiAnbWFjcm9zJ30pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24obWFjcm9zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbWFjcm9OYW1lIGluIHRva2VuLm1hY3JvTmFtZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hY3Jvcy5oYXNPd25Qcm9wZXJ0eShtYWNyb05hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0W3Rva2VuLm1hY3JvTmFtZXNbbWFjcm9OYW1lXV0gPSBtYWNyb3NbbWFjcm9OYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiBjaGFpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAnJ1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBUaGUgZW1iZWQgdGFnIGNvbWJpbmVzIHRoZSBiZWhhdmlvdXIgb2YgaW5jbHVkZSBhbmQgZXh0ZW5kcy5cblx0ICAgICAgICAgICAgICogSXQgYWxsb3dzIHlvdSB0byBpbmNsdWRlIGFub3RoZXIgdGVtcGxhdGUncyBjb250ZW50cywganVzdCBsaWtlIGluY2x1ZGUgZG9lcy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogIEZvcm1hdDogeyUgZW1iZWQgXCJ0ZW1wbGF0ZS50d2lnXCIgW3dpdGgge3NvbWU6ICd2YWx1ZXMnfSBvbmx5XSAlfVxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmVtYmVkLFxuXHQgICAgICAgICAgICByZWdleDogL15lbWJlZFxccysoLis/KSg/Olxcc3wkKShpZ25vcmUgbWlzc2luZyg/Olxcc3wkKSk/KD86d2l0aFxccysoW1xcU1xcc10rPykpPyg/Olxcc3wkKShvbmx5KT8kLyxcblx0ICAgICAgICAgICAgbmV4dDogW1xuXHQgICAgICAgICAgICAgICAgVHdpZy5sb2dpYy50eXBlLmVuZGVtYmVkXG5cdCAgICAgICAgICAgIF0sXG5cdCAgICAgICAgICAgIG9wZW46IHRydWUsXG5cdCAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICh0b2tlbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdG9rZW4ubWF0Y2gsXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG1hdGNoWzFdLnRyaW0oKSxcblx0ICAgICAgICAgICAgICAgICAgICBpZ25vcmVNaXNzaW5nID0gbWF0Y2hbMl0gIT09IHVuZGVmaW5lZCxcblx0ICAgICAgICAgICAgICAgICAgICB3aXRoQ29udGV4dCA9IG1hdGNoWzNdLFxuXHQgICAgICAgICAgICAgICAgICAgIG9ubHkgPSAoKG1hdGNoWzRdICE9PSB1bmRlZmluZWQpICYmIG1hdGNoWzRdLmxlbmd0aCk7XG5cblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcblxuXHQgICAgICAgICAgICAgICAgdG9rZW4ub25seSA9IG9ubHk7XG5cdCAgICAgICAgICAgICAgICB0b2tlbi5pZ25vcmVNaXNzaW5nID0gaWdub3JlTWlzc2luZztcblxuXHQgICAgICAgICAgICAgICAgdG9rZW4uc3RhY2sgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5hcHBseSh0aGlzLCBbe1xuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6ICBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG5cdCAgICAgICAgICAgICAgICB9XSkuc3RhY2s7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh3aXRoQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4ud2l0aFN0YWNrID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuYXBwbHkodGhpcywgW3tcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogIFR3aWcuZXhwcmVzc2lvbi50eXBlLmV4cHJlc3Npb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB3aXRoQ29udGV4dC50cmltKClcblx0ICAgICAgICAgICAgICAgICAgICB9XSkuc3RhY2s7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgZmlsZW5hbWVcblx0ICAgICAgICAgICAgICAgIHZhciBpbm5lckNvbnRleHQgPSB7fSxcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgICAgICBpLFxuXHQgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLFxuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBUd2lnLlByb21pc2UucmVzb2x2ZSgpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRva2VuLm9ubHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gY29udGV4dCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShpKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyQ29udGV4dFtpXSA9IGNvbnRleHRbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4ud2l0aFN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuYXBwbHkodGhpcywgW3Rva2VuLndpdGhTdGFjaywgY29udGV4dF0pXG5cdCAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24od2l0aENvbnRleHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIHdpdGhDb250ZXh0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2l0aENvbnRleHQuaGFzT3duUHJvcGVydHkoaSkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJDb250ZXh0W2ldID0gd2l0aENvbnRleHRbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuYXBwbHkodGhhdCwgW3Rva2VuLnN0YWNrLCBpbm5lckNvbnRleHRdKTtcblx0ICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihmaWxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBUd2lnLlRlbXBsYXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gZmlsZTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbXBvcnQgZmlsZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGF0LmltcG9ydEZpbGUoZmlsZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLmlnbm9yZU1pc3NpbmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHByZXZpb3VzIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuYmxvY2tzID0ge307XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0b2tlbnMuIG91dHB1dCB3aWxsIGJlIG5vdCB1c2VkXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR3aWcucGFyc2VBc3luYy5hcHBseSh0aGF0LCBbdG9rZW4ub3V0cHV0LCBpbm5lckNvbnRleHRdKVxuXHQgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgdGVtcGFsdGUgd2l0aCBibG9ja3MgZGVmaW5lZCBpbiBlbWJlZCBibG9ja1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVuZGVyQXN5bmMoaW5uZXJDb250ZXh0LCB7J2Jsb2Nrcyc6dGhhdC5ibG9ja3N9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihvdXRwdXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvKiBBZGQgdGhlIHslIGVuZGVtYmVkICV9IHRva2VuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5lbmRlbWJlZCxcblx0ICAgICAgICAgICAgcmVnZXg6IC9eZW5kZW1iZWQkLyxcblx0ICAgICAgICAgICAgbmV4dDogWyBdLFxuXHQgICAgICAgICAgICBvcGVuOiBmYWxzZVxuXHQgICAgICAgIH1cblxuXHQgICAgXTtcblxuXG5cdCAgICAvKipcblx0ICAgICAqIFJlZ2lzdHJ5IGZvciBsb2dpYyBoYW5kbGVycy5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5sb2dpYy5oYW5kbGVyID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVmaW5lIGEgbmV3IHRva2VuIHR5cGUsIGF2YWlsYWJsZSBhdCBUd2lnLmxvZ2ljLnR5cGUue3R5cGV9XG5cdCAgICAgKi9cblx0ICAgIFR3aWcubG9naWMuZXh0ZW5kVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgKFwiVHdpZy5sb2dpYy50eXBlXCIgKyB0eXBlKTtcblx0ICAgICAgICBUd2lnLmxvZ2ljLnR5cGVbdHlwZV0gPSB2YWx1ZTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogRXh0ZW5kIHRoZSBsb2dpYyBwYXJzaW5nIGZ1bmN0aW9uYWxpdHkgd2l0aCBhIG5ldyB0b2tlbiBkZWZpbml0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIC8vIERlZmluZSBhIG5ldyB0YWdcblx0ICAgICAqIFR3aWcubG9naWMuZXh0ZW5kKHtcblx0ICAgICAqICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUue3R5cGV9LFxuXHQgICAgICogICAgIC8vIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIGZvciB0aGlzIHRva2VuXG5cdCAgICAgKiAgICAgcmVnZXg6IC4uLixcblx0ICAgICAqICAgICAvLyBXaGF0IHRva2VuIHR5cGVzIGNhbiBmb2xsb3cgdGhpcyB0b2tlbiwgbGVhdmUgYmxhbmsgaWYgYW55LlxuXHQgICAgICogICAgIG5leHQ6IFsgLi4uIF1cblx0ICAgICAqICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBjb21waWxlZCB2ZXJzaW9uIG9mIHRoZSB0b2tlblxuXHQgICAgICogICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRva2VuKSB7IC4uLiB9XG5cdCAgICAgKiAgICAgLy8gUGFyc2UgdGhlIGNvbXBpbGVkIHRva2VuIHdpdGggdGhlIGNvbnRleHQgcHJvdmlkZWQgYnkgdGhlIHJlbmRlciBjYWxsXG5cdCAgICAgKiAgICAgLy8gICBhbmQgd2hldGhlciB0aGlzIHRva2VuIGNoYWluIGlzIGNvbXBsZXRlLlxuXHQgICAgICogICAgIHBhcnNlOiBmdW5jdGlvbih0b2tlbiwgY29udGV4dCwgY2hhaW4pIHsgLi4uIH1cblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIFRoZSBuZXcgbG9naWMgZXhwcmVzc2lvbi5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5sb2dpYy5leHRlbmQgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuXG5cdCAgICAgICAgaWYgKCFkZWZpbml0aW9uLnR5cGUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoXCJVbmFibGUgdG8gZXh0ZW5kIGxvZ2ljIGRlZmluaXRpb24uIE5vIHR5cGUgcHJvdmlkZWQgZm9yIFwiICsgZGVmaW5pdGlvbik7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgVHdpZy5sb2dpYy5leHRlbmRUeXBlKGRlZmluaXRpb24udHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFR3aWcubG9naWMuaGFuZGxlcltkZWZpbml0aW9uLnR5cGVdID0gZGVmaW5pdGlvbjtcblx0ICAgIH07XG5cblx0ICAgIC8vIEV4dGVuZCB3aXRoIGJ1aWx0LWluIGV4cHJlc3Npb25zXG5cdCAgICB3aGlsZSAoVHdpZy5sb2dpYy5kZWZpbml0aW9ucy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgVHdpZy5sb2dpYy5leHRlbmQoVHdpZy5sb2dpYy5kZWZpbml0aW9ucy5zaGlmdCgpKTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb21waWxlIGEgbG9naWMgdG9rZW4gaW50byBhbiBvYmplY3QgcmVhZHkgZm9yIHBhcnNpbmcuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IHJhd190b2tlbiBBbiB1bmNvbXBpbGVkIGxvZ2ljIHRva2VuLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBjb21waWxlZCBsb2dpYyB0b2tlbiwgcmVhZHkgZm9yIHBhcnNpbmcuXG5cdCAgICAgKi9cblx0ICAgIFR3aWcubG9naWMuY29tcGlsZSA9IGZ1bmN0aW9uIChyYXdfdG9rZW4pIHtcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJhd190b2tlbi52YWx1ZS50cmltKCksXG5cdCAgICAgICAgICAgIHRva2VuID0gVHdpZy5sb2dpYy50b2tlbml6ZS5hcHBseSh0aGlzLCBbZXhwcmVzc2lvbl0pLFxuXHQgICAgICAgICAgICB0b2tlbl90ZW1wbGF0ZSA9IFR3aWcubG9naWMuaGFuZGxlclt0b2tlbi50eXBlXTtcblxuXHQgICAgICAgIC8vIENoZWNrIGlmIHRoZSB0b2tlbiBuZWVkcyBjb21waWxpbmdcblx0ICAgICAgICBpZiAodG9rZW5fdGVtcGxhdGUuY29tcGlsZSkge1xuXHQgICAgICAgICAgICB0b2tlbiA9IHRva2VuX3RlbXBsYXRlLmNvbXBpbGUuYXBwbHkodGhpcywgW3Rva2VuXSk7XG5cdCAgICAgICAgICAgIFR3aWcubG9nLnRyYWNlKFwiVHdpZy5sb2dpYy5jb21waWxlOiBcIiwgXCJDb21waWxlZCBsb2dpYyB0b2tlbiB0byBcIiwgdG9rZW4pO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVG9rZW5pemUgbG9naWMgZXhwcmVzc2lvbnMuIFRoaXMgZnVuY3Rpb24gbWF0Y2hlcyB0b2tlbiBleHByZXNzaW9ucyBhZ2FpbnN0IHJlZ3VsYXJcblx0ICAgICAqIGV4cHJlc3Npb25zIHByb3ZpZGVkIGluIHRva2VuIGRlZmluaXRpb25zIHByb3ZpZGVkIHdpdGggVHdpZy5sb2dpYy5leHRlbmQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gdGhlIGxvZ2ljIHRva2VuIGV4cHJlc3Npb24gdG8gdG9rZW5pemVcblx0ICAgICAqICAgICAgICAgICAgICAgIChpLmUuIHdoYXQncyBiZXR3ZWVuIHslIGFuZCAlfSlcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtYXRjaGVkIHRva2VuIHdpdGggdHlwZSBzZXQgdG8gdGhlIHRva2VuIHR5cGUgYW5kIG1hdGNoIHRvIHRoZSByZWdleCBtYXRjaC5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5sb2dpYy50b2tlbml6ZSA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG5cdCAgICAgICAgdmFyIHRva2VuID0ge30sXG5cdCAgICAgICAgICAgIHRva2VuX3RlbXBsYXRlX3R5cGUgPSBudWxsLFxuXHQgICAgICAgICAgICB0b2tlbl90eXBlID0gbnVsbCxcblx0ICAgICAgICAgICAgdG9rZW5fcmVnZXggPSBudWxsLFxuXHQgICAgICAgICAgICByZWdleF9hcnJheSA9IG51bGwsXG5cdCAgICAgICAgICAgIHJlZ2V4ID0gbnVsbCxcblx0ICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xuXG5cdCAgICAgICAgLy8gSWdub3JlIHdoaXRlc3BhY2UgYXJvdW5kIGV4cHJlc3Npb25zLlxuXHQgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnRyaW0oKTtcblxuXHQgICAgICAgIGZvciAodG9rZW5fdGVtcGxhdGVfdHlwZSBpbiBUd2lnLmxvZ2ljLmhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgaWYgKFR3aWcubG9naWMuaGFuZGxlci5oYXNPd25Qcm9wZXJ0eSh0b2tlbl90ZW1wbGF0ZV90eXBlKSkge1xuXHQgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0eXBlIGFuZCByZWdleCBmb3IgdGhpcyB0ZW1wbGF0ZSB0eXBlXG5cdCAgICAgICAgICAgICAgICB0b2tlbl90eXBlID0gVHdpZy5sb2dpYy5oYW5kbGVyW3Rva2VuX3RlbXBsYXRlX3R5cGVdLnR5cGU7XG5cdCAgICAgICAgICAgICAgICB0b2tlbl9yZWdleCA9IFR3aWcubG9naWMuaGFuZGxlclt0b2tlbl90ZW1wbGF0ZV90eXBlXS5yZWdleDtcblxuXHQgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG11bHRpcGxlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgcGVyIHR5cGUuXG5cdCAgICAgICAgICAgICAgICByZWdleF9hcnJheSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuX3JlZ2V4IGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZWdleF9hcnJheSA9IHRva2VuX3JlZ2V4O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZWdleF9hcnJheS5wdXNoKHRva2VuX3JlZ2V4KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcmVndWxhciBleHByZXNzaW9ucyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgZGVmaW5pdGlvbi5cblx0ICAgICAgICAgICAgICAgIHdoaWxlIChyZWdleF9hcnJheS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXggPSByZWdleF9hcnJheS5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhleHByZXNzaW9uLnRyaW0oKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgID0gdG9rZW5fdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2ggPSBtYXRjaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgVHdpZy5sb2cudHJhY2UoXCJUd2lnLmxvZ2ljLnRva2VuaXplOiBcIiwgXCJNYXRjaGVkIGEgXCIsIHRva2VuX3R5cGUsIFwiIHJlZ3VsYXIgZXhwcmVzc2lvbiBvZiBcIiwgbWF0Y2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gTm8gcmVnZXggbWF0Y2hlc1xuXHQgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKFwiVW5hYmxlIHRvIHBhcnNlICdcIiArIGV4cHJlc3Npb24udHJpbSgpICsgXCInXCIpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYXJzZSBhIGxvZ2ljIHRva2VuIHdpdGhpbiBhIGdpdmVuIGNvbnRleHQuXG5cdCAgICAgKlxuXHQgICAgICogV2hhdCBhcmUgbG9naWMgY2hhaW5zP1xuXHQgICAgICogICAgICBMb2dpYyBjaGFpbnMgcmVwcmVzZW50IGEgc2VyaWVzIG9mIHRva2VucyB0aGF0IGFyZSBjb25uZWN0ZWQsXG5cdCAgICAgKiAgICAgICAgICBmb3IgZXhhbXBsZTpcblx0ICAgICAqICAgICAgICAgIHslIGlmIC4uLiAlfSB7JSBlbHNlICV9IHslIGVuZGlmICV9XG5cdCAgICAgKlxuXHQgICAgICogICAgICBUaGUgY2hhaW4gcGFyYW1ldGVyIGlzIHVzZWQgdG8gc2lnbmlmeSBpZiBhIGNoYWluIGlzIG9wZW4gb2YgY2xvc2VkLlxuXHQgICAgICogICAgICBvcGVuOlxuXHQgICAgICogICAgICAgICAgTW9yZSB0b2tlbnMgaW4gdGhpcyBjaGFpbiBzaG91bGQgYmUgcGFyc2VkLlxuXHQgICAgICogICAgICBjbG9zZWQ6XG5cdCAgICAgKiAgICAgICAgICBUaGlzIHRva2VuIGNoYWluIGhhcyBjb21wbGV0ZWQgcGFyc2luZyBhbmQgYW55IGFkZGl0aW9uYWxcblx0ICAgICAqICAgICAgICAgIHRva2VucyAoZWxzZSwgZWxzZWlmLCBldGMuLi4pIHNob3VsZCBiZSBpZ25vcmVkLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBUaGUgY29tcGlsZWQgdG9rZW4uXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgcmVuZGVyIGNvbnRleHQuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoYWluIElzIHRoaXMgYW4gb3BlbiBsb2dpYyBjaGFpbi4gSWYgZmFsc2UsIHRoYXQgbWVhbnMgYVxuXHQgICAgICogICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiBpcyBjbG9zZWQgYW5kIG5vIGZ1cnRoZXIgY2FzZXMgc2hvdWxkIGJlIHBhcnNlZC5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5sb2dpYy5wYXJzZSA9IGZ1bmN0aW9uICh0b2tlbiwgY29udGV4dCwgY2hhaW4sIGFsbG93X2FzeW5jKSB7XG5cdCAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuXHQgICAgICAgICAgICBwcm9taXNlLFxuXHQgICAgICAgICAgICBpc19hc3luYyA9IHRydWUsXG5cdCAgICAgICAgICAgIHRva2VuX3RlbXBsYXRlO1xuXG5cdCAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgeyB9O1xuXG5cdCAgICAgICAgVHdpZy5sb2cuZGVidWcoXCJUd2lnLmxvZ2ljLnBhcnNlOiBcIiwgXCJQYXJzaW5nIGxvZ2ljIHRva2VuIFwiLCB0b2tlbik7XG5cblx0ICAgICAgICB0b2tlbl90ZW1wbGF0ZSA9IFR3aWcubG9naWMuaGFuZGxlclt0b2tlbi50eXBlXTtcblxuXHQgICAgICAgIGlmICh0b2tlbl90ZW1wbGF0ZS5wYXJzZSkge1xuXHQgICAgICAgICAgICBvdXRwdXQgPSB0b2tlbl90ZW1wbGF0ZS5wYXJzZS5hcHBseSh0aGlzLCBbdG9rZW4sIGNvbnRleHQsIGNoYWluXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHJvbWlzZSA9IFR3aWcuaXNQcm9taXNlKG91dHB1dCkgPyBvdXRwdXQgOiBUd2lnLlByb21pc2UucmVzb2x2ZShvdXRwdXQpO1xuXG5cdCAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKG8pIHtcblx0ICAgICAgICAgICAgaXNfYXN5bmMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgb3V0cHV0ID0gbztcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGlmIChhbGxvd19hc3luYylcblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2UgfHwgVHdpZy5Qcm9taXNlLnJlc29sdmUob3V0cHV0KTtcblxuXHQgICAgICAgIGlmIChpc19hc3luYylcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1lvdSBhcmUgdXNpbmcgVHdpZy5qcyBpbiBzeW5jIG1vZGUgaW4gY29tYmluYXRpb24gd2l0aCBhc3luYyBleHRlbnNpb25zLicpO1xuXG5cdCAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBUd2lnO1xuXG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDIyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFR3aWcpIHtcblx0ICAgICd1c2Ugc3RyaWN0JztcblxuXHQgICAgVHdpZy5UZW1wbGF0ZXMucmVnaXN0ZXJQYXJzZXIoJ3NvdXJjZScsIGZ1bmN0aW9uKHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiBwYXJhbXMuZGF0YSB8fCAnJztcblx0ICAgIH0pO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAyMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUd2lnKSB7XG5cdCAgICAndXNlIHN0cmljdCc7XG5cblx0ICAgIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdGVyUGFyc2VyKCd0d2lnJywgZnVuY3Rpb24ocGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBUd2lnLlRlbXBsYXRlKHBhcmFtcyk7XG5cdCAgICB9KTtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMjQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vICMjIHR3aWcucGF0aC5qc1xuXHQvL1xuXHQvLyBUaGlzIGZpbGUgaGFuZGxlcyBwYXRoIHBhcnNpbmdcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVHdpZykge1xuXHQgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTmFtZXNwYWNlIGZvciBwYXRoIGhhbmRsaW5nLlxuXHQgICAgICovXG5cdCAgICBUd2lnLnBhdGggPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBHZW5lcmF0ZSB0aGUgY2Fub25pY2FsIHZlcnNpb24gb2YgYSB1cmwgYmFzZWQgb24gdGhlIGdpdmVuIGJhc2UgcGF0aCBhbmQgZmlsZSBwYXRoIGFuZCBpblxuXHQgICAgICogdGhlIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBuYW1lc3BhY2VzLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGVtcGxhdGUgVGhlIFR3aWcgVGVtcGxhdGVcblx0ICAgICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgICAgVGhlIGZpbGUgcGF0aCwgbWF5IGJlIHJlbGF0aXZlIGFuZCBtYXkgY29udGFpbiBuYW1lc3BhY2VzLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgVGhlIGNhbm9uaWNhbCB2ZXJzaW9uIG9mIHRoZSBwYXRoXG5cdCAgICAgKi9cblx0ICAgICBUd2lnLnBhdGgucGFyc2VQYXRoID0gZnVuY3Rpb24odGVtcGxhdGUsIGZpbGUpIHtcblx0ICAgICAgICB2YXIgbmFtZXNwYWNlcyA9IG51bGwsXG5cdCAgICAgICAgICAgIGZpbGUgPSBmaWxlIHx8IFwiXCI7XG5cblx0ICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGVtcGxhdGUub3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgICAgbmFtZXNwYWNlcyA9IHRlbXBsYXRlLm9wdGlvbnMubmFtZXNwYWNlcztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdvYmplY3QnICYmIChmaWxlLmluZGV4T2YoJzo6JykgPiAwKSB8fCBmaWxlLmluZGV4T2YoJ0AnKSA+PSAwKXtcblx0ICAgICAgICAgICAgZm9yICh2YXIgayBpbiBuYW1lc3BhY2VzKXtcblx0ICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KGspKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGZpbGUucmVwbGFjZShrICsgJzo6JywgbmFtZXNwYWNlc1trXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGZpbGUucmVwbGFjZSgnQCcgKyBrLCBuYW1lc3BhY2VzW2tdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmaWxlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBUd2lnLnBhdGgucmVsYXRpdmVQYXRoKHRlbXBsYXRlLCBmaWxlKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogR2VuZXJhdGUgdGhlIHJlbGF0aXZlIGNhbm9uaWNhbCB2ZXJzaW9uIG9mIGEgdXJsIGJhc2VkIG9uIHRoZSBnaXZlbiBiYXNlIHBhdGggYW5kIGZpbGUgcGF0aC5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1R3aWcuVGVtcGxhdGV9IHRlbXBsYXRlIFRoZSBUd2lnLlRlbXBsYXRlLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgVGhlIGZpbGUgcGF0aCwgcmVsYXRpdmUgdG8gdGhlIGJhc2UgcGF0aC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjYW5vbmljYWwgdmVyc2lvbiBvZiB0aGUgcGF0aC5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5wYXRoLnJlbGF0aXZlUGF0aCA9IGZ1bmN0aW9uKHRlbXBsYXRlLCBmaWxlKSB7XG5cdCAgICAgICAgdmFyIGJhc2UsXG5cdCAgICAgICAgICAgIGJhc2VfcGF0aCxcblx0ICAgICAgICAgICAgc2VwX2NociA9IFwiL1wiLFxuXHQgICAgICAgICAgICBuZXdfcGF0aCA9IFtdLFxuXHQgICAgICAgICAgICBmaWxlID0gZmlsZSB8fCBcIlwiLFxuXHQgICAgICAgICAgICB2YWw7XG5cblx0ICAgICAgICBpZiAodGVtcGxhdGUudXJsKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUuYmFzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICAgICAgICAgIGJhc2UgPSB0ZW1wbGF0ZS5iYXNlICsgKCh0ZW1wbGF0ZS5iYXNlLmNoYXJBdCh0ZW1wbGF0ZS5iYXNlLmxlbmd0aC0xKSA9PT0gJy8nKSA/ICcnIDogJy8nKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGJhc2UgPSB0ZW1wbGF0ZS51cmw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLnBhdGgpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IHRoZSBzeXN0ZW0tc3BlY2lmaWMgcGF0aCBzZXBhcmF0b3Jcblx0ICAgICAgICAgICAgdmFyIHBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSxcblx0ICAgICAgICAgICAgICAgIHNlcCA9IHBhdGguc2VwIHx8IHNlcF9jaHIsXG5cdCAgICAgICAgICAgICAgICByZWxhdGl2ZSA9IG5ldyBSZWdFeHAoXCJeXFxcXC57MSwyfVwiICsgc2VwLnJlcGxhY2UoXCJcXFxcXCIsIFwiXFxcXFxcXFxcIikpO1xuXHQgICAgICAgICAgICBmaWxlID0gZmlsZS5yZXBsYWNlKC9cXC8vZywgc2VwKTtcblxuXHQgICAgICAgICAgICBpZiAodGVtcGxhdGUuYmFzZSAhPT0gdW5kZWZpbmVkICYmIGZpbGUubWF0Y2gocmVsYXRpdmUpID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGZpbGUgPSBmaWxlLnJlcGxhY2UodGVtcGxhdGUuYmFzZSwgJycpO1xuXHQgICAgICAgICAgICAgICAgYmFzZSA9IHRlbXBsYXRlLmJhc2UgKyBzZXA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBiYXNlID0gcGF0aC5ub3JtYWxpemUodGVtcGxhdGUucGF0aCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKHNlcCtzZXAsIHNlcCk7XG5cdCAgICAgICAgICAgIHNlcF9jaHIgPSBzZXA7XG5cdCAgICAgICAgfSBlbHNlIGlmICgodGVtcGxhdGUubmFtZSB8fCB0ZW1wbGF0ZS5pZCkgJiYgdGVtcGxhdGUubWV0aG9kICYmIHRlbXBsYXRlLm1ldGhvZCAhPT0gJ2ZzJyAmJiB0ZW1wbGF0ZS5tZXRob2QgIT09ICdhamF4Jykge1xuXHQgICAgICAgICAgICAvLyBDdXN0b20gcmVnaXN0ZXJlZCBsb2FkZXJcblx0ICAgICAgICAgICAgYmFzZSA9IHRlbXBsYXRlLmJhc2UgfHwgdGVtcGxhdGUubmFtZSB8fCB0ZW1wbGF0ZS5pZDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcIkNhbm5vdCBleHRlbmQgYW4gaW5saW5lIHRlbXBsYXRlLlwiKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBiYXNlX3BhdGggPSBiYXNlLnNwbGl0KHNlcF9jaHIpO1xuXG5cdCAgICAgICAgLy8gUmVtb3ZlIGZpbGUgZnJvbSB1cmxcblx0ICAgICAgICBiYXNlX3BhdGgucG9wKCk7XG5cdCAgICAgICAgYmFzZV9wYXRoID0gYmFzZV9wYXRoLmNvbmNhdChmaWxlLnNwbGl0KHNlcF9jaHIpKTtcblxuXHQgICAgICAgIHdoaWxlIChiYXNlX3BhdGgubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICB2YWwgPSBiYXNlX3BhdGguc2hpZnQoKTtcblx0ICAgICAgICAgICAgaWYgKHZhbCA9PSBcIi5cIikge1xuXHQgICAgICAgICAgICAgICAgLy8gSWdub3JlXG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID09IFwiLi5cIiAmJiBuZXdfcGF0aC5sZW5ndGggPiAwICYmIG5ld19wYXRoW25ld19wYXRoLmxlbmd0aC0xXSAhPSBcIi4uXCIpIHtcblx0ICAgICAgICAgICAgICAgIG5ld19wYXRoLnBvcCgpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbmV3X3BhdGgucHVzaCh2YWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG5ld19wYXRoLmpvaW4oc2VwX2Nocik7XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gVHdpZztcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMjUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vICMjIHR3aWcudGVzdHMuanNcblx0Ly9cblx0Ly8gVGhpcyBmaWxlIGhhbmRsZXMgZXhwcmVzc2lvbiB0ZXN0cy4gKGlzIGVtcHR5LCBpcyBub3QgZGVmaW5lZCwgZXRjLi4uKVxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG5cdCAgICBcInVzZSBzdHJpY3RcIjtcblx0ICAgIFR3aWcudGVzdHMgPSB7XG5cdCAgICAgICAgZW1wdHk6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgLy8gSGFuZGxlciBudW1iZXJzXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHJldHVybiBmYWxzZTsgLy8gbnVtYmVycyBhcmUgbmV2ZXIgXCJlbXB0eVwiXG5cdCAgICAgICAgICAgIC8vIEhhbmRsZSBzdHJpbmdzIGFuZCBhcnJheXNcblx0ICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggPiAwKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIC8vIEhhbmRsZSBvYmplY3RzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIG9kZDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlICUgMiA9PT0gMTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGV2ZW46IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZSAlIDIgPT09IDA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBkaXZpc2libGVieTogZnVuY3Rpb24odmFsdWUsIHBhcmFtcykge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWUgJSBwYXJhbXNbMF0gPT09IDA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBkZWZpbmVkOiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIG5vbmU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdudWxsJzogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9uZSh2YWx1ZSk7IC8vIEFsaWFzIG9mIG5vbmVcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdzYW1lIGFzJzogZnVuY3Rpb24odmFsdWUsIHBhcmFtcykge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHBhcmFtc1swXTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNhbWVhczogZnVuY3Rpb24odmFsdWUsIHBhcmFtcykge1xuXHQgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2BzYW1lYXNgIGlzIGRlcHJlY2F0ZWQgdXNlIGBzYW1lIGFzYCcpO1xuXHQgICAgICAgICAgICByZXR1cm4gVHdpZy50ZXN0c1snc2FtZSBhcyddKHZhbHVlLCBwYXJhbXMpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgaXRlcmFibGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZSAmJiAoVHdpZy5saWIuaXMoXCJBcnJheVwiLCB2YWx1ZSkgfHwgVHdpZy5saWIuaXMoXCJPYmplY3RcIiwgdmFsdWUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLypcblx0ICAgICAgICBjb25zdGFudCA/XG5cdCAgICAgICAgICovXG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLnRlc3QgPSBmdW5jdGlvbih0ZXN0LCB2YWx1ZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKCFUd2lnLnRlc3RzW3Rlc3RdKSB7XG5cdCAgICAgICAgICAgIHRocm93IFwiVGVzdCBcIiArIHRlc3QgKyBcIiBpcyBub3QgZGVmaW5lZC5cIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFR3aWcudGVzdHNbdGVzdF0odmFsdWUsIHBhcmFtcyk7XG5cdCAgICB9O1xuXG5cdCAgICBUd2lnLnRlc3QuZXh0ZW5kID0gZnVuY3Rpb24odGVzdCwgZGVmaW5pdGlvbikge1xuXHQgICAgICAgIFR3aWcudGVzdHNbdGVzdF0gPSBkZWZpbml0aW9uO1xuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIFR3aWc7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDI2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyAjIyB0d2lnLmFzeW5jLmpzXG5cdC8vXG5cdC8vIFRoaXMgZmlsZSBoYW5kbGVzIGFzeW5jaHJvbm91cyB0YXNrcyB3aXRoaW4gdHdpZy5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVHdpZykge1xuXHQgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cblx0ICAgIFR3aWcucGFyc2VBc3luYyA9IGZ1bmN0aW9uICh0b2tlbnMsIGNvbnRleHQpIHtcblx0ICAgICAgICByZXR1cm4gVHdpZy5wYXJzZS5hcHBseSh0aGlzLCBbdG9rZW5zLCBjb250ZXh0LCB0cnVlXSk7XG5cdCAgICB9XG5cblx0ICAgIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jID0gZnVuY3Rpb24gKHRva2VucywgY29udGV4dCwgdG9rZW5zX2FyZV9wYXJhbWV0ZXJzKSB7XG5cdCAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZS5hcHBseSh0aGlzLCBbdG9rZW5zLCBjb250ZXh0LCB0b2tlbnNfYXJlX3BhcmFtZXRlcnMsIHRydWVdKTtcblx0ICAgIH1cblxuXHQgICAgVHdpZy5sb2dpYy5wYXJzZUFzeW5jID0gZnVuY3Rpb24gKHRva2VuLCBjb250ZXh0LCBjaGFpbikge1xuXHQgICAgICAgIHJldHVybiBUd2lnLmxvZ2ljLnBhcnNlLmFwcGx5KHRoaXMsIFt0b2tlbiwgY29udGV4dCwgY2hhaW4sIHRydWVdKTtcblx0ICAgIH1cblxuXHQgICAgVHdpZy5UZW1wbGF0ZS5wcm90b3R5cGUucmVuZGVyQXN5bmMgPSBmdW5jdGlvbiAoY29udGV4dCwgcGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKGNvbnRleHQsIHBhcmFtcywgdHJ1ZSk7XG5cdCAgICB9XG5cblx0ICAgIFR3aWcuYXN5bmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgZm9yIGB0aGVuYWJsZWAgb2JqZWN0c1xuXHQgICAgICovXG5cdCAgICBUd2lnLmlzUHJvbWlzZSA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgIHJldHVybiBvYmogJiYgKHR5cGVvZiBvYmoudGhlbiA9PSAnZnVuY3Rpb24nKTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhbHRlcm5hdGUgaW1wbGVtZW50YXRpb24gb2YgYSBQcm9taXNlIHRoYXQgZG9lcyBub3QgZnVsbHkgZm9sbG93XG5cdCAgICAgKiB0aGUgc3BlYywgYnV0IGluc3RlYWQgd29ya3MgZnVsbHkgc3luY2hyb25vdXMgd2hpbGUgc3RpbGwgYmVpbmdcblx0ICAgICAqIHRoZW5hYmxlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZXNlIHByb21pc2VzIGNhbiBiZSBtaXhlZCB3aXRoIHJlZ3VsYXIgcHJvbWlzZXMgYXQgd2hpY2ggcG9pbnRcblx0ICAgICAqIHRoZSBzeW5jaHJvbm91cyBiZWhhdmlvdXIgaXMgbG9zdC5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5Qcm9taXNlID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0ICAgICAgICAvLyBTdGF0ZVxuXHQgICAgICAgIHZhciBzdGF0ZSA9ICd1bmtub3duJztcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuXHQgICAgICAgIHZhciBoYW5kbGVycyA9IG51bGw7XG5cblx0ICAgICAgICBmdW5jdGlvbiBjaGFuZ2VTdGF0ZShuZXdTdGF0ZSwgdikge1xuXHQgICAgICAgICAgICBzdGF0ZSA9IG5ld1N0YXRlO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHY7XG5cdCAgICAgICAgICAgIG5vdGlmeSgpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gb25SZXNvbHZlKHYpIHsgY2hhbmdlU3RhdGUoJ3Jlc29sdmUnLCB2KTsgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0KGUpIHsgY2hhbmdlU3RhdGUoJ3JlamVjdCcsIGUpOyB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBub3RpZnkoKSB7XG5cdCAgICAgICAgICAgIGlmICghaGFuZGxlcnMpIHJldHVybjtcblxuXHQgICAgICAgICAgICBUd2lnLmZvckVhY2goaGFuZGxlcnMsIGZ1bmN0aW9uKGgpIHtcblx0ICAgICAgICAgICAgICAgIGFwcGVuZChoLnJlc29sdmUsIGgucmVqZWN0KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGhhbmRsZXJzID0gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBhcHBlbmQob25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuXHQgICAgICAgICAgICB2YXIgaCA9IHtcblx0ICAgICAgICAgICAgICAgIHJlc29sdmU6IG9uUmVzb2x2ZWQsXG5cdCAgICAgICAgICAgICAgICByZWplY3Q6IG9uUmVqZWN0ZWRcblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICAvLyBUaGUgcHJvbWlzZSBoYXMgeWV0IHRvIGJlIHJlamVjdGVkIG9yIHJlc29sdmVkLlxuXHQgICAgICAgICAgICBpZiAoc3RhdGUgPT0gJ3Vua25vd24nKSB7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGhhbmRsZXJzIHx8IFtdO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJzLnB1c2goaCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBUaGUgc3RhdGUgaGFzIGJlZW4gY2hhbmdlZCB0byBlaXRoZXIgcmVzb2x2ZSwgb3IgcmVqZWN0XG5cdCAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIHdlIHNob3VsZCBjYWxsIHRoZSBoYW5kbGVyLlxuXHQgICAgICAgICAgICBpZiAoaFtzdGF0ZV0pXG5cdCAgICAgICAgICAgICAgICBoW3N0YXRlXSh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gcnVuKGZuLCByZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uKHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodik7XG5cdCAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSBjYXRjaChlKSB7XG5cdCAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHJlamVjdChlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIHJlYWR5KHJlc3VsdCkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFUd2lnLmlzUHJvbWlzZShyZXN1bHQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBydW4ocmVzdWx0LnRoZW4uYmluZChyZXN1bHQpLCByZWFkeSwgb25SZWplY3QpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICBvblJlamVjdChlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJ1bihleGVjdXRvciwgcmVhZHksIG9uUmVqZWN0KTtcblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBoYXNSZXNvbHZlZCA9IHR5cGVvZiBvblJlc29sdmVkID09ICdmdW5jdGlvbic7XG5cdCAgICAgICAgICAgICAgICB2YXIgaGFzUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR3aWcuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhcHBlbmQoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNSZXNvbHZlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9uUmVzb2x2ZWQocmVzdWx0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNSZWplY3RlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9uUmVqZWN0ZWQoZXJyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBjYXRjaDogZnVuY3Rpb24ob25SZWplY3RlZCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIFR3aWcuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFR3aWcuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblxuXHQgICAgVHdpZy5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFR3aWcuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgcmVqZWN0KGUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblxuXHQgICAgVHdpZy5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuXHQgICAgICAgIHJldHVybiBUd2lnLmFzeW5jLmZvckVhY2gocHJvbWlzZXMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmICghVHdpZy5pc1Byb21pc2UocCkpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gcDtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBwLnRoZW4oZnVuY3Rpb24odikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2O1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KVxuXHQgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgKiBHbyBvdmVyIGVhY2ggaXRlbSBpbiBhIGZhc2hpb24gY29tcGF0aWJsZSB3aXRoIFR3aWcuZm9yRWFjaCxcblx0ICAgICogYWxsb3cgdGhlIGZ1bmN0aW9uIHRvIHJldHVybiBhIHByb21pc2Ugb3IgY2FsbCB0aGUgdGhpcmQgYXJndW1lbnRcblx0ICAgICogdG8gc2lnbmFsIGl0IGlzIGZpbmlzaGVkLlxuXHQgICAgKlxuXHQgICAgKiBFYWNoIGl0ZW0gaW4gdGhlIGFycmF5IHdpbGwgYmUgY2FsbGVkIHNlcXVlbnRpYWxseS5cblx0ICAgICovXG5cdCAgICBUd2lnLmFzeW5jLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoQXN5bmMoYXJyLCBjYWxsYmFjaykge1xuXHQgICAgICAgIHZhciBhcmdfaW5kZXggPSAwO1xuXHQgICAgICAgIHZhciBjYWxsYmFja3MgPSB7fTtcblx0ICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBUd2lnLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrcyA9IHtcblx0ICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG5cdCAgICAgICAgICAgICAgICByZWplY3Q6IHJlamVjdFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgZnVuY3Rpb24gZmFpbChlcnIpIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2tzLnJlamVjdChlcnIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIG5leHQodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKCFUd2lnLmlzUHJvbWlzZSh2YWx1ZSkpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0ZSgpO1xuXG5cdCAgICAgICAgICAgIHZhbHVlLnRoZW4obmV4dCwgZmFpbCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZSgpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gYXJnX2luZGV4Kys7XG5cblx0ICAgICAgICAgICAgaWYgKGluZGV4ID09IGFyci5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBuZXh0KGNhbGxiYWNrKGFycltpbmRleF0sIGluZGV4KSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaXRlcmF0ZSgpO1xuXG5cdCAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gVHdpZztcblxuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAyNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gIyMgdHdpZy5leHBvcnRzLmpzXG5cdC8vXG5cdC8vIFRoaXMgZmlsZSBwcm92aWRlcyBleHRlbnNpb24gcG9pbnRzIGFuZCBvdGhlciBob29rcyBpbnRvIHRoZSB0d2lnIGZ1bmN0aW9uYWxpdHkuXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVHdpZykge1xuXHQgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cdCAgICBUd2lnLmV4cG9ydHMgPSB7XG5cdCAgICAgICAgVkVSU0lPTjogVHdpZy5WRVJTSU9OXG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZSBhbmQgY29tcGlsZSBhIHR3aWcuanMgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFBhcmFtdGVyZXMgZm9yIGNyZWF0aW5nIGEgVHdpZyB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtUd2lnLlRlbXBsYXRlfSBBIFR3aWcgdGVtcGxhdGUgcmVhZHkgZm9yIHJlbmRlcmluZy5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5leHBvcnRzLnR3aWcgPSBmdW5jdGlvbiB0d2lnKHBhcmFtcykge1xuXHQgICAgICAgICd1c2Ugc3RyaWN0Jztcblx0ICAgICAgICB2YXIgaWQgPSBwYXJhbXMuaWQsXG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB7XG5cdCAgICAgICAgICAgICAgICBzdHJpY3RfdmFyaWFibGVzOiBwYXJhbXMuc3RyaWN0X3ZhcmlhYmxlcyB8fCBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIC8vIFRPRE86IHR1cm4gYXV0b3NjYXBlIG9uIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cblx0ICAgICAgICAgICAgICAgIGF1dG9lc2NhcGU6IHBhcmFtcy5hdXRvZXNjYXBlICE9IG51bGwgJiYgcGFyYW1zLmF1dG9lc2NhcGUgfHwgZmFsc2UsXG5cdCAgICAgICAgICAgICAgICBhbGxvd0lubGluZUluY2x1ZGVzOiBwYXJhbXMuYWxsb3dJbmxpbmVJbmNsdWRlcyB8fCBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIHJldGhyb3c6IHBhcmFtcy5yZXRocm93IHx8IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgbmFtZXNwYWNlczogcGFyYW1zLm5hbWVzcGFjZXNcblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgIGlmIChUd2lnLmNhY2hlICYmIGlkKSB7XG5cdCAgICAgICAgICAgIFR3aWcudmFsaWRhdGVJZChpZCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHBhcmFtcy5kZWJ1ZyAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIFR3aWcuZGVidWcgPSBwYXJhbXMuZGVidWc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwYXJhbXMudHJhY2UgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBUd2lnLnRyYWNlID0gcGFyYW1zLnRyYWNlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChwYXJhbXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUd2lnLlRlbXBsYXRlcy5wYXJzZXJzLnR3aWcoe1xuXHQgICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zLmRhdGEsXG5cdCAgICAgICAgICAgICAgICBwYXRoOiBwYXJhbXMuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSA/IHBhcmFtcy5wYXRoIDogdW5kZWZpbmVkLFxuXHQgICAgICAgICAgICAgICAgbW9kdWxlOiBwYXJhbXMubW9kdWxlLFxuXHQgICAgICAgICAgICAgICAgaWQ6ICAgaWQsXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMucmVmICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgaWYgKHBhcmFtcy5pZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihcIkJvdGggcmVmIGFuZCBpZCBjYW5ub3QgYmUgc2V0IG9uIGEgdHdpZy5qcyB0ZW1wbGF0ZS5cIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFR3aWcuVGVtcGxhdGVzLmxvYWQocGFyYW1zLnJlZik7XG5cdCAgICAgICAgXG5cdCAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgaWYgKCFUd2lnLlRlbXBsYXRlcy5pc1JlZ2lzdGVyZWRMb2FkZXIocGFyYW1zLm1ldGhvZCkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdMb2FkZXIgZm9yIFwiJyArIHBhcmFtcy5tZXRob2QgKyAnXCIgaXMgbm90IGRlZmluZWQuJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFR3aWcuVGVtcGxhdGVzLmxvYWRSZW1vdGUocGFyYW1zLm5hbWUgfHwgcGFyYW1zLmhyZWYgfHwgcGFyYW1zLnBhdGggfHwgaWQgfHwgdW5kZWZpbmVkLCB7XG5cdCAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IHBhcmFtcy5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICBwYXJzZXI6IHBhcmFtcy5wYXJzZXIgfHwgJ3R3aWcnLFxuXHQgICAgICAgICAgICAgICAgYmFzZTogcGFyYW1zLmJhc2UsXG5cdCAgICAgICAgICAgICAgICBtb2R1bGU6IHBhcmFtcy5tb2R1bGUsXG5cdCAgICAgICAgICAgICAgICBwcmVjb21waWxlZDogcGFyYW1zLnByZWNvbXBpbGVkLFxuXHQgICAgICAgICAgICAgICAgYXN5bmM6IHBhcmFtcy5hc3luYyxcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcblxuXHQgICAgICAgICAgICB9LCBwYXJhbXMubG9hZCwgcGFyYW1zLmVycm9yKTtcblxuXHQgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmhyZWYgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVHdpZy5UZW1wbGF0ZXMubG9hZFJlbW90ZShwYXJhbXMuaHJlZiwge1xuXHQgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiAnYWpheCcsXG5cdCAgICAgICAgICAgICAgICBwYXJzZXI6IHBhcmFtcy5wYXJzZXIgfHwgJ3R3aWcnLFxuXHQgICAgICAgICAgICAgICAgYmFzZTogcGFyYW1zLmJhc2UsXG5cdCAgICAgICAgICAgICAgICBtb2R1bGU6IHBhcmFtcy5tb2R1bGUsXG5cdCAgICAgICAgICAgICAgICBwcmVjb21waWxlZDogcGFyYW1zLnByZWNvbXBpbGVkLFxuXHQgICAgICAgICAgICAgICAgYXN5bmM6IHBhcmFtcy5hc3luYyxcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcblxuXHQgICAgICAgICAgICB9LCBwYXJhbXMubG9hZCwgcGFyYW1zLmVycm9yKTtcblxuXHQgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnBhdGggIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVHdpZy5UZW1wbGF0ZXMubG9hZFJlbW90ZShwYXJhbXMucGF0aCwge1xuXHQgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiAnZnMnLFxuXHQgICAgICAgICAgICAgICAgcGFyc2VyOiBwYXJhbXMucGFyc2VyIHx8ICd0d2lnJyxcblx0ICAgICAgICAgICAgICAgIGJhc2U6IHBhcmFtcy5iYXNlLFxuXHQgICAgICAgICAgICAgICAgbW9kdWxlOiBwYXJhbXMubW9kdWxlLFxuXHQgICAgICAgICAgICAgICAgcHJlY29tcGlsZWQ6IHBhcmFtcy5wcmVjb21waWxlZCxcblx0ICAgICAgICAgICAgICAgIGFzeW5jOiBwYXJhbXMuYXN5bmMsXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG5cblx0ICAgICAgICAgICAgfSwgcGFyYW1zLmxvYWQsIHBhcmFtcy5lcnJvcik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLy8gRXh0ZW5kIFR3aWcgd2l0aCBhIG5ldyBmaWx0ZXIuXG5cdCAgICBUd2lnLmV4cG9ydHMuZXh0ZW5kRmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyLCBkZWZpbml0aW9uKSB7XG5cdCAgICAgICAgVHdpZy5maWx0ZXIuZXh0ZW5kKGZpbHRlciwgZGVmaW5pdGlvbik7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBFeHRlbmQgVHdpZyB3aXRoIGEgbmV3IGZ1bmN0aW9uLlxuXHQgICAgVHdpZy5leHBvcnRzLmV4dGVuZEZ1bmN0aW9uID0gZnVuY3Rpb24oZm4sIGRlZmluaXRpb24pIHtcblx0ICAgICAgICBUd2lnLl9mdW5jdGlvbi5leHRlbmQoZm4sIGRlZmluaXRpb24pO1xuXHQgICAgfTtcblxuXHQgICAgLy8gRXh0ZW5kIFR3aWcgd2l0aCBhIG5ldyB0ZXN0LlxuXHQgICAgVHdpZy5leHBvcnRzLmV4dGVuZFRlc3QgPSBmdW5jdGlvbih0ZXN0LCBkZWZpbml0aW9uKSB7XG5cdCAgICAgICAgVHdpZy50ZXN0LmV4dGVuZCh0ZXN0LCBkZWZpbml0aW9uKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEV4dGVuZCBUd2lnIHdpdGggYSBuZXcgZGVmaW5pdGlvbi5cblx0ICAgIFR3aWcuZXhwb3J0cy5leHRlbmRUYWcgPSBmdW5jdGlvbihkZWZpbml0aW9uKSB7XG5cdCAgICAgICAgVHdpZy5sb2dpYy5leHRlbmQoZGVmaW5pdGlvbik7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBQcm92aWRlIGFuIGVudmlyb25tZW50IGZvciBleHRlbmRpbmcgVHdpZyBjb3JlLlxuXHQgICAgLy8gQ2FsbHMgZm4gd2l0aCB0aGUgaW50ZXJuYWwgVHdpZyBvYmplY3QuXG5cdCAgICBUd2lnLmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oZm4pIHtcblx0ICAgICAgICBmbihUd2lnKTtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiBQcm92aWRlIGFuIGV4dGVuc2lvbiBmb3IgdXNlIHdpdGggZXhwcmVzcyAyLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgVGhlIHRlbXBsYXRlIG1hcmt1cC5cblx0ICAgICAqIEBwYXJhbSB7YXJyYXl9IG9wdGlvbnMgVGhlIGV4cHJlc3Mgb3B0aW9ucy5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSByZW5kZXJlZCB0ZW1wbGF0ZS5cblx0ICAgICAqL1xuXHQgICAgVHdpZy5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgaWQgPSBvcHRpb25zLmZpbGVuYW1lLFxuXHQgICAgICAgICAgICBwYXRoID0gb3B0aW9ucy5maWxlbmFtZSxcblx0ICAgICAgICAgICAgdGVtcGxhdGU7XG5cblx0ICAgICAgICAvLyBUcnkgdG8gbG9hZCB0aGUgdGVtcGxhdGUgZnJvbSB0aGUgY2FjaGVcblx0ICAgICAgICB0ZW1wbGF0ZSA9IG5ldyBUd2lnLlRlbXBsYXRlKHtcblx0ICAgICAgICAgICAgZGF0YTogbWFya3VwLFxuXHQgICAgICAgICAgICBwYXRoOiBwYXRoLFxuXHQgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMuc2V0dGluZ3NbJ3R3aWcgb3B0aW9ucyddXG5cdCAgICAgICAgfSk7IC8vIFR3aWcuVGVtcGxhdGVzLmxvYWQoaWQpIHx8XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVuZGVyKGNvbnRleHQpO1xuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFByb3ZpZGUgYW4gZXh0ZW5zaW9uIGZvciB1c2Ugd2l0aCBleHByZXNzIDMuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIGxvY2F0aW9uIG9mIHRoZSB0ZW1wbGF0ZSBmaWxlIG9uIGRpc2suXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gVGhlIG9wdGlvbnMgb3IgY2FsbGJhY2suXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBjYWxsYmFjay5cblx0ICAgICAqIFxuXHQgICAgICogQHRocm93cyBUd2lnLkVycm9yXG5cdCAgICAgKi9cblx0ICAgIFR3aWcuZXhwb3J0cy5yZW5kZXJGaWxlID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9ucywgZm4pIHtcblx0ICAgICAgICAvLyBoYW5kbGUgY2FsbGJhY2sgaW4gb3B0aW9uc1xuXHQgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBmbiA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHQgICAgICAgIHZhciBzZXR0aW5ncyA9IG9wdGlvbnMuc2V0dGluZ3MgfHwge307XG5cblx0ICAgICAgICB2YXIgcGFyYW1zID0ge1xuXHQgICAgICAgICAgICBwYXRoOiBwYXRoLFxuXHQgICAgICAgICAgICBiYXNlOiBzZXR0aW5ncy52aWV3cyxcblx0ICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24odGVtcGxhdGUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIHJlbmRlciBhbmQgcmV0dXJuIHRlbXBsYXRlIGFzIGEgc2ltcGxlIHN0cmluZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2lnanMvdHdpZy5qcy9wdWxsLzM0OCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHQgICAgICAgICAgICAgICAgZm4obnVsbCwgJycgKyB0ZW1wbGF0ZS5yZW5kZXIob3B0aW9ucykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIG1peGluIGFueSBvcHRpb25zIHByb3ZpZGVkIHRvIHRoZSBleHByZXNzIGFwcC5cblx0ICAgICAgICB2YXIgdmlld19vcHRpb25zID0gc2V0dGluZ3NbJ3R3aWcgb3B0aW9ucyddO1xuXG5cdCAgICAgICAgaWYgKHZpZXdfb3B0aW9ucykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBvcHRpb24gaW4gdmlld19vcHRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodmlld19vcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb3B0aW9uXSA9IHZpZXdfb3B0aW9uc1tvcHRpb25dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgVHdpZy5leHBvcnRzLnR3aWcocGFyYW1zKTtcblx0ICAgIH07XG5cblx0ICAgIC8vIEV4cHJlc3MgMyBoYW5kbGVyXG5cdCAgICBUd2lnLmV4cG9ydHMuX19leHByZXNzID0gVHdpZy5leHBvcnRzLnJlbmRlckZpbGU7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvdWQgVHdpZy5qcyBjYWNoZSB0ZW1wbGF0ZXMuXG5cdCAgICAgKiBEaXNhYmxlIGR1cmluZyBkZXZlbG9wbWVudCB0byBzZWUgY2hhbmdlcyB0byB0ZW1wbGF0ZXMgd2l0aG91dFxuXHQgICAgICogcmVsb2FkaW5nLCBhbmQgZGlzYWJsZSBpbiBwcm9kdWN0aW9uIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBjYWNoZVxuXHQgICAgICovXG5cdCAgICBUd2lnLmV4cG9ydHMuY2FjaGUgPSBmdW5jdGlvbihjYWNoZSkge1xuXHQgICAgICAgIFR3aWcuY2FjaGUgPSBjYWNoZTtcblx0ICAgIH07XG5cblx0ICAgIC8vV2UgbmVlZCB0byBleHBvcnQgdGhlIHBhdGggbW9kdWxlIHNvIHdlIGNhbiBlZmZlY3RpdmVseSB0ZXN0IGl0XG5cdCAgICBUd2lnLmV4cG9ydHMucGF0aCA9IFR3aWcucGF0aDtcblxuXHQgICAgLy9FeHBvcnQgb3VyIGZpbHRlcnMuXG5cdCAgICAvL1Jlc29sdmVzICMzMDdcblx0ICAgIFR3aWcuZXhwb3J0cy5maWx0ZXJzID0gVHdpZy5maWx0ZXJzO1xuXG5cdCAgICByZXR1cm4gVHdpZztcblx0fTtcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3R3aWcvdHdpZy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	eval("/* (ignored) */\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZnMgKGlnbm9yZWQpPzM0MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBmcyAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcz84MDNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyw4QkFBOEI7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Sidebar2 = __webpack_require__(5);\n\nvar _Sidebar3 = _interopRequireDefault(_Sidebar2);\n\nvar _EE = __webpack_require__(1);\n\nvar _EE2 = _interopRequireDefault(_EE);\n\nvar _flatpickr = __webpack_require__(31);\n\nvar _flatpickr2 = _interopRequireDefault(_flatpickr);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar PageSettings = function (_Sidebar) {\n    _inherits(PageSettings, _Sidebar);\n\n    function PageSettings() {\n        _classCallCheck(this, PageSettings);\n\n        return _possibleConstructorReturn(this, (PageSettings.__proto__ || Object.getPrototypeOf(PageSettings)).apply(this, arguments));\n    }\n\n    _createClass(PageSettings, [{\n        key: 'init',\n        value: function init() {\n            this.pageSettings = this.config.pageSettings;\n            this.content = this.render();\n        }\n    }, {\n        key: 'click',\n        value: function click() {\n            return this.content;\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var form = document.createElement('form');\n            form.classList.add('fred--page_settings_form');\n\n            form.appendChild(this.getGeneralFields());\n            form.appendChild(this.getAdvancedFields());\n\n            var save = document.createElement('button');\n            save.setAttribute('type', 'button');\n            save.classList.add('fred--btn-sidebar', 'fred--settings_form_save');\n            save.innerText = 'Save';\n\n            save.addEventListener('click', function (e) {\n                e.preventDefault();\n                _EE2.default.emit('fred-save');\n            });\n\n            form.appendChild(save);\n\n            return form;\n        }\n    }, {\n        key: 'getGeneralFields',\n        value: function getGeneralFields() {\n            var fieldset = document.createElement('fieldset');\n\n            fieldset.appendChild(this.buildTextInput('pagetitle', 'Page Title'));\n            fieldset.appendChild(this.buildTextInput('longtitle', 'Long Title'));\n            fieldset.appendChild(this.buildTextAreaInput('description', 'Description'));\n            fieldset.appendChild(this.buildTextAreaInput('introtext', 'Intro Text'));\n            fieldset.appendChild(this.buildTextInput('menutitle', 'Menu Title'));\n            fieldset.appendChild(this.buildTextInput('alias', 'Alias'));\n            fieldset.appendChild(this.buildToggleInput('published', 'Published'));\n            fieldset.appendChild(this.buildToggleInput('hidemenu', 'Hide from Menu'));\n\n            return fieldset;\n        }\n    }, {\n        key: 'getAdvancedFields',\n        value: function getAdvancedFields() {\n            var dl = document.createElement('dl');\n\n            var dt = document.createElement('dt');\n            dt.setAttribute('role', 'tab');\n            dt.setAttribute('tabindex', '0');\n            dt.innerHTML = 'Advanced Settings';\n\n            dt.addEventListener('click', function (e) {\n                e.preventDefault();\n                dt.classList.toggle('active');\n            });\n\n            var dd = document.createElement('dd');\n            var fieldset = document.createElement('fieldset');\n            fieldset.classList.add('fred--page_settings_form_advanced');\n\n            fieldset.appendChild(this.buildDateTimeInput('publishedon', 'Published On'));\n            fieldset.appendChild(this.buildDateTimeInput('publishon', 'Publish On'));\n            fieldset.appendChild(this.buildDateTimeInput('unpublishon', 'Unpublish On'));\n            fieldset.appendChild(this.buildTextInput('menuindex', 'Menu Index'));\n            fieldset.appendChild(this.buildToggleInput('deleted', 'Deleted'));\n\n            dd.appendChild(fieldset);\n\n            dl.appendChild(dt);\n            dl.appendChild(dd);\n\n            return dl;\n        }\n    }, {\n        key: 'buildTextInput',\n        value: function buildTextInput(name, label) {\n            var _this2 = this;\n\n            var labelEl = document.createElement('label');\n            labelEl.innerHTML = label;\n\n            var input = document.createElement('input');\n            input.type = 'text';\n            input.value = this.pageSettings[name];\n\n            input.addEventListener('keyup', function (e) {\n                _this2.pageSettings[name] = input.value;\n\n                _EE2.default.emit('fred-page-setting-change', name, input.value, input);\n            });\n\n            _EE2.default.on('fred-page-setting-change', function (settingName, settingValue, sourceEl) {\n                if (input !== sourceEl && name === settingName) {\n                    _this2.pageSettings[settingName] = settingValue;\n                    input.value = settingValue;\n                }\n            });\n\n            labelEl.appendChild(input);\n\n            return labelEl;\n        }\n    }, {\n        key: 'buildTextAreaInput',\n        value: function buildTextAreaInput(name, label) {\n            var _this3 = this;\n\n            var labelEl = document.createElement('label');\n            labelEl.innerHTML = label;\n\n            var textarea = document.createElement('textarea');\n            textarea.innerHTML = this.pageSettings[name];\n\n            textarea.addEventListener('keyup', function (e) {\n                _this3.pageSettings[name] = textarea.value;\n\n                _EE2.default.emit('fred-page-setting-change', name, textarea.value, textarea);\n            });\n\n            _EE2.default.on('fred-page-setting-change', function (settingName, settingValue, sourceEl) {\n                if (textarea !== sourceEl && name === settingName) {\n                    _this3.pageSettings[settingName] = settingValue;\n                    textarea.value = settingValue;\n                }\n            });\n\n            labelEl.appendChild(textarea);\n\n            return labelEl;\n        }\n    }, {\n        key: 'buildToggleInput',\n        value: function buildToggleInput(name, label) {\n            var _this4 = this;\n\n            var labelEl = document.createElement('label');\n            labelEl.classList.add('fred--page_settings_form_checkbox', 'fred--toggle');\n            labelEl.innerHTML = label;\n\n            var input = document.createElement('input');\n            input.setAttribute('type', 'checkbox');\n            if (this.pageSettings[name] === true) {\n                input.setAttribute('checked', 'checked');\n            }\n\n            input.addEventListener('change', function (e) {\n                _this4.pageSettings[name] = e.target.checked;\n            });\n\n            var span = document.createElement('span');\n\n            labelEl.appendChild(input);\n            labelEl.appendChild(span);\n\n            return labelEl;\n        }\n    }, {\n        key: 'buildDateTimeInput',\n        value: function buildDateTimeInput(name, label) {\n            var _this5 = this;\n\n            var labelEl = document.createElement('label');\n            labelEl.innerHTML = label;\n\n            var group = document.createElement('div');\n            group.classList.add('fred--input-group', 'fred--datetime');\n\n            var input = document.createElement('input');\n\n            var picker = (0, _flatpickr2.default)(input, {\n                enableTime: true,\n                dateFormat: \"Y-m-d H:i\",\n                appendTo: group,\n                defaultDate: this.pageSettings[name] === 0 ? '' : this.pageSettings[name] * 1000,\n                onChange: function onChange(selectedDates) {\n                    if (selectedDates.length === 0) {\n                        _this5.pageSettings[name] = 0;\n                    } else {\n                        _this5.pageSettings[name] = selectedDates[0].getTime() / 1000;\n                    }\n                }\n            });\n\n            var clear = document.createElement('a');\n            clear.classList.add('fred--close-small');\n            clear.setAttribute('title', 'Clear');\n            clear.addEventListener('click', function (e) {\n                e.preventDefault();\n                picker.clear();\n            });\n\n            group.appendChild(input);\n            group.appendChild(clear);\n\n            labelEl.appendChild(group);\n\n            return labelEl;\n        }\n    }]);\n\n    return PageSettings;\n}(_Sidebar3.default);\n\nPageSettings.title = 'Page Settings';\nPageSettings.expandable = true;\nexports.default = PageSettings;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0NvbXBvbmVudHMvU2lkZWJhci9QYWdlU2V0dGluZ3MuanM/YTA0NSJdLCJuYW1lcyI6WyJQYWdlU2V0dGluZ3MiLCJwYWdlU2V0dGluZ3MiLCJjb25maWciLCJjb250ZW50IiwicmVuZGVyIiwiZm9ybSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImFwcGVuZENoaWxkIiwiZ2V0R2VuZXJhbEZpZWxkcyIsImdldEFkdmFuY2VkRmllbGRzIiwic2F2ZSIsInNldEF0dHJpYnV0ZSIsImlubmVyVGV4dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicHJldmVudERlZmF1bHQiLCJlbWl0IiwiZmllbGRzZXQiLCJidWlsZFRleHRJbnB1dCIsImJ1aWxkVGV4dEFyZWFJbnB1dCIsImJ1aWxkVG9nZ2xlSW5wdXQiLCJkbCIsImR0IiwiaW5uZXJIVE1MIiwidG9nZ2xlIiwiZGQiLCJidWlsZERhdGVUaW1lSW5wdXQiLCJuYW1lIiwibGFiZWwiLCJsYWJlbEVsIiwiaW5wdXQiLCJ0eXBlIiwidmFsdWUiLCJvbiIsInNldHRpbmdOYW1lIiwic2V0dGluZ1ZhbHVlIiwic291cmNlRWwiLCJ0ZXh0YXJlYSIsInRhcmdldCIsImNoZWNrZWQiLCJzcGFuIiwiZ3JvdXAiLCJwaWNrZXIiLCJlbmFibGVUaW1lIiwiZGF0ZUZvcm1hdCIsImFwcGVuZFRvIiwiZGVmYXVsdERhdGUiLCJvbkNoYW5nZSIsInNlbGVjdGVkRGF0ZXMiLCJsZW5ndGgiLCJnZXRUaW1lIiwiY2xlYXIiLCJ0aXRsZSIsImV4cGFuZGFibGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFcUJBLFk7Ozs7Ozs7Ozs7OytCQUlWO0FBQ0gsaUJBQUtDLFlBQUwsR0FBb0IsS0FBS0MsTUFBTCxDQUFZRCxZQUFoQztBQUNBLGlCQUFLRSxPQUFMLEdBQWUsS0FBS0Ms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QUs3QixZQUFMLENBQWtCNkIsSUFBbEIsSUFBMEIsSUFKbkQ7QUFLNUJvQiwwQkFBVSxpQ0FBaUI7QUFDdkIsd0JBQUlDLGNBQWNDLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0M7QUFDNUIsK0JBQUtuRCxZQUFMLENBQWtCNkIsSUFBbEIsSUFBMEIsQ0FBMUI7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQUs3QixZQUFMLENBQWtCNkIsSUFBbEIsSUFBMEJxQixjQUFjLENBQWQsRUFBaUJFLE9BQWpCLEtBQTZCLElBQXZEO0FBQ0g7QUFDSjtBQVgyQixhQUFqQixDQUFmOztBQWNBLGdCQUFNQyxRQUFRaEQsU0FBU0MsYUFBVCxDQUF1QixHQUF2QixDQUFkO0FBQ0ErQyxrQkFBTTlDLFNBQU4sQ0FBZ0JDLEdBQWhCLENBQW9CLG1CQUFwQjtBQUNBNkMsa0JBQU14QyxZQUFOLENBQW1CLE9BQW5CLEVBQTRCLE9BQTVCO0FBQ0F3QyxrQkFBTXRDLGdCQUFOLENBQXVCLE9BQXZCLEVBQWdDLGFBQUs7QUFDakNDLGtCQUFFQyxjQUFGO0FBQ0EyQix1QkFBT1MsS0FBUDtBQUNILGFBSEQ7O0FBS0FWLGtCQUFNbEMsV0FBTixDQUFrQnVCLEtBQWxCO0FBQ0FXLGtCQUFNbEMsV0FBTixDQUFrQjRDLEtBQWxCOztBQUVBdEIsb0JBQVF0QixXQUFSLENBQW9Ca0MsS0FBcEI7O0FBRUEsbUJBQU9aLE9BQVA7QUFDSDs7Ozs7O0FBaE1nQmhDLFksQ0FDVnVELEssR0FBUSxlO0FBREV2RCxZLENBRVZ3RCxVLEdBQWEsSTtrQkFGSHhELFkiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2lkZWJhciBmcm9tICcuLi9TaWRlYmFyJztcbmltcG9ydCBlbWl0dGVyIGZyb20gJy4uLy4uL0VFJztcbmltcG9ydCBmbGF0cGlja3IgZnJvbSBcImZsYXRwaWNrclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlU2V0dGluZ3MgZXh0ZW5kcyBTaWRlYmFyIHtcbiAgICBzdGF0aWMgdGl0bGUgPSAnUGFnZSBTZXR0aW5ncyc7XG4gICAgc3RhdGljIGV4cGFuZGFibGUgPSB0cnVlO1xuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5wYWdlU2V0dGluZ3MgPSB0aGlzLmNvbmZpZy5wYWdlU2V0dGluZ3M7XG4gICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgY2xpY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgfVxuICAgIFxuICAgIHJlbmRlciAoKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgICAgIGZvcm0uY2xhc3NMaXN0LmFkZCgnZnJlZC0tcGFnZV9zZXR0aW5nc19mb3JtJyk7XG5cbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZCh0aGlzLmdldEdlbmVyYWxGaWVsZHMoKSk7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQodGhpcy5nZXRBZHZhbmNlZEZpZWxkcygpKTtcblxuICAgICAgICBjb25zdCBzYXZlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHNhdmUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgICAgICBzYXZlLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLWJ0bi1zaWRlYmFyJywgJ2ZyZWQtLXNldHRpbmdzX2Zvcm1fc2F2ZScpO1xuICAgICAgICBzYXZlLmlubmVyVGV4dCA9ICdTYXZlJztcblxuICAgICAgICBzYXZlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtc2F2ZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHNhdmUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgfVxuICAgIFxuICAgIGdldEdlbmVyYWxGaWVsZHMoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkc2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmllbGRzZXQnKTtcbiAgICAgICAgXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKHRoaXMuYnVpbGRUZXh0SW5wdXQoJ3BhZ2V0aXRsZScsICdQYWdlIFRpdGxlJykpO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkVGV4dElucHV0KCdsb25ndGl0bGUnLCAnTG9uZyBUaXRsZScpKTtcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQodGhpcy5idWlsZFRleHRBcmVhSW5wdXQoJ2Rlc2NyaXB0aW9uJywgJ0Rlc2NyaXB0aW9uJykpO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkVGV4dEFyZWFJbnB1dCgnaW50cm90ZXh0JywgJ0ludHJvIFRleHQnKSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKHRoaXMuYnVpbGRUZXh0SW5wdXQoJ21lbnV0aXRsZScsICdNZW51IFRpdGxlJykpO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkVGV4dElucHV0KCdhbGlhcycsICdBbGlhcycpKTtcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQodGhpcy5idWlsZFRvZ2dsZUlucHV0KCdwdWJsaXNoZWQnLCAnUHVibGlzaGVkJykpO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkVG9nZ2xlSW5wdXQoJ2hpZGVtZW51JywgJ0hpZGUgZnJvbSBNZW51JykpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZpZWxkc2V0O1xuICAgIH1cblxuICAgIGdldEFkdmFuY2VkRmllbGRzKCkge1xuICAgICAgICBjb25zdCBkbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RsJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2R0Jyk7XG4gICAgICAgIGR0LnNldEF0dHJpYnV0ZSgncm9sZScsICd0YWInKTtcbiAgICAgICAgZHQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgIGR0LmlubmVySFRNTCA9ICdBZHZhbmNlZCBTZXR0aW5ncyc7XG5cbiAgICAgICAgZHQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGR0LmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBkZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RkJyk7XG4gICAgICAgIGNvbnN0IGZpZWxkc2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmllbGRzZXQnKTtcbiAgICAgICAgZmllbGRzZXQuY2xhc3NMaXN0LmFkZCgnZnJlZC0tcGFnZV9zZXR0aW5nc19mb3JtX2FkdmFuY2VkJyk7XG4gICAgICAgIFxuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkRGF0ZVRpbWVJbnB1dCgncHVibGlzaGVkb24nLCAnUHVibGlzaGVkIE9uJykpO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkRGF0ZVRpbWVJbnB1dCgncHVibGlzaG9uJywgJ1B1Ymxpc2ggT24nKSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKHRoaXMuYnVpbGREYXRlVGltZUlucHV0KCd1bnB1Ymxpc2hvbicsICdVbnB1Ymxpc2ggT24nKSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKHRoaXMuYnVpbGRUZXh0SW5wdXQoJ21lbnVpbmRleCcsICdNZW51IEluZGV4JykpO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkVG9nZ2xlSW5wdXQoJ2RlbGV0ZWQnLCAnRGVsZXRlZCcpKTtcblxuICAgICAgICBkZC5hcHBlbmRDaGlsZChmaWVsZHNldCk7XG5cbiAgICAgICAgZGwuYXBwZW5kQ2hpbGQoZHQpO1xuICAgICAgICBkbC5hcHBlbmRDaGlsZChkZCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZGw7XG4gICAgfVxuICAgIFxuICAgIGJ1aWxkVGV4dElucHV0KG5hbWUsIGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBsYWJlbEVsLmlubmVySFRNTCA9IGxhYmVsO1xuXG4gICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLnBhZ2VTZXR0aW5nc1tuYW1lXTtcblxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYWdlU2V0dGluZ3NbbmFtZV0gPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdmcmVkLXBhZ2Utc2V0dGluZy1jaGFuZ2UnLCBuYW1lLCBpbnB1dC52YWx1ZSwgaW5wdXQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbWl0dGVyLm9uKCdmcmVkLXBhZ2Utc2V0dGluZy1jaGFuZ2UnLCAoc2V0dGluZ05hbWUsIHNldHRpbmdWYWx1ZSwgc291cmNlRWwpID0+IHtcbiAgICAgICAgICAgIGlmICgoaW5wdXQgIT09IHNvdXJjZUVsKSAmJiAobmFtZSA9PT0gc2V0dGluZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlU2V0dGluZ3Nbc2V0dGluZ05hbWVdID0gc2V0dGluZ1ZhbHVlO1xuICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gc2V0dGluZ1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsYWJlbEVsLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBsYWJlbEVsO1xuICAgIH1cbiAgICBcbiAgICBidWlsZFRleHRBcmVhSW5wdXQobmFtZSwgbGFiZWwpIHtcbiAgICAgICAgY29uc3QgbGFiZWxFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGxhYmVsRWwuaW5uZXJIVE1MID0gbGFiZWw7XG5cbiAgICAgICAgY29uc3QgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICB0ZXh0YXJlYS5pbm5lckhUTUwgPSB0aGlzLnBhZ2VTZXR0aW5nc1tuYW1lXTtcblxuICAgICAgICB0ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYWdlU2V0dGluZ3NbbmFtZV0gPSB0ZXh0YXJlYS52YWx1ZTtcblxuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdmcmVkLXBhZ2Utc2V0dGluZy1jaGFuZ2UnLCBuYW1lLCB0ZXh0YXJlYS52YWx1ZSwgdGV4dGFyZWEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbWl0dGVyLm9uKCdmcmVkLXBhZ2Utc2V0dGluZy1jaGFuZ2UnLCAoc2V0dGluZ05hbWUsIHNldHRpbmdWYWx1ZSwgc291cmNlRWwpID0+IHtcbiAgICAgICAgICAgIGlmICgodGV4dGFyZWEgIT09IHNvdXJjZUVsKSAmJiAobmFtZSA9PT0gc2V0dGluZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlU2V0dGluZ3Nbc2V0dGluZ05hbWVdID0gc2V0dGluZ1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRleHRhcmVhLnZhbHVlID0gc2V0dGluZ1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsYWJlbEVsLmFwcGVuZENoaWxkKHRleHRhcmVhKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBsYWJlbEVsO1xuICAgIH1cbiAgICBcbiAgICBidWlsZFRvZ2dsZUlucHV0KG5hbWUsIGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBsYWJlbEVsLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLXBhZ2Vfc2V0dGluZ3NfZm9ybV9jaGVja2JveCcsICdmcmVkLS10b2dnbGUnKTtcbiAgICAgICAgbGFiZWxFbC5pbm5lckhUTUwgPSBsYWJlbDtcblxuICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICBpZiAodGhpcy5wYWdlU2V0dGluZ3NbbmFtZV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFnZVNldHRpbmdzW25hbWVdID0gZS50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuICAgICAgICBsYWJlbEVsLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgbGFiZWxFbC5hcHBlbmRDaGlsZChzcGFuKTtcblxuICAgICAgICByZXR1cm4gbGFiZWxFbDtcbiAgICB9XG4gICAgXG4gICAgYnVpbGREYXRlVGltZUlucHV0KG5hbWUsIGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBsYWJlbEVsLmlubmVySFRNTCA9IGxhYmVsO1xuXG4gICAgICAgIGNvbnN0IGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGdyb3VwLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLWlucHV0LWdyb3VwJywgJ2ZyZWQtLWRhdGV0aW1lJyk7XG5cbiAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGlja2VyID0gZmxhdHBpY2tyKGlucHV0LCB7XG4gICAgICAgICAgICBlbmFibGVUaW1lOiB0cnVlLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdDogXCJZLW0tZCBIOmlcIixcbiAgICAgICAgICAgIGFwcGVuZFRvOiBncm91cCxcbiAgICAgICAgICAgIGRlZmF1bHREYXRlOiAodGhpcy5wYWdlU2V0dGluZ3NbbmFtZV0gPT09IDApID8gJycgOiAodGhpcy5wYWdlU2V0dGluZ3NbbmFtZV0gKiAxMDAwKSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBzZWxlY3RlZERhdGVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlU2V0dGluZ3NbbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZVNldHRpbmdzW25hbWVdID0gc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKCkgLyAxMDAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjbGVhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgY2xlYXIuY2xhc3NMaXN0LmFkZCgnZnJlZC0tY2xvc2Utc21hbGwnKTtcbiAgICAgICAgY2xlYXIuc2V0QXR0cmlidXRlKCd0aXRsZScsICdDbGVhcicpO1xuICAgICAgICBjbGVhci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcGlja2VyLmNsZWFyKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQoY2xlYXIpO1xuICAgICAgICBcbiAgICAgICAgbGFiZWxFbC5hcHBlbmRDaGlsZChncm91cCk7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsRWw7XG4gICAgfVxuXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vX2J1aWxkL2Fzc2V0cy9qcy9Db21wb25lbnRzL1NpZGViYXIvUGFnZVNldHRpbmdzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* flatpickr v4.4.3, @license MIT */\n(function (global, factory) {\n     true ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.flatpickr = factory());\n}(this, (function () { 'use strict';\n\n    var pad = function pad(number) {\n      return (\"0\" + number).slice(-2);\n    };\n    var int = function int(bool) {\n      return bool === true ? 1 : 0;\n    };\n    function debounce(func, wait, immediate) {\n      if (immediate === void 0) {\n        immediate = false;\n      }\n\n      var timeout;\n      return function () {\n        var context = this,\n            args = arguments;\n        timeout !== null && clearTimeout(timeout);\n        timeout = window.setTimeout(function () {\n          timeout = null;\n          if (!immediate) func.apply(context, args);\n        }, wait);\n        if (immediate && !timeout) func.apply(context, args);\n      };\n    }\n    var arrayify = function arrayify(obj) {\n      return obj instanceof Array ? obj : [obj];\n    };\n\n    var do_nothing = function do_nothing() {\n      return undefined;\n    };\n\n    var monthToStr = function monthToStr(monthNumber, shorthand, locale) {\n      return locale.months[shorthand ? \"shorthand\" : \"longhand\"][monthNumber];\n    };\n    var revFormat = {\n      D: do_nothing,\n      F: function F(dateObj, monthName, locale) {\n        dateObj.setMonth(locale.months.longhand.indexOf(monthName));\n      },\n      G: function G(dateObj, hour) {\n        dateObj.setHours(parseFloat(hour));\n      },\n      H: function H(dateObj, hour) {\n        dateObj.setHours(parseFloat(hour));\n      },\n      J: function J(dateObj, day) {\n        dateObj.setDate(parseFloat(day));\n      },\n      K: function K(dateObj, amPM, locale) {\n        dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], \"i\").test(amPM)));\n      },\n      M: function M(dateObj, shortMonth, locale) {\n        dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));\n      },\n      S: function S(dateObj, seconds) {\n        dateObj.setSeconds(parseFloat(seconds));\n      },\n      U: function U(_, unixSeconds) {\n        return new Date(parseFloat(unixSeconds) * 1000);\n      },\n      W: function W(dateObj, weekNum) {\n        var weekNumber = parseInt(weekNum);\n        return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);\n      },\n      Y: function Y(dateObj, year) {\n        dateObj.setFullYear(parseFloat(year));\n      },\n      Z: function Z(_, ISODate) {\n        return new Date(ISODate);\n      },\n      d: function d(dateObj, day) {\n        dateObj.setDate(parseFloat(day));\n      },\n      h: function h(dateObj, hour) {\n        dateObj.setHours(parseFloat(hour));\n      },\n      i: function i(dateObj, minutes) {\n        dateObj.setMinutes(parseFloat(minutes));\n      },\n      j: function j(dateObj, day) {\n        dateObj.setDate(parseFloat(day));\n      },\n      l: do_nothing,\n      m: function m(dateObj, month) {\n        dateObj.setMonth(parseFloat(month) - 1);\n      },\n      n: function n(dateObj, month) {\n        dateObj.setMonth(parseFloat(month) - 1);\n      },\n      s: function s(dateObj, seconds) {\n        dateObj.setSeconds(parseFloat(seconds));\n      },\n      w: do_nothing,\n      y: function y(dateObj, year) {\n        dateObj.setFullYear(2000 + parseFloat(year));\n      }\n    };\n    var tokenRegex = {\n      D: \"(\\\\w+)\",\n      F: \"(\\\\w+)\",\n      G: \"(\\\\d\\\\d|\\\\d)\",\n      H: \"(\\\\d\\\\d|\\\\d)\",\n      J: \"(\\\\d\\\\d|\\\\d)\\\\w+\",\n      K: \"\",\n      M: \"(\\\\w+)\",\n      S: \"(\\\\d\\\\d|\\\\d)\",\n      U: \"(.+)\",\n      W: \"(\\\\d\\\\d|\\\\d)\",\n      Y: \"(\\\\d{4})\",\n      Z: \"(.+)\",\n      d: \"(\\\\d\\\\d|\\\\d)\",\n      h: \"(\\\\d\\\\d|\\\\d)\",\n      i: \"(\\\\d\\\\d|\\\\d)\",\n      j: \"(\\\\d\\\\d|\\\\d)\",\n      l: \"(\\\\w+)\",\n      m: \"(\\\\d\\\\d|\\\\d)\",\n      n: \"(\\\\d\\\\d|\\\\d)\",\n      s: \"(\\\\d\\\\d|\\\\d)\",\n      w: \"(\\\\d\\\\d|\\\\d)\",\n      y: \"(\\\\d{2})\"\n    };\n    var formats = {\n      Z: function Z(date) {\n        return date.toISOString();\n      },\n      D: function D(date, locale, options) {\n        return locale.weekdays.shorthand[formats.w(date, locale, options)];\n      },\n      F: function F(date, locale, options) {\n        return monthToStr(formats.n(date, locale, options) - 1, false, locale);\n      },\n      G: function G(date, locale, options) {\n        return pad(formats.h(date, locale, options));\n      },\n      H: function H(date) {\n        return pad(date.getHours());\n      },\n      J: function J(date, locale) {\n        return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();\n      },\n      K: function K(date, locale) {\n        return locale.amPM[int(date.getHours() > 11)];\n      },\n      M: function M(date, locale) {\n        return monthToStr(date.getMonth(), true, locale);\n      },\n      S: function S(date) {\n        return pad(date.getSeconds());\n      },\n      U: function U(date) {\n        return date.getTime() / 1000;\n      },\n      W: function W(date, _, options) {\n        return options.getWeek(date);\n      },\n      Y: function Y(date) {\n        return date.getFullYear();\n      },\n      d: function d(date) {\n        return pad(date.getDate());\n      },\n      h: function h(date) {\n        return date.getHours() % 12 ? date.getHours() % 12 : 12;\n      },\n      i: function i(date) {\n        return pad(date.getMinutes());\n      },\n      j: function j(date) {\n        return date.getDate();\n      },\n      l: function l(date, locale) {\n        return locale.weekdays.longhand[date.getDay()];\n      },\n      m: function m(date) {\n        return pad(date.getMonth() + 1);\n      },\n      n: function n(date) {\n        return date.getMonth() + 1;\n      },\n      s: function s(date) {\n        return date.getSeconds();\n      },\n      w: function w(date) {\n        return date.getDay();\n      },\n      y: function y(date) {\n        return String(date.getFullYear()).substring(2);\n      }\n    };\n\n    var english = {\n      weekdays: {\n        shorthand: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n        longhand: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n      },\n      months: {\n        shorthand: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n        longhand: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\n      },\n      daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n      firstDayOfWeek: 0,\n      ordinal: function ordinal(nth) {\n        var s = nth % 100;\n        if (s > 3 && s < 21) return \"th\";\n\n        switch (s % 10) {\n          case 1:\n            return \"st\";\n\n          case 2:\n            return \"nd\";\n\n          case 3:\n            return \"rd\";\n\n          default:\n            return \"th\";\n        }\n      },\n      rangeSeparator: \" to \",\n      weekAbbreviation: \"Wk\",\n      scrollTitle: \"Scroll to increment\",\n      toggleTitle: \"Click to toggle\",\n      amPM: [\"AM\", \"PM\"],\n      yearAriaLabel: \"Year\"\n    };\n\n    var createDateFormatter = function createDateFormatter(_ref) {\n      var _ref$config = _ref.config,\n          config = _ref$config === void 0 ? defaults : _ref$config,\n          _ref$l10n = _ref.l10n,\n          l10n = _ref$l10n === void 0 ? english : _ref$l10n;\n      return function (dateObj, frmt, overrideLocale) {\n        if (config.formatDate !== undefined) return config.formatDate(dateObj, frmt);\n        var locale = overrideLocale || l10n;\n        return frmt.split(\"\").map(function (c, i, arr) {\n          return formats[c] && arr[i - 1] !== \"\\\\\" ? formats[c](dateObj, locale, config) : c !== \"\\\\\" ? c : \"\";\n        }).join(\"\");\n      };\n    };\n    var createDateParser = function createDateParser(_ref2) {\n      var _ref2$config = _ref2.config,\n          config = _ref2$config === void 0 ? defaults : _ref2$config,\n          _ref2$l10n = _ref2.l10n,\n          l10n = _ref2$l10n === void 0 ? english : _ref2$l10n;\n      return function (date, givenFormat, timeless) {\n        if (date !== 0 && !date) return undefined;\n        var parsedDate;\n        var date_orig = date;\n        if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== \"string\" && date.toFixed !== undefined) parsedDate = new Date(date);else if (typeof date === \"string\") {\n          var format = givenFormat || (config || defaults).dateFormat;\n          var datestr = String(date).trim();\n\n          if (datestr === \"today\") {\n            parsedDate = new Date();\n            timeless = true;\n          } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) parsedDate = new Date(date);else if (config && config.parseDate) parsedDate = config.parseDate(date, format);else {\n            parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));\n            var matched,\n                ops = [];\n\n            for (var i = 0, matchIndex = 0, regexStr = \"\"; i < format.length; i++) {\n              var token = format[i];\n              var isBackSlash = token === \"\\\\\";\n              var escaped = format[i - 1] === \"\\\\\" || isBackSlash;\n\n              if (tokenRegex[token] && !escaped) {\n                regexStr += tokenRegex[token];\n                var match = new RegExp(regexStr).exec(date);\n\n                if (match && (matched = true)) {\n                  ops[token !== \"Y\" ? \"push\" : \"unshift\"]({\n                    fn: revFormat[token],\n                    val: match[++matchIndex]\n                  });\n                }\n              } else if (!isBackSlash) regexStr += \".\";\n\n              ops.forEach(function (_ref3) {\n                var fn = _ref3.fn,\n                    val = _ref3.val;\n                return parsedDate = fn(parsedDate, val, l10n) || parsedDate;\n              });\n            }\n\n            parsedDate = matched ? parsedDate : undefined;\n          }\n        }\n\n        if (!(parsedDate instanceof Date)) {\n          config.errorHandler(new Error(\"Invalid date provided: \" + date_orig));\n          return undefined;\n        }\n\n        if (timeless === true) parsedDate.setHours(0, 0, 0, 0);\n        return parsedDate;\n      };\n    };\n    function compareDates(date1, date2, timeless) {\n      if (timeless === void 0) {\n        timeless = true;\n      }\n\n      if (timeless !== false) {\n        return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);\n      }\n\n      return date1.getTime() - date2.getTime();\n    }\n    var getWeek = function getWeek(givenDate) {\n      var date = new Date(givenDate.getTime());\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);\n      var week1 = new Date(date.getFullYear(), 0, 4);\n      return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);\n    };\n    var isBetween = function isBetween(ts, ts1, ts2) {\n      return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);\n    };\n    var duration = {\n      DAY: 86400000\n    };\n\n    var defaults = {\n      _disable: [],\n      _enable: [],\n      allowInput: false,\n      altFormat: \"F j, Y\",\n      altInput: false,\n      altInputClass: \"form-control input\",\n      animate: typeof window === \"object\" && window.navigator.userAgent.indexOf(\"MSIE\") === -1,\n      ariaDateFormat: \"F j, Y\",\n      clickOpens: true,\n      closeOnSelect: true,\n      conjunction: \", \",\n      dateFormat: \"Y-m-d\",\n      defaultHour: 12,\n      defaultMinute: 0,\n      defaultSeconds: 0,\n      disable: [],\n      disableMobile: false,\n      enable: [],\n      enableSeconds: false,\n      enableTime: false,\n      errorHandler: console.warn,\n      getWeek: getWeek,\n      hourIncrement: 1,\n      ignoredFocusElements: [],\n      inline: false,\n      locale: \"default\",\n      minuteIncrement: 5,\n      mode: \"single\",\n      nextArrow: \"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>\",\n      noCalendar: false,\n      now: new Date(),\n      onChange: [],\n      onClose: [],\n      onDayCreate: [],\n      onDestroy: [],\n      onKeyDown: [],\n      onMonthChange: [],\n      onOpen: [],\n      onParseConfig: [],\n      onReady: [],\n      onValueUpdate: [],\n      onYearChange: [],\n      onPreCalendarPosition: [],\n      plugins: [],\n      position: \"auto\",\n      positionElement: undefined,\n      prevArrow: \"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>\",\n      shorthandCurrentMonth: false,\n      showMonths: 1,\n      static: false,\n      time_24hr: false,\n      weekNumbers: false,\n      wrap: false\n    };\n\n    function toggleClass(elem, className, bool) {\n      if (bool === true) return elem.classList.add(className);\n      elem.classList.remove(className);\n    }\n    function createElement(tag, className, content) {\n      var e = window.document.createElement(tag);\n      className = className || \"\";\n      content = content || \"\";\n      e.className = className;\n      if (content !== undefined) e.textContent = content;\n      return e;\n    }\n    function clearNode(node) {\n      while (node.firstChild) {\n        node.removeChild(node.firstChild);\n      }\n    }\n    function findParent(node, condition) {\n      if (condition(node)) return node;else if (node.parentNode) return findParent(node.parentNode, condition);\n      return undefined;\n    }\n    function createNumberInput(inputClassName, opts) {\n      var wrapper = createElement(\"div\", \"numInputWrapper\"),\n          numInput = createElement(\"input\", \"numInput \" + inputClassName),\n          arrowUp = createElement(\"span\", \"arrowUp\"),\n          arrowDown = createElement(\"span\", \"arrowDown\");\n      numInput.type = \"text\";\n      numInput.pattern = \"\\\\d*\";\n      if (opts !== undefined) for (var key in opts) {\n        numInput.setAttribute(key, opts[key]);\n      }\n      wrapper.appendChild(numInput);\n      wrapper.appendChild(arrowUp);\n      wrapper.appendChild(arrowDown);\n      return wrapper;\n    }\n\n    if (typeof Object.assign !== \"function\") {\n      Object.assign = function (target) {\n        if (!target) {\n          throw TypeError(\"Cannot convert undefined or null to object\");\n        }\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        var _loop = function _loop(source) {\n          if (source) {\n            Object.keys(source).forEach(function (key) {\n              return target[key] = source[key];\n            });\n          }\n        };\n\n        for (var _i = 0; _i < args.length; _i++) {\n          var source = args[_i];\n\n          _loop(source);\n        }\n\n        return target;\n      };\n    }\n\n    var DEBOUNCED_CHANGE_MS = 300;\n\n    function FlatpickrInstance(element, instanceConfig) {\n      var self = {\n        config: Object.assign({}, flatpickr.defaultConfig),\n        l10n: english\n      };\n      self.parseDate = createDateParser({\n        config: self.config,\n        l10n: self.l10n\n      });\n      self._handlers = [];\n      self._bind = bind;\n      self._setHoursFromDate = setHoursFromDate;\n      self.changeMonth = changeMonth;\n      self.changeYear = changeYear;\n      self.clear = clear;\n      self.close = close;\n      self._createElement = createElement;\n      self.destroy = destroy;\n      self.isEnabled = isEnabled;\n      self.jumpToDate = jumpToDate;\n      self.open = open;\n      self.redraw = redraw;\n      self.set = set;\n      self.setDate = setDate;\n      self.toggle = toggle;\n\n      function setupHelperFunctions() {\n        self.utils = {\n          getDaysInMonth: function getDaysInMonth(month, yr) {\n            if (month === void 0) {\n              month = self.currentMonth;\n            }\n\n            if (yr === void 0) {\n              yr = self.currentYear;\n            }\n\n            if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;\n            return self.l10n.daysInMonth[month];\n          }\n        };\n      }\n\n      function init() {\n        self.element = self.input = element;\n        self.isOpen = false;\n        parseConfig();\n        setupLocale();\n        setupInputs();\n        setupDates();\n        setupHelperFunctions();\n        if (!self.isMobile) build();\n        bindEvents();\n\n        if (self.selectedDates.length || self.config.noCalendar) {\n          if (self.config.enableTime) {\n            setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : undefined);\n          }\n\n          updateValue(false);\n        }\n\n        self.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;\n\n        if (self.daysContainer !== undefined) {\n          self.calendarContainer.style.visibility = \"hidden\";\n          self.calendarContainer.style.display = \"block\";\n          var daysWidth = (self.daysContainer.offsetWidth + 1) * self.config.showMonths;\n          self.daysContainer.style.width = daysWidth + \"px\";\n          self.calendarContainer.style.width = daysWidth + \"px\";\n\n          if (self.weekWrapper !== undefined) {\n            self.calendarContainer.style.width = daysWidth + self.weekWrapper.offsetWidth + \"px\";\n          }\n\n          self.calendarContainer.style.visibility = \"visible\";\n          self.calendarContainer.style.display = null;\n        }\n\n        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n        if (!self.isMobile && isSafari) {\n          positionCalendar();\n        }\n\n        triggerEvent(\"onReady\");\n      }\n\n      function bindToInstance(fn) {\n        return fn.bind(self);\n      }\n\n      function updateTime(e) {\n        if (self.selectedDates.length === 0) return;\n        timeWrapper(e);\n\n        if (e.type !== \"input\") {\n          setHoursFromInputs();\n          updateValue();\n        } else {\n          setTimeout(function () {\n            setHoursFromInputs();\n            updateValue();\n          }, DEBOUNCED_CHANGE_MS);\n        }\n      }\n\n      function ampm2military(hour, amPM) {\n        return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);\n      }\n\n      function military2ampm(hour) {\n        switch (hour % 24) {\n          case 0:\n          case 12:\n            return 12;\n\n          default:\n            return hour % 12;\n        }\n      }\n\n      function setHoursFromInputs() {\n        if (self.hourElement === undefined || self.minuteElement === undefined) return;\n        var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,\n            minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,\n            seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;\n        if (self.amPM !== undefined) hours = ampm2military(hours, self.amPM.textContent);\n        var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;\n        var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;\n\n        if (limitMaxHours) {\n          var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;\n          hours = Math.min(hours, maxTime.getHours());\n          if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());\n          if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());\n        }\n\n        if (limitMinHours) {\n          var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;\n          hours = Math.max(hours, minTime.getHours());\n          if (hours === minTime.getHours()) minutes = Math.max(minutes, minTime.getMinutes());\n          if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());\n        }\n\n        setHours(hours, minutes, seconds);\n      }\n\n      function setHoursFromDate(dateObj) {\n        var date = dateObj || self.latestSelectedDateObj;\n        if (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());\n      }\n\n      function setHours(hours, minutes, seconds) {\n        if (self.latestSelectedDateObj !== undefined) {\n          self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);\n        }\n\n        if (!self.hourElement || !self.minuteElement || self.isMobile) return;\n        self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);\n        self.minuteElement.value = pad(minutes);\n        if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];\n        if (self.secondElement !== undefined) self.secondElement.value = pad(seconds);\n      }\n\n      function onYearInput(event) {\n        var year = parseInt(event.target.value) + (event.delta || 0);\n\n        if (year.toString().length === 4 || event.key === \"Enter\") {\n          event.target.blur();\n          if (!/[^\\d]/.test(year.toString())) changeYear(year);\n        }\n      }\n\n      function bind(element, event, handler, options) {\n        if (event instanceof Array) return event.forEach(function (ev) {\n          return bind(element, ev, handler, options);\n        });\n        if (element instanceof Array) return element.forEach(function (el) {\n          return bind(el, event, handler, options);\n        });\n        element.addEventListener(event, handler, options);\n\n        self._handlers.push({\n          element: element,\n          event: event,\n          handler: handler\n        });\n      }\n\n      function onClick(handler) {\n        return function (evt) {\n          evt.which === 1 && handler(evt);\n        };\n      }\n\n      function triggerChange() {\n        triggerEvent(\"onChange\");\n      }\n\n      function bindEvents() {\n        if (self.config.wrap) {\n          [\"open\", \"close\", \"toggle\", \"clear\"].forEach(function (evt) {\n            Array.prototype.forEach.call(self.element.querySelectorAll(\"[data-\" + evt + \"]\"), function (el) {\n              return bind(el, \"click\", self[evt]);\n            });\n          });\n        }\n\n        if (self.isMobile) {\n          setupMobile();\n          return;\n        }\n\n        var debouncedResize = debounce(onResize, 50);\n        self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);\n        if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, \"mouseover\", function (e) {\n          if (self.config.mode === \"range\") onMouseOver(e.target);\n        });\n        bind(window.document.body, \"keydown\", onKeyDown);\n        if (!self.config.static) bind(self._input, \"keydown\", onKeyDown);\n        if (!self.config.inline && !self.config.static) bind(window, \"resize\", debouncedResize);\n        if (window.ontouchstart !== undefined) bind(window.document, \"touchstart\", documentClick);\n        bind(window.document, \"mousedown\", onClick(documentClick));\n        bind(window.document, \"focus\", documentClick, {\n          capture: true\n        });\n\n        if (self.config.clickOpens === true) {\n          bind(self._input, \"focus\", self.open);\n          bind(self._input, \"mousedown\", onClick(self.open));\n        }\n\n        if (self.daysContainer !== undefined) {\n          bind(self.monthNav, \"mousedown\", onClick(onMonthNavClick));\n          bind(self.monthNav, [\"keyup\", \"increment\"], onYearInput);\n          bind(self.daysContainer, \"mousedown\", onClick(selectDate));\n        }\n\n        if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {\n          var selText = function selText(e) {\n            return e.target.select();\n          };\n\n          bind(self.timeContainer, [\"input\", \"increment\"], updateTime);\n          bind(self.timeContainer, \"mousedown\", onClick(timeIncrement));\n          bind(self.timeContainer, [\"input\", \"increment\"], self._debouncedChange, {\n            passive: true\n          });\n          bind([self.hourElement, self.minuteElement], [\"focus\", \"click\"], selText);\n          if (self.secondElement !== undefined) bind(self.secondElement, \"focus\", function () {\n            return self.secondElement && self.secondElement.select();\n          });\n\n          if (self.amPM !== undefined) {\n            bind(self.amPM, \"mousedown\", onClick(function (e) {\n              updateTime(e);\n              triggerChange();\n            }));\n          }\n        }\n      }\n\n      function jumpToDate(jumpDate) {\n        var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);\n\n        try {\n          if (jumpTo !== undefined) {\n            self.currentYear = jumpTo.getFullYear();\n            self.currentMonth = jumpTo.getMonth();\n          }\n        } catch (e) {\n          e.message = \"Invalid date supplied: \" + jumpTo;\n          self.config.errorHandler(e);\n        }\n\n        self.redraw();\n      }\n\n      function timeIncrement(e) {\n        if (~e.target.className.indexOf(\"arrow\")) incrementNumInput(e, e.target.classList.contains(\"arrowUp\") ? 1 : -1);\n      }\n\n      function incrementNumInput(e, delta, inputElem) {\n        var target = e && e.target;\n        var input = inputElem || target && target.parentNode && target.parentNode.firstChild;\n        var event = createEvent(\"increment\");\n        event.delta = delta;\n        input && input.dispatchEvent(event);\n      }\n\n      function build() {\n        var fragment = window.document.createDocumentFragment();\n        self.calendarContainer = createElement(\"div\", \"flatpickr-calendar\");\n        self.calendarContainer.tabIndex = -1;\n\n        if (!self.config.noCalendar) {\n          fragment.appendChild(buildMonthNav());\n          self.innerContainer = createElement(\"div\", \"flatpickr-innerContainer\");\n\n          if (self.config.weekNumbers) {\n            var _buildWeeks = buildWeeks(),\n                weekWrapper = _buildWeeks.weekWrapper,\n                weekNumbers = _buildWeeks.weekNumbers;\n\n            self.innerContainer.appendChild(weekWrapper);\n            self.weekNumbers = weekNumbers;\n            self.weekWrapper = weekWrapper;\n          }\n\n          self.rContainer = createElement(\"div\", \"flatpickr-rContainer\");\n          self.rContainer.appendChild(buildWeekdays());\n\n          if (!self.daysContainer) {\n            self.daysContainer = createElement(\"div\", \"flatpickr-days\");\n            self.daysContainer.tabIndex = -1;\n          }\n\n          buildDays();\n          self.rContainer.appendChild(self.daysContainer);\n          self.innerContainer.appendChild(self.rContainer);\n          fragment.appendChild(self.innerContainer);\n        }\n\n        if (self.config.enableTime) {\n          fragment.appendChild(buildTime());\n        }\n\n        toggleClass(self.calendarContainer, \"rangeMode\", self.config.mode === \"range\");\n        toggleClass(self.calendarContainer, \"animate\", self.config.animate === true);\n        toggleClass(self.calendarContainer, \"multiMonth\", self.config.showMonths > 1);\n        self.calendarContainer.appendChild(fragment);\n        var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;\n\n        if (self.config.inline || self.config.static) {\n          self.calendarContainer.classList.add(self.config.inline ? \"inline\" : \"static\");\n\n          if (self.config.inline) {\n            if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);\n          }\n\n          if (self.config.static) {\n            var wrapper = createElement(\"div\", \"flatpickr-wrapper\");\n            if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);\n            wrapper.appendChild(self.element);\n            if (self.altInput) wrapper.appendChild(self.altInput);\n            wrapper.appendChild(self.calendarContainer);\n          }\n        }\n\n        if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);\n      }\n\n      function createDay(className, date, dayNumber, i) {\n        var dateIsEnabled = isEnabled(date, true),\n            dayElement = createElement(\"span\", \"flatpickr-day \" + className, date.getDate().toString());\n        dayElement.dateObj = date;\n        dayElement.$i = i;\n        dayElement.setAttribute(\"aria-label\", self.formatDate(date, self.config.ariaDateFormat));\n\n        if (compareDates(date, self.now) === 0) {\n          self.todayDateElem = dayElement;\n          dayElement.classList.add(\"today\");\n        }\n\n        if (dateIsEnabled) {\n          dayElement.tabIndex = -1;\n\n          if (isDateSelected(date)) {\n            dayElement.classList.add(\"selected\");\n            self.selectedDateElem = dayElement;\n\n            if (self.config.mode === \"range\") {\n              toggleClass(dayElement, \"startRange\", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);\n              toggleClass(dayElement, \"endRange\", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);\n              if (className === \"nextMonthDay\") dayElement.classList.add(\"inRange\");\n            }\n          }\n        } else {\n          dayElement.classList.add(\"disabled\");\n        }\n\n        if (self.config.mode === \"range\") {\n          if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add(\"inRange\");\n        }\n\n        if (self.weekNumbers && self.config.showMonths === 1 && className !== \"prevMonthDay\" && dayNumber % 7 === 1) {\n          self.weekNumbers.insertAdjacentHTML(\"beforeend\", \"<span class='flatpickr-day'>\" + self.config.getWeek(date) + \"</span>\");\n        }\n\n        triggerEvent(\"onDayCreate\", dayElement);\n        return dayElement;\n      }\n\n      function focusOnDay(currentInd, offset) {\n        var currentIndex = currentInd !== undefined ? currentInd : document.activeElement.$i;\n        var newIndex = (currentIndex || 0) + offset || 0,\n            targetNode = Array.prototype.find.call(self.days.children, function (c, i) {\n          return i >= newIndex && c.className.indexOf(\"MonthDay\") === -1 && isEnabled(c.dateObj);\n        });\n\n        if (targetNode !== undefined) {\n          targetNode.focus();\n          if (self.config.mode === \"range\") onMouseOver(targetNode);\n        }\n      }\n\n      function buildMonthDays(year, month) {\n        var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;\n        var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);\n        var daysInMonth = self.utils.getDaysInMonth(month),\n            days = window.document.createDocumentFragment();\n        var dayNumber = prevMonthDays + 1 - firstOfMonth,\n            dayIndex = 0;\n\n        for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {\n          days.appendChild(createDay(\"prevMonthDay\", new Date(year, month - 1, dayNumber), dayNumber, dayIndex));\n        }\n\n        for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {\n          days.appendChild(createDay(\"\", new Date(year, month, dayNumber), dayNumber, dayIndex));\n        }\n\n        for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {\n          days.appendChild(createDay(\"nextMonthDay\", new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));\n        }\n\n        var dayContainer = createElement(\"div\", \"dayContainer\");\n        dayContainer.appendChild(days);\n        return dayContainer;\n      }\n\n      function buildDays() {\n        if (self.daysContainer === undefined) {\n          return;\n        }\n\n        clearNode(self.daysContainer);\n        if (self.weekNumbers) clearNode(self.weekNumbers);\n        var frag = document.createDocumentFragment();\n\n        for (var i = 0; i < self.config.showMonths; i++) {\n          var d = new Date(self.currentYear, self.currentMonth, 1);\n          d.setMonth(self.currentMonth + i);\n          frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));\n        }\n\n        self.daysContainer.appendChild(frag);\n        self.days = self.daysContainer.firstChild;\n      }\n\n      function buildMonth() {\n        var container = createElement(\"div\", \"flatpickr-month\");\n        var monthNavFragment = window.document.createDocumentFragment();\n        var monthElement = createElement(\"span\", \"cur-month\");\n        monthElement.title = self.l10n.scrollTitle;\n        var yearInput = createNumberInput(\"cur-year\", {\n          tabindex: \"-1\"\n        });\n        var yearElement = yearInput.childNodes[0];\n        yearElement.title = self.l10n.scrollTitle;\n        yearElement.setAttribute(\"aria-label\", self.l10n.yearAriaLabel);\n        if (self.config.minDate) yearElement.setAttribute(\"data-min\", self.config.minDate.getFullYear().toString());\n\n        if (self.config.maxDate) {\n          yearElement.setAttribute(\"data-max\", self.config.maxDate.getFullYear().toString());\n          yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();\n        }\n\n        var currentMonth = createElement(\"div\", \"flatpickr-current-month\");\n        currentMonth.appendChild(monthElement);\n        currentMonth.appendChild(yearInput);\n        monthNavFragment.appendChild(currentMonth);\n        container.appendChild(monthNavFragment);\n        return {\n          container: container,\n          yearElement: yearElement,\n          monthElement: monthElement\n        };\n      }\n\n      function buildMonthNav() {\n        self.monthNav = createElement(\"div\", \"flatpickr-months\");\n        self.yearElements = [];\n        self.monthElements = [];\n        self.prevMonthNav = createElement(\"span\", \"flatpickr-prev-month\");\n        self.prevMonthNav.innerHTML = self.config.prevArrow;\n        self.nextMonthNav = createElement(\"span\", \"flatpickr-next-month\");\n        self.nextMonthNav.innerHTML = self.config.nextArrow;\n        self.monthNav.appendChild(self.prevMonthNav);\n\n        for (var m = self.config.showMonths; m--;) {\n          var month = buildMonth();\n          self.yearElements.push(month.yearElement);\n          self.monthElements.push(month.monthElement);\n          self.monthNav.appendChild(month.container);\n        }\n\n        self.monthNav.appendChild(self.nextMonthNav);\n        Object.defineProperty(self, \"_hidePrevMonthArrow\", {\n          get: function get() {\n            return self.__hidePrevMonthArrow;\n          },\n          set: function set(bool) {\n            if (self.__hidePrevMonthArrow !== bool) {\n              toggleClass(self.prevMonthNav, \"disabled\", bool);\n              self.__hidePrevMonthArrow = bool;\n            }\n          }\n        });\n        Object.defineProperty(self, \"_hideNextMonthArrow\", {\n          get: function get() {\n            return self.__hideNextMonthArrow;\n          },\n          set: function set(bool) {\n            if (self.__hideNextMonthArrow !== bool) {\n              toggleClass(self.nextMonthNav, \"disabled\", bool);\n              self.__hideNextMonthArrow = bool;\n            }\n          }\n        });\n        self.currentYearElement = self.yearElements[0];\n        updateNavigationCurrentMonth();\n        return self.monthNav;\n      }\n\n      function buildTime() {\n        self.calendarContainer.classList.add(\"hasTime\");\n        if (self.config.noCalendar) self.calendarContainer.classList.add(\"noCalendar\");\n        self.timeContainer = createElement(\"div\", \"flatpickr-time\");\n        self.timeContainer.tabIndex = -1;\n        var separator = createElement(\"span\", \"flatpickr-time-separator\", \":\");\n        var hourInput = createNumberInput(\"flatpickr-hour\");\n        self.hourElement = hourInput.childNodes[0];\n        var minuteInput = createNumberInput(\"flatpickr-minute\");\n        self.minuteElement = minuteInput.childNodes[0];\n        self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;\n        self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? self.config.defaultHour : military2ampm(self.config.defaultHour));\n        self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);\n        self.hourElement.setAttribute(\"data-step\", self.config.hourIncrement.toString());\n        self.minuteElement.setAttribute(\"data-step\", self.config.minuteIncrement.toString());\n        self.hourElement.setAttribute(\"data-min\", self.config.time_24hr ? \"0\" : \"1\");\n        self.hourElement.setAttribute(\"data-max\", self.config.time_24hr ? \"23\" : \"12\");\n        self.minuteElement.setAttribute(\"data-min\", \"0\");\n        self.minuteElement.setAttribute(\"data-max\", \"59\");\n        self.timeContainer.appendChild(hourInput);\n        self.timeContainer.appendChild(separator);\n        self.timeContainer.appendChild(minuteInput);\n        if (self.config.time_24hr) self.timeContainer.classList.add(\"time24hr\");\n\n        if (self.config.enableSeconds) {\n          self.timeContainer.classList.add(\"hasSeconds\");\n          var secondInput = createNumberInput(\"flatpickr-second\");\n          self.secondElement = secondInput.childNodes[0];\n          self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : self.config.defaultSeconds);\n          self.secondElement.setAttribute(\"data-step\", self.minuteElement.getAttribute(\"data-step\"));\n          self.secondElement.setAttribute(\"data-min\", self.minuteElement.getAttribute(\"data-min\"));\n          self.secondElement.setAttribute(\"data-max\", self.minuteElement.getAttribute(\"data-max\"));\n          self.timeContainer.appendChild(createElement(\"span\", \"flatpickr-time-separator\", \":\"));\n          self.timeContainer.appendChild(secondInput);\n        }\n\n        if (!self.config.time_24hr) {\n          self.amPM = createElement(\"span\", \"flatpickr-am-pm\", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);\n          self.amPM.title = self.l10n.toggleTitle;\n          self.amPM.tabIndex = -1;\n          self.timeContainer.appendChild(self.amPM);\n        }\n\n        return self.timeContainer;\n      }\n\n      function buildWeekdays() {\n        if (!self.weekdayContainer) self.weekdayContainer = createElement(\"div\", \"flatpickr-weekdays\");\n\n        for (var i = self.config.showMonths; i--;) {\n          var container = createElement(\"div\", \"flatpickr-weekdaycontainer\");\n          self.weekdayContainer.appendChild(container);\n        }\n\n        updateWeekdays();\n        return self.weekdayContainer;\n      }\n\n      function updateWeekdays() {\n        var firstDayOfWeek = self.l10n.firstDayOfWeek;\n        var weekdays = self.l10n.weekdays.shorthand.concat();\n\n        if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {\n          weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));\n        }\n\n        for (var i = self.config.showMonths; i--;) {\n          self.weekdayContainer.children[i].innerHTML = \"\\n      <span class=flatpickr-weekday>\\n        \" + weekdays.join(\"</span><span class=flatpickr-weekday>\") + \"\\n      </span>\\n      \";\n        }\n      }\n\n      function buildWeeks() {\n        self.calendarContainer.classList.add(\"hasWeeks\");\n        var weekWrapper = createElement(\"div\", \"flatpickr-weekwrapper\");\n        weekWrapper.appendChild(createElement(\"span\", \"flatpickr-weekday\", self.l10n.weekAbbreviation));\n        var weekNumbers = createElement(\"div\", \"flatpickr-weeks\");\n        weekWrapper.appendChild(weekNumbers);\n        return {\n          weekWrapper: weekWrapper,\n          weekNumbers: weekNumbers\n        };\n      }\n\n      function changeMonth(value, is_offset, from_keyboard) {\n        if (is_offset === void 0) {\n          is_offset = true;\n        }\n\n        if (from_keyboard === void 0) {\n          from_keyboard = false;\n        }\n\n        var delta = is_offset ? value : value - self.currentMonth;\n        if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;\n        self.currentMonth += delta;\n\n        if (self.currentMonth < 0 || self.currentMonth > 11) {\n          self.currentYear += self.currentMonth > 11 ? 1 : -1;\n          self.currentMonth = (self.currentMonth + 12) % 12;\n          triggerEvent(\"onYearChange\");\n        }\n\n        buildDays();\n        triggerEvent(\"onMonthChange\");\n        updateNavigationCurrentMonth();\n\n        if (from_keyboard === true) {\n          focusOnDay(undefined, 0);\n        }\n      }\n\n      function clear(triggerChangeEvent) {\n        if (triggerChangeEvent === void 0) {\n          triggerChangeEvent = true;\n        }\n\n        self.input.value = \"\";\n        if (self.altInput !== undefined) self.altInput.value = \"\";\n        if (self.mobileInput !== undefined) self.mobileInput.value = \"\";\n        self.selectedDates = [];\n        self.latestSelectedDateObj = undefined;\n        self.showTimeInput = false;\n\n        if (self.config.enableTime === true) {\n          if (self.config.minDate !== undefined) setHoursFromDate(self.config.minDate);else setHours(self.config.defaultHour, self.config.defaultMinute, self.config.defaultSeconds);\n        }\n\n        self.redraw();\n        if (triggerChangeEvent) triggerEvent(\"onChange\");\n      }\n\n      function close() {\n        self.isOpen = false;\n\n        if (!self.isMobile) {\n          self.calendarContainer.classList.remove(\"open\");\n\n          self._input.classList.remove(\"active\");\n        }\n\n        triggerEvent(\"onClose\");\n      }\n\n      function destroy() {\n        if (self.config !== undefined) triggerEvent(\"onDestroy\");\n\n        for (var i = self._handlers.length; i--;) {\n          var h = self._handlers[i];\n          h.element.removeEventListener(h.event, h.handler);\n        }\n\n        self._handlers = [];\n\n        if (self.mobileInput) {\n          if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);\n          self.mobileInput = undefined;\n        } else if (self.calendarContainer && self.calendarContainer.parentNode) self.calendarContainer.parentNode.removeChild(self.calendarContainer);\n\n        if (self.altInput) {\n          self.input.type = \"text\";\n          if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);\n          delete self.altInput;\n        }\n\n        if (self.input) {\n          self.input.type = self.input._type;\n          self.input.classList.remove(\"flatpickr-input\");\n          self.input.removeAttribute(\"readonly\");\n          self.input.value = \"\";\n        }\n\n        [\"_showTimeInput\", \"latestSelectedDateObj\", \"_hideNextMonthArrow\", \"_hidePrevMonthArrow\", \"__hideNextMonthArrow\", \"__hidePrevMonthArrow\", \"isMobile\", \"isOpen\", \"selectedDateElem\", \"minDateHasTime\", \"maxDateHasTime\", \"days\", \"daysContainer\", \"_input\", \"_positionElement\", \"innerContainer\", \"rContainer\", \"monthNav\", \"todayDateElem\", \"calendarContainer\", \"weekdayContainer\", \"prevMonthNav\", \"nextMonthNav\", \"currentMonthElement\", \"currentYearElement\", \"navigationCurrentMonth\", \"selectedDateElem\", \"config\"].forEach(function (k) {\n          try {\n            delete self[k];\n          } catch (_) {}\n        });\n      }\n\n      function isCalendarElem(elem) {\n        if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;\n        return self.calendarContainer.contains(elem);\n      }\n\n      function documentClick(e) {\n        if (self.isOpen && !self.config.inline) {\n          var isCalendarElement = isCalendarElem(e.target);\n          var isInput = e.target === self.input || e.target === self.altInput || self.element.contains(e.target) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));\n          var lostFocus = e.type === \"blur\" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement;\n          var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {\n            return elem.contains(e.target);\n          });\n\n          if (lostFocus && isIgnored) {\n            self.close();\n\n            if (self.config.mode === \"range\" && self.selectedDates.length === 1) {\n              self.clear(false);\n              self.redraw();\n            }\n          }\n        }\n      }\n\n      function changeYear(newYear) {\n        if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;\n        var newYearNum = newYear,\n            isNewYear = self.currentYear !== newYearNum;\n        self.currentYear = newYearNum || self.currentYear;\n\n        if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {\n          self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);\n        } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {\n          self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);\n        }\n\n        if (isNewYear) {\n          self.redraw();\n          triggerEvent(\"onYearChange\");\n        }\n      }\n\n      function isEnabled(date, timeless) {\n        if (timeless === void 0) {\n          timeless = true;\n        }\n\n        var dateToCheck = self.parseDate(date, undefined, timeless);\n        if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;\n        if (self.config.enable.length === 0 && self.config.disable.length === 0) return true;\n        if (dateToCheck === undefined) return false;\n        var bool = self.config.enable.length > 0,\n            array = bool ? self.config.enable : self.config.disable;\n\n        for (var i = 0, d; i < array.length; i++) {\n          d = array[i];\n          if (typeof d === \"function\" && d(dateToCheck)) return bool;else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) return bool;else if (typeof d === \"string\" && dateToCheck !== undefined) {\n            var parsed = self.parseDate(d, undefined, true);\n            return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;\n          } else if (typeof d === \"object\" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;\n        }\n\n        return !bool;\n      }\n\n      function onKeyDown(e) {\n        var isInput = e.target === self._input;\n        var calendarElem = isCalendarElem(e.target);\n        var allowInput = self.config.allowInput;\n        var allowKeydown = self.isOpen && (!allowInput || !isInput);\n        var allowInlineKeydown = self.config.inline && isInput && !allowInput;\n\n        if (e.keyCode === 13 && isInput) {\n          if (allowInput) {\n            self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);\n            return e.target.blur();\n          } else self.open();\n        } else if (calendarElem || allowKeydown || allowInlineKeydown) {\n          var isTimeObj = !!self.timeContainer && self.timeContainer.contains(e.target);\n\n          switch (e.keyCode) {\n            case 13:\n              if (isTimeObj) updateValue();else selectDate(e);\n              break;\n\n            case 27:\n              e.preventDefault();\n              focusAndClose();\n              break;\n\n            case 8:\n            case 46:\n              if (isInput && !self.config.allowInput) {\n                e.preventDefault();\n                self.clear();\n              }\n\n              break;\n\n            case 37:\n            case 39:\n              if (!isTimeObj) {\n                e.preventDefault();\n\n                if (self.daysContainer) {\n                  var _delta = isInput ? 0 : e.keyCode === 39 ? 1 : -1;\n\n                  if (!e.ctrlKey) focusOnDay(undefined, _delta);else changeMonth(_delta, true, true);\n                }\n              } else if (self.hourElement) self.hourElement.focus();\n\n              break;\n\n            case 38:\n            case 40:\n              e.preventDefault();\n              var delta = e.keyCode === 40 ? 1 : -1;\n\n              if (self.daysContainer && e.target.$i !== undefined) {\n                if (e.ctrlKey) {\n                  changeYear(self.currentYear - delta);\n                  focusOnDay(e.target.$i, 0);\n                } else if (!isTimeObj) focusOnDay(e.target.$i, delta * 7);\n              } else if (self.config.enableTime) {\n                if (!isTimeObj && self.hourElement) self.hourElement.focus();\n                updateTime(e);\n\n                self._debouncedChange();\n              }\n\n              break;\n\n            case 9:\n              if (e.target === self.hourElement) {\n                e.preventDefault();\n                self.minuteElement.select();\n              } else if (e.target === self.minuteElement && (self.secondElement || self.amPM)) {\n                e.preventDefault();\n                if (self.secondElement !== undefined) self.secondElement.focus();else if (self.amPM !== undefined) self.amPM.focus();\n              } else if (e.target === self.secondElement && self.amPM) {\n                e.preventDefault();\n                self.amPM.focus();\n              }\n\n              break;\n\n            default:\n              break;\n          }\n\n          switch (e.key) {\n            case self.l10n.amPM[0].charAt(0):\n            case self.l10n.amPM[0].charAt(0).toLowerCase():\n              if (self.amPM !== undefined && e.target === self.amPM) {\n                self.amPM.textContent = self.l10n.amPM[0];\n                setHoursFromInputs();\n                updateValue();\n              }\n\n              break;\n\n            case self.l10n.amPM[1].charAt(0):\n            case self.l10n.amPM[1].charAt(0).toLowerCase():\n              if (self.amPM !== undefined && e.target === self.amPM) {\n                self.amPM.textContent = self.l10n.amPM[1];\n                setHoursFromInputs();\n                updateValue();\n              }\n\n              break;\n\n            default:\n              break;\n          }\n\n          triggerEvent(\"onKeyDown\", e);\n        }\n      }\n\n      function onMouseOver(elem) {\n        if (self.selectedDates.length !== 1 || !elem.classList.contains(\"flatpickr-day\") || elem.classList.contains(\"disabled\")) return;\n        var hoverDate = elem.dateObj.getTime(),\n            initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(),\n            rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()),\n            rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());\n        var months = self.daysContainer.children,\n            firstDay = months[0].children[0].dateObj.getTime(),\n            lastDay = months[months.length - 1].lastChild.dateObj.getTime();\n        var containsDisabled = false;\n        var minRange = 0,\n            maxRange = 0;\n\n        for (var t = firstDay; t < lastDay; t += duration.DAY) {\n          if (!isEnabled(new Date(t), true)) {\n            containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;\n            if (t < initialDate && (!minRange || t > minRange)) minRange = t;else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;\n          }\n        }\n\n        for (var m = 0; m < self.config.showMonths; m++) {\n          var month = self.daysContainer.children[m];\n          var prevMonth = self.daysContainer.children[m - 1];\n\n          var _loop = function _loop(i, l) {\n            var dayElem = month.children[i],\n                date = dayElem.dateObj;\n            var timestamp = date.getTime();\n            var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;\n\n            if (outOfRange) {\n              dayElem.classList.add(\"notAllowed\");\n              [\"inRange\", \"startRange\", \"endRange\"].forEach(function (c) {\n                dayElem.classList.remove(c);\n              });\n              return \"continue\";\n            } else if (containsDisabled && !outOfRange) return \"continue\";\n\n            [\"startRange\", \"inRange\", \"endRange\", \"notAllowed\"].forEach(function (c) {\n              dayElem.classList.remove(c);\n            });\n            elem.classList.add(hoverDate < self.selectedDates[0].getTime() ? \"startRange\" : \"endRange\");\n\n            if (month.contains(elem) || !(m > 0 && prevMonth && prevMonth.lastChild.dateObj.getTime() >= timestamp)) {\n              if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add(\"startRange\");else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add(\"endRange\");\n              if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add(\"inRange\");\n            }\n          };\n\n          for (var i = 0, l = month.children.length; i < l; i++) {\n            var _ret = _loop(i, l);\n\n            if (_ret === \"continue\") continue;\n          }\n        }\n      }\n\n      function onResize() {\n        if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();\n      }\n\n      function open(e, positionElement) {\n        if (positionElement === void 0) {\n          positionElement = self._input;\n        }\n\n        if (self.isMobile === true) {\n          if (e) {\n            e.preventDefault();\n            e.target && e.target.blur();\n          }\n\n          setTimeout(function () {\n            self.mobileInput !== undefined && self.mobileInput.click();\n          }, 0);\n          triggerEvent(\"onOpen\");\n          return;\n        }\n\n        if (self._input.disabled || self.config.inline) return;\n        var wasOpen = self.isOpen;\n        self.isOpen = true;\n\n        if (!wasOpen) {\n          self.calendarContainer.classList.add(\"open\");\n\n          self._input.classList.add(\"active\");\n\n          triggerEvent(\"onOpen\");\n          positionCalendar(positionElement);\n        }\n\n        if (self.config.enableTime === true && self.config.noCalendar === true) {\n          if (self.selectedDates.length === 0) {\n            self.setDate(self.config.minDate !== undefined ? new Date(self.config.minDate.getTime()) : new Date().setHours(self.config.defaultHour, self.config.defaultMinute, self.config.defaultSeconds, 0), false);\n            setHoursFromInputs();\n            updateValue();\n          }\n\n          setTimeout(function () {\n            return self.hourElement.select();\n          }, 50);\n        }\n      }\n\n      function minMaxDateSetter(type) {\n        return function (date) {\n          var dateObj = self.config[\"_\" + type + \"Date\"] = self.parseDate(date, self.config.dateFormat);\n          var inverseDateObj = self.config[\"_\" + (type === \"min\" ? \"max\" : \"min\") + \"Date\"];\n\n          if (dateObj !== undefined) {\n            self[type === \"min\" ? \"minDateHasTime\" : \"maxDateHasTime\"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;\n          }\n\n          if (self.selectedDates) {\n            self.selectedDates = self.selectedDates.filter(function (d) {\n              return isEnabled(d);\n            });\n            if (!self.selectedDates.length && type === \"min\") setHoursFromDate(dateObj);\n            updateValue();\n          }\n\n          if (self.daysContainer) {\n            redraw();\n            if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();else self.currentYearElement.removeAttribute(type);\n            self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();\n          }\n        };\n      }\n\n      function parseConfig() {\n        var boolOpts = [\"wrap\", \"weekNumbers\", \"allowInput\", \"clickOpens\", \"time_24hr\", \"enableTime\", \"noCalendar\", \"altInput\", \"shorthandCurrentMonth\", \"inline\", \"static\", \"enableSeconds\", \"disableMobile\"];\n        var hooks = [\"onChange\", \"onClose\", \"onDayCreate\", \"onDestroy\", \"onKeyDown\", \"onMonthChange\", \"onOpen\", \"onParseConfig\", \"onReady\", \"onValueUpdate\", \"onYearChange\", \"onPreCalendarPosition\"];\n        var userConfig = Object.assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));\n        var formats$$1 = {};\n        self.config.parseDate = userConfig.parseDate;\n        self.config.formatDate = userConfig.formatDate;\n        Object.defineProperty(self.config, \"enable\", {\n          get: function get() {\n            return self.config._enable;\n          },\n          set: function set(dates) {\n            self.config._enable = parseDateRules(dates);\n          }\n        });\n        Object.defineProperty(self.config, \"disable\", {\n          get: function get() {\n            return self.config._disable;\n          },\n          set: function set(dates) {\n            self.config._disable = parseDateRules(dates);\n          }\n        });\n\n        if (!userConfig.dateFormat && userConfig.enableTime) {\n          formats$$1.dateFormat = userConfig.noCalendar ? \"H:i\" + (userConfig.enableSeconds ? \":S\" : \"\") : flatpickr.defaultConfig.dateFormat + \" H:i\" + (userConfig.enableSeconds ? \":S\" : \"\");\n        }\n\n        if (userConfig.altInput && userConfig.enableTime && !userConfig.altFormat) {\n          formats$$1.altFormat = userConfig.noCalendar ? \"h:i\" + (userConfig.enableSeconds ? \":S K\" : \" K\") : flatpickr.defaultConfig.altFormat + (\" h:i\" + (userConfig.enableSeconds ? \":S\" : \"\") + \" K\");\n        }\n\n        Object.defineProperty(self.config, \"minDate\", {\n          get: function get() {\n            return self.config._minDate;\n          },\n          set: minMaxDateSetter(\"min\")\n        });\n        Object.defineProperty(self.config, \"maxDate\", {\n          get: function get() {\n            return self.config._maxDate;\n          },\n          set: minMaxDateSetter(\"max\")\n        });\n\n        var minMaxTimeSetter = function minMaxTimeSetter(type) {\n          return function (val) {\n            self.config[type === \"min\" ? \"_minTime\" : \"_maxTime\"] = self.parseDate(val, \"H:i\");\n          };\n        };\n\n        Object.defineProperty(self.config, \"minTime\", {\n          get: function get() {\n            return self.config._minTime;\n          },\n          set: minMaxTimeSetter(\"min\")\n        });\n        Object.defineProperty(self.config, \"maxTime\", {\n          get: function get() {\n            return self.config._maxTime;\n          },\n          set: minMaxTimeSetter(\"max\")\n        });\n        Object.assign(self.config, formats$$1, userConfig);\n\n        for (var i = 0; i < boolOpts.length; i++) {\n          self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === \"true\";\n        }\n\n        for (var _i = hooks.length; _i--;) {\n          if (self.config[hooks[_i]] !== undefined) {\n            self.config[hooks[_i]] = arrayify(self.config[hooks[_i]] || []).map(bindToInstance);\n          }\n        }\n\n        if (self.config.mode === \"time\") {\n          self.config.noCalendar = true;\n          self.config.enableTime = true;\n        }\n\n        for (var _i2 = 0; _i2 < self.config.plugins.length; _i2++) {\n          var pluginConf = self.config.plugins[_i2](self) || {};\n\n          for (var key in pluginConf) {\n            if (~hooks.indexOf(key)) {\n              self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);\n            } else if (typeof userConfig[key] === \"undefined\") self.config[key] = pluginConf[key];\n          }\n        }\n\n        self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === \"single\" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        triggerEvent(\"onParseConfig\");\n      }\n\n      function setupLocale() {\n        if (typeof self.config.locale !== \"object\" && typeof flatpickr.l10ns[self.config.locale] === \"undefined\") self.config.errorHandler(new Error(\"flatpickr: invalid locale \" + self.config.locale));\n        self.l10n = Object.assign({}, flatpickr.l10ns.default, typeof self.config.locale === \"object\" ? self.config.locale : self.config.locale !== \"default\" ? flatpickr.l10ns[self.config.locale] : undefined);\n        tokenRegex.K = \"(\" + self.l10n.amPM[0] + \"|\" + self.l10n.amPM[1] + \"|\" + self.l10n.amPM[0].toLowerCase() + \"|\" + self.l10n.amPM[1].toLowerCase() + \")\";\n        self.formatDate = createDateFormatter(self);\n      }\n\n      function positionCalendar(customPositionElement) {\n        if (self.calendarContainer === undefined) return;\n        triggerEvent(\"onPreCalendarPosition\");\n        var positionElement = customPositionElement || self._positionElement;\n        var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {\n          return acc + child.offsetHeight;\n        }, 0),\n            calendarWidth = self.calendarContainer.offsetWidth,\n            configPos = self.config.position,\n            inputBounds = positionElement.getBoundingClientRect(),\n            distanceFromBottom = window.innerHeight - inputBounds.bottom,\n            showOnTop = configPos === \"above\" || configPos !== \"below\" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;\n        var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);\n        toggleClass(self.calendarContainer, \"arrowTop\", !showOnTop);\n        toggleClass(self.calendarContainer, \"arrowBottom\", showOnTop);\n        if (self.config.inline) return;\n        var left = window.pageXOffset + inputBounds.left;\n        var right = window.document.body.offsetWidth - inputBounds.right;\n        var rightMost = left + calendarWidth > window.document.body.offsetWidth;\n        toggleClass(self.calendarContainer, \"rightMost\", rightMost);\n        if (self.config.static) return;\n        self.calendarContainer.style.top = top + \"px\";\n\n        if (!rightMost) {\n          self.calendarContainer.style.left = left + \"px\";\n          self.calendarContainer.style.right = \"auto\";\n        } else {\n          self.calendarContainer.style.left = \"auto\";\n          self.calendarContainer.style.right = right + \"px\";\n        }\n      }\n\n      function redraw() {\n        if (self.config.noCalendar || self.isMobile) return;\n        updateWeekdays();\n        updateNavigationCurrentMonth();\n        buildDays();\n      }\n\n      function focusAndClose() {\n        self._input.focus();\n\n        if (window.navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.msMaxTouchPoints !== undefined) {\n          setTimeout(self.close, 0);\n        } else {\n          self.close();\n        }\n      }\n\n      function selectDate(e) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        var isSelectable = function isSelectable(day) {\n          return day.classList && day.classList.contains(\"flatpickr-day\") && !day.classList.contains(\"disabled\") && !day.classList.contains(\"notAllowed\");\n        };\n\n        var t = findParent(e.target, isSelectable);\n        if (t === undefined) return;\n        var target = t;\n        var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());\n        var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== \"range\";\n        self.selectedDateElem = target;\n        if (self.config.mode === \"single\") self.selectedDates = [selectedDate];else if (self.config.mode === \"multiple\") {\n          var selectedIndex = isDateSelected(selectedDate);\n          if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);else self.selectedDates.push(selectedDate);\n        } else if (self.config.mode === \"range\") {\n          if (self.selectedDates.length === 2) self.clear(false);\n          self.selectedDates.push(selectedDate);\n          if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {\n            return a.getTime() - b.getTime();\n          });\n        }\n        setHoursFromInputs();\n\n        if (shouldChangeMonth) {\n          var isNewYear = self.currentYear !== selectedDate.getFullYear();\n          self.currentYear = selectedDate.getFullYear();\n          self.currentMonth = selectedDate.getMonth();\n          if (isNewYear) triggerEvent(\"onYearChange\");\n          triggerEvent(\"onMonthChange\");\n        }\n\n        updateNavigationCurrentMonth();\n        buildDays();\n        if (self.config.minDate && self.minDateHasTime && self.config.enableTime && compareDates(selectedDate, self.config.minDate) === 0) setHoursFromDate(self.config.minDate);\n        updateValue();\n        if (self.config.enableTime) setTimeout(function () {\n          return self.showTimeInput = true;\n        }, 50);\n\n        if (self.config.mode === \"range\") {\n          if (self.selectedDates.length === 1) {\n            onMouseOver(target);\n          } else updateNavigationCurrentMonth();\n        }\n\n        if (!shouldChangeMonth && self.config.mode !== \"range\" && self.config.showMonths === 1) focusOnDay(target.$i, 0);else self.selectedDateElem && self.selectedDateElem.focus();\n        if (self.hourElement !== undefined) setTimeout(function () {\n          return self.hourElement !== undefined && self.hourElement.select();\n        }, 451);\n\n        if (self.config.closeOnSelect) {\n          var single = self.config.mode === \"single\" && !self.config.enableTime;\n          var range = self.config.mode === \"range\" && self.selectedDates.length === 2 && !self.config.enableTime;\n\n          if (single || range) {\n            focusAndClose();\n          }\n        }\n\n        triggerChange();\n      }\n\n      var CALLBACKS = {\n        locale: [setupLocale]\n      };\n\n      function set(option, value) {\n        if (option !== null && typeof option === \"object\") Object.assign(self.config, option);else {\n          self.config[option] = value;\n          if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function (x) {\n            return x();\n          });\n        }\n        self.redraw();\n        jumpToDate();\n      }\n\n      function setSelectedDate(inputDate, format) {\n        var dates = [];\n        if (inputDate instanceof Array) dates = inputDate.map(function (d) {\n          return self.parseDate(d, format);\n        });else if (inputDate instanceof Date || typeof inputDate === \"number\") dates = [self.parseDate(inputDate, format)];else if (typeof inputDate === \"string\") {\n          switch (self.config.mode) {\n            case \"single\":\n              dates = [self.parseDate(inputDate, format)];\n              break;\n\n            case \"multiple\":\n              dates = inputDate.split(self.config.conjunction).map(function (date) {\n                return self.parseDate(date, format);\n              });\n              break;\n\n            case \"range\":\n              dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {\n                return self.parseDate(date, format);\n              });\n              break;\n\n            default:\n              break;\n          }\n        } else self.config.errorHandler(new Error(\"Invalid date supplied: \" + JSON.stringify(inputDate)));\n        self.selectedDates = dates.filter(function (d) {\n          return d instanceof Date && isEnabled(d, false);\n        });\n        if (self.config.mode === \"range\") self.selectedDates.sort(function (a, b) {\n          return a.getTime() - b.getTime();\n        });\n      }\n\n      function setDate(date, triggerChange, format) {\n        if (triggerChange === void 0) {\n          triggerChange = false;\n        }\n\n        if (format === void 0) {\n          format = self.config.dateFormat;\n        }\n\n        if (date !== 0 && !date) return self.clear(triggerChange);\n        setSelectedDate(date, format);\n        self.showTimeInput = self.selectedDates.length > 0;\n        self.latestSelectedDateObj = self.selectedDates[0];\n        self.redraw();\n        jumpToDate();\n        setHoursFromDate();\n        updateValue(triggerChange);\n        if (triggerChange) triggerEvent(\"onChange\");\n      }\n\n      function parseDateRules(arr) {\n        return arr.map(function (rule) {\n          if (typeof rule === \"string\" || typeof rule === \"number\" || rule instanceof Date) {\n            return self.parseDate(rule, undefined, true);\n          } else if (rule && typeof rule === \"object\" && rule.from && rule.to) return {\n            from: self.parseDate(rule.from, undefined),\n            to: self.parseDate(rule.to, undefined)\n          };\n\n          return rule;\n        }).filter(function (x) {\n          return x;\n        });\n      }\n\n      function setupDates() {\n        self.selectedDates = [];\n        self.now = self.parseDate(self.config.now) || new Date();\n        var preloadedDate = self.config.defaultDate || self.input.value;\n        if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);\n        var initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;\n        self.currentYear = initialDate.getFullYear();\n        self.currentMonth = initialDate.getMonth();\n        if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];\n        if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, \"H:i\");\n        if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, \"H:i\");\n        self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);\n        self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);\n        Object.defineProperty(self, \"showTimeInput\", {\n          get: function get() {\n            return self._showTimeInput;\n          },\n          set: function set(bool) {\n            self._showTimeInput = bool;\n            if (self.calendarContainer) toggleClass(self.calendarContainer, \"showTimeInput\", bool);\n            self.isOpen && positionCalendar();\n          }\n        });\n      }\n\n      function setupInputs() {\n        self.input = self.config.wrap ? element.querySelector(\"[data-input]\") : element;\n\n        if (!self.input) {\n          self.config.errorHandler(new Error(\"Invalid input element specified\"));\n          return;\n        }\n\n        self.input._type = self.input.type;\n        self.input.type = \"text\";\n        self.input.classList.add(\"flatpickr-input\");\n        self._input = self.input;\n\n        if (self.config.altInput) {\n          self.altInput = createElement(self.input.nodeName, self.input.className + \" \" + self.config.altInputClass);\n          self._input = self.altInput;\n          self.altInput.placeholder = self.input.placeholder;\n          self.altInput.disabled = self.input.disabled;\n          self.altInput.required = self.input.required;\n          self.altInput.tabIndex = self.input.tabIndex;\n          self.altInput.type = \"text\";\n          self.input.type = \"hidden\";\n          if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);\n        }\n\n        if (!self.config.allowInput) self._input.setAttribute(\"readonly\", \"readonly\");\n        self._positionElement = self.config.positionElement || self._input;\n      }\n\n      function setupMobile() {\n        var inputType = self.config.enableTime ? self.config.noCalendar ? \"time\" : \"datetime-local\" : \"date\";\n        self.mobileInput = createElement(\"input\", self.input.className + \" flatpickr-mobile\");\n        self.mobileInput.step = self.input.getAttribute(\"step\") || \"any\";\n        self.mobileInput.tabIndex = 1;\n        self.mobileInput.type = inputType;\n        self.mobileInput.disabled = self.input.disabled;\n        self.mobileInput.required = self.input.required;\n        self.mobileInput.placeholder = self.input.placeholder;\n        self.mobileFormatStr = inputType === \"datetime-local\" ? \"Y-m-d\\\\TH:i:S\" : inputType === \"date\" ? \"Y-m-d\" : \"H:i:S\";\n\n        if (self.selectedDates.length > 0) {\n          self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);\n        }\n\n        if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, \"Y-m-d\");\n        if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, \"Y-m-d\");\n        self.input.type = \"hidden\";\n        if (self.altInput !== undefined) self.altInput.type = \"hidden\";\n\n        try {\n          if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);\n        } catch (_a) {}\n\n        bind(self.mobileInput, \"change\", function (e) {\n          self.setDate(e.target.value, false, self.mobileFormatStr);\n          triggerEvent(\"onChange\");\n          triggerEvent(\"onClose\");\n        });\n      }\n\n      function toggle() {\n        if (self.isOpen) return self.close();\n        self.open();\n      }\n\n      function triggerEvent(event, data) {\n        var hooks = self.config[event];\n\n        if (hooks !== undefined && hooks.length > 0) {\n          for (var i = 0; hooks[i] && i < hooks.length; i++) {\n            hooks[i](self.selectedDates, self.input.value, self, data);\n          }\n        }\n\n        if (event === \"onChange\") {\n          self.input.dispatchEvent(createEvent(\"change\"));\n          self.input.dispatchEvent(createEvent(\"input\"));\n        }\n      }\n\n      function createEvent(name) {\n        var e = document.createEvent(\"Event\");\n        e.initEvent(name, true, true);\n        return e;\n      }\n\n      function isDateSelected(date) {\n        for (var i = 0; i < self.selectedDates.length; i++) {\n          if (compareDates(self.selectedDates[i], date) === 0) return \"\" + i;\n        }\n\n        return false;\n      }\n\n      function isDateInRange(date) {\n        if (self.config.mode !== \"range\" || self.selectedDates.length < 2) return false;\n        return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;\n      }\n\n      function updateNavigationCurrentMonth() {\n        if (self.config.noCalendar || self.isMobile || !self.monthNav) return;\n        self.yearElements.forEach(function (yearElement, i) {\n          var d = new Date(self.currentYear, self.currentMonth, 1);\n          d.setMonth(self.currentMonth + i);\n          self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + \" \";\n          yearElement.value = d.getFullYear().toString();\n        });\n        self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());\n        self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());\n      }\n\n      function updateValue(triggerChange) {\n        if (triggerChange === void 0) {\n          triggerChange = true;\n        }\n\n        if (self.selectedDates.length === 0) return self.clear(triggerChange);\n\n        if (self.mobileInput !== undefined && self.mobileFormatStr) {\n          self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : \"\";\n        }\n\n        var joinChar = self.config.mode !== \"range\" ? self.config.conjunction : self.l10n.rangeSeparator;\n        self.input.value = self.selectedDates.map(function (dObj) {\n          return self.formatDate(dObj, self.config.dateFormat);\n        }).join(joinChar);\n\n        if (self.altInput !== undefined) {\n          self.altInput.value = self.selectedDates.map(function (dObj) {\n            return self.formatDate(dObj, self.config.altFormat);\n          }).join(joinChar);\n        }\n\n        if (triggerChange !== false) triggerEvent(\"onValueUpdate\");\n      }\n\n      function onMonthNavClick(e) {\n        var isPrevMonth = self.prevMonthNav.contains(e.target);\n        var isNextMonth = self.nextMonthNav.contains(e.target);\n\n        if (isPrevMonth || isNextMonth) {\n          changeMonth(isPrevMonth ? -1 : 1);\n        } else if (self.yearElements.indexOf(e.target) >= 0) {\n          e.preventDefault();\n          e.target.select();\n        } else if (e.target.classList.contains(\"arrowUp\")) {\n          self.changeYear(self.currentYear + 1);\n        } else if (e.target.classList.contains(\"arrowDown\")) {\n          self.changeYear(self.currentYear - 1);\n        }\n      }\n\n      function timeWrapper(e) {\n        e.preventDefault();\n        var isKeyDown = e.type === \"keydown\",\n            input = e.target;\n\n        if (self.amPM !== undefined && e.target === self.amPM) {\n          self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];\n        }\n\n        var min = parseFloat(input.getAttribute(\"data-min\")),\n            max = parseFloat(input.getAttribute(\"data-max\")),\n            step = parseFloat(input.getAttribute(\"data-step\")),\n            curValue = parseInt(input.value, 10),\n            delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);\n        var newValue = curValue + step * delta;\n\n        if (typeof input.value !== \"undefined\" && input.value.length === 2) {\n          var isHourElem = input === self.hourElement,\n              isMinuteElem = input === self.minuteElement;\n\n          if (newValue < min) {\n            newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));\n            if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);\n          } else if (newValue > max) {\n            newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;\n            if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);\n          }\n\n          if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {\n            self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];\n          }\n\n          input.value = pad(newValue);\n        }\n      }\n\n      init();\n      return self;\n    }\n\n    function _flatpickr(nodeList, config) {\n      var nodes = Array.prototype.slice.call(nodeList);\n      var instances = [];\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n\n        try {\n          if (node.getAttribute(\"data-fp-omit\") !== null) continue;\n\n          if (node._flatpickr !== undefined) {\n            node._flatpickr.destroy();\n\n            node._flatpickr = undefined;\n          }\n\n          node._flatpickr = FlatpickrInstance(node, config || {});\n          instances.push(node._flatpickr);\n        } catch (e) {\n          console.error(e);\n        }\n      }\n\n      return instances.length === 1 ? instances[0] : instances;\n    }\n\n    if (typeof HTMLElement !== \"undefined\") {\n      HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {\n        return _flatpickr(this, config);\n      };\n\n      HTMLElement.prototype.flatpickr = function (config) {\n        return _flatpickr([this], config);\n      };\n    }\n\n    var flatpickr = function flatpickr(selector, config) {\n      if (selector instanceof NodeList) return _flatpickr(selector, config);else if (typeof selector === \"string\") return _flatpickr(window.document.querySelectorAll(selector), config);\n      return _flatpickr([selector], config);\n    };\n\n    flatpickr.defaultConfig = defaults;\n    flatpickr.l10ns = {\n      en: Object.assign({}, english),\n      default: Object.assign({}, english)\n    };\n\n    flatpickr.localize = function (l10n) {\n      flatpickr.l10ns.default = Object.assign({}, flatpickr.l10ns.default, l10n);\n    };\n\n    flatpickr.setDefaults = function (config) {\n      flatpickr.defaultConfig = Object.assign({}, flatpickr.defaultConfig, config);\n    };\n\n    flatpickr.parseDate = createDateParser({});\n    flatpickr.formatDate = createDateFormatter({});\n    flatpickr.compareDates = compareDates;\n\n    if (typeof jQuery !== \"undefined\") {\n      jQuery.fn.flatpickr = function (config) {\n        return _flatpickr(this, config);\n      };\n    }\n\n    Date.prototype.fp_incr = function (days) {\n      return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === \"string\" ? parseInt(days, 10) : days));\n    };\n\n    return flatpickr;\n\n})));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZsYXRwaWNrci9kaXN0L2ZsYXRwaWNrci5qcz9hNTA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdKQUFnSjtBQUNoSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUEsNkNBQTZDO0FBQzdDLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZmxhdHBpY2tyIHY0LjQuMywgQGxpY2Vuc2UgTUlUICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuZmxhdHBpY2tyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHBhZCA9IGZ1bmN0aW9uIHBhZChudW1iZXIpIHtcbiAgICAgIHJldHVybiAoXCIwXCIgKyBudW1iZXIpLnNsaWNlKC0yKTtcbiAgICB9O1xuICAgIHZhciBpbnQgPSBmdW5jdGlvbiBpbnQoYm9vbCkge1xuICAgICAgcmV0dXJuIGJvb2wgPT09IHRydWUgPyAxIDogMDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgICAgaWYgKGltbWVkaWF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGltbWVkaWF0ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZW91dDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcyxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRpbWVvdXQgIT09IG51bGwgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9LCB3YWl0KTtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSAmJiAhdGltZW91dCkgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBhcnJheWlmeSA9IGZ1bmN0aW9uIGFycmF5aWZ5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogW29ial07XG4gICAgfTtcblxuICAgIHZhciBkb19ub3RoaW5nID0gZnVuY3Rpb24gZG9fbm90aGluZygpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIHZhciBtb250aFRvU3RyID0gZnVuY3Rpb24gbW9udGhUb1N0cihtb250aE51bWJlciwgc2hvcnRoYW5kLCBsb2NhbGUpIHtcbiAgICAgIHJldHVybiBsb2NhbGUubW9udGhzW3Nob3J0aGFuZCA/IFwic2hvcnRoYW5kXCIgOiBcImxvbmdoYW5kXCJdW21vbnRoTnVtYmVyXTtcbiAgICB9O1xuICAgIHZhciByZXZGb3JtYXQgPSB7XG4gICAgICBEOiBkb19ub3RoaW5nLFxuICAgICAgRjogZnVuY3Rpb24gRihkYXRlT2JqLCBtb250aE5hbWUsIGxvY2FsZSkge1xuICAgICAgICBkYXRlT2JqLnNldE1vbnRoKGxvY2FsZS5tb250aHMubG9uZ2hhbmQuaW5kZXhPZihtb250aE5hbWUpKTtcbiAgICAgIH0sXG4gICAgICBHOiBmdW5jdGlvbiBHKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgIH0sXG4gICAgICBIOiBmdW5jdGlvbiBIKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgIH0sXG4gICAgICBKOiBmdW5jdGlvbiBKKGRhdGVPYmosIGRheSkge1xuICAgICAgICBkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcbiAgICAgIH0sXG4gICAgICBLOiBmdW5jdGlvbiBLKGRhdGVPYmosIGFtUE0sIGxvY2FsZSkge1xuICAgICAgICBkYXRlT2JqLnNldEhvdXJzKGRhdGVPYmouZ2V0SG91cnMoKSAlIDEyICsgMTIgKiBpbnQobmV3IFJlZ0V4cChsb2NhbGUuYW1QTVsxXSwgXCJpXCIpLnRlc3QoYW1QTSkpKTtcbiAgICAgIH0sXG4gICAgICBNOiBmdW5jdGlvbiBNKGRhdGVPYmosIHNob3J0TW9udGgsIGxvY2FsZSkge1xuICAgICAgICBkYXRlT2JqLnNldE1vbnRoKGxvY2FsZS5tb250aHMuc2hvcnRoYW5kLmluZGV4T2Yoc2hvcnRNb250aCkpO1xuICAgICAgfSxcbiAgICAgIFM6IGZ1bmN0aW9uIFMoZGF0ZU9iaiwgc2Vjb25kcykge1xuICAgICAgICBkYXRlT2JqLnNldFNlY29uZHMocGFyc2VGbG9hdChzZWNvbmRzKSk7XG4gICAgICB9LFxuICAgICAgVTogZnVuY3Rpb24gVShfLCB1bml4U2Vjb25kcykge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VGbG9hdCh1bml4U2Vjb25kcykgKiAxMDAwKTtcbiAgICAgIH0sXG4gICAgICBXOiBmdW5jdGlvbiBXKGRhdGVPYmosIHdlZWtOdW0pIHtcbiAgICAgICAgdmFyIHdlZWtOdW1iZXIgPSBwYXJzZUludCh3ZWVrTnVtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVPYmouZ2V0RnVsbFllYXIoKSwgMCwgMiArICh3ZWVrTnVtYmVyIC0gMSkgKiA3LCAwLCAwLCAwLCAwKTtcbiAgICAgIH0sXG4gICAgICBZOiBmdW5jdGlvbiBZKGRhdGVPYmosIHllYXIpIHtcbiAgICAgICAgZGF0ZU9iai5zZXRGdWxsWWVhcihwYXJzZUZsb2F0KHllYXIpKTtcbiAgICAgIH0sXG4gICAgICBaOiBmdW5jdGlvbiBaKF8sIElTT0RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKElTT0RhdGUpO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIGQoZGF0ZU9iaiwgZGF5KSB7XG4gICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIGgoZGF0ZU9iaiwgaG91cikge1xuICAgICAgICBkYXRlT2JqLnNldEhvdXJzKHBhcnNlRmxvYXQoaG91cikpO1xuICAgICAgfSxcbiAgICAgIGk6IGZ1bmN0aW9uIGkoZGF0ZU9iaiwgbWludXRlcykge1xuICAgICAgICBkYXRlT2JqLnNldE1pbnV0ZXMocGFyc2VGbG9hdChtaW51dGVzKSk7XG4gICAgICB9LFxuICAgICAgajogZnVuY3Rpb24gaihkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgZGF0ZU9iai5zZXREYXRlKHBhcnNlRmxvYXQoZGF5KSk7XG4gICAgICB9LFxuICAgICAgbDogZG9fbm90aGluZyxcbiAgICAgIG06IGZ1bmN0aW9uIG0oZGF0ZU9iaiwgbW9udGgpIHtcbiAgICAgICAgZGF0ZU9iai5zZXRNb250aChwYXJzZUZsb2F0KG1vbnRoKSAtIDEpO1xuICAgICAgfSxcbiAgICAgIG46IGZ1bmN0aW9uIG4oZGF0ZU9iaiwgbW9udGgpIHtcbiAgICAgICAgZGF0ZU9iai5zZXRNb250aChwYXJzZUZsb2F0KG1vbnRoKSAtIDEpO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIHMoZGF0ZU9iaiwgc2Vjb25kcykge1xuICAgICAgICBkYXRlT2JqLnNldFNlY29uZHMocGFyc2VGbG9hdChzZWNvbmRzKSk7XG4gICAgICB9LFxuICAgICAgdzogZG9fbm90aGluZyxcbiAgICAgIHk6IGZ1bmN0aW9uIHkoZGF0ZU9iaiwgeWVhcikge1xuICAgICAgICBkYXRlT2JqLnNldEZ1bGxZZWFyKDIwMDAgKyBwYXJzZUZsb2F0KHllYXIpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0b2tlblJlZ2V4ID0ge1xuICAgICAgRDogXCIoXFxcXHcrKVwiLFxuICAgICAgRjogXCIoXFxcXHcrKVwiLFxuICAgICAgRzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgIEg6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICBKOiBcIihcXFxcZFxcXFxkfFxcXFxkKVxcXFx3K1wiLFxuICAgICAgSzogXCJcIixcbiAgICAgIE06IFwiKFxcXFx3KylcIixcbiAgICAgIFM6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICBVOiBcIiguKylcIixcbiAgICAgIFc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICBZOiBcIihcXFxcZHs0fSlcIixcbiAgICAgIFo6IFwiKC4rKVwiLFxuICAgICAgZDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgIGg6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICBpOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgajogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgIGw6IFwiKFxcXFx3KylcIixcbiAgICAgIG06IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICBuOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgczogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgIHc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICB5OiBcIihcXFxcZHsyfSlcIlxuICAgIH07XG4gICAgdmFyIGZvcm1hdHMgPSB7XG4gICAgICBaOiBmdW5jdGlvbiBaKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbiAgICAgIH0sXG4gICAgICBEOiBmdW5jdGlvbiBEKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzLnNob3J0aGFuZFtmb3JtYXRzLncoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKV07XG4gICAgICB9LFxuICAgICAgRjogZnVuY3Rpb24gRihkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG1vbnRoVG9TdHIoZm9ybWF0cy5uKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykgLSAxLCBmYWxzZSwgbG9jYWxlKTtcbiAgICAgIH0sXG4gICAgICBHOiBmdW5jdGlvbiBHKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcGFkKGZvcm1hdHMuaChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpKTtcbiAgICAgIH0sXG4gICAgICBIOiBmdW5jdGlvbiBIKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldEhvdXJzKCkpO1xuICAgICAgfSxcbiAgICAgIEo6IGZ1bmN0aW9uIEooZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUub3JkaW5hbCAhPT0gdW5kZWZpbmVkID8gZGF0ZS5nZXREYXRlKCkgKyBsb2NhbGUub3JkaW5hbChkYXRlLmdldERhdGUoKSkgOiBkYXRlLmdldERhdGUoKTtcbiAgICAgIH0sXG4gICAgICBLOiBmdW5jdGlvbiBLKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmFtUE1baW50KGRhdGUuZ2V0SG91cnMoKSA+IDExKV07XG4gICAgICB9LFxuICAgICAgTTogZnVuY3Rpb24gTShkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIG1vbnRoVG9TdHIoZGF0ZS5nZXRNb250aCgpLCB0cnVlLCBsb2NhbGUpO1xuICAgICAgfSxcbiAgICAgIFM6IGZ1bmN0aW9uIFMoZGF0ZSkge1xuICAgICAgICByZXR1cm4gcGFkKGRhdGUuZ2V0U2Vjb25kcygpKTtcbiAgICAgIH0sXG4gICAgICBVOiBmdW5jdGlvbiBVKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICAgIH0sXG4gICAgICBXOiBmdW5jdGlvbiBXKGRhdGUsIF8sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZ2V0V2VlayhkYXRlKTtcbiAgICAgIH0sXG4gICAgICBZOiBmdW5jdGlvbiBZKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiBkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldERhdGUoKSk7XG4gICAgICB9LFxuICAgICAgaDogZnVuY3Rpb24gaChkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldEhvdXJzKCkgJSAxMiA/IGRhdGUuZ2V0SG91cnMoKSAlIDEyIDogMTI7XG4gICAgICB9LFxuICAgICAgaTogZnVuY3Rpb24gaShkYXRlKSB7XG4gICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRNaW51dGVzKCkpO1xuICAgICAgfSxcbiAgICAgIGo6IGZ1bmN0aW9uIGooZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXREYXRlKCk7XG4gICAgICB9LFxuICAgICAgbDogZnVuY3Rpb24gbChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5cy5sb25naGFuZFtkYXRlLmdldERheSgpXTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiBtKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldE1vbnRoKCkgKyAxKTtcbiAgICAgIH0sXG4gICAgICBuOiBmdW5jdGlvbiBuKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gcyhkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldFNlY29uZHMoKTtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiB3KGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7XG4gICAgICB9LFxuICAgICAgeTogZnVuY3Rpb24geShkYXRlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoZGF0ZS5nZXRGdWxsWWVhcigpKS5zdWJzdHJpbmcoMik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBlbmdsaXNoID0ge1xuICAgICAgd2Vla2RheXM6IHtcbiAgICAgICAgc2hvcnRoYW5kOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgICAgIGxvbmdoYW5kOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXVxuICAgICAgfSxcbiAgICAgIG1vbnRoczoge1xuICAgICAgICBzaG9ydGhhbmQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSxcbiAgICAgICAgbG9uZ2hhbmQ6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdXG4gICAgICB9LFxuICAgICAgZGF5c0luTW9udGg6IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXSxcbiAgICAgIGZpcnN0RGF5T2ZXZWVrOiAwLFxuICAgICAgb3JkaW5hbDogZnVuY3Rpb24gb3JkaW5hbChudGgpIHtcbiAgICAgICAgdmFyIHMgPSBudGggJSAxMDA7XG4gICAgICAgIGlmIChzID4gMyAmJiBzIDwgMjEpIHJldHVybiBcInRoXCI7XG5cbiAgICAgICAgc3dpdGNoIChzICUgMTApIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gXCJzdFwiO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIFwibmRcIjtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBcInJkXCI7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwidGhcIjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJhbmdlU2VwYXJhdG9yOiBcIiB0byBcIixcbiAgICAgIHdlZWtBYmJyZXZpYXRpb246IFwiV2tcIixcbiAgICAgIHNjcm9sbFRpdGxlOiBcIlNjcm9sbCB0byBpbmNyZW1lbnRcIixcbiAgICAgIHRvZ2dsZVRpdGxlOiBcIkNsaWNrIHRvIHRvZ2dsZVwiLFxuICAgICAgYW1QTTogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICAgIHllYXJBcmlhTGFiZWw6IFwiWWVhclwiXG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEYXRlRm9ybWF0dGVyID0gZnVuY3Rpb24gY3JlYXRlRGF0ZUZvcm1hdHRlcihfcmVmKSB7XG4gICAgICB2YXIgX3JlZiRjb25maWcgPSBfcmVmLmNvbmZpZyxcbiAgICAgICAgICBjb25maWcgPSBfcmVmJGNvbmZpZyA9PT0gdm9pZCAwID8gZGVmYXVsdHMgOiBfcmVmJGNvbmZpZyxcbiAgICAgICAgICBfcmVmJGwxMG4gPSBfcmVmLmwxMG4sXG4gICAgICAgICAgbDEwbiA9IF9yZWYkbDEwbiA9PT0gdm9pZCAwID8gZW5nbGlzaCA6IF9yZWYkbDEwbjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZU9iaiwgZnJtdCwgb3ZlcnJpZGVMb2NhbGUpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5mb3JtYXREYXRlICE9PSB1bmRlZmluZWQpIHJldHVybiBjb25maWcuZm9ybWF0RGF0ZShkYXRlT2JqLCBmcm10KTtcbiAgICAgICAgdmFyIGxvY2FsZSA9IG92ZXJyaWRlTG9jYWxlIHx8IGwxMG47XG4gICAgICAgIHJldHVybiBmcm10LnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAoYywgaSwgYXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdHNbY10gJiYgYXJyW2kgLSAxXSAhPT0gXCJcXFxcXCIgPyBmb3JtYXRzW2NdKGRhdGVPYmosIGxvY2FsZSwgY29uZmlnKSA6IGMgIT09IFwiXFxcXFwiID8gYyA6IFwiXCI7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZURhdGVQYXJzZXIgPSBmdW5jdGlvbiBjcmVhdGVEYXRlUGFyc2VyKF9yZWYyKSB7XG4gICAgICB2YXIgX3JlZjIkY29uZmlnID0gX3JlZjIuY29uZmlnLFxuICAgICAgICAgIGNvbmZpZyA9IF9yZWYyJGNvbmZpZyA9PT0gdm9pZCAwID8gZGVmYXVsdHMgOiBfcmVmMiRjb25maWcsXG4gICAgICAgICAgX3JlZjIkbDEwbiA9IF9yZWYyLmwxMG4sXG4gICAgICAgICAgbDEwbiA9IF9yZWYyJGwxMG4gPT09IHZvaWQgMCA/IGVuZ2xpc2ggOiBfcmVmMiRsMTBuO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBnaXZlbkZvcm1hdCwgdGltZWxlc3MpIHtcbiAgICAgICAgaWYgKGRhdGUgIT09IDAgJiYgIWRhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBwYXJzZWREYXRlO1xuICAgICAgICB2YXIgZGF0ZV9vcmlnID0gZGF0ZTtcbiAgICAgICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO2Vsc2UgaWYgKHR5cGVvZiBkYXRlICE9PSBcInN0cmluZ1wiICYmIGRhdGUudG9GaXhlZCAhPT0gdW5kZWZpbmVkKSBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZSk7ZWxzZSBpZiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0ID0gZ2l2ZW5Gb3JtYXQgfHwgKGNvbmZpZyB8fCBkZWZhdWx0cykuZGF0ZUZvcm1hdDtcbiAgICAgICAgICB2YXIgZGF0ZXN0ciA9IFN0cmluZyhkYXRlKS50cmltKCk7XG5cbiAgICAgICAgICBpZiAoZGF0ZXN0ciA9PT0gXCJ0b2RheVwiKSB7XG4gICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRpbWVsZXNzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9aJC8udGVzdChkYXRlc3RyKSB8fCAvR01UJC8udGVzdChkYXRlc3RyKSkgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO2Vsc2UgaWYgKGNvbmZpZyAmJiBjb25maWcucGFyc2VEYXRlKSBwYXJzZWREYXRlID0gY29uZmlnLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpO2Vsc2Uge1xuICAgICAgICAgICAgcGFyc2VkRGF0ZSA9ICFjb25maWcgfHwgIWNvbmZpZy5ub0NhbGVuZGFyID8gbmV3IERhdGUobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCAwLCAxLCAwLCAwLCAwLCAwKSA6IG5ldyBEYXRlKG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQsXG4gICAgICAgICAgICAgICAgb3BzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXRjaEluZGV4ID0gMCwgcmVnZXhTdHIgPSBcIlwiOyBpIDwgZm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciB0b2tlbiA9IGZvcm1hdFtpXTtcbiAgICAgICAgICAgICAgdmFyIGlzQmFja1NsYXNoID0gdG9rZW4gPT09IFwiXFxcXFwiO1xuICAgICAgICAgICAgICB2YXIgZXNjYXBlZCA9IGZvcm1hdFtpIC0gMV0gPT09IFwiXFxcXFwiIHx8IGlzQmFja1NsYXNoO1xuXG4gICAgICAgICAgICAgIGlmICh0b2tlblJlZ2V4W3Rva2VuXSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgIHJlZ2V4U3RyICs9IHRva2VuUmVnZXhbdG9rZW5dO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG5ldyBSZWdFeHAocmVnZXhTdHIpLmV4ZWMoZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoZWQgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgb3BzW3Rva2VuICE9PSBcIllcIiA/IFwicHVzaFwiIDogXCJ1bnNoaWZ0XCJdKHtcbiAgICAgICAgICAgICAgICAgICAgZm46IHJldkZvcm1hdFt0b2tlbl0sXG4gICAgICAgICAgICAgICAgICAgIHZhbDogbWF0Y2hbKyttYXRjaEluZGV4XVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0JhY2tTbGFzaCkgcmVnZXhTdHIgKz0gXCIuXCI7XG5cbiAgICAgICAgICAgICAgb3BzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gX3JlZjMuZm4sXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IF9yZWYzLnZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkRGF0ZSA9IGZuKHBhcnNlZERhdGUsIHZhbCwgbDEwbikgfHwgcGFyc2VkRGF0ZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlZERhdGUgPSBtYXRjaGVkID8gcGFyc2VkRGF0ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShwYXJzZWREYXRlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICBjb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBwcm92aWRlZDogXCIgKyBkYXRlX29yaWcpKTtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWVsZXNzID09PSB0cnVlKSBwYXJzZWREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gcGFyc2VkRGF0ZTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjb21wYXJlRGF0ZXMoZGF0ZTEsIGRhdGUyLCB0aW1lbGVzcykge1xuICAgICAgaWYgKHRpbWVsZXNzID09PSB2b2lkIDApIHtcbiAgICAgICAgdGltZWxlc3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZWxlc3MgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlMS5nZXRUaW1lKCkpLnNldEhvdXJzKDAsIDAsIDAsIDApIC0gbmV3IERhdGUoZGF0ZTIuZ2V0VGltZSgpKS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGUxLmdldFRpbWUoKSAtIGRhdGUyLmdldFRpbWUoKTtcbiAgICB9XG4gICAgdmFyIGdldFdlZWsgPSBmdW5jdGlvbiBnZXRXZWVrKGdpdmVuRGF0ZSkge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShnaXZlbkRhdGUuZ2V0VGltZSgpKTtcbiAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAzIC0gKGRhdGUuZ2V0RGF5KCkgKyA2KSAlIDcpO1xuICAgICAgdmFyIHdlZWsxID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCA0KTtcbiAgICAgIHJldHVybiAxICsgTWF0aC5yb3VuZCgoKGRhdGUuZ2V0VGltZSgpIC0gd2VlazEuZ2V0VGltZSgpKSAvIDg2NDAwMDAwIC0gMyArICh3ZWVrMS5nZXREYXkoKSArIDYpICUgNykgLyA3KTtcbiAgICB9O1xuICAgIHZhciBpc0JldHdlZW4gPSBmdW5jdGlvbiBpc0JldHdlZW4odHMsIHRzMSwgdHMyKSB7XG4gICAgICByZXR1cm4gdHMgPiBNYXRoLm1pbih0czEsIHRzMikgJiYgdHMgPCBNYXRoLm1heCh0czEsIHRzMik7XG4gICAgfTtcbiAgICB2YXIgZHVyYXRpb24gPSB7XG4gICAgICBEQVk6IDg2NDAwMDAwXG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIF9kaXNhYmxlOiBbXSxcbiAgICAgIF9lbmFibGU6IFtdLFxuICAgICAgYWxsb3dJbnB1dDogZmFsc2UsXG4gICAgICBhbHRGb3JtYXQ6IFwiRiBqLCBZXCIsXG4gICAgICBhbHRJbnB1dDogZmFsc2UsXG4gICAgICBhbHRJbnB1dENsYXNzOiBcImZvcm0tY29udHJvbCBpbnB1dFwiLFxuICAgICAgYW5pbWF0ZTogdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSA9PT0gLTEsXG4gICAgICBhcmlhRGF0ZUZvcm1hdDogXCJGIGosIFlcIixcbiAgICAgIGNsaWNrT3BlbnM6IHRydWUsXG4gICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxuICAgICAgY29uanVuY3Rpb246IFwiLCBcIixcbiAgICAgIGRhdGVGb3JtYXQ6IFwiWS1tLWRcIixcbiAgICAgIGRlZmF1bHRIb3VyOiAxMixcbiAgICAgIGRlZmF1bHRNaW51dGU6IDAsXG4gICAgICBkZWZhdWx0U2Vjb25kczogMCxcbiAgICAgIGRpc2FibGU6IFtdLFxuICAgICAgZGlzYWJsZU1vYmlsZTogZmFsc2UsXG4gICAgICBlbmFibGU6IFtdLFxuICAgICAgZW5hYmxlU2Vjb25kczogZmFsc2UsXG4gICAgICBlbmFibGVUaW1lOiBmYWxzZSxcbiAgICAgIGVycm9ySGFuZGxlcjogY29uc29sZS53YXJuLFxuICAgICAgZ2V0V2VlazogZ2V0V2VlayxcbiAgICAgIGhvdXJJbmNyZW1lbnQ6IDEsXG4gICAgICBpZ25vcmVkRm9jdXNFbGVtZW50czogW10sXG4gICAgICBpbmxpbmU6IGZhbHNlLFxuICAgICAgbG9jYWxlOiBcImRlZmF1bHRcIixcbiAgICAgIG1pbnV0ZUluY3JlbWVudDogNSxcbiAgICAgIG1vZGU6IFwic2luZ2xlXCIsXG4gICAgICBuZXh0QXJyb3c6IFwiPHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHZpZXdCb3g9JzAgMCAxNyAxNyc+PGc+PC9nPjxwYXRoIGQ9J00xMy4yMDcgOC40NzJsLTcuODU0IDcuODU0LTAuNzA3LTAuNzA3IDcuMTQ2LTcuMTQ2LTcuMTQ2LTcuMTQ4IDAuNzA3LTAuNzA3IDcuODU0IDcuODU0eicgLz48L3N2Zz5cIixcbiAgICAgIG5vQ2FsZW5kYXI6IGZhbHNlLFxuICAgICAgbm93OiBuZXcgRGF0ZSgpLFxuICAgICAgb25DaGFuZ2U6IFtdLFxuICAgICAgb25DbG9zZTogW10sXG4gICAgICBvbkRheUNyZWF0ZTogW10sXG4gICAgICBvbkRlc3Ryb3k6IFtdLFxuICAgICAgb25LZXlEb3duOiBbXSxcbiAgICAgIG9uTW9udGhDaGFuZ2U6IFtdLFxuICAgICAgb25PcGVuOiBbXSxcbiAgICAgIG9uUGFyc2VDb25maWc6IFtdLFxuICAgICAgb25SZWFkeTogW10sXG4gICAgICBvblZhbHVlVXBkYXRlOiBbXSxcbiAgICAgIG9uWWVhckNoYW5nZTogW10sXG4gICAgICBvblByZUNhbGVuZGFyUG9zaXRpb246IFtdLFxuICAgICAgcGx1Z2luczogW10sXG4gICAgICBwb3NpdGlvbjogXCJhdXRvXCIsXG4gICAgICBwb3NpdGlvbkVsZW1lbnQ6IHVuZGVmaW5lZCxcbiAgICAgIHByZXZBcnJvdzogXCI8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgdmlld0JveD0nMCAwIDE3IDE3Jz48Zz48L2c+PHBhdGggZD0nTTUuMjA3IDguNDcxbDcuMTQ2IDcuMTQ3LTAuNzA3IDAuNzA3LTcuODUzLTcuODU0IDcuODU0LTcuODUzIDAuNzA3IDAuNzA3LTcuMTQ3IDcuMTQ2eicgLz48L3N2Zz5cIixcbiAgICAgIHNob3J0aGFuZEN1cnJlbnRNb250aDogZmFsc2UsXG4gICAgICBzaG93TW9udGhzOiAxLFxuICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgIHRpbWVfMjRocjogZmFsc2UsXG4gICAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgICB3cmFwOiBmYWxzZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtLCBjbGFzc05hbWUsIGJvb2wpIHtcbiAgICAgIGlmIChib29sID09PSB0cnVlKSByZXR1cm4gZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzTmFtZSwgY29udGVudCkge1xuICAgICAgdmFyIGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8IFwiXCI7XG4gICAgICBjb250ZW50ID0gY29udGVudCB8fCBcIlwiO1xuICAgICAgZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKSBlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhck5vZGUobm9kZSkge1xuICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRQYXJlbnQobm9kZSwgY29uZGl0aW9uKSB7XG4gICAgICBpZiAoY29uZGl0aW9uKG5vZGUpKSByZXR1cm4gbm9kZTtlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpIHJldHVybiBmaW5kUGFyZW50KG5vZGUucGFyZW50Tm9kZSwgY29uZGl0aW9uKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU51bWJlcklucHV0KGlucHV0Q2xhc3NOYW1lLCBvcHRzKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJudW1JbnB1dFdyYXBwZXJcIiksXG4gICAgICAgICAgbnVtSW5wdXQgPSBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgXCJudW1JbnB1dCBcIiArIGlucHV0Q2xhc3NOYW1lKSxcbiAgICAgICAgICBhcnJvd1VwID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJhcnJvd1VwXCIpLFxuICAgICAgICAgIGFycm93RG93biA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiYXJyb3dEb3duXCIpO1xuICAgICAgbnVtSW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgbnVtSW5wdXQucGF0dGVybiA9IFwiXFxcXGQqXCI7XG4gICAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSBmb3IgKHZhciBrZXkgaW4gb3B0cykge1xuICAgICAgICBudW1JbnB1dC5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRzW2tleV0pO1xuICAgICAgfVxuICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChudW1JbnB1dCk7XG4gICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGFycm93VXApO1xuICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChhcnJvd0Rvd24pO1xuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aoc291cmNlKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3MubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NbX2ldO1xuXG4gICAgICAgICAgX2xvb3Aoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBERUJPVU5DRURfQ0hBTkdFX01TID0gMzAwO1xuXG4gICAgZnVuY3Rpb24gRmxhdHBpY2tySW5zdGFuY2UoZWxlbWVudCwgaW5zdGFuY2VDb25maWcpIHtcbiAgICAgIHZhciBzZWxmID0ge1xuICAgICAgICBjb25maWc6IE9iamVjdC5hc3NpZ24oe30sIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnKSxcbiAgICAgICAgbDEwbjogZW5nbGlzaFxuICAgICAgfTtcbiAgICAgIHNlbGYucGFyc2VEYXRlID0gY3JlYXRlRGF0ZVBhcnNlcih7XG4gICAgICAgIGNvbmZpZzogc2VsZi5jb25maWcsXG4gICAgICAgIGwxMG46IHNlbGYubDEwblxuICAgICAgfSk7XG4gICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgc2VsZi5fYmluZCA9IGJpbmQ7XG4gICAgICBzZWxmLl9zZXRIb3Vyc0Zyb21EYXRlID0gc2V0SG91cnNGcm9tRGF0ZTtcbiAgICAgIHNlbGYuY2hhbmdlTW9udGggPSBjaGFuZ2VNb250aDtcbiAgICAgIHNlbGYuY2hhbmdlWWVhciA9IGNoYW5nZVllYXI7XG4gICAgICBzZWxmLmNsZWFyID0gY2xlYXI7XG4gICAgICBzZWxmLmNsb3NlID0gY2xvc2U7XG4gICAgICBzZWxmLl9jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbiAgICAgIHNlbGYuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgICBzZWxmLmlzRW5hYmxlZCA9IGlzRW5hYmxlZDtcbiAgICAgIHNlbGYuanVtcFRvRGF0ZSA9IGp1bXBUb0RhdGU7XG4gICAgICBzZWxmLm9wZW4gPSBvcGVuO1xuICAgICAgc2VsZi5yZWRyYXcgPSByZWRyYXc7XG4gICAgICBzZWxmLnNldCA9IHNldDtcbiAgICAgIHNlbGYuc2V0RGF0ZSA9IHNldERhdGU7XG4gICAgICBzZWxmLnRvZ2dsZSA9IHRvZ2dsZTtcblxuICAgICAgZnVuY3Rpb24gc2V0dXBIZWxwZXJGdW5jdGlvbnMoKSB7XG4gICAgICAgIHNlbGYudXRpbHMgPSB7XG4gICAgICAgICAgZ2V0RGF5c0luTW9udGg6IGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKG1vbnRoLCB5cikge1xuICAgICAgICAgICAgaWYgKG1vbnRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbW9udGggPSBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHlyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgeXIgPSBzZWxmLmN1cnJlbnRZZWFyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9udGggPT09IDEgJiYgKHlyICUgNCA9PT0gMCAmJiB5ciAlIDEwMCAhPT0gMCB8fCB5ciAlIDQwMCA9PT0gMCkpIHJldHVybiAyOTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmwxMG4uZGF5c0luTW9udGhbbW9udGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgc2VsZi5lbGVtZW50ID0gc2VsZi5pbnB1dCA9IGVsZW1lbnQ7XG4gICAgICAgIHNlbGYuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHBhcnNlQ29uZmlnKCk7XG4gICAgICAgIHNldHVwTG9jYWxlKCk7XG4gICAgICAgIHNldHVwSW5wdXRzKCk7XG4gICAgICAgIHNldHVwRGF0ZXMoKTtcbiAgICAgICAgc2V0dXBIZWxwZXJGdW5jdGlvbnMoKTtcbiAgICAgICAgaWYgKCFzZWxmLmlzTW9iaWxlKSBidWlsZCgpO1xuICAgICAgICBiaW5kRXZlbnRzKCk7XG5cbiAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcikge1xuICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgICBzZXRIb3Vyc0Zyb21EYXRlKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiB8fCBzZWxmLmNvbmZpZy5taW5EYXRlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNob3dUaW1lSW5wdXQgPSBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMCB8fCBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyO1xuXG4gICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgIHZhciBkYXlzV2lkdGggPSAoc2VsZi5kYXlzQ29udGFpbmVyLm9mZnNldFdpZHRoICsgMSkgKiBzZWxmLmNvbmZpZy5zaG93TW9udGhzO1xuICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IGRheXNXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLndpZHRoID0gZGF5c1dpZHRoICsgXCJweFwiO1xuXG4gICAgICAgICAgaWYgKHNlbGYud2Vla1dyYXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGRheXNXaWR0aCArIHNlbGYud2Vla1dyYXBwZXIub2Zmc2V0V2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgICAgICAgaWYgKCFzZWxmLmlzTW9iaWxlICYmIGlzU2FmYXJpKSB7XG4gICAgICAgICAgcG9zaXRpb25DYWxlbmRhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50KFwib25SZWFkeVwiKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYmluZFRvSW5zdGFuY2UoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuLmJpbmQoc2VsZik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRpbWUoZSkge1xuICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICB0aW1lV3JhcHBlcihlKTtcblxuICAgICAgICBpZiAoZS50eXBlICE9PSBcImlucHV0XCIpIHtcbiAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgIH0sIERFQk9VTkNFRF9DSEFOR0VfTVMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFtcG0ybWlsaXRhcnkoaG91ciwgYW1QTSkge1xuICAgICAgICByZXR1cm4gaG91ciAlIDEyICsgMTIgKiBpbnQoYW1QTSA9PT0gc2VsZi5sMTBuLmFtUE1bMV0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtaWxpdGFyeTJhbXBtKGhvdXIpIHtcbiAgICAgICAgc3dpdGNoIChob3VyICUgMjQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiAxMjtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gaG91ciAlIDEyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldEhvdXJzRnJvbUlucHV0cygpIHtcbiAgICAgICAgaWYgKHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCB8fCBzZWxmLm1pbnV0ZUVsZW1lbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICB2YXIgaG91cnMgPSAocGFyc2VJbnQoc2VsZi5ob3VyRWxlbWVudC52YWx1ZS5zbGljZSgtMiksIDEwKSB8fCAwKSAlIDI0LFxuICAgICAgICAgICAgbWludXRlcyA9IChwYXJzZUludChzZWxmLm1pbnV0ZUVsZW1lbnQudmFsdWUsIDEwKSB8fCAwKSAlIDYwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IHNlbGYuc2Vjb25kRWxlbWVudCAhPT0gdW5kZWZpbmVkID8gKHBhcnNlSW50KHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjAgOiAwO1xuICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIGhvdXJzID0gYW1wbTJtaWxpdGFyeShob3Vycywgc2VsZi5hbVBNLnRleHRDb250ZW50KTtcbiAgICAgICAgdmFyIGxpbWl0TWluSG91cnMgPSBzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWQgfHwgc2VsZi5jb25maWcubWluRGF0ZSAmJiBzZWxmLm1pbkRhdGVIYXNUaW1lICYmIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICYmIGNvbXBhcmVEYXRlcyhzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiwgc2VsZi5jb25maWcubWluRGF0ZSwgdHJ1ZSkgPT09IDA7XG4gICAgICAgIHZhciBsaW1pdE1heEhvdXJzID0gc2VsZi5jb25maWcubWF4VGltZSAhPT0gdW5kZWZpbmVkIHx8IHNlbGYuY29uZmlnLm1heERhdGUgJiYgc2VsZi5tYXhEYXRlSGFzVGltZSAmJiBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAmJiBjb21wYXJlRGF0ZXMoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmosIHNlbGYuY29uZmlnLm1heERhdGUsIHRydWUpID09PSAwO1xuXG4gICAgICAgIGlmIChsaW1pdE1heEhvdXJzKSB7XG4gICAgICAgICAgdmFyIG1heFRpbWUgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWQgPyBzZWxmLmNvbmZpZy5tYXhUaW1lIDogc2VsZi5jb25maWcubWF4RGF0ZTtcbiAgICAgICAgICBob3VycyA9IE1hdGgubWluKGhvdXJzLCBtYXhUaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4VGltZS5nZXRIb3VycygpKSBtaW51dGVzID0gTWF0aC5taW4obWludXRlcywgbWF4VGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgIGlmIChtaW51dGVzID09PSBtYXhUaW1lLmdldE1pbnV0ZXMoKSkgc2Vjb25kcyA9IE1hdGgubWluKHNlY29uZHMsIG1heFRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdE1pbkhvdXJzKSB7XG4gICAgICAgICAgdmFyIG1pblRpbWUgPSBzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWQgPyBzZWxmLmNvbmZpZy5taW5UaW1lIDogc2VsZi5jb25maWcubWluRGF0ZTtcbiAgICAgICAgICBob3VycyA9IE1hdGgubWF4KGhvdXJzLCBtaW5UaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgIGlmIChob3VycyA9PT0gbWluVGltZS5nZXRIb3VycygpKSBtaW51dGVzID0gTWF0aC5tYXgobWludXRlcywgbWluVGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgIGlmIChtaW51dGVzID09PSBtaW5UaW1lLmdldE1pbnV0ZXMoKSkgc2Vjb25kcyA9IE1hdGgubWF4KHNlY29uZHMsIG1pblRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0SG91cnNGcm9tRGF0ZShkYXRlT2JqKSB7XG4gICAgICAgIHZhciBkYXRlID0gZGF0ZU9iaiB8fCBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iajtcbiAgICAgICAgaWYgKGRhdGUpIHNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCksIGRhdGUuZ2V0U2Vjb25kcygpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgICAgICAgaWYgKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5zZXRIb3Vycyhob3VycyAlIDI0LCBtaW51dGVzLCBzZWNvbmRzIHx8IDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxmLmhvdXJFbGVtZW50IHx8ICFzZWxmLm1pbnV0ZUVsZW1lbnQgfHwgc2VsZi5pc01vYmlsZSkgcmV0dXJuO1xuICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnZhbHVlID0gcGFkKCFzZWxmLmNvbmZpZy50aW1lXzI0aHIgPyAoMTIgKyBob3VycykgJSAxMiArIDEyICogaW50KGhvdXJzICUgMTIgPT09IDApIDogaG91cnMpO1xuICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQudmFsdWUgPSBwYWQobWludXRlcyk7XG4gICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCkgc2VsZi5hbVBNLnRleHRDb250ZW50ID0gc2VsZi5sMTBuLmFtUE1baW50KGhvdXJzID49IDEyKV07XG4gICAgICAgIGlmIChzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZCkgc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlID0gcGFkKHNlY29uZHMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblllYXJJbnB1dChldmVudCkge1xuICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC52YWx1ZSkgKyAoZXZlbnQuZGVsdGEgfHwgMCk7XG5cbiAgICAgICAgaWYgKHllYXIudG9TdHJpbmcoKS5sZW5ndGggPT09IDQgfHwgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICBldmVudC50YXJnZXQuYmx1cigpO1xuICAgICAgICAgIGlmICghL1teXFxkXS8udGVzdCh5ZWFyLnRvU3RyaW5nKCkpKSBjaGFuZ2VZZWFyKHllYXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJpbmQoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIHJldHVybiBiaW5kKGVsZW1lbnQsIGV2LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmQoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG5cbiAgICAgICAgc2VsZi5faGFuZGxlcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25DbGljayhoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgZXZ0LndoaWNoID09PSAxICYmIGhhbmRsZXIoZXZ0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJpZ2dlckNoYW5nZSgpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy53cmFwKSB7XG4gICAgICAgICAgW1wib3BlblwiLCBcImNsb3NlXCIsIFwidG9nZ2xlXCIsIFwiY2xlYXJcIl0uZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHNlbGYuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtXCIgKyBldnQgKyBcIl1cIiksIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICByZXR1cm4gYmluZChlbCwgXCJjbGlja1wiLCBzZWxmW2V2dF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5pc01vYmlsZSkge1xuICAgICAgICAgIHNldHVwTW9iaWxlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlYm91bmNlZFJlc2l6ZSA9IGRlYm91bmNlKG9uUmVzaXplLCA1MCk7XG4gICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSA9IGRlYm91bmNlKHRyaWdnZXJDaGFuZ2UsIERFQk9VTkNFRF9DSEFOR0VfTVMpO1xuICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICYmICEvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIGJpbmQoc2VsZi5kYXlzQ29udGFpbmVyLCBcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIG9uTW91c2VPdmVyKGUudGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LmJvZHksIFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgICBpZiAoIXNlbGYuY29uZmlnLnN0YXRpYykgYmluZChzZWxmLl9pbnB1dCwgXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICAgIGlmICghc2VsZi5jb25maWcuaW5saW5lICYmICFzZWxmLmNvbmZpZy5zdGF0aWMpIGJpbmQod2luZG93LCBcInJlc2l6ZVwiLCBkZWJvdW5jZWRSZXNpemUpO1xuICAgICAgICBpZiAod2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkKSBiaW5kKHdpbmRvdy5kb2N1bWVudCwgXCJ0b3VjaHN0YXJ0XCIsIGRvY3VtZW50Q2xpY2spO1xuICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudCwgXCJtb3VzZWRvd25cIiwgb25DbGljayhkb2N1bWVudENsaWNrKSk7XG4gICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcImZvY3VzXCIsIGRvY3VtZW50Q2xpY2ssIHtcbiAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5jbGlja09wZW5zID09PSB0cnVlKSB7XG4gICAgICAgICAgYmluZChzZWxmLl9pbnB1dCwgXCJmb2N1c1wiLCBzZWxmLm9wZW4pO1xuICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soc2VsZi5vcGVuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBiaW5kKHNlbGYubW9udGhOYXYsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2sob25Nb250aE5hdkNsaWNrKSk7XG4gICAgICAgICAgYmluZChzZWxmLm1vbnRoTmF2LCBbXCJrZXl1cFwiLCBcImluY3JlbWVudFwiXSwgb25ZZWFySW5wdXQpO1xuICAgICAgICAgIGJpbmQoc2VsZi5kYXlzQ29udGFpbmVyLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKHNlbGVjdERhdGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnRpbWVDb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiBzZWxmLm1pbnV0ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiBzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2VsVGV4dCA9IGZ1bmN0aW9uIHNlbFRleHQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUudGFyZ2V0LnNlbGVjdCgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgW1wiaW5wdXRcIiwgXCJpbmNyZW1lbnRcIl0sIHVwZGF0ZVRpbWUpO1xuICAgICAgICAgIGJpbmQoc2VsZi50aW1lQ29udGFpbmVyLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKHRpbWVJbmNyZW1lbnQpKTtcbiAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgW1wiaW5wdXRcIiwgXCJpbmNyZW1lbnRcIl0sIHNlbGYuX2RlYm91bmNlZENoYW5nZSwge1xuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJpbmQoW3NlbGYuaG91ckVsZW1lbnQsIHNlbGYubWludXRlRWxlbWVudF0sIFtcImZvY3VzXCIsIFwiY2xpY2tcIl0sIHNlbFRleHQpO1xuICAgICAgICAgIGlmIChzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZCkgYmluZChzZWxmLnNlY29uZEVsZW1lbnQsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2Vjb25kRWxlbWVudCAmJiBzZWxmLnNlY29uZEVsZW1lbnQuc2VsZWN0KCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJpbmQoc2VsZi5hbVBNLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZVRpbWUoZSk7XG4gICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24ganVtcFRvRGF0ZShqdW1wRGF0ZSkge1xuICAgICAgICB2YXIganVtcFRvID0ganVtcERhdGUgIT09IHVuZGVmaW5lZCA/IHNlbGYucGFyc2VEYXRlKGp1bXBEYXRlKSA6IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqIHx8IChzZWxmLmNvbmZpZy5taW5EYXRlICYmIHNlbGYuY29uZmlnLm1pbkRhdGUgPiBzZWxmLm5vdyA/IHNlbGYuY29uZmlnLm1pbkRhdGUgOiBzZWxmLmNvbmZpZy5tYXhEYXRlICYmIHNlbGYuY29uZmlnLm1heERhdGUgPCBzZWxmLm5vdyA/IHNlbGYuY29uZmlnLm1heERhdGUgOiBzZWxmLm5vdyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoanVtcFRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBqdW1wVG8uZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0ganVtcFRvLmdldE1vbnRoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZS5tZXNzYWdlID0gXCJJbnZhbGlkIGRhdGUgc3VwcGxpZWQ6IFwiICsganVtcFRvO1xuICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVJbmNyZW1lbnQoZSkge1xuICAgICAgICBpZiAofmUudGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKFwiYXJyb3dcIikpIGluY3JlbWVudE51bUlucHV0KGUsIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93VXBcIikgPyAxIDogLTEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbmNyZW1lbnROdW1JbnB1dChlLCBkZWx0YSwgaW5wdXRFbGVtKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlICYmIGUudGFyZ2V0O1xuICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dEVsZW0gfHwgdGFyZ2V0ICYmIHRhcmdldC5wYXJlbnROb2RlICYmIHRhcmdldC5wYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUV2ZW50KFwiaW5jcmVtZW50XCIpO1xuICAgICAgICBldmVudC5kZWx0YSA9IGRlbHRhO1xuICAgICAgICBpbnB1dCAmJiBpbnB1dC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWNhbGVuZGFyXCIpO1xuICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG5cbiAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKSB7XG4gICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoYnVpbGRNb250aE5hdigpKTtcbiAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1pbm5lckNvbnRhaW5lclwiKTtcblxuICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy53ZWVrTnVtYmVycykge1xuICAgICAgICAgICAgdmFyIF9idWlsZFdlZWtzID0gYnVpbGRXZWVrcygpLFxuICAgICAgICAgICAgICAgIHdlZWtXcmFwcGVyID0gX2J1aWxkV2Vla3Mud2Vla1dyYXBwZXIsXG4gICAgICAgICAgICAgICAgd2Vla051bWJlcnMgPSBfYnVpbGRXZWVrcy53ZWVrTnVtYmVycztcblxuICAgICAgICAgICAgc2VsZi5pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZCh3ZWVrV3JhcHBlcik7XG4gICAgICAgICAgICBzZWxmLndlZWtOdW1iZXJzID0gd2Vla051bWJlcnM7XG4gICAgICAgICAgICBzZWxmLndlZWtXcmFwcGVyID0gd2Vla1dyYXBwZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5yQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1yQ29udGFpbmVyXCIpO1xuICAgICAgICAgIHNlbGYuckNvbnRhaW5lci5hcHBlbmRDaGlsZChidWlsZFdlZWtkYXlzKCkpO1xuXG4gICAgICAgICAgaWYgKCFzZWxmLmRheXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItZGF5c1wiKTtcbiAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICAgIHNlbGYuckNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmRheXNDb250YWluZXIpO1xuICAgICAgICAgIHNlbGYuaW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5yQ29udGFpbmVyKTtcbiAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChzZWxmLmlubmVyQ29udGFpbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoYnVpbGRUaW1lKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyYW5nZU1vZGVcIiwgc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhbmltYXRlXCIsIHNlbGYuY29uZmlnLmFuaW1hdGUgPT09IHRydWUpO1xuICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcIm11bHRpTW9udGhcIiwgc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEpO1xuICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgdmFyIGN1c3RvbUFwcGVuZCA9IHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWQgJiYgc2VsZi5jb25maWcuYXBwZW5kVG8ubm9kZVR5cGUgIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoc2VsZi5jb25maWcuaW5saW5lIHx8IHNlbGYuY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChzZWxmLmNvbmZpZy5pbmxpbmUgPyBcImlubGluZVwiIDogXCJzdGF0aWNcIik7XG5cbiAgICAgICAgICBpZiAoc2VsZi5jb25maWcuaW5saW5lKSB7XG4gICAgICAgICAgICBpZiAoIWN1c3RvbUFwcGVuZCAmJiBzZWxmLmVsZW1lbnQucGFyZW50Tm9kZSkgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIHNlbGYuX2lucHV0Lm5leHRTaWJsaW5nKTtlbHNlIGlmIChzZWxmLmNvbmZpZy5hcHBlbmRUbyAhPT0gdW5kZWZpbmVkKSBzZWxmLmNvbmZpZy5hcHBlbmRUby5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc3RhdGljKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd3JhcHBlclwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmVsZW1lbnQucGFyZW50Tm9kZSkgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHNlbGYuZWxlbWVudCk7XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCkgd3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmFsdElucHV0KTtcbiAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgIXNlbGYuY29uZmlnLmlubGluZSkgKHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWQgPyBzZWxmLmNvbmZpZy5hcHBlbmRUbyA6IHdpbmRvdy5kb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlRGF5KGNsYXNzTmFtZSwgZGF0ZSwgZGF5TnVtYmVyLCBpKSB7XG4gICAgICAgIHZhciBkYXRlSXNFbmFibGVkID0gaXNFbmFibGVkKGRhdGUsIHRydWUpLFxuICAgICAgICAgICAgZGF5RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLWRheSBcIiArIGNsYXNzTmFtZSwgZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGRheUVsZW1lbnQuZGF0ZU9iaiA9IGRhdGU7XG4gICAgICAgIGRheUVsZW1lbnQuJGkgPSBpO1xuICAgICAgICBkYXlFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc2VsZi5mb3JtYXREYXRlKGRhdGUsIHNlbGYuY29uZmlnLmFyaWFEYXRlRm9ybWF0KSk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLm5vdykgPT09IDApIHtcbiAgICAgICAgICBzZWxmLnRvZGF5RGF0ZUVsZW0gPSBkYXlFbGVtZW50O1xuICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInRvZGF5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGVJc0VuYWJsZWQpIHtcbiAgICAgICAgICBkYXlFbGVtZW50LnRhYkluZGV4ID0gLTE7XG5cbiAgICAgICAgICBpZiAoaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpIHtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVFbGVtID0gZGF5RWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhkYXlFbGVtZW50LCBcInN0YXJ0UmFuZ2VcIiwgc2VsZi5zZWxlY3RlZERhdGVzWzBdICYmIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHRydWUpID09PSAwKTtcbiAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZGF5RWxlbWVudCwgXCJlbmRSYW5nZVwiLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0gJiYgY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1sxXSwgdHJ1ZSkgPT09IDApO1xuICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09PSBcIm5leHRNb250aERheVwiKSBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJpblJhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICBpZiAoaXNEYXRlSW5SYW5nZShkYXRlKSAmJiAhaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycyAmJiBzZWxmLmNvbmZpZy5zaG93TW9udGhzID09PSAxICYmIGNsYXNzTmFtZSAhPT0gXCJwcmV2TW9udGhEYXlcIiAmJiBkYXlOdW1iZXIgJSA3ID09PSAxKSB7XG4gICAgICAgICAgc2VsZi53ZWVrTnVtYmVycy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCI8c3BhbiBjbGFzcz0nZmxhdHBpY2tyLWRheSc+XCIgKyBzZWxmLmNvbmZpZy5nZXRXZWVrKGRhdGUpICsgXCI8L3NwYW4+XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50KFwib25EYXlDcmVhdGVcIiwgZGF5RWxlbWVudCk7XG4gICAgICAgIHJldHVybiBkYXlFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmb2N1c09uRGF5KGN1cnJlbnRJbmQsIG9mZnNldCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gY3VycmVudEluZCAhPT0gdW5kZWZpbmVkID8gY3VycmVudEluZCA6IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuJGk7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IChjdXJyZW50SW5kZXggfHwgMCkgKyBvZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHNlbGYuZGF5cy5jaGlsZHJlbiwgZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgICByZXR1cm4gaSA+PSBuZXdJbmRleCAmJiBjLmNsYXNzTmFtZS5pbmRleE9mKFwiTW9udGhEYXlcIikgPT09IC0xICYmIGlzRW5hYmxlZChjLmRhdGVPYmopO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGFyZ2V0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGFyZ2V0Tm9kZS5mb2N1cygpO1xuICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIG9uTW91c2VPdmVyKHRhcmdldE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhEYXlzKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHZhciBmaXJzdE9mTW9udGggPSAobmV3IERhdGUoeWVhciwgbW9udGgsIDEpLmdldERheSgpIC0gc2VsZi5sMTBuLmZpcnN0RGF5T2ZXZWVrICsgNykgJSA3O1xuICAgICAgICB2YXIgcHJldk1vbnRoRGF5cyA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgoKG1vbnRoIC0gMSArIDEyKSAlIDEyKTtcbiAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gc2VsZi51dGlscy5nZXREYXlzSW5Nb250aChtb250aCksXG4gICAgICAgICAgICBkYXlzID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgdmFyIGRheU51bWJlciA9IHByZXZNb250aERheXMgKyAxIC0gZmlyc3RPZk1vbnRoLFxuICAgICAgICAgICAgZGF5SW5kZXggPSAwO1xuXG4gICAgICAgIGZvciAoOyBkYXlOdW1iZXIgPD0gcHJldk1vbnRoRGF5czsgZGF5TnVtYmVyKyssIGRheUluZGV4KyspIHtcbiAgICAgICAgICBkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShcInByZXZNb250aERheVwiLCBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoZGF5TnVtYmVyID0gMTsgZGF5TnVtYmVyIDw9IGRheXNJbk1vbnRoOyBkYXlOdW1iZXIrKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KFwiXCIsIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXlOdW1iZXIpLCBkYXlOdW1iZXIsIGRheUluZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBkYXlOdW0gPSBkYXlzSW5Nb250aCArIDE7IGRheU51bSA8PSA0MiAtIGZpcnN0T2ZNb250aCAmJiAoc2VsZi5jb25maWcuc2hvd01vbnRocyA9PT0gMSB8fCBkYXlJbmRleCAlIDcgIT09IDApOyBkYXlOdW0rKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KFwibmV4dE1vbnRoRGF5XCIsIG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgZGF5TnVtICUgZGF5c0luTW9udGgpLCBkYXlOdW0sIGRheUluZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF5Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImRheUNvbnRhaW5lclwiKTtcbiAgICAgICAgZGF5Q29udGFpbmVyLmFwcGVuZENoaWxkKGRheXMpO1xuICAgICAgICByZXR1cm4gZGF5Q29udGFpbmVyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZERheXMoKSB7XG4gICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyTm9kZShzZWxmLmRheXNDb250YWluZXIpO1xuICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycykgY2xlYXJOb2RlKHNlbGYud2Vla051bWJlcnMpO1xuICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuY29uZmlnLnNob3dNb250aHM7IGkrKykge1xuICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGgsIDEpO1xuICAgICAgICAgIGQuc2V0TW9udGgoc2VsZi5jdXJyZW50TW9udGggKyBpKTtcbiAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGJ1aWxkTW9udGhEYXlzKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmRheXNDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICAgIHNlbGYuZGF5cyA9IHNlbGYuZGF5c0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1vbnRoKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1tb250aFwiKTtcbiAgICAgICAgdmFyIG1vbnRoTmF2RnJhZ21lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICB2YXIgbW9udGhFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJjdXItbW9udGhcIik7XG4gICAgICAgIG1vbnRoRWxlbWVudC50aXRsZSA9IHNlbGYubDEwbi5zY3JvbGxUaXRsZTtcbiAgICAgICAgdmFyIHllYXJJbnB1dCA9IGNyZWF0ZU51bWJlcklucHV0KFwiY3VyLXllYXJcIiwge1xuICAgICAgICAgIHRhYmluZGV4OiBcIi0xXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB5ZWFyRWxlbWVudCA9IHllYXJJbnB1dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICB5ZWFyRWxlbWVudC50aXRsZSA9IHNlbGYubDEwbi5zY3JvbGxUaXRsZTtcbiAgICAgICAgeWVhckVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmwxMG4ueWVhckFyaWFMYWJlbCk7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlKSB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1pblwiLCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUpIHtcbiAgICAgICAgICB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1heFwiLCBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgeWVhckVsZW1lbnQuZGlzYWJsZWQgPSAhIXNlbGYuY29uZmlnLm1pbkRhdGUgJiYgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudE1vbnRoID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1jdXJyZW50LW1vbnRoXCIpO1xuICAgICAgICBjdXJyZW50TW9udGguYXBwZW5kQ2hpbGQobW9udGhFbGVtZW50KTtcbiAgICAgICAgY3VycmVudE1vbnRoLmFwcGVuZENoaWxkKHllYXJJbnB1dCk7XG4gICAgICAgIG1vbnRoTmF2RnJhZ21lbnQuYXBwZW5kQ2hpbGQoY3VycmVudE1vbnRoKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1vbnRoTmF2RnJhZ21lbnQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgIHllYXJFbGVtZW50OiB5ZWFyRWxlbWVudCxcbiAgICAgICAgICBtb250aEVsZW1lbnQ6IG1vbnRoRWxlbWVudFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1vbnRoTmF2KCkge1xuICAgICAgICBzZWxmLm1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1tb250aHNcIik7XG4gICAgICAgIHNlbGYueWVhckVsZW1lbnRzID0gW107XG4gICAgICAgIHNlbGYubW9udGhFbGVtZW50cyA9IFtdO1xuICAgICAgICBzZWxmLnByZXZNb250aE5hdiA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXByZXYtbW9udGhcIik7XG4gICAgICAgIHNlbGYucHJldk1vbnRoTmF2LmlubmVySFRNTCA9IHNlbGYuY29uZmlnLnByZXZBcnJvdztcbiAgICAgICAgc2VsZi5uZXh0TW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1uZXh0LW1vbnRoXCIpO1xuICAgICAgICBzZWxmLm5leHRNb250aE5hdi5pbm5lckhUTUwgPSBzZWxmLmNvbmZpZy5uZXh0QXJyb3c7XG4gICAgICAgIHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQoc2VsZi5wcmV2TW9udGhOYXYpO1xuXG4gICAgICAgIGZvciAodmFyIG0gPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBtLS07KSB7XG4gICAgICAgICAgdmFyIG1vbnRoID0gYnVpbGRNb250aCgpO1xuICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzLnB1c2gobW9udGgueWVhckVsZW1lbnQpO1xuICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50cy5wdXNoKG1vbnRoLm1vbnRoRWxlbWVudCk7XG4gICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChtb250aC5jb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChzZWxmLm5leHRNb250aE5hdik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcIl9oaWRlUHJldk1vbnRoQXJyb3dcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3c7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChib29sKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fX2hpZGVQcmV2TW9udGhBcnJvdyAhPT0gYm9vbCkge1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLnByZXZNb250aE5hdiwgXCJkaXNhYmxlZFwiLCBib29sKTtcbiAgICAgICAgICAgICAgc2VsZi5fX2hpZGVQcmV2TW9udGhBcnJvdyA9IGJvb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fX2hpZGVOZXh0TW9udGhBcnJvdztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJvb2wpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9faGlkZU5leHRNb250aEFycm93ICE9PSBib29sKSB7XG4gICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYubmV4dE1vbnRoTmF2LCBcImRpc2FibGVkXCIsIGJvb2wpO1xuICAgICAgICAgICAgICBzZWxmLl9faGlkZU5leHRNb250aEFycm93ID0gYm9vbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudCA9IHNlbGYueWVhckVsZW1lbnRzWzBdO1xuICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgIHJldHVybiBzZWxmLm1vbnRoTmF2O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZFRpbWUoKSB7XG4gICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1RpbWVcIik7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJub0NhbGVuZGFyXCIpO1xuICAgICAgICBzZWxmLnRpbWVDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXRpbWVcIik7XG4gICAgICAgIHNlbGYudGltZUNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItdGltZS1zZXBhcmF0b3JcIiwgXCI6XCIpO1xuICAgICAgICB2YXIgaG91cklucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3ItaG91clwiKTtcbiAgICAgICAgc2VsZi5ob3VyRWxlbWVudCA9IGhvdXJJbnB1dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICB2YXIgbWludXRlSW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1taW51dGVcIik7XG4gICAgICAgIHNlbGYubWludXRlRWxlbWVudCA9IG1pbnV0ZUlucHV0LmNoaWxkTm9kZXNbMF07XG4gICAgICAgIHNlbGYuaG91ckVsZW1lbnQudGFiSW5kZXggPSBzZWxmLm1pbnV0ZUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgc2VsZi5ob3VyRWxlbWVudC52YWx1ZSA9IHBhZChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldEhvdXJzKCkgOiBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPyBzZWxmLmNvbmZpZy5kZWZhdWx0SG91ciA6IG1pbGl0YXJ5MmFtcG0oc2VsZi5jb25maWcuZGVmYXVsdEhvdXIpKTtcbiAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0TWludXRlcygpIDogc2VsZi5jb25maWcuZGVmYXVsdE1pbnV0ZSk7XG4gICAgICAgIHNlbGYuaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdGVwXCIsIHNlbGYuY29uZmlnLmhvdXJJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0ZXBcIiwgc2VsZi5jb25maWcubWludXRlSW5jcmVtZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtbWluXCIsIHNlbGYuY29uZmlnLnRpbWVfMjRociA/IFwiMFwiIDogXCIxXCIpO1xuICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtbWF4XCIsIHNlbGYuY29uZmlnLnRpbWVfMjRociA/IFwiMjNcIiA6IFwiMTJcIik7XG4gICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1pblwiLCBcIjBcIik7XG4gICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1heFwiLCBcIjU5XCIpO1xuICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoaG91cklucHV0KTtcbiAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlcGFyYXRvcik7XG4gICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChtaW51dGVJbnB1dCk7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50aW1lXzI0aHIpIHNlbGYudGltZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGltZTI0aHJcIik7XG5cbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVNlY29uZHMpIHtcbiAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1NlY29uZHNcIik7XG4gICAgICAgICAgdmFyIHNlY29uZElucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3Itc2Vjb25kXCIpO1xuICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudCA9IHNlY29uZElucHV0LmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0U2Vjb25kcygpIDogc2VsZi5jb25maWcuZGVmYXVsdFNlY29uZHMpO1xuICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0ZXBcIiwgc2VsZi5taW51dGVFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtc3RlcFwiKSk7XG4gICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtbWluXCIsIHNlbGYubWludXRlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1pblwiKSk7XG4gICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtbWF4XCIsIHNlbGYubWludXRlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1heFwiKSk7XG4gICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKSk7XG4gICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlY29uZElucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2VsZi5jb25maWcudGltZV8yNGhyKSB7XG4gICAgICAgICAgc2VsZi5hbVBNID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItYW0tcG1cIiwgc2VsZi5sMTBuLmFtUE1baW50KChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA/IHNlbGYuaG91ckVsZW1lbnQudmFsdWUgOiBzZWxmLmNvbmZpZy5kZWZhdWx0SG91cikgPiAxMSldKTtcbiAgICAgICAgICBzZWxmLmFtUE0udGl0bGUgPSBzZWxmLmwxMG4udG9nZ2xlVGl0bGU7XG4gICAgICAgICAgc2VsZi5hbVBNLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuYW1QTSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi50aW1lQ29udGFpbmVyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZFdlZWtkYXlzKCkge1xuICAgICAgICBpZiAoIXNlbGYud2Vla2RheUNvbnRhaW5lcikgc2VsZi53ZWVrZGF5Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrZGF5c1wiKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5jb25maWcuc2hvd01vbnRoczsgaS0tOykge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtkYXljb250YWluZXJcIik7XG4gICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVXZWVrZGF5cygpO1xuICAgICAgICByZXR1cm4gc2VsZi53ZWVrZGF5Q29udGFpbmVyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVXZWVrZGF5cygpIHtcbiAgICAgICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gc2VsZi5sMTBuLmZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBzZWxmLmwxMG4ud2Vla2RheXMuc2hvcnRoYW5kLmNvbmNhdCgpO1xuXG4gICAgICAgIGlmIChmaXJzdERheU9mV2VlayA+IDAgJiYgZmlyc3REYXlPZldlZWsgPCB3ZWVrZGF5cy5sZW5ndGgpIHtcbiAgICAgICAgICB3ZWVrZGF5cyA9IHdlZWtkYXlzLnNwbGljZShmaXJzdERheU9mV2Vlaywgd2Vla2RheXMubGVuZ3RoKS5jb25jYXQod2Vla2RheXMuc3BsaWNlKDAsIGZpcnN0RGF5T2ZXZWVrKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5jb25maWcuc2hvd01vbnRoczsgaS0tOykge1xuICAgICAgICAgIHNlbGYud2Vla2RheUNvbnRhaW5lci5jaGlsZHJlbltpXS5pbm5lckhUTUwgPSBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPWZsYXRwaWNrci13ZWVrZGF5PlxcbiAgICAgICAgXCIgKyB3ZWVrZGF5cy5qb2luKFwiPC9zcGFuPjxzcGFuIGNsYXNzPWZsYXRwaWNrci13ZWVrZGF5PlwiKSArIFwiXFxuICAgICAgPC9zcGFuPlxcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkV2Vla3MoKSB7XG4gICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1dlZWtzXCIpO1xuICAgICAgICB2YXIgd2Vla1dyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWt3cmFwcGVyXCIpO1xuICAgICAgICB3ZWVrV3JhcHBlci5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci13ZWVrZGF5XCIsIHNlbGYubDEwbi53ZWVrQWJicmV2aWF0aW9uKSk7XG4gICAgICAgIHZhciB3ZWVrTnVtYmVycyA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla3NcIik7XG4gICAgICAgIHdlZWtXcmFwcGVyLmFwcGVuZENoaWxkKHdlZWtOdW1iZXJzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3ZWVrV3JhcHBlcjogd2Vla1dyYXBwZXIsXG4gICAgICAgICAgd2Vla051bWJlcnM6IHdlZWtOdW1iZXJzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoYW5nZU1vbnRoKHZhbHVlLCBpc19vZmZzZXQsIGZyb21fa2V5Ym9hcmQpIHtcbiAgICAgICAgaWYgKGlzX29mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgaXNfb2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tX2tleWJvYXJkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBmcm9tX2tleWJvYXJkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGEgPSBpc19vZmZzZXQgPyB2YWx1ZSA6IHZhbHVlIC0gc2VsZi5jdXJyZW50TW9udGg7XG4gICAgICAgIGlmIChkZWx0YSA8IDAgJiYgc2VsZi5faGlkZVByZXZNb250aEFycm93ID09PSB0cnVlIHx8IGRlbHRhID4gMCAmJiBzZWxmLl9oaWRlTmV4dE1vbnRoQXJyb3cgPT09IHRydWUpIHJldHVybjtcbiAgICAgICAgc2VsZi5jdXJyZW50TW9udGggKz0gZGVsdGE7XG5cbiAgICAgICAgaWYgKHNlbGYuY3VycmVudE1vbnRoIDwgMCB8fCBzZWxmLmN1cnJlbnRNb250aCA+IDExKSB7XG4gICAgICAgICAgc2VsZi5jdXJyZW50WWVhciArPSBzZWxmLmN1cnJlbnRNb250aCA+IDExID8gMSA6IC0xO1xuICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gKHNlbGYuY3VycmVudE1vbnRoICsgMTIpICUgMTI7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgIHRyaWdnZXJFdmVudChcIm9uTW9udGhDaGFuZ2VcIik7XG4gICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcblxuICAgICAgICBpZiAoZnJvbV9rZXlib2FyZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvY3VzT25EYXkodW5kZWZpbmVkLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhcih0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdHJpZ2dlckNoYW5nZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKSBzZWxmLmFsdElucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQgIT09IHVuZGVmaW5lZCkgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IFtdO1xuICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZi5zaG93VGltZUlucHV0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkKSBzZXRIb3Vyc0Zyb21EYXRlKHNlbGYuY29uZmlnLm1pbkRhdGUpO2Vsc2Ugc2V0SG91cnMoc2VsZi5jb25maWcuZGVmYXVsdEhvdXIsIHNlbGYuY29uZmlnLmRlZmF1bHRNaW51dGUsIHNlbGYuY29uZmlnLmRlZmF1bHRTZWNvbmRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgc2VsZi5pc09wZW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXNlbGYuaXNNb2JpbGUpIHtcbiAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGVuXCIpO1xuXG4gICAgICAgICAgc2VsZi5faW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2xvc2VcIik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZyAhPT0gdW5kZWZpbmVkKSB0cmlnZ2VyRXZlbnQoXCJvbkRlc3Ryb3lcIik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYuX2hhbmRsZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHZhciBoID0gc2VsZi5faGFuZGxlcnNbaV07XG4gICAgICAgICAgaC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoaC5ldmVudCwgaC5oYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX2hhbmRsZXJzID0gW107XG5cbiAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQpIHtcbiAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dC5wYXJlbnROb2RlKSBzZWxmLm1vYmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5tb2JpbGVJbnB1dCk7XG4gICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyICYmIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZSkgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuXG4gICAgICAgIGlmIChzZWxmLmFsdElucHV0KSB7XG4gICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQucGFyZW50Tm9kZSkgc2VsZi5hbHRJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmFsdElucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBzZWxmLmlucHV0Ll90eXBlO1xuICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICBzZWxmLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgW1wiX3Nob3dUaW1lSW5wdXRcIiwgXCJsYXRlc3RTZWxlY3RlZERhdGVPYmpcIiwgXCJfaGlkZU5leHRNb250aEFycm93XCIsIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLCBcIl9faGlkZU5leHRNb250aEFycm93XCIsIFwiX19oaWRlUHJldk1vbnRoQXJyb3dcIiwgXCJpc01vYmlsZVwiLCBcImlzT3BlblwiLCBcInNlbGVjdGVkRGF0ZUVsZW1cIiwgXCJtaW5EYXRlSGFzVGltZVwiLCBcIm1heERhdGVIYXNUaW1lXCIsIFwiZGF5c1wiLCBcImRheXNDb250YWluZXJcIiwgXCJfaW5wdXRcIiwgXCJfcG9zaXRpb25FbGVtZW50XCIsIFwiaW5uZXJDb250YWluZXJcIiwgXCJyQ29udGFpbmVyXCIsIFwibW9udGhOYXZcIiwgXCJ0b2RheURhdGVFbGVtXCIsIFwiY2FsZW5kYXJDb250YWluZXJcIiwgXCJ3ZWVrZGF5Q29udGFpbmVyXCIsIFwicHJldk1vbnRoTmF2XCIsIFwibmV4dE1vbnRoTmF2XCIsIFwiY3VycmVudE1vbnRoRWxlbWVudFwiLCBcImN1cnJlbnRZZWFyRWxlbWVudFwiLCBcIm5hdmlnYXRpb25DdXJyZW50TW9udGhcIiwgXCJzZWxlY3RlZERhdGVFbGVtXCIsIFwiY29uZmlnXCJdLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGZba107XG4gICAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQ2FsZW5kYXJFbGVtKGVsZW0pIHtcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFwcGVuZFRvICYmIHNlbGYuY29uZmlnLmFwcGVuZFRvLmNvbnRhaW5zKGVsZW0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY29udGFpbnMoZWxlbSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICBpZiAoc2VsZi5pc09wZW4gJiYgIXNlbGYuY29uZmlnLmlubGluZSkge1xuICAgICAgICAgIHZhciBpc0NhbGVuZGFyRWxlbWVudCA9IGlzQ2FsZW5kYXJFbGVtKGUudGFyZ2V0KTtcbiAgICAgICAgICB2YXIgaXNJbnB1dCA9IGUudGFyZ2V0ID09PSBzZWxmLmlucHV0IHx8IGUudGFyZ2V0ID09PSBzZWxmLmFsdElucHV0IHx8IHNlbGYuZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkgfHwgZS5wYXRoICYmIGUucGF0aC5pbmRleE9mICYmICh+ZS5wYXRoLmluZGV4T2Yoc2VsZi5pbnB1dCkgfHwgfmUucGF0aC5pbmRleE9mKHNlbGYuYWx0SW5wdXQpKTtcbiAgICAgICAgICB2YXIgbG9zdEZvY3VzID0gZS50eXBlID09PSBcImJsdXJcIiA/IGlzSW5wdXQgJiYgZS5yZWxhdGVkVGFyZ2V0ICYmICFpc0NhbGVuZGFyRWxlbShlLnJlbGF0ZWRUYXJnZXQpIDogIWlzSW5wdXQgJiYgIWlzQ2FsZW5kYXJFbGVtZW50O1xuICAgICAgICAgIHZhciBpc0lnbm9yZWQgPSAhc2VsZi5jb25maWcuaWdub3JlZEZvY3VzRWxlbWVudHMuc29tZShmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGFpbnMoZS50YXJnZXQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGxvc3RGb2N1cyAmJiBpc0lnbm9yZWQpIHtcbiAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIiAmJiBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIHNlbGYuY2xlYXIoZmFsc2UpO1xuICAgICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGFuZ2VZZWFyKG5ld1llYXIpIHtcbiAgICAgICAgaWYgKCFuZXdZZWFyIHx8IHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgbmV3WWVhciA8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSB8fCBzZWxmLmNvbmZpZy5tYXhEYXRlICYmIG5ld1llYXIgPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpIHJldHVybjtcbiAgICAgICAgdmFyIG5ld1llYXJOdW0gPSBuZXdZZWFyLFxuICAgICAgICAgICAgaXNOZXdZZWFyID0gc2VsZi5jdXJyZW50WWVhciAhPT0gbmV3WWVhck51bTtcbiAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IG5ld1llYXJOdW0gfHwgc2VsZi5jdXJyZW50WWVhcjtcblxuICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSAmJiBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IE1hdGgubWluKHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKSwgc2VsZi5jdXJyZW50TW9udGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBNYXRoLm1heChzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKCksIHNlbGYuY3VycmVudE1vbnRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05ld1llYXIpIHtcbiAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoZGF0ZSwgdGltZWxlc3MpIHtcbiAgICAgICAgaWYgKHRpbWVsZXNzID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aW1lbGVzcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0ZVRvQ2hlY2sgPSBzZWxmLnBhcnNlRGF0ZShkYXRlLCB1bmRlZmluZWQsIHRpbWVsZXNzKTtcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgZGF0ZVRvQ2hlY2sgJiYgY29tcGFyZURhdGVzKGRhdGVUb0NoZWNrLCBzZWxmLmNvbmZpZy5taW5EYXRlLCB0aW1lbGVzcyAhPT0gdW5kZWZpbmVkID8gdGltZWxlc3MgOiAhc2VsZi5taW5EYXRlSGFzVGltZSkgPCAwIHx8IHNlbGYuY29uZmlnLm1heERhdGUgJiYgZGF0ZVRvQ2hlY2sgJiYgY29tcGFyZURhdGVzKGRhdGVUb0NoZWNrLCBzZWxmLmNvbmZpZy5tYXhEYXRlLCB0aW1lbGVzcyAhPT0gdW5kZWZpbmVkID8gdGltZWxlc3MgOiAhc2VsZi5tYXhEYXRlSGFzVGltZSkgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID09PSAwICYmIHNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGRhdGVUb0NoZWNrID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGJvb2wgPSBzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIGFycmF5ID0gYm9vbCA/IHNlbGYuY29uZmlnLmVuYWJsZSA6IHNlbGYuY29uZmlnLmRpc2FibGU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGQ7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGQgPSBhcnJheVtpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGQgPT09IFwiZnVuY3Rpb25cIiAmJiBkKGRhdGVUb0NoZWNrKSkgcmV0dXJuIGJvb2w7ZWxzZSBpZiAoZCBpbnN0YW5jZW9mIERhdGUgJiYgZGF0ZVRvQ2hlY2sgIT09IHVuZGVmaW5lZCAmJiBkLmdldFRpbWUoKSA9PT0gZGF0ZVRvQ2hlY2suZ2V0VGltZSgpKSByZXR1cm4gYm9vbDtlbHNlIGlmICh0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIiAmJiBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gc2VsZi5wYXJzZURhdGUoZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQgJiYgcGFyc2VkLmdldFRpbWUoKSA9PT0gZGF0ZVRvQ2hlY2suZ2V0VGltZSgpID8gYm9vbCA6ICFib29sO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGQgPT09IFwib2JqZWN0XCIgJiYgZGF0ZVRvQ2hlY2sgIT09IHVuZGVmaW5lZCAmJiBkLmZyb20gJiYgZC50byAmJiBkYXRlVG9DaGVjay5nZXRUaW1lKCkgPj0gZC5mcm9tLmdldFRpbWUoKSAmJiBkYXRlVG9DaGVjay5nZXRUaW1lKCkgPD0gZC50by5nZXRUaW1lKCkpIHJldHVybiBib29sO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICFib29sO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgICB2YXIgaXNJbnB1dCA9IGUudGFyZ2V0ID09PSBzZWxmLl9pbnB1dDtcbiAgICAgICAgdmFyIGNhbGVuZGFyRWxlbSA9IGlzQ2FsZW5kYXJFbGVtKGUudGFyZ2V0KTtcbiAgICAgICAgdmFyIGFsbG93SW5wdXQgPSBzZWxmLmNvbmZpZy5hbGxvd0lucHV0O1xuICAgICAgICB2YXIgYWxsb3dLZXlkb3duID0gc2VsZi5pc09wZW4gJiYgKCFhbGxvd0lucHV0IHx8ICFpc0lucHV0KTtcbiAgICAgICAgdmFyIGFsbG93SW5saW5lS2V5ZG93biA9IHNlbGYuY29uZmlnLmlubGluZSAmJiBpc0lucHV0ICYmICFhbGxvd0lucHV0O1xuXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzICYmIGlzSW5wdXQpIHtcbiAgICAgICAgICBpZiAoYWxsb3dJbnB1dCkge1xuICAgICAgICAgICAgc2VsZi5zZXREYXRlKHNlbGYuX2lucHV0LnZhbHVlLCB0cnVlLCBlLnRhcmdldCA9PT0gc2VsZi5hbHRJbnB1dCA/IHNlbGYuY29uZmlnLmFsdEZvcm1hdCA6IHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgcmV0dXJuIGUudGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICB9IGVsc2Ugc2VsZi5vcGVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FsZW5kYXJFbGVtIHx8IGFsbG93S2V5ZG93biB8fCBhbGxvd0lubGluZUtleWRvd24pIHtcbiAgICAgICAgICB2YXIgaXNUaW1lT2JqID0gISFzZWxmLnRpbWVDb250YWluZXIgJiYgc2VsZi50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KTtcblxuICAgICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBpZiAoaXNUaW1lT2JqKSB1cGRhdGVWYWx1ZSgpO2Vsc2Ugc2VsZWN0RGF0ZShlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZm9jdXNBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgICAgICAgaWYgKGlzSW5wdXQgJiYgIXNlbGYuY29uZmlnLmFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhcigpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICBpZiAoIWlzVGltZU9iaikge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfZGVsdGEgPSBpc0lucHV0ID8gMCA6IGUua2V5Q29kZSA9PT0gMzkgPyAxIDogLTE7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghZS5jdHJsS2V5KSBmb2N1c09uRGF5KHVuZGVmaW5lZCwgX2RlbHRhKTtlbHNlIGNoYW5nZU1vbnRoKF9kZWx0YSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaG91ckVsZW1lbnQpIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZS5rZXlDb2RlID09PSA0MCA/IDEgOiAtMTtcblxuICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICYmIGUudGFyZ2V0LiRpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICBjaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgLSBkZWx0YSk7XG4gICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KGUudGFyZ2V0LiRpLCAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc1RpbWVPYmopIGZvY3VzT25EYXkoZS50YXJnZXQuJGksIGRlbHRhICogNyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNUaW1lT2JqICYmIHNlbGYuaG91ckVsZW1lbnQpIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKGUpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IHNlbGYuaG91ckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnNlbGVjdCgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUudGFyZ2V0ID09PSBzZWxmLm1pbnV0ZUVsZW1lbnQgJiYgKHNlbGYuc2Vjb25kRWxlbWVudCB8fCBzZWxmLmFtUE0pKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZCkgc2VsZi5zZWNvbmRFbGVtZW50LmZvY3VzKCk7ZWxzZSBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHNlbGYuYW1QTS5mb2N1cygpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUudGFyZ2V0ID09PSBzZWxmLnNlY29uZEVsZW1lbnQgJiYgc2VsZi5hbVBNKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS5mb2N1cygpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMF0uY2hhckF0KDApOlxuICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVswXS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkICYmIGUudGFyZ2V0ID09PSBzZWxmLmFtUE0pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVswXTtcbiAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMV0uY2hhckF0KDApOlxuICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVsxXS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkICYmIGUudGFyZ2V0ID09PSBzZWxmLmFtUE0pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVsxXTtcbiAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uS2V5RG93blwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbk1vdXNlT3ZlcihlbGVtKSB7XG4gICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoICE9PSAxIHx8ICFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kYXlcIikgfHwgZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoXCJkaXNhYmxlZFwiKSkgcmV0dXJuO1xuICAgICAgICB2YXIgaG92ZXJEYXRlID0gZWxlbS5kYXRlT2JqLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGluaXRpYWxEYXRlID0gc2VsZi5wYXJzZURhdGUoc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB1bmRlZmluZWQsIHRydWUpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIHJhbmdlU3RhcnREYXRlID0gTWF0aC5taW4oaG92ZXJEYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpKSxcbiAgICAgICAgICAgIHJhbmdlRW5kRGF0ZSA9IE1hdGgubWF4KGhvdmVyRGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKSk7XG4gICAgICAgIHZhciBtb250aHMgPSBzZWxmLmRheXNDb250YWluZXIuY2hpbGRyZW4sXG4gICAgICAgICAgICBmaXJzdERheSA9IG1vbnRoc1swXS5jaGlsZHJlblswXS5kYXRlT2JqLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGxhc3REYXkgPSBtb250aHNbbW9udGhzLmxlbmd0aCAtIDFdLmxhc3RDaGlsZC5kYXRlT2JqLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGNvbnRhaW5zRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG1pblJhbmdlID0gMCxcbiAgICAgICAgICAgIG1heFJhbmdlID0gMDtcblxuICAgICAgICBmb3IgKHZhciB0ID0gZmlyc3REYXk7IHQgPCBsYXN0RGF5OyB0ICs9IGR1cmF0aW9uLkRBWSkge1xuICAgICAgICAgIGlmICghaXNFbmFibGVkKG5ldyBEYXRlKHQpLCB0cnVlKSkge1xuICAgICAgICAgICAgY29udGFpbnNEaXNhYmxlZCA9IGNvbnRhaW5zRGlzYWJsZWQgfHwgdCA+IHJhbmdlU3RhcnREYXRlICYmIHQgPCByYW5nZUVuZERhdGU7XG4gICAgICAgICAgICBpZiAodCA8IGluaXRpYWxEYXRlICYmICghbWluUmFuZ2UgfHwgdCA+IG1pblJhbmdlKSkgbWluUmFuZ2UgPSB0O2Vsc2UgaWYgKHQgPiBpbml0aWFsRGF0ZSAmJiAoIW1heFJhbmdlIHx8IHQgPCBtYXhSYW5nZSkpIG1heFJhbmdlID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHNlbGYuY29uZmlnLnNob3dNb250aHM7IG0rKykge1xuICAgICAgICAgIHZhciBtb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttXTtcbiAgICAgICAgICB2YXIgcHJldk1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW20gLSAxXTtcblxuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGksIGwpIHtcbiAgICAgICAgICAgIHZhciBkYXlFbGVtID0gbW9udGguY2hpbGRyZW5baV0sXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGRheUVsZW0uZGF0ZU9iajtcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBvdXRPZlJhbmdlID0gbWluUmFuZ2UgPiAwICYmIHRpbWVzdGFtcCA8IG1pblJhbmdlIHx8IG1heFJhbmdlID4gMCAmJiB0aW1lc3RhbXAgPiBtYXhSYW5nZTtcblxuICAgICAgICAgICAgaWYgKG91dE9mUmFuZ2UpIHtcbiAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwibm90QWxsb3dlZFwiKTtcbiAgICAgICAgICAgICAgW1wiaW5SYW5nZVwiLCBcInN0YXJ0UmFuZ2VcIiwgXCJlbmRSYW5nZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGFpbnNEaXNhYmxlZCAmJiAhb3V0T2ZSYW5nZSkgcmV0dXJuIFwiY29udGludWVcIjtcblxuICAgICAgICAgICAgW1wic3RhcnRSYW5nZVwiLCBcImluUmFuZ2VcIiwgXCJlbmRSYW5nZVwiLCBcIm5vdEFsbG93ZWRcIl0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChob3ZlckRhdGUgPCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpID8gXCJzdGFydFJhbmdlXCIgOiBcImVuZFJhbmdlXCIpO1xuXG4gICAgICAgICAgICBpZiAobW9udGguY29udGFpbnMoZWxlbSkgfHwgIShtID4gMCAmJiBwcmV2TW9udGggJiYgcHJldk1vbnRoLmxhc3RDaGlsZC5kYXRlT2JqLmdldFRpbWUoKSA+PSB0aW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgIGlmIChpbml0aWFsRGF0ZSA8IGhvdmVyRGF0ZSAmJiB0aW1lc3RhbXAgPT09IGluaXRpYWxEYXRlKSBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJzdGFydFJhbmdlXCIpO2Vsc2UgaWYgKGluaXRpYWxEYXRlID4gaG92ZXJEYXRlICYmIHRpbWVzdGFtcCA9PT0gaW5pdGlhbERhdGUpIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcImVuZFJhbmdlXCIpO1xuICAgICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG1pblJhbmdlICYmIChtYXhSYW5nZSA9PT0gMCB8fCB0aW1lc3RhbXAgPD0gbWF4UmFuZ2UpICYmIGlzQmV0d2Vlbih0aW1lc3RhbXAsIGluaXRpYWxEYXRlLCBob3ZlckRhdGUpKSBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJpblJhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1vbnRoLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChpLCBsKTtcblxuICAgICAgICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAoc2VsZi5pc09wZW4gJiYgIXNlbGYuY29uZmlnLnN0YXRpYyAmJiAhc2VsZi5jb25maWcuaW5saW5lKSBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9wZW4oZSwgcG9zaXRpb25FbGVtZW50KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbkVsZW1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHBvc2l0aW9uRWxlbWVudCA9IHNlbGYuX2lucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuaXNNb2JpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS50YXJnZXQgJiYgZS50YXJnZXQuYmx1cigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkICYmIHNlbGYubW9iaWxlSW5wdXQuY2xpY2soKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk9wZW5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuX2lucHV0LmRpc2FibGVkIHx8IHNlbGYuY29uZmlnLmlubGluZSkgcmV0dXJuO1xuICAgICAgICB2YXIgd2FzT3BlbiA9IHNlbGYuaXNPcGVuO1xuICAgICAgICBzZWxmLmlzT3BlbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF3YXNPcGVuKSB7XG4gICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwib3BlblwiKTtcblxuICAgICAgICAgIHNlbGYuX2lucHV0LmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG5cbiAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk9wZW5cIik7XG4gICAgICAgICAgcG9zaXRpb25DYWxlbmRhcihwb3NpdGlvbkVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUgJiYgc2VsZi5jb25maWcubm9DYWxlbmRhciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzZWxmLnNldERhdGUoc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkID8gbmV3IERhdGUoc2VsZi5jb25maWcubWluRGF0ZS5nZXRUaW1lKCkpIDogbmV3IERhdGUoKS5zZXRIb3VycyhzZWxmLmNvbmZpZy5kZWZhdWx0SG91ciwgc2VsZi5jb25maWcuZGVmYXVsdE1pbnV0ZSwgc2VsZi5jb25maWcuZGVmYXVsdFNlY29uZHMsIDApLCBmYWxzZSk7XG4gICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5ob3VyRWxlbWVudC5zZWxlY3QoKTtcbiAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWluTWF4RGF0ZVNldHRlcih0eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgIHZhciBkYXRlT2JqID0gc2VsZi5jb25maWdbXCJfXCIgKyB0eXBlICsgXCJEYXRlXCJdID0gc2VsZi5wYXJzZURhdGUoZGF0ZSwgc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgdmFyIGludmVyc2VEYXRlT2JqID0gc2VsZi5jb25maWdbXCJfXCIgKyAodHlwZSA9PT0gXCJtaW5cIiA/IFwibWF4XCIgOiBcIm1pblwiKSArIFwiRGF0ZVwiXTtcblxuICAgICAgICAgIGlmIChkYXRlT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGZbdHlwZSA9PT0gXCJtaW5cIiA/IFwibWluRGF0ZUhhc1RpbWVcIiA6IFwibWF4RGF0ZUhhc1RpbWVcIl0gPSBkYXRlT2JqLmdldEhvdXJzKCkgPiAwIHx8IGRhdGVPYmouZ2V0TWludXRlcygpID4gMCB8fCBkYXRlT2JqLmdldFNlY29uZHMoKSA+IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcykge1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gc2VsZi5zZWxlY3RlZERhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICByZXR1cm4gaXNFbmFibGVkKGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggJiYgdHlwZSA9PT0gXCJtaW5cIikgc2V0SG91cnNGcm9tRGF0ZShkYXRlT2JqKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAoZGF0ZU9iaiAhPT0gdW5kZWZpbmVkKSBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudFt0eXBlXSA9IGRhdGVPYmouZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO2Vsc2Ugc2VsZi5jdXJyZW50WWVhckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHR5cGUpO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQuZGlzYWJsZWQgPSAhIWludmVyc2VEYXRlT2JqICYmIGRhdGVPYmogIT09IHVuZGVmaW5lZCAmJiBpbnZlcnNlRGF0ZU9iai5nZXRGdWxsWWVhcigpID09PSBkYXRlT2JqLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXJzZUNvbmZpZygpIHtcbiAgICAgICAgdmFyIGJvb2xPcHRzID0gW1wid3JhcFwiLCBcIndlZWtOdW1iZXJzXCIsIFwiYWxsb3dJbnB1dFwiLCBcImNsaWNrT3BlbnNcIiwgXCJ0aW1lXzI0aHJcIiwgXCJlbmFibGVUaW1lXCIsIFwibm9DYWxlbmRhclwiLCBcImFsdElucHV0XCIsIFwic2hvcnRoYW5kQ3VycmVudE1vbnRoXCIsIFwiaW5saW5lXCIsIFwic3RhdGljXCIsIFwiZW5hYmxlU2Vjb25kc1wiLCBcImRpc2FibGVNb2JpbGVcIl07XG4gICAgICAgIHZhciBob29rcyA9IFtcIm9uQ2hhbmdlXCIsIFwib25DbG9zZVwiLCBcIm9uRGF5Q3JlYXRlXCIsIFwib25EZXN0cm95XCIsIFwib25LZXlEb3duXCIsIFwib25Nb250aENoYW5nZVwiLCBcIm9uT3BlblwiLCBcIm9uUGFyc2VDb25maWdcIiwgXCJvblJlYWR5XCIsIFwib25WYWx1ZVVwZGF0ZVwiLCBcIm9uWWVhckNoYW5nZVwiLCBcIm9uUHJlQ2FsZW5kYXJQb3NpdGlvblwiXTtcbiAgICAgICAgdmFyIHVzZXJDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZUNvbmZpZywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbGVtZW50LmRhdGFzZXQgfHwge30pKSk7XG4gICAgICAgIHZhciBmb3JtYXRzJCQxID0ge307XG4gICAgICAgIHNlbGYuY29uZmlnLnBhcnNlRGF0ZSA9IHVzZXJDb25maWcucGFyc2VEYXRlO1xuICAgICAgICBzZWxmLmNvbmZpZy5mb3JtYXREYXRlID0gdXNlckNvbmZpZy5mb3JtYXREYXRlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwiZW5hYmxlXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbmZpZy5fZW5hYmxlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZGF0ZXMpIHtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLl9lbmFibGUgPSBwYXJzZURhdGVSdWxlcyhkYXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcImRpc2FibGVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29uZmlnLl9kaXNhYmxlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZGF0ZXMpIHtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLl9kaXNhYmxlID0gcGFyc2VEYXRlUnVsZXMoZGF0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF1c2VyQ29uZmlnLmRhdGVGb3JtYXQgJiYgdXNlckNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgZm9ybWF0cyQkMS5kYXRlRm9ybWF0ID0gdXNlckNvbmZpZy5ub0NhbGVuZGFyID8gXCJIOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKSA6IGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLmRhdGVGb3JtYXQgKyBcIiBIOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VyQ29uZmlnLmFsdElucHV0ICYmIHVzZXJDb25maWcuZW5hYmxlVGltZSAmJiAhdXNlckNvbmZpZy5hbHRGb3JtYXQpIHtcbiAgICAgICAgICBmb3JtYXRzJCQxLmFsdEZvcm1hdCA9IHVzZXJDb25maWcubm9DYWxlbmRhciA/IFwiaDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6UyBLXCIgOiBcIiBLXCIpIDogZmxhdHBpY2tyLmRlZmF1bHRDb25maWcuYWx0Rm9ybWF0ICsgKFwiIGg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpICsgXCIgS1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtaW5EYXRlXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbmZpZy5fbWluRGF0ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogbWluTWF4RGF0ZVNldHRlcihcIm1pblwiKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1heERhdGVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29uZmlnLl9tYXhEYXRlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBtaW5NYXhEYXRlU2V0dGVyKFwibWF4XCIpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBtaW5NYXhUaW1lU2V0dGVyID0gZnVuY3Rpb24gbWluTWF4VGltZVNldHRlcih0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnW3R5cGUgPT09IFwibWluXCIgPyBcIl9taW5UaW1lXCIgOiBcIl9tYXhUaW1lXCJdID0gc2VsZi5wYXJzZURhdGUodmFsLCBcIkg6aVwiKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtaW5UaW1lXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbmZpZy5fbWluVGltZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogbWluTWF4VGltZVNldHRlcihcIm1pblwiKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1heFRpbWVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29uZmlnLl9tYXhUaW1lO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBtaW5NYXhUaW1lU2V0dGVyKFwibWF4XCIpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlbGYuY29uZmlnLCBmb3JtYXRzJCQxLCB1c2VyQ29uZmlnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xPcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID0gc2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID09PSB0cnVlIHx8IHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaSA9IGhvb2tzLmxlbmd0aDsgX2ktLTspIHtcbiAgICAgICAgICBpZiAoc2VsZi5jb25maWdbaG9va3NbX2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLmNvbmZpZ1tob29rc1tfaV1dID0gYXJyYXlpZnkoc2VsZi5jb25maWdbaG9va3NbX2ldXSB8fCBbXSkubWFwKGJpbmRUb0luc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLmNvbmZpZy5lbmFibGVUaW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHNlbGYuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBwbHVnaW5Db25mID0gc2VsZi5jb25maWcucGx1Z2luc1tfaTJdKHNlbGYpIHx8IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHBsdWdpbkNvbmYpIHtcbiAgICAgICAgICAgIGlmICh+aG9va3MuaW5kZXhPZihrZXkpKSB7XG4gICAgICAgICAgICAgIHNlbGYuY29uZmlnW2tleV0gPSBhcnJheWlmeShwbHVnaW5Db25mW2tleV0pLm1hcChiaW5kVG9JbnN0YW5jZSkuY29uY2F0KHNlbGYuY29uZmlnW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdXNlckNvbmZpZ1trZXldID09PSBcInVuZGVmaW5lZFwiKSBzZWxmLmNvbmZpZ1trZXldID0gcGx1Z2luQ29uZltrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuaXNNb2JpbGUgPSAhc2VsZi5jb25maWcuZGlzYWJsZU1vYmlsZSAmJiAhc2VsZi5jb25maWcuaW5saW5lICYmIHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIgJiYgIXNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoICYmICFzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoICYmICFzZWxmLmNvbmZpZy53ZWVrTnVtYmVycyAmJiAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIHRyaWdnZXJFdmVudChcIm9uUGFyc2VDb25maWdcIik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldHVwTG9jYWxlKCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYuY29uZmlnLmxvY2FsZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZmxhdHBpY2tyLmwxMG5zW3NlbGYuY29uZmlnLmxvY2FsZV0gPT09IFwidW5kZWZpbmVkXCIpIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJmbGF0cGlja3I6IGludmFsaWQgbG9jYWxlIFwiICsgc2VsZi5jb25maWcubG9jYWxlKSk7XG4gICAgICAgIHNlbGYubDEwbiA9IE9iamVjdC5hc3NpZ24oe30sIGZsYXRwaWNrci5sMTBucy5kZWZhdWx0LCB0eXBlb2Ygc2VsZi5jb25maWcubG9jYWxlID09PSBcIm9iamVjdFwiID8gc2VsZi5jb25maWcubG9jYWxlIDogc2VsZi5jb25maWcubG9jYWxlICE9PSBcImRlZmF1bHRcIiA/IGZsYXRwaWNrci5sMTBuc1tzZWxmLmNvbmZpZy5sb2NhbGVdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgdG9rZW5SZWdleC5LID0gXCIoXCIgKyBzZWxmLmwxMG4uYW1QTVswXSArIFwifFwiICsgc2VsZi5sMTBuLmFtUE1bMV0gKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzBdLnRvTG93ZXJDYXNlKCkgKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzFdLnRvTG93ZXJDYXNlKCkgKyBcIilcIjtcbiAgICAgICAgc2VsZi5mb3JtYXREYXRlID0gY3JlYXRlRGF0ZUZvcm1hdHRlcihzZWxmKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcG9zaXRpb25DYWxlbmRhcihjdXN0b21Qb3NpdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblByZUNhbGVuZGFyUG9zaXRpb25cIik7XG4gICAgICAgIHZhciBwb3NpdGlvbkVsZW1lbnQgPSBjdXN0b21Qb3NpdGlvbkVsZW1lbnQgfHwgc2VsZi5fcG9zaXRpb25FbGVtZW50O1xuICAgICAgICB2YXIgY2FsZW5kYXJIZWlnaHQgPSBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jaGlsZHJlbiwgZnVuY3Rpb24gKGFjYywgY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gYWNjICsgY2hpbGQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9LCAwKSxcbiAgICAgICAgICAgIGNhbGVuZGFyV2lkdGggPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgY29uZmlnUG9zID0gc2VsZi5jb25maWcucG9zaXRpb24sXG4gICAgICAgICAgICBpbnB1dEJvdW5kcyA9IHBvc2l0aW9uRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGRpc3RhbmNlRnJvbUJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGlucHV0Qm91bmRzLmJvdHRvbSxcbiAgICAgICAgICAgIHNob3dPblRvcCA9IGNvbmZpZ1BvcyA9PT0gXCJhYm92ZVwiIHx8IGNvbmZpZ1BvcyAhPT0gXCJiZWxvd1wiICYmIGRpc3RhbmNlRnJvbUJvdHRvbSA8IGNhbGVuZGFySGVpZ2h0ICYmIGlucHV0Qm91bmRzLnRvcCA+IGNhbGVuZGFySGVpZ2h0O1xuICAgICAgICB2YXIgdG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0ICsgaW5wdXRCb3VuZHMudG9wICsgKCFzaG93T25Ub3AgPyBwb3NpdGlvbkVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgMiA6IC1jYWxlbmRhckhlaWdodCAtIDIpO1xuICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFycm93VG9wXCIsICFzaG93T25Ub3ApO1xuICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFycm93Qm90dG9tXCIsIHNob3dPblRvcCk7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5pbmxpbmUpIHJldHVybjtcbiAgICAgICAgdmFyIGxlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgKyBpbnB1dEJvdW5kcy5sZWZ0O1xuICAgICAgICB2YXIgcmlnaHQgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAtIGlucHV0Qm91bmRzLnJpZ2h0O1xuICAgICAgICB2YXIgcmlnaHRNb3N0ID0gbGVmdCArIGNhbGVuZGFyV2lkdGggPiB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyaWdodE1vc3RcIiwgcmlnaHRNb3N0KTtcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYykgcmV0dXJuO1xuICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcblxuICAgICAgICBpZiAoIXJpZ2h0TW9zdCkge1xuICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSByaWdodCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyIHx8IHNlbGYuaXNNb2JpbGUpIHJldHVybjtcbiAgICAgICAgdXBkYXRlV2Vla2RheXMoKTtcbiAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICBidWlsZERheXMoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZm9jdXNBbmRDbG9zZSgpIHtcbiAgICAgICAgc2VsZi5faW5wdXQuZm9jdXMoKTtcblxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgIT09IC0xIHx8IG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KHNlbGYuY2xvc2UsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZWxlY3REYXRlKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHZhciBpc1NlbGVjdGFibGUgPSBmdW5jdGlvbiBpc1NlbGVjdGFibGUoZGF5KSB7XG4gICAgICAgICAgcmV0dXJuIGRheS5jbGFzc0xpc3QgJiYgZGF5LmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kYXlcIikgJiYgIWRheS5jbGFzc0xpc3QuY29udGFpbnMoXCJkaXNhYmxlZFwiKSAmJiAhZGF5LmNsYXNzTGlzdC5jb250YWlucyhcIm5vdEFsbG93ZWRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHQgPSBmaW5kUGFyZW50KGUudGFyZ2V0LCBpc1NlbGVjdGFibGUpO1xuICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgIHZhciB0YXJnZXQgPSB0O1xuICAgICAgICB2YXIgc2VsZWN0ZWREYXRlID0gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBuZXcgRGF0ZSh0YXJnZXQuZGF0ZU9iai5nZXRUaW1lKCkpO1xuICAgICAgICB2YXIgc2hvdWxkQ2hhbmdlTW9udGggPSAoc2VsZWN0ZWREYXRlLmdldE1vbnRoKCkgPCBzZWxmLmN1cnJlbnRNb250aCB8fCBzZWxlY3RlZERhdGUuZ2V0TW9udGgoKSA+IHNlbGYuY3VycmVudE1vbnRoICsgc2VsZi5jb25maWcuc2hvd01vbnRocyAtIDEpICYmIHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIjtcbiAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVFbGVtID0gdGFyZ2V0O1xuICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIikgc2VsZi5zZWxlY3RlZERhdGVzID0gW3NlbGVjdGVkRGF0ZV07ZWxzZSBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJtdWx0aXBsZVwiKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSBpc0RhdGVTZWxlY3RlZChzZWxlY3RlZERhdGUpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4KSBzZWxmLnNlbGVjdGVkRGF0ZXMuc3BsaWNlKHBhcnNlSW50KHNlbGVjdGVkSW5kZXgpLCAxKTtlbHNlIHNlbGYuc2VsZWN0ZWREYXRlcy5wdXNoKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIpIHNlbGYuY2xlYXIoZmFsc2UpO1xuICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5wdXNoKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgaWYgKGNvbXBhcmVEYXRlcyhzZWxlY3RlZERhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgdHJ1ZSkgIT09IDApIHNlbGYuc2VsZWN0ZWREYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcblxuICAgICAgICBpZiAoc2hvdWxkQ2hhbmdlTW9udGgpIHtcbiAgICAgICAgICB2YXIgaXNOZXdZZWFyID0gc2VsZi5jdXJyZW50WWVhciAhPT0gc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IHNlbGVjdGVkRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gc2VsZWN0ZWREYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgaWYgKGlzTmV3WWVhcikgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uTW9udGhDaGFuZ2VcIik7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSAmJiBzZWxmLm1pbkRhdGVIYXNUaW1lICYmIHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgJiYgY29tcGFyZURhdGVzKHNlbGVjdGVkRGF0ZSwgc2VsZi5jb25maWcubWluRGF0ZSkgPT09IDApIHNldEhvdXJzRnJvbURhdGUoc2VsZi5jb25maWcubWluRGF0ZSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5zaG93VGltZUlucHV0ID0gdHJ1ZTtcbiAgICAgICAgfSwgNTApO1xuXG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgb25Nb3VzZU92ZXIodGFyZ2V0KTtcbiAgICAgICAgICB9IGVsc2UgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaG91bGRDaGFuZ2VNb250aCAmJiBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgJiYgc2VsZi5jb25maWcuc2hvd01vbnRocyA9PT0gMSkgZm9jdXNPbkRheSh0YXJnZXQuJGksIDApO2Vsc2Ugc2VsZi5zZWxlY3RlZERhdGVFbGVtICYmIHNlbGYuc2VsZWN0ZWREYXRlRWxlbS5mb2N1cygpO1xuICAgICAgICBpZiAoc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkKSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIHNlbGYuaG91ckVsZW1lbnQuc2VsZWN0KCk7XG4gICAgICAgIH0sIDQ1MSk7XG5cbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLmNsb3NlT25TZWxlY3QpIHtcbiAgICAgICAgICB2YXIgc2luZ2xlID0gc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIiAmJiAhc2VsZi5jb25maWcuZW5hYmxlVGltZTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIgJiYgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMiAmJiAhc2VsZi5jb25maWcuZW5hYmxlVGltZTtcblxuICAgICAgICAgIGlmIChzaW5nbGUgfHwgcmFuZ2UpIHtcbiAgICAgICAgICAgIGZvY3VzQW5kQ2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBDQUxMQkFDS1MgPSB7XG4gICAgICAgIGxvY2FsZTogW3NldHVwTG9jYWxlXVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gc2V0KG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbiAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uID09PSBcIm9iamVjdFwiKSBPYmplY3QuYXNzaWduKHNlbGYuY29uZmlnLCBvcHRpb24pO2Vsc2Uge1xuICAgICAgICAgIHNlbGYuY29uZmlnW29wdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoQ0FMTEJBQ0tTW29wdGlvbl0gIT09IHVuZGVmaW5lZCkgQ0FMTEJBQ0tTW29wdGlvbl0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHgoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICBqdW1wVG9EYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGVkRGF0ZShpbnB1dERhdGUsIGZvcm1hdCkge1xuICAgICAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICAgICAgaWYgKGlucHV0RGF0ZSBpbnN0YW5jZW9mIEFycmF5KSBkYXRlcyA9IGlucHV0RGF0ZS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5wYXJzZURhdGUoZCwgZm9ybWF0KTtcbiAgICAgICAgfSk7ZWxzZSBpZiAoaW5wdXREYXRlIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgaW5wdXREYXRlID09PSBcIm51bWJlclwiKSBkYXRlcyA9IFtzZWxmLnBhcnNlRGF0ZShpbnB1dERhdGUsIGZvcm1hdCldO2Vsc2UgaWYgKHR5cGVvZiBpbnB1dERhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNlbGYuY29uZmlnLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzaW5nbGVcIjpcbiAgICAgICAgICAgICAgZGF0ZXMgPSBbc2VsZi5wYXJzZURhdGUoaW5wdXREYXRlLCBmb3JtYXQpXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICBkYXRlcyA9IGlucHV0RGF0ZS5zcGxpdChzZWxmLmNvbmZpZy5jb25qdW5jdGlvbikubWFwKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyc2VEYXRlKGRhdGUsIGZvcm1hdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInJhbmdlXCI6XG4gICAgICAgICAgICAgIGRhdGVzID0gaW5wdXREYXRlLnNwbGl0KHNlbGYubDEwbi5yYW5nZVNlcGFyYXRvcikubWFwKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyc2VEYXRlKGRhdGUsIGZvcm1hdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Ugc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBzdXBwbGllZDogXCIgKyBKU09OLnN0cmluZ2lmeShpbnB1dERhdGUpKSk7XG4gICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IGRhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkIGluc3RhbmNlb2YgRGF0ZSAmJiBpc0VuYWJsZWQoZCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikgc2VsZi5zZWxlY3RlZERhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldERhdGUoZGF0ZSwgdHJpZ2dlckNoYW5nZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICBmb3JtYXQgPSBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGUgIT09IDAgJiYgIWRhdGUpIHJldHVybiBzZWxmLmNsZWFyKHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICBzZXRTZWxlY3RlZERhdGUoZGF0ZSwgZm9ybWF0KTtcbiAgICAgICAgc2VsZi5zaG93VGltZUlucHV0ID0gc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDA7XG4gICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gc2VsZi5zZWxlY3RlZERhdGVzWzBdO1xuICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICBqdW1wVG9EYXRlKCk7XG4gICAgICAgIHNldEhvdXJzRnJvbURhdGUoKTtcbiAgICAgICAgdXBkYXRlVmFsdWUodHJpZ2dlckNoYW5nZSk7XG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGFyc2VEYXRlUnVsZXMoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBydWxlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBydWxlID09PSBcIm51bWJlclwiIHx8IHJ1bGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wYXJzZURhdGUocnVsZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUgJiYgdHlwZW9mIHJ1bGUgPT09IFwib2JqZWN0XCIgJiYgcnVsZS5mcm9tICYmIHJ1bGUudG8pIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBzZWxmLnBhcnNlRGF0ZShydWxlLmZyb20sIHVuZGVmaW5lZCksXG4gICAgICAgICAgICB0bzogc2VsZi5wYXJzZURhdGUocnVsZS50bywgdW5kZWZpbmVkKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXR1cERhdGVzKCkge1xuICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgc2VsZi5ub3cgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5ub3cpIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciBwcmVsb2FkZWREYXRlID0gc2VsZi5jb25maWcuZGVmYXVsdERhdGUgfHwgc2VsZi5pbnB1dC52YWx1ZTtcbiAgICAgICAgaWYgKHByZWxvYWRlZERhdGUpIHNldFNlbGVjdGVkRGF0ZShwcmVsb2FkZWREYXRlLCBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KTtcbiAgICAgICAgdmFyIGluaXRpYWxEYXRlID0gc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDAgPyBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0gOiBzZWxmLmNvbmZpZy5taW5EYXRlICYmIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0VGltZSgpID4gc2VsZi5ub3cuZ2V0VGltZSgpID8gc2VsZi5jb25maWcubWluRGF0ZSA6IHNlbGYuY29uZmlnLm1heERhdGUgJiYgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRUaW1lKCkgPCBzZWxmLm5vdy5nZXRUaW1lKCkgPyBzZWxmLmNvbmZpZy5tYXhEYXRlIDogc2VsZi5ub3c7XG4gICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBpbml0aWFsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IGluaXRpYWxEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMCkgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxmLnNlbGVjdGVkRGF0ZXNbMF07XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWQpIHNlbGYuY29uZmlnLm1pblRpbWUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5taW5UaW1lLCBcIkg6aVwiKTtcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heFRpbWUgIT09IHVuZGVmaW5lZCkgc2VsZi5jb25maWcubWF4VGltZSA9IHNlbGYucGFyc2VEYXRlKHNlbGYuY29uZmlnLm1heFRpbWUsIFwiSDppXCIpO1xuICAgICAgICBzZWxmLm1pbkRhdGVIYXNUaW1lID0gISFzZWxmLmNvbmZpZy5taW5EYXRlICYmIChzZWxmLmNvbmZpZy5taW5EYXRlLmdldEhvdXJzKCkgPiAwIHx8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TWludXRlcygpID4gMCB8fCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldFNlY29uZHMoKSA+IDApO1xuICAgICAgICBzZWxmLm1heERhdGVIYXNUaW1lID0gISFzZWxmLmNvbmZpZy5tYXhEYXRlICYmIChzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEhvdXJzKCkgPiAwIHx8IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TWludXRlcygpID4gMCB8fCBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldFNlY29uZHMoKSA+IDApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJzaG93VGltZUlucHV0XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9zaG93VGltZUlucHV0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYm9vbCkge1xuICAgICAgICAgICAgc2VsZi5fc2hvd1RpbWVJbnB1dCA9IGJvb2w7XG4gICAgICAgICAgICBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lcikgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJzaG93VGltZUlucHV0XCIsIGJvb2wpO1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gJiYgcG9zaXRpb25DYWxlbmRhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldHVwSW5wdXRzKCkge1xuICAgICAgICBzZWxmLmlucHV0ID0gc2VsZi5jb25maWcud3JhcCA/IGVsZW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLWlucHV0XVwiKSA6IGVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCFzZWxmLmlucHV0KSB7XG4gICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgZWxlbWVudCBzcGVjaWZpZWRcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuaW5wdXQuX3R5cGUgPSBzZWxmLmlucHV0LnR5cGU7XG4gICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICBzZWxmLmlucHV0LmNsYXNzTGlzdC5hZGQoXCJmbGF0cGlja3ItaW5wdXRcIik7XG4gICAgICAgIHNlbGYuX2lucHV0ID0gc2VsZi5pbnB1dDtcblxuICAgICAgICBpZiAoc2VsZi5jb25maWcuYWx0SW5wdXQpIHtcbiAgICAgICAgICBzZWxmLmFsdElucHV0ID0gY3JlYXRlRWxlbWVudChzZWxmLmlucHV0Lm5vZGVOYW1lLCBzZWxmLmlucHV0LmNsYXNzTmFtZSArIFwiIFwiICsgc2VsZi5jb25maWcuYWx0SW5wdXRDbGFzcyk7XG4gICAgICAgICAgc2VsZi5faW5wdXQgPSBzZWxmLmFsdElucHV0O1xuICAgICAgICAgIHNlbGYuYWx0SW5wdXQucGxhY2Vob2xkZXIgPSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyO1xuICAgICAgICAgIHNlbGYuYWx0SW5wdXQuZGlzYWJsZWQgPSBzZWxmLmlucHV0LmRpc2FibGVkO1xuICAgICAgICAgIHNlbGYuYWx0SW5wdXQucmVxdWlyZWQgPSBzZWxmLmlucHV0LnJlcXVpcmVkO1xuICAgICAgICAgIHNlbGYuYWx0SW5wdXQudGFiSW5kZXggPSBzZWxmLmlucHV0LnRhYkluZGV4O1xuICAgICAgICAgIHNlbGYuYWx0SW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgc2VsZi5pbnB1dC5wYXJlbnROb2RlKSBzZWxmLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuYWx0SW5wdXQsIHNlbGYuaW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5hbGxvd0lucHV0KSBzZWxmLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICBzZWxmLl9wb3NpdGlvbkVsZW1lbnQgPSBzZWxmLmNvbmZpZy5wb3NpdGlvbkVsZW1lbnQgfHwgc2VsZi5faW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldHVwTW9iaWxlKCkge1xuICAgICAgICB2YXIgaW5wdXRUeXBlID0gc2VsZi5jb25maWcuZW5hYmxlVGltZSA/IHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPyBcInRpbWVcIiA6IFwiZGF0ZXRpbWUtbG9jYWxcIiA6IFwiZGF0ZVwiO1xuICAgICAgICBzZWxmLm1vYmlsZUlucHV0ID0gY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHNlbGYuaW5wdXQuY2xhc3NOYW1lICsgXCIgZmxhdHBpY2tyLW1vYmlsZVwiKTtcbiAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5zdGVwID0gc2VsZi5pbnB1dC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpIHx8IFwiYW55XCI7XG4gICAgICAgIHNlbGYubW9iaWxlSW5wdXQudGFiSW5kZXggPSAxO1xuICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnR5cGUgPSBpbnB1dFR5cGU7XG4gICAgICAgIHNlbGYubW9iaWxlSW5wdXQuZGlzYWJsZWQgPSBzZWxmLmlucHV0LmRpc2FibGVkO1xuICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnJlcXVpcmVkID0gc2VsZi5pbnB1dC5yZXF1aXJlZDtcbiAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5wbGFjZWhvbGRlciA9IHNlbGYuaW5wdXQucGxhY2Vob2xkZXI7XG4gICAgICAgIHNlbGYubW9iaWxlRm9ybWF0U3RyID0gaW5wdXRUeXBlID09PSBcImRhdGV0aW1lLWxvY2FsXCIgPyBcIlktbS1kXFxcXFRIOmk6U1wiIDogaW5wdXRUeXBlID09PSBcImRhdGVcIiA/IFwiWS1tLWRcIiA6IFwiSDppOlNcIjtcblxuICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmRlZmF1bHRWYWx1ZSA9IHNlbGYubW9iaWxlSW5wdXQudmFsdWUgPSBzZWxmLmZvcm1hdERhdGUoc2VsZi5zZWxlY3RlZERhdGVzWzBdLCBzZWxmLm1vYmlsZUZvcm1hdFN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSkgc2VsZi5tb2JpbGVJbnB1dC5taW4gPSBzZWxmLmZvcm1hdERhdGUoc2VsZi5jb25maWcubWluRGF0ZSwgXCJZLW0tZFwiKTtcbiAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUpIHNlbGYubW9iaWxlSW5wdXQubWF4ID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuY29uZmlnLm1heERhdGUsIFwiWS1tLWRcIik7XG4gICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIGlmIChzZWxmLmFsdElucHV0ICE9PSB1bmRlZmluZWQpIHNlbGYuYWx0SW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc2VsZi5pbnB1dC5wYXJlbnROb2RlKSBzZWxmLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYubW9iaWxlSW5wdXQsIHNlbGYuaW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGNhdGNoIChfYSkge31cblxuICAgICAgICBiaW5kKHNlbGYubW9iaWxlSW5wdXQsIFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgc2VsZi5zZXREYXRlKGUudGFyZ2V0LnZhbHVlLCBmYWxzZSwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpO1xuICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2xvc2VcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICAgIGlmIChzZWxmLmlzT3BlbikgcmV0dXJuIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgc2VsZi5vcGVuKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudCwgZGF0YSkge1xuICAgICAgICB2YXIgaG9va3MgPSBzZWxmLmNvbmZpZ1tldmVudF07XG5cbiAgICAgICAgaWYgKGhvb2tzICE9PSB1bmRlZmluZWQgJiYgaG9va3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBob29rc1tpXSAmJiBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGhvb2tzW2ldKHNlbGYuc2VsZWN0ZWREYXRlcywgc2VsZi5pbnB1dC52YWx1ZSwgc2VsZiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50ID09PSBcIm9uQ2hhbmdlXCIpIHtcbiAgICAgICAgICBzZWxmLmlucHV0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoXCJjaGFuZ2VcIikpO1xuICAgICAgICAgIHNlbGYuaW5wdXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChcImlucHV0XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChuYW1lKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICAgICAgZS5pbml0RXZlbnQobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0RhdGVTZWxlY3RlZChkYXRlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVEYXRlcyhzZWxmLnNlbGVjdGVkRGF0ZXNbaV0sIGRhdGUpID09PSAwKSByZXR1cm4gXCJcIiArIGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzRGF0ZUluUmFuZ2UoZGF0ZSkge1xuICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiIHx8IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdKSA+PSAwICYmIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0pIDw9IDA7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKSB7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyIHx8IHNlbGYuaXNNb2JpbGUgfHwgIXNlbGYubW9udGhOYXYpIHJldHVybjtcbiAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoeWVhckVsZW1lbnQsIGkpIHtcbiAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHNlbGYuY3VycmVudFllYXIsIHNlbGYuY3VycmVudE1vbnRoLCAxKTtcbiAgICAgICAgICBkLnNldE1vbnRoKHNlbGYuY3VycmVudE1vbnRoICsgaSk7XG4gICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzW2ldLnRleHRDb250ZW50ID0gbW9udGhUb1N0cihkLmdldE1vbnRoKCksIHNlbGYuY29uZmlnLnNob3J0aGFuZEN1cnJlbnRNb250aCwgc2VsZi5sMTBuKSArIFwiIFwiO1xuICAgICAgICAgIHllYXJFbGVtZW50LnZhbHVlID0gZC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgPSBzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQgJiYgKHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSA/IHNlbGYuY3VycmVudE1vbnRoIDw9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TW9udGgoKSA6IHNlbGYuY3VycmVudFllYXIgPCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgICBzZWxmLl9oaWRlTmV4dE1vbnRoQXJyb3cgPSBzZWxmLmNvbmZpZy5tYXhEYXRlICE9PSB1bmRlZmluZWQgJiYgKHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSA/IHNlbGYuY3VycmVudE1vbnRoICsgMSA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKSA6IHNlbGYuY3VycmVudFllYXIgPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZSh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gc2VsZi5jbGVhcih0cmlnZ2VyQ2hhbmdlKTtcblxuICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkICYmIHNlbGYubW9iaWxlRm9ybWF0U3RyKSB7XG4gICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICE9PSB1bmRlZmluZWQgPyBzZWxmLmZvcm1hdERhdGUoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmosIHNlbGYubW9iaWxlRm9ybWF0U3RyKSA6IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgam9pbkNoYXIgPSBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgPyBzZWxmLmNvbmZpZy5jb25qdW5jdGlvbiA6IHNlbGYubDEwbi5yYW5nZVNlcGFyYXRvcjtcbiAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9IHNlbGYuc2VsZWN0ZWREYXRlcy5tYXAoZnVuY3Rpb24gKGRPYmopIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXREYXRlKGRPYmosIHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICB9KS5qb2luKGpvaW5DaGFyKTtcblxuICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZi5hbHRJbnB1dC52YWx1ZSA9IHNlbGYuc2VsZWN0ZWREYXRlcy5tYXAoZnVuY3Rpb24gKGRPYmopIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmZvcm1hdERhdGUoZE9iaiwgc2VsZi5jb25maWcuYWx0Rm9ybWF0KTtcbiAgICAgICAgICB9KS5qb2luKGpvaW5DaGFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlICE9PSBmYWxzZSkgdHJpZ2dlckV2ZW50KFwib25WYWx1ZVVwZGF0ZVwiKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Nb250aE5hdkNsaWNrKGUpIHtcbiAgICAgICAgdmFyIGlzUHJldk1vbnRoID0gc2VsZi5wcmV2TW9udGhOYXYuY29udGFpbnMoZS50YXJnZXQpO1xuICAgICAgICB2YXIgaXNOZXh0TW9udGggPSBzZWxmLm5leHRNb250aE5hdi5jb250YWlucyhlLnRhcmdldCk7XG5cbiAgICAgICAgaWYgKGlzUHJldk1vbnRoIHx8IGlzTmV4dE1vbnRoKSB7XG4gICAgICAgICAgY2hhbmdlTW9udGgoaXNQcmV2TW9udGggPyAtMSA6IDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYueWVhckVsZW1lbnRzLmluZGV4T2YoZS50YXJnZXQpID49IDApIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS50YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXJyb3dVcFwiKSkge1xuICAgICAgICAgIHNlbGYuY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyICsgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXJyb3dEb3duXCIpKSB7XG4gICAgICAgICAgc2VsZi5jaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lV3JhcHBlcihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGlzS2V5RG93biA9IGUudHlwZSA9PT0gXCJrZXlkb3duXCIsXG4gICAgICAgICAgICBpbnB1dCA9IGUudGFyZ2V0O1xuXG4gICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCAmJiBlLnRhcmdldCA9PT0gc2VsZi5hbVBNKSB7XG4gICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID0gc2VsZi5sMTBuLmFtUE1baW50KHNlbGYuYW1QTS50ZXh0Q29udGVudCA9PT0gc2VsZi5sMTBuLmFtUE1bMF0pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW4gPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtbWluXCIpKSxcbiAgICAgICAgICAgIG1heCA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYXhcIikpLFxuICAgICAgICAgICAgc3RlcCA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdGVwXCIpKSxcbiAgICAgICAgICAgIGN1clZhbHVlID0gcGFyc2VJbnQoaW5wdXQudmFsdWUsIDEwKSxcbiAgICAgICAgICAgIGRlbHRhID0gZS5kZWx0YSB8fCAoaXNLZXlEb3duID8gZS53aGljaCA9PT0gMzggPyAxIDogLTEgOiAwKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VyVmFsdWUgKyBzdGVwICogZGVsdGE7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB2YXIgaXNIb3VyRWxlbSA9IGlucHV0ID09PSBzZWxmLmhvdXJFbGVtZW50LFxuICAgICAgICAgICAgICBpc01pbnV0ZUVsZW0gPSBpbnB1dCA9PT0gc2VsZi5taW51dGVFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG1heCArIG5ld1ZhbHVlICsgaW50KCFpc0hvdXJFbGVtKSArIChpbnQoaXNIb3VyRWxlbSkgJiYgaW50KCFzZWxmLmFtUE0pKTtcbiAgICAgICAgICAgIGlmIChpc01pbnV0ZUVsZW0pIGluY3JlbWVudE51bUlucHV0KHVuZGVmaW5lZCwgLTEsIHNlbGYuaG91ckVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5wdXQgPT09IHNlbGYuaG91ckVsZW1lbnQgPyBuZXdWYWx1ZSAtIG1heCAtIGludCghc2VsZi5hbVBNKSA6IG1pbjtcbiAgICAgICAgICAgIGlmIChpc01pbnV0ZUVsZW0pIGluY3JlbWVudE51bUlucHV0KHVuZGVmaW5lZCwgMSwgc2VsZi5ob3VyRWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYuYW1QTSAmJiBpc0hvdXJFbGVtICYmIChzdGVwID09PSAxID8gbmV3VmFsdWUgKyBjdXJWYWx1ZSA9PT0gMjMgOiBNYXRoLmFicyhuZXdWYWx1ZSAtIGN1clZhbHVlKSA+IHN0ZXApKSB7XG4gICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVtpbnQoc2VsZi5hbVBNLnRleHRDb250ZW50ID09PSBzZWxmLmwxMG4uYW1QTVswXSldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlucHV0LnZhbHVlID0gcGFkKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbml0KCk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmxhdHBpY2tyKG5vZGVMaXN0LCBjb25maWcpIHtcbiAgICAgIHZhciBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGVMaXN0KTtcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1mcC1vbWl0XCIpICE9PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChub2RlLl9mbGF0cGlja3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUuX2ZsYXRwaWNrciA9IEZsYXRwaWNrckluc3RhbmNlKG5vZGUsIGNvbmZpZyB8fCB7fSk7XG4gICAgICAgICAgaW5zdGFuY2VzLnB1c2gobm9kZS5fZmxhdHBpY2tyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlcy5sZW5ndGggPT09IDEgPyBpbnN0YW5jZXNbMF0gOiBpbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLmZsYXRwaWNrciA9IE5vZGVMaXN0LnByb3RvdHlwZS5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHRoaXMsIGNvbmZpZyk7XG4gICAgICB9O1xuXG4gICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZmxhdHBpY2tyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcihbdGhpc10sIGNvbmZpZyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBmbGF0cGlja3IgPSBmdW5jdGlvbiBmbGF0cGlja3Ioc2VsZWN0b3IsIGNvbmZpZykge1xuICAgICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgTm9kZUxpc3QpIHJldHVybiBfZmxhdHBpY2tyKHNlbGVjdG9yLCBjb25maWcpO2Vsc2UgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9mbGF0cGlja3Iod2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBjb25maWcpO1xuICAgICAgcmV0dXJuIF9mbGF0cGlja3IoW3NlbGVjdG9yXSwgY29uZmlnKTtcbiAgICB9O1xuXG4gICAgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0cztcbiAgICBmbGF0cGlja3IubDEwbnMgPSB7XG4gICAgICBlbjogT2JqZWN0LmFzc2lnbih7fSwgZW5nbGlzaCksXG4gICAgICBkZWZhdWx0OiBPYmplY3QuYXNzaWduKHt9LCBlbmdsaXNoKVxuICAgIH07XG5cbiAgICBmbGF0cGlja3IubG9jYWxpemUgPSBmdW5jdGlvbiAobDEwbikge1xuICAgICAgZmxhdHBpY2tyLmwxMG5zLmRlZmF1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBmbGF0cGlja3IubDEwbnMuZGVmYXVsdCwgbDEwbik7XG4gICAgfTtcblxuICAgIGZsYXRwaWNrci5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcsIGNvbmZpZyk7XG4gICAgfTtcblxuICAgIGZsYXRwaWNrci5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHt9KTtcbiAgICBmbGF0cGlja3IuZm9ybWF0RGF0ZSA9IGNyZWF0ZURhdGVGb3JtYXR0ZXIoe30pO1xuICAgIGZsYXRwaWNrci5jb21wYXJlRGF0ZXMgPSBjb21wYXJlRGF0ZXM7XG5cbiAgICBpZiAodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgalF1ZXJ5LmZuLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IodGhpcywgY29uZmlnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgRGF0ZS5wcm90b3R5cGUuZnBfaW5jciA9IGZ1bmN0aW9uIChkYXlzKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5nZXRGdWxsWWVhcigpLCB0aGlzLmdldE1vbnRoKCksIHRoaXMuZ2V0RGF0ZSgpICsgKHR5cGVvZiBkYXlzID09PSBcInN0cmluZ1wiID8gcGFyc2VJbnQoZGF5cywgMTApIDogZGF5cykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZmxhdHBpY2tyO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZsYXRwaWNrci9kaXN0L2ZsYXRwaWNrci5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	eval("var promiseCancel = function(promise, options) {\n\toptions = options || {};\n\tvar timeout = options.timeout;\n\tvar canceled = false;\n\n\tvar cancelResolve;\n\tvar dummyRequest = new Promise(function(resolve, reject) {\n\t\tcancelResolve = resolve;\n\t});\n\n\tvar race = Promise.race([dummyRequest, promise])\n\t.then(function(data) {\n\t\tif(canceled) {\n\t\t\tvar error = new Error('User cancelled promise.');\n\t\t\terror.type = 'cancel';\n\n\t\t\treturn Promise.reject(error);\n\t\t}\n\t\telse if(timeout) {\n\t\t\tvar error = new Error('Promise timeout');\n\t\t\terror.type = 'timeout';\n\n\t\t\treturn Promise.reject(error);\n\t\t}\n\t\telse {\n\t\t\treturn Promise.resolve(data);\n\t\t}\n\t});\n\n\tif(options.timeout) {\n\t\tsetTimeout(function() {\n\t\t\ttimeout = true;\n\t\t\tcancelResolve();\n\t\t}, +options.timeout);\n\t}\n\n\tfunction cancel() {\n\t\tcanceled = true;\n\t\tcancelResolve();\n\t}\n\n\treturn {\n\t\tpromise: race,\n\t\tcancel: cancel,\n\t\tabort: cancel\n\t};\n};\n\nmodule.exports = promiseCancel;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb21pc2UtY2FuY2VsL2luZGV4LmpzP2UyYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHByb21pc2VDYW5jZWwgPSBmdW5jdGlvbihwcm9taXNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHR2YXIgdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcblx0dmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cblx0dmFyIGNhbmNlbFJlc29sdmU7XG5cdHZhciBkdW1teVJlcXVlc3QgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRjYW5jZWxSZXNvbHZlID0gcmVzb2x2ZTtcblx0fSk7XG5cblx0dmFyIHJhY2UgPSBQcm9taXNlLnJhY2UoW2R1bW15UmVxdWVzdCwgcHJvbWlzZV0pXG5cdC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRpZihjYW5jZWxlZCkge1xuXHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCdVc2VyIGNhbmNlbGxlZCBwcm9taXNlLicpO1xuXHRcdFx0ZXJyb3IudHlwZSA9ICdjYW5jZWwnO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuXHRcdH1cblx0XHRlbHNlIGlmKHRpbWVvdXQpIHtcblx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcignUHJvbWlzZSB0aW1lb3V0Jyk7XG5cdFx0XHRlcnJvci50eXBlID0gJ3RpbWVvdXQnO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZihvcHRpb25zLnRpbWVvdXQpIHtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0dGltZW91dCA9IHRydWU7XG5cdFx0XHRjYW5jZWxSZXNvbHZlKCk7XG5cdFx0fSwgK29wdGlvbnMudGltZW91dCk7XG5cdH1cblxuXHRmdW5jdGlvbiBjYW5jZWwoKSB7XG5cdFx0Y2FuY2VsZWQgPSB0cnVlO1xuXHRcdGNhbmNlbFJlc29sdmUoKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0cHJvbWlzZTogcmFjZSxcblx0XHRjYW5jZWw6IGNhbmNlbCxcblx0XHRhYm9ydDogY2FuY2VsXG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByb21pc2VDYW5jZWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb21pc2UtY2FuY2VsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EE = __webpack_require__(1);\n\nvar _EE2 = _interopRequireDefault(_EE);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Launcher = function () {\n    function Launcher() {\n        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'bottom_left';\n\n        _classCallCheck(this, Launcher);\n\n        this.position = position;\n\n        this.render();\n    }\n\n    _createClass(Launcher, [{\n        key: 'render',\n        value: function render() {\n            var wrapper = document.createElement('div');\n            wrapper.classList.add('fred--launcher', 'fred--launcher_' + this.position);\n\n            var fred = document.createElement('button');\n            fred.classList.add('fred--launcher_btn', 'fred--launcher_btn_fred');\n            fred.setAttribute('role', 'button');\n            fred.addEventListener('click', function (e) {\n                e.preventDefault();\n                _EE2.default.emit('fred-sidebar-toggle');\n            });\n\n            var save = document.createElement('button');\n            save.classList.add('fred--launcher_btn', 'fred--launcher_btn_save');\n            save.setAttribute('role', 'button');\n            save.addEventListener('click', function (e) {\n                e.preventDefault();\n                _EE2.default.emit('fred-save');\n            });\n\n            var undo = document.createElement('button');\n            undo.classList.add('fred--launcher_btn', 'fred--launcher_btn_undo');\n            undo.setAttribute('role', 'button');\n            undo.addEventListener('click', function (e) {\n                e.preventDefault();\n                _EE2.default.emit('fred-undo');\n            });\n\n            wrapper.appendChild(fred);\n            wrapper.appendChild(save);\n            wrapper.appendChild(undo);\n\n            _EE2.default.emit('fred-wrapper-insert', wrapper);\n        }\n    }]);\n\n    return Launcher;\n}();\n\nexports.default = Launcher;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0xhdW5jaGVyLmpzPzUxZDkiXSwibmFtZXMiOlsiTGF1bmNoZXIiLCJwb3NpdGlvbiIsInJlbmRlciIsIndyYXBwZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJmcmVkIiwic2V0QXR0cmlidXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImVtaXQiLCJzYXZlIiwidW5kbyIsImFwcGVuZENoaWxkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7OztJQUVxQkEsUTtBQUNqQix3QkFBc0M7QUFBQSxZQUExQkMsUUFBMEIsdUVBQWYsYUFBZTs7QUFBQTs7QUFDbEMsYUFBS0EsUUFBTCxHQUFnQkEsUUFBaEI7O0FBRUEsYUFBS0MsTUFBTDtBQUNIOzs7O2lDQUVRO0FBQ0wsZ0JBQU1DLFVBQVVDLFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQUYsb0JBQVFHLFNBQVIsQ0FBa0JDLEdBQWxCLENBQXNCLGdCQUF0QixzQkFBMEQsS0FBS04sUUFBL0Q7O0FBRUEsZ0JBQU1PLE9BQU9KLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBYjtBQUNBRyxpQkFBS0YsU0FBTCxDQUFlQyxHQUFmLENBQW1CLG9CQUFuQixFQUF5Qyx5QkFBekM7QUFDQUMsaUJBQUtDLFlBQUwsQ0FBa0IsTUFBbEIsRUFBMEIsUUFBMUI7QUFDQUQsaUJBQUtFLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLGFBQUs7QUFDaENDLGtCQUFFQyxjQUFGO0FBQ0EsNkJBQVFDLElBQVIsQ0FBYSxxQkFBYjtBQUNILGFBSEQ7O0FBS0EsZ0JBQU1DLE9BQU9WLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBYjtBQUNBUyxpQkFBS1IsU0FBTCxDQUFlQyxHQUFmLENBQW1CLG9CQUFuQixFQUF5Qyx5QkFBekM7QUFDQU8saUJBQUtMLFlBQUwsQ0FBa0IsTUFBbEIsRUFBMEIsUUFBMUI7QUFDQUssaUJBQUtKLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLGFBQUs7QUFDaENDLGtCQUFFQyxjQUFGO0FBQ0EsNkJBQVFDLElBQVIsQ0FBYSxXQUFiO0FBQ0gsYUFIRDs7QUFLQSxnQkFBTUUsT0FBT1gsU0FBU0MsYUFBVCxDQUF1QixRQUF2QixDQUFiO0FBQ0FVLGlCQUFLVCxTQUFMLENBQWVDLEdBQWYsQ0FBbUIsb0JBQW5CLEVBQXlDLHlCQUF6QztBQUNBUSxpQkFBS04sWUFBTCxDQUFrQixNQUFsQixFQUEwQixRQUExQjtBQUNBTSxpQkFBS0wsZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsYUFBSztBQUNoQ0Msa0JBQUVDLGNBQUY7QUFDQSw2QkFBUUMsSUFBUixDQUFhLFdBQWI7QUFDSCxhQUhEOztBQUtBVixvQkFBUWEsV0FBUixDQUFvQlIsSUFBcEI7QUFDQUwsb0JBQVFhLFdBQVIsQ0FBb0JGLElBQXBCO0FBQ0FYLG9CQUFRYSxXQUFSLENBQW9CRCxJQUFwQjs7QUFFQSx5QkFBUUYsSUFBUixDQUFhLHFCQUFiLEVBQW9DVixPQUFwQztBQUNIOzs7Ozs7a0JBeENnQkgsUSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlbWl0dGVyIGZyb20gJy4vRUUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXVuY2hlciB7XG4gICAgY29uc3RydWN0b3IocG9zaXRpb24gPSAnYm90dG9tX2xlZnQnKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcblxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdmcmVkLS1sYXVuY2hlcicsIGBmcmVkLS1sYXVuY2hlcl8ke3RoaXMucG9zaXRpb259YCk7XG5cbiAgICAgICAgY29uc3QgZnJlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBmcmVkLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLWxhdW5jaGVyX2J0bicsICdmcmVkLS1sYXVuY2hlcl9idG5fZnJlZCcpO1xuICAgICAgICBmcmVkLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgZnJlZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdmcmVkLXNpZGViYXItdG9nZ2xlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBzYXZlLmNsYXNzTGlzdC5hZGQoJ2ZyZWQtLWxhdW5jaGVyX2J0bicsICdmcmVkLS1sYXVuY2hlcl9idG5fc2F2ZScpO1xuICAgICAgICBzYXZlLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgc2F2ZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdmcmVkLXNhdmUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB1bmRvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHVuZG8uY2xhc3NMaXN0LmFkZCgnZnJlZC0tbGF1bmNoZXJfYnRuJywgJ2ZyZWQtLWxhdW5jaGVyX2J0bl91bmRvJyk7XG4gICAgICAgIHVuZG8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xuICAgICAgICB1bmRvLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZyZWQtdW5kbycpO1xuICAgICAgICB9KTtcblxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGZyZWQpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNhdmUpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHVuZG8pO1xuXG4gICAgICAgIGVtaXR0ZXIuZW1pdCgnZnJlZC13cmFwcGVyLWluc2VydCcsIHdyYXBwZXIpO1xuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9fYnVpbGQvYXNzZXRzL2pzL0xhdW5jaGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ElementSettings = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EE = __webpack_require__(1);\n\nvar _EE2 = _interopRequireDefault(_EE);\n\nvar _isomorphicFetch = __webpack_require__(6);\n\nvar _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);\n\nvar _Utils = __webpack_require__(35);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ElementSettings = exports.ElementSettings = function () {\n    function ElementSettings() {\n        _classCallCheck(this, ElementSettings);\n\n        this.el = null;\n        this.settings = {};\n        this.originalValues = {};\n        this.wrapper = null;\n\n        this.render();\n\n        _EE2.default.on('fred-element-settings-open', this.openSettings.bind(this));\n    }\n\n    _createClass(ElementSettings, [{\n        key: 'render',\n        value: function render() {\n            this.wrapper = document.createElement('div');\n            this.wrapper.classList.add('fred--panel', 'fred--panel_element', 'fred--hidden');\n\n            _EE2.default.emit('fred-wrapper-insert', this.wrapper);\n        }\n    }, {\n        key: 'openSettings',\n        value: function openSettings(el) {\n            this.el = el;\n            this.settings = el.options.settings;\n            this.originalValues = {};\n            this.remote = el.options.remote || false;\n            this.debouncedRender = (0, _Utils.debounce)(200, this.el.render);\n\n            this.wrapper.innerHTML = '';\n            this.wrapper.appendChild(this.renderSettings());\n\n            this.open();\n        }\n    }, {\n        key: 'renderSettings',\n        value: function renderSettings() {\n            var _this = this;\n\n            var form = document.createElement('form');\n            var fieldSet = document.createElement('fieldset');\n\n            var legend = document.createElement('legend');\n            legend.innerHTML = 'Element Settings';\n\n            fieldSet.appendChild(legend);\n\n            this.settings.forEach(function (setting) {\n                if (setting.group && setting.settings) {\n                    fieldSet.appendChild(_this.renderSettingsGroup(setting));\n                } else {\n                    var defaultValue = _this.el.settings[setting.name] || setting.value;\n                    _this.originalValues[setting.name] = defaultValue;\n                    fieldSet.appendChild(_this.renderSetting(setting, defaultValue));\n                }\n            });\n\n            var apply = document.createElement('button');\n            apply.classList.add('fred--btn-panel', 'fred--btn-apply');\n            apply.innerHTML = 'Apply';\n            apply.addEventListener('click', function (e) {\n                e.preventDefault();\n                _this.apply();\n            });\n\n            var cancel = document.createElement('button');\n            cancel.classList.add('fred--btn-panel');\n            cancel.innerHTML = 'Cancel';\n            cancel.addEventListener('click', function (e) {\n                e.preventDefault();\n                _this.cancel(cancel);\n            });\n\n            fieldSet.appendChild(apply);\n            fieldSet.appendChild(cancel);\n\n            form.appendChild(fieldSet);\n\n            return form;\n        }\n    }, {\n        key: 'renderSettingsGroup',\n        value: function renderSettingsGroup(group) {\n            var _this2 = this;\n\n            var content = document.createElement('dl');\n\n            var dt = document.createElement('dt');\n            dt.setAttribute('role', 'tab');\n            dt.setAttribute('tabindex', '1');\n            dt.innerHTML = group.group;\n\n            var dd = document.createElement('dd');\n            group.settings.forEach(function (setting) {\n                var defaultValue = _this2.el.settings[setting.name] || setting.value;\n                _this2.originalValues[setting.name] = defaultValue;\n                dd.appendChild(_this2.renderSetting(setting, defaultValue));\n            });\n\n            content.appendChild(dt);\n            content.appendChild(dd);\n\n            return content;\n        }\n    }, {\n        key: 'renderSetting',\n        value: function renderSetting(setting, defaultValue) {\n\n            switch (setting.type) {\n                case 'select':\n                    return this.buildSelectInput(setting, defaultValue);\n                case 'toggle':\n                    return this.buildToggleInput(setting, defaultValue);\n                default:\n                    return this.buildTextInput(setting, defaultValue);\n            }\n        }\n    }, {\n        key: 'buildTextInput',\n        value: function buildTextInput(setting, defaultValue) {\n            var _this3 = this;\n\n            var label = document.createElement('label');\n            label.innerHTML = setting.label || setting.name;\n\n            var input = document.createElement('input');\n            input.setAttribute('type', 'text');\n            input.value = defaultValue;\n\n            input.addEventListener('keyup', function (e) {\n                _this3.setSetting(setting.name, input.value);\n            });\n\n            label.appendChild(input);\n\n            return label;\n        }\n    }, {\n        key: 'buildSelectInput',\n        value: function buildSelectInput(setting, defaultValue) {\n            var _this4 = this;\n\n            var label = document.createElement('label');\n            label.innerHTML = setting.label || setting.name;\n\n            var select = document.createElement('select');\n\n            if (setting.options) {\n                for (var value in setting.options) {\n                    if (setting.options.hasOwnProperty(value)) {\n                        var option = document.createElement('option');\n                        option.innerHTML = setting.options[value];\n                        option.value = value;\n\n                        if (value === defaultValue) {\n                            option.setAttribute('selected', 'selected');\n                        }\n\n                        select.appendChild(option);\n                    }\n                }\n            }\n\n            select.addEventListener('change', function (e) {\n                if (setting.options[select.value]) {\n                    _this4.setSetting(setting.name, select.value);\n                }\n            });\n\n            label.appendChild(select);\n\n            return label;\n        }\n    }, {\n        key: 'buildToggleInput',\n        value: function buildToggleInput(setting, defaultValue) {\n            var _this5 = this;\n\n            var label = document.createElement('label');\n            label.classList.add('fred--toggle');\n            label.innerHTML = setting.label || setting.name;\n\n            var input = document.createElement('input');\n            input.setAttribute('type', 'checkbox');\n            if (defaultValue === true) {\n                input.setAttribute('checked', 'checked');\n            }\n\n            input.addEventListener('change', function (e) {\n                _this5.setSetting(setting.name, e.target.checked);\n            });\n\n            var span = document.createElement('span');\n\n            label.appendChild(input);\n            label.appendChild(span);\n\n            return label;\n        }\n    }, {\n        key: 'setSetting',\n        value: function setSetting(name, value) {\n            this.el.settings[name] = value;\n\n            if (this.remote === false) {\n                this.el.render();\n            } else {\n                this.debouncedRender();\n            }\n        }\n    }, {\n        key: 'apply',\n        value: function apply() {\n            this.el.render();\n            this.close();\n        }\n    }, {\n        key: 'settingChanged',\n        value: function settingChanged() {\n            for (var name in this.el.settings) {\n                if (this.el.settings.hasOwnProperty(name)) {\n                    if (!(this.originalValues[name] && this.originalValues[name] === this.el.settings[name])) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n    }, {\n        key: 'cancel',\n        value: function cancel(btn) {\n            if (this.settingChanged() && btn.confirmed !== true) {\n                btn.innerHTML = 'There are unsaved changes, are you sure?';\n                btn.confirmed = true;\n                return;\n            }\n\n            this.realCancel();\n        }\n    }, {\n        key: 'realCancel',\n        value: function realCancel() {\n            this.el.settings = this.originalValues;\n            this.el.render();\n            this.close();\n        }\n    }, {\n        key: 'open',\n        value: function open() {\n            this.wrapper.classList.remove('fred--hidden');\n        }\n    }, {\n        key: 'close',\n        value: function close() {\n            this.wrapper.classList.add('fred--hidden');\n        }\n    }]);\n\n    return ElementSettings;\n}();\n\nexports.default = ElementSettings;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL0NvbXBvbmVudHMvU2lkZWJhci9FbGVtZW50cy9FbGVtZW50U2V0dGluZ3MuanM/ZTAzOCJdLCJuYW1lcyI6WyJFbGVtZW50U2V0dGluZ3MiLCJlbCIsInNldHRpbmdzIiwib3JpZ2luYWxWYWx1ZXMiLCJ3cmFwcGVyIiwicmVuZGVyIiwib24iLCJvcGVuU2V0dGluZ3MiLCJiaW5kIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwiZW1pdCIsIm9wdGlvbnMiLCJyZW1vdGUiLCJkZWJvdW5jZWRSZW5kZXIiLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsInJlbmRlclNldHRpbmdzIiwib3BlbiIsImZvcm0iLCJmaWVsZFNldCIsImxlZ2VuZCIsImZvckVhY2giLCJzZXR0aW5nIiwiZ3JvdXAiLCJyZW5kZXJTZXR0aW5nc0dyb3VwIiwiZGVmYXVsdFZhbHVlIiwibmFtZSIsInZhbHVlIiwicmVuZGVyU2V0dGluZyIsImFwcGx5IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImNhbmNlbCIsImNvbnRlbnQiLCJkdCIsInNldEF0dHJpYnV0ZSIsImRkIiwidHlwZSIsImJ1aWxkU2VsZWN0SW5wdXQiLCJidWlsZFRvZ2dsZUlucHV0IiwiYnVpbGRUZXh0SW5wdXQiLCJsYWJlbCIsImlucHV0Iiwic2V0U2V0dGluZyIsInNlbGVjdCIsImhhc093blByb3BlcnR5Iiwib3B0aW9uIiwidGFyZ2V0IiwiY2hlY2tlZCIsInNwYW4iLCJjbG9zZSIsImJ0biIsInNldHRpbmdDaGFuZ2VkIiwiY29uZmlybWVkIiwicmVhbENhbmNlbCIsInJlbW92ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7SUFFYUEsZSxXQUFBQSxlO0FBQ1QsK0JBQWM7QUFBQTs7QUFDVixhQUFLQyxFQUFMLEdBQVUsSUFBVjtBQUNBLGFB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QUtDLFVBQUw7QUFDSDs7O3FDQUVZO0FBQ1QsaUJBQUt6RCxFQUFMLENBQVFDLFFBQVIsR0FBbUIsS0FBS0MsY0FBeEI7QUFDQSxpQkFBS0YsRUFBTCxDQUFRSSxNQUFSO0FBQ0EsaUJBQUtpRCxLQUFMO0FBQ0g7OzsrQkFFTTtBQUNILGlCQUFLbEQsT0FBTCxDQUFhTyxTQUFiLENBQXVCZ0QsTUFBdkIsQ0FBOEIsY0FBOUI7QUFDSDs7O2dDQUVPO0FBQ0osaUJBQUt2RCxPQUFMLENBQWFPLFNBQWIsQ0FBdUJDLEdBQXZCLENBQTJCLGNBQTNCO0FBQ0g7Ozs7OztrQkFHVVosZSIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlbWl0dGVyIGZyb20gJy4uLy4uLy4uL0VFJztcbmltcG9ydCBmZXRjaCBmcm9tICdpc29tb3JwaGljLWZldGNoJztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnLi4vLi4vLi4vVXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgRWxlbWVudFNldHRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLndyYXBwZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIFxuICAgICAgICBlbWl0dGVyLm9uKCdmcmVkLWVsZW1lbnQtc2V0dGluZ3Mtb3BlbicsIHRoaXMub3BlblNldHRpbmdzLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKCdmcmVkLS1wYW5lbCcsICdmcmVkLS1wYW5lbF9lbGVtZW50JywgJ2ZyZWQtLWhpZGRlbicpO1xuXG4gICAgICAgIGVtaXR0ZXIuZW1pdCgnZnJlZC13cmFwcGVyLWluc2VydCcsIHRoaXMud3JhcHBlcik7XG4gICAgfVxuICAgIFxuICAgIG9wZW5TZXR0aW5ncyhlbCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBlbC5vcHRpb25zLnNldHRpbmdzO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVmFsdWVzID0ge307XG4gICAgICAgIHRoaXMucmVtb3RlID0gZWwub3B0aW9ucy5yZW1vdGUgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkUmVuZGVyID0gZGVib3VuY2UoMjAwLCB0aGlzLmVsLnJlbmRlcik7XG5cbiAgICAgICAgdGhpcy53cmFwcGVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJTZXR0aW5ncygpKTtcblxuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gICAgXG4gICAgcmVuZGVyU2V0dGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgICAgIGNvbnN0IGZpZWxkU2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmllbGRzZXQnKTtcblxuICAgICAgICBjb25zdCBsZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kLmlubmVySFRNTCA9ICdFbGVtZW50IFNldHRpbmdzJztcblxuICAgICAgICBmaWVsZFNldC5hcHBlbmRDaGlsZChsZWdlbmQpO1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nLmdyb3VwICYmIHNldHRpbmcuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBmaWVsZFNldC5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlclNldHRpbmdzR3JvdXAoc2V0dGluZykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmVsLnNldHRpbmdzW3NldHRpbmcubmFtZV0gfHwgc2V0dGluZy52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsVmFsdWVzW3NldHRpbmcubmFtZV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgZmllbGRTZXQuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJTZXR0aW5nKHNldHRpbmcsIGRlZmF1bHRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBhcHBseSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBhcHBseS5jbGFzc0xpc3QuYWRkKCdmcmVkLS1idG4tcGFuZWwnLCAnZnJlZC0tYnRuLWFwcGx5Jyk7XG4gICAgICAgIGFwcGx5LmlubmVySFRNTCA9ICdBcHBseSc7XG4gICAgICAgIGFwcGx5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmFwcGx5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNhbmNlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBjYW5jZWwuY2xhc3NMaXN0LmFkZCgnZnJlZC0tYnRuLXBhbmVsJyk7XG4gICAgICAgIGNhbmNlbC5pbm5lckhUTUwgPSAnQ2FuY2VsJztcbiAgICAgICAgY2FuY2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbChjYW5jZWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmaWVsZFNldC5hcHBlbmRDaGlsZChhcHBseSk7XG4gICAgICAgIGZpZWxkU2V0LmFwcGVuZENoaWxkKGNhbmNlbCk7XG5cbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChmaWVsZFNldCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZm9ybTtcbiAgICB9XG5cbiAgICByZW5kZXJTZXR0aW5nc0dyb3VwKGdyb3VwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkbCcpO1xuXG4gICAgICAgIGNvbnN0IGR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZHQnKTtcbiAgICAgICAgZHQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RhYicpO1xuICAgICAgICBkdC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzEnKTtcbiAgICAgICAgZHQuaW5uZXJIVE1MID0gZ3JvdXAuZ3JvdXA7XG5cbiAgICAgICAgY29uc3QgZGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkZCcpO1xuICAgICAgICBncm91cC5zZXR0aW5ncy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5lbC5zZXR0aW5nc1tzZXR0aW5nLm5hbWVdIHx8IHNldHRpbmcudmFsdWU7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsVmFsdWVzW3NldHRpbmcubmFtZV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICBkZC5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlclNldHRpbmcoc2V0dGluZywgZGVmYXVsdFZhbHVlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZHQpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGRkKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIHJlbmRlclNldHRpbmcoc2V0dGluZywgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgc3dpdGNoIChzZXR0aW5nLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTZWxlY3RJbnB1dChzZXR0aW5nLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAndG9nZ2xlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFRvZ2dsZUlucHV0KHNldHRpbmcsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkVGV4dElucHV0KHNldHRpbmcsIGRlZmF1bHRWYWx1ZSk7ICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBidWlsZFRleHRJbnB1dChzZXR0aW5nLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSBzZXR0aW5nLmxhYmVsIHx8IHNldHRpbmcubmFtZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2V0dGluZyhzZXR0aW5nLm5hbWUsIGlucHV0LnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cbiAgICBcbiAgICBidWlsZFNlbGVjdElucHV0KHNldHRpbmcsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGxhYmVsLmlubmVySFRNTCA9IHNldHRpbmcubGFiZWwgfHwgc2V0dGluZy5uYW1lO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc2V0dGluZy5vcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSBpbiBzZXR0aW5nLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZy5vcHRpb25zLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmlubmVySFRNTCA9IHNldHRpbmcub3B0aW9uc1t2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgICAgICAgICAgaWYgKHNldHRpbmcub3B0aW9uc1tzZWxlY3QudmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZXR0aW5nKHNldHRpbmcubmFtZSwgc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcblxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgfVxuXG4gICAgYnVpbGRUb2dnbGVJbnB1dChzZXR0aW5nLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdmcmVkLS10b2dnbGUnKTtcbiAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gc2V0dGluZy5sYWJlbCB8fCBzZXR0aW5nLm5hbWU7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFNldHRpbmcoc2V0dGluZy5uYW1lLCBlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKHNwYW4pO1xuXG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9XG4gICAgXG4gICAgc2V0U2V0dGluZyhuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmVsLnNldHRpbmdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5yZW1vdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnJlbmRlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZWRSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBhcHBseSgpIHtcbiAgICAgICAgdGhpcy5lbC5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICBcbiAgICBzZXR0aW5nQ2hhbmdlZCgpIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmVsLnNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbC5zZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICghKHRoaXMub3JpZ2luYWxWYWx1ZXNbbmFtZV0gJiYgKHRoaXMub3JpZ2luYWxWYWx1ZXNbbmFtZV0gPT09IHRoaXMuZWwuc2V0dGluZ3NbbmFtZV0pKSkge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY2FuY2VsKGJ0bikge1xuICAgICAgICBpZih0aGlzLnNldHRpbmdDaGFuZ2VkKCkgJiYgKGJ0bi5jb25maXJtZWQgIT09IHRydWUpKSB7XG4gICAgICAgICAgICBidG4uaW5uZXJIVE1MID0gJ1RoZXJlIGFyZSB1bnNhdmVkIGNoYW5nZXMsIGFyZSB5b3Ugc3VyZT8nO1xuICAgICAgICAgICAgYnRuLmNvbmZpcm1lZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMucmVhbENhbmNlbCgpO1xuICAgIH1cbiAgICBcbiAgICByZWFsQ2FuY2VsKCkge1xuICAgICAgICB0aGlzLmVsLnNldHRpbmdzID0gdGhpcy5vcmlnaW5hbFZhbHVlcztcbiAgICAgICAgdGhpcy5lbC5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICBcbiAgICBvcGVuKCkge1xuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnZnJlZC0taGlkZGVuJyk7XG4gICAgfVxuICAgIFxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCgnZnJlZC0taGlkZGVuJyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbGVtZW50U2V0dGluZ3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vX2J1aWxkL2Fzc2V0cy9qcy9Db21wb25lbnRzL1NpZGViYXIvRWxlbWVudHMvRWxlbWVudFNldHRpbmdzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar debounce = exports.debounce = function debounce(delay, fn) {\n    var timerId = void 0;\n\n    return function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(function () {\n            fn.apply(undefined, args);\n            timerId = null;\n        }, delay);\n    };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL1V0aWxzLmpzP2QzZjMiXSwibmFtZXMiOlsiZGVib3VuY2UiLCJkZWxheSIsImZuIiwidGltZXJJZCIsImFyZ3MiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Il0sIm1hcHBpbmdzIjoiOzs7OztBQUFPLElBQU1BLDhCQUFXLFNBQVhBLFFBQVcsQ0FBQ0MsS0FBRCxFQUFRQyxFQUFSLEVBQWU7QUFDbkMsUUFBSUMsZ0JBQUo7O0FBRUEsV0FBTyxZQUFtQjtBQUFBLDBDQUFOQyxJQUFNO0FBQU5BLGdCQUFNO0FBQUE7O0FBQ3RCLFlBQUlELE9BQUosRUFBYTtBQUNURSx5QkFBYUYsT0FBYjtBQUNIO0FBQ0RBLGtCQUFVRyxXQUFXLFlBQU07QUFDdkJKLGdDQUFNRSxJQUFOO0FBQ0FELHNCQUFVLElBQVY7QUFDSCxTQUhTLEVBR1BGLEtBSE8sQ0FBVjtBQUlILEtBUkQ7QUFTSCxDQVpNIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGRlYm91bmNlID0gKGRlbGF5LCBmbikgPT4ge1xuICAgIGxldCB0aW1lcklkO1xuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAodGltZXJJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGZuKC4uLmFyZ3MpO1xuICAgICAgICAgICAgdGltZXJJZCA9IG51bGw7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9fYnVpbGQvYXNzZXRzL2pzL1V0aWxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _modxlink = __webpack_require__(37);\n\nvar _modxlink2 = _interopRequireDefault(_modxlink);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar registerPlugins = function registerPlugins(fred) {\n    tinymce.PluginManager.add('modxlink', (0, _modxlink2.default)(fred));\n};\n\nexports.default = registerPlugins;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL1RpbnlNQ0UvUmVnaXN0ZXJQbHVnaW5zLmpzPzkzNjMiXSwibmFtZXMiOlsicmVnaXN0ZXJQbHVnaW5zIiwidGlueW1jZSIsIlBsdWdpbk1hbmFnZXIiLCJhZGQiLCJmcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7O0FBRUEsSUFBTUEsa0JBQWtCLFNBQWxCQSxlQUFrQixPQUFRO0FBQzVCQyxZQUFRQyxhQUFSLENBQXNCQyxHQUF0QixDQUEwQixVQUExQixFQUFzQyx3QkFBU0MsSUFBVCxDQUF0QztBQUVILENBSEQ7O2tCQUtlSixlIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZHhsaW5rIGZyb20gJy4vUGx1Z2lucy9tb2R4bGluay9tb2R4bGluayc7XG5cbmNvbnN0IHJlZ2lzdGVyUGx1Z2lucyA9IGZyZWQgPT4ge1xuICAgIHRpbnltY2UuUGx1Z2luTWFuYWdlci5hZGQoJ21vZHhsaW5rJywgbW9keGxpbmsoZnJlZCkpO1xuXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZWdpc3RlclBsdWdpbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vX2J1aWxkL2Fzc2V0cy9qcy9UaW55TUNFL1JlZ2lzdGVyUGx1Z2lucy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _choices = __webpack_require__(8);\n\nvar _choices2 = _interopRequireDefault(_choices);\n\nvar _isomorphicFetch = __webpack_require__(6);\n\nvar _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);\n\nvar _ElementHelper = __webpack_require__(38);\n\nvar _ElementHelper2 = _interopRequireDefault(_ElementHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (fred) {\n    return function (editor, url) {\n        // Add a button that opens a window\n\n        editor.addButton('modxlink', {\n            icon: 'link',\n            onclick: function onclick() {\n\n                var elm = void 0;\n                var activeTab = 0;\n\n                var data = {\n                    link_text: editor.selection.getContent(),\n                    link_title: '',\n                    classes: '',\n                    new_window: false,\n                    page: {\n                        page: '',\n                        url: '',\n                        anchor: ''\n                    },\n                    url: {\n                        url: ''\n                    },\n                    email: {\n                        to: '',\n                        subject: '',\n                        body: ''\n                    },\n                    phone: {},\n                    file: {}\n                };\n\n                elm = editor.dom.getParent(editor.selection.getStart(), 'a[href]');\n                if (elm) {\n                    editor.selection.select(elm);\n\n                    var parsedData = _ElementHelper2.default.getData(elm, data);\n\n                    data = _extends({}, data, parsedData.data);\n\n                    switch (parsedData.tab) {\n                        case 'page':\n                            activeTab = 0;\n                            break;\n                        case 'url':\n                            activeTab = 1;\n                            break;\n                        case 'email':\n                            activeTab = 2;\n                            break;\n                    }\n                }\n\n                console.log(data);\n\n                var tabPanel = new tinymce.ui.TabPanel({\n                    type: 'tabpanel',\n                    classes: 'fred--modxlink-panel',\n                    activeTab: activeTab,\n                    items: [{\n                        title: 'Page',\n                        id: 'page',\n                        type: 'form',\n                        items: [{\n                            type: 'form',\n                            layout: 'grid',\n                            padding: 0,\n                            columns: 2,\n                            items: [{\n                                type: 'selectbox',\n                                label: 'Page',\n                                id: 'page_url',\n                                value: data.page.page\n                            }, {\n                                type: 'textbox',\n                                label: 'Block on \\'' + fred.config.pageSettings.pagetitle + '\\'',\n                                id: 'page_anchor',\n                                value: data.page.anchor,\n                                onkeyup: function onkeyup() {\n                                    data.page.anchor = this.value();\n                                }\n                            }]\n                        }]\n                    }, {\n                        title: 'URL',\n                        id: 'url',\n                        type: 'form',\n                        items: [{\n                            type: 'textbox',\n                            label: 'URL',\n                            value: data.url.url,\n                            onkeyup: function onkeyup() {\n                                data.url.url = this.value();\n                            }\n                        }]\n                    }, {\n                        title: 'Email',\n                        id: 'email',\n                        type: 'form',\n                        items: [{\n                            type: 'textbox',\n                            label: 'To',\n                            value: data.email.to,\n                            onkeyup: function onkeyup() {\n                                data.email.to = this.value();\n                            }\n                        }, {\n                            type: 'textbox',\n                            label: 'Subject',\n                            value: data.email.subject,\n                            onkeyup: function onkeyup() {\n                                data.email.subject = this.value();\n                            }\n                        }, {\n                            type: 'textbox',\n                            multiline: true,\n                            label: 'Body',\n                            value: data.email.body,\n                            onkeyup: function onkeyup() {\n                                data.email.body = this.value();\n                            }\n                        }]\n                    }, {\n                        title: 'Phone',\n                        id: 'phone',\n                        type: 'form',\n                        items: []\n                    }, {\n                        title: 'File',\n                        id: 'file',\n                        type: 'form',\n                        items: []\n                    }]\n                });\n\n                // Open window\n                var win = editor.windowManager.open({\n                    title: 'Link to',\n                    classes: 'fred--modxlink',\n                    data: data,\n                    body: [{\n                        type: 'textbox',\n                        label: 'Link Text',\n                        name: 'link_text',\n                        onkeyup: function onkeyup() {\n                            data.link_text = this.value();\n                        }\n                    }, {\n                        type: 'form',\n                        layout: 'grid',\n                        padding: 0,\n                        columns: 3,\n                        items: [{\n                            type: 'textbox',\n                            name: 'link_title',\n                            label: 'Link Title',\n                            onkeyup: function onkeyup() {\n                                data.link_title = this.value();\n                            }\n                        }, {\n                            type: 'textbox',\n                            name: 'classes',\n                            label: 'Classes',\n                            onkeyup: function onkeyup() {\n                                data.classes = this.value();\n                            }\n                        }, {\n                            type: 'checkbox',\n                            name: 'new_window',\n                            label: 'New Window',\n                            onchange: function onchange() {\n                                data.new_window = this.value();\n                            }\n                        }]\n                    }, tabPanel],\n                    onsubmit: function (tabPanel) {\n                        return function (e) {\n                            var activeTab = tabPanel.items()[tabPanel.activeTabId.slice(1)]._id;\n                            console.log(activeTab);\n                            console.log(data);\n\n                            var elm = editor.dom.getParent(editor.selection.getStart(), 'a[href]');\n\n                            if (activeTab === 'page') {\n                                if (elm) {\n                                    if (!data.page.page && !data.page.anchor) return;\n\n                                    editor.focus();\n                                    editor.dom.removeAllAttribs(elm);\n\n                                    editor.dom.setAttrib(elm, 'data-fred-link-page', data.page.page);\n\n                                    if (data.page.anchor) {\n                                        editor.dom.setAttrib(elm, 'data-fred-link-anchor', data.page.anchor);\n                                        editor.dom.setAttrib(elm, 'href', data.page.url + '#' + data.page.anchor);\n                                    } else {\n                                        editor.dom.setAttrib(elm, 'href', data.page.url);\n                                    }\n\n                                    if (data.link_title) {\n                                        editor.dom.setAttrib(elm, 'title', data.link_title);\n                                    }\n\n                                    if (data.new_window) {\n                                        editor.dom.setAttrib(elm, 'target', '_blank');\n                                    }\n\n                                    if (data.classes) {\n                                        editor.dom.setAttrib(elm, 'class', data.classes);\n                                    }\n\n                                    elm.innerText = editor.dom.encode(data.link_text);\n                                    editor.selection.select(elm);\n                                    editor.selection.collapse(false);\n                                } else {\n                                    var attrs = {\n                                        href: data.page.url,\n                                        'data-fred-link-page': data.page.page\n                                    };\n\n                                    if (data.page.anchor) {\n                                        attrs['data-fred-link-anchor'] = data.page.anchor;\n                                        attrs.href = data.page.url + '#' + data.page.anchor;\n                                    }\n\n                                    if (data.link_title) {\n                                        attrs.title = data.link_title;\n                                    }\n\n                                    if (data.new_window) {\n                                        attrs.target = '_blank';\n                                    }\n\n                                    if (data.classes) {\n                                        attrs.class = data.classes;\n                                    }\n\n                                    editor.insertContent(editor.dom.createHTML('a', attrs, editor.dom.encode(data.link_text)));\n\n                                    editor.selection.collapse(false);\n                                }\n\n                                return;\n                            }\n\n                            if (activeTab === 'url') {\n                                if (elm) {\n                                    editor.focus();\n                                    editor.dom.removeAllAttribs(elm);\n\n                                    editor.dom.setAttrib(elm, 'href', data.url.url);\n\n                                    if (data.link_title) {\n                                        editor.dom.setAttrib(elm, 'title', data.link_title);\n                                    }\n\n                                    if (data.new_window) {\n                                        editor.dom.setAttrib(elm, 'target', '_blank');\n                                    }\n\n                                    if (data.classes) {\n                                        editor.dom.setAttrib(elm, 'class', data.classes);\n                                    }\n\n                                    elm.innerText = editor.dom.encode(data.link_text);\n                                    editor.selection.select(elm);\n                                    editor.selection.collapse(false);\n                                } else {\n                                    var _attrs = {\n                                        href: data.url.url\n                                    };\n\n                                    if (data.link_title) {\n                                        _attrs.title = data.link_title;\n                                    }\n\n                                    if (data.new_window) {\n                                        _attrs.target = '_blank';\n                                    }\n\n                                    if (data.classes) {\n                                        _attrs.class = data.classes;\n                                    }\n\n                                    editor.insertContent(editor.dom.createHTML('a', _attrs, editor.dom.encode(data.link_text)));\n\n                                    editor.selection.collapse(false);\n                                }\n                            }\n\n                            if (activeTab === 'email') {\n                                if (elm) {\n                                    editor.focus();\n                                    editor.dom.removeAllAttribs(elm);\n\n                                    var href = 'mailto:' + data.email.to;\n                                    var mailAttrs = [];\n\n                                    if (data.email.subject) {\n                                        mailAttrs.push('subject=' + encodeURI(data.email.subject));\n                                    }\n\n                                    if (data.email.body) {\n                                        mailAttrs.push('body=' + encodeURI(data.email.body));\n                                    }\n\n                                    if (mailAttrs.length > 0) {\n                                        href += '?' + mailAttrs.join('&');\n                                    }\n\n                                    editor.dom.setAttrib(elm, 'href', href);\n\n                                    if (data.link_title) {\n                                        editor.dom.setAttrib(elm, 'title', data.link_title);\n                                    }\n\n                                    if (data.new_window) {\n                                        editor.dom.setAttrib(elm, 'target', '_blank');\n                                    }\n\n                                    if (data.classes) {\n                                        editor.dom.setAttrib(elm, 'class', data.classes);\n                                    }\n\n                                    elm.innerText = editor.dom.encode(data.link_text);\n                                    editor.selection.select(elm);\n                                    editor.selection.collapse(false);\n                                } else {\n                                    var _href = 'mailto:' + data.email.to;\n                                    var _mailAttrs = [];\n\n                                    if (data.email.subject) {\n                                        _mailAttrs.push('subject=' + encodeURI(data.email.subject));\n                                    }\n\n                                    if (data.email.body) {\n                                        _mailAttrs.push('body=' + encodeURI(data.email.body));\n                                    }\n\n                                    if (_mailAttrs.length > 0) {\n                                        _href += '?' + _mailAttrs.join('&');\n                                    }\n\n                                    var _attrs2 = {\n                                        href: _href\n                                    };\n\n                                    if (data.link_title) {\n                                        _attrs2.title = data.link_title;\n                                    }\n\n                                    if (data.new_window) {\n                                        _attrs2.target = '_blank';\n                                    }\n\n                                    if (data.classes) {\n                                        _attrs2.class = data.classes;\n                                    }\n\n                                    editor.insertContent(editor.dom.createHTML('a', _attrs2, editor.dom.encode(data.link_text)));\n\n                                    editor.selection.collapse(false);\n                                }\n                            }\n                        };\n                    }(tabPanel)\n                });\n\n                var input = document.querySelector('#page_url');\n                // const wrapper = document.createElement('div');\n                // wrapper.classList.add('choices__inner');\n                //\n                // input.parentNode.replaceChild(wrapper, input);\n                // wrapper.appendChild(input);\n\n                var lookupTimeout = null;\n                var lookupCache = {};\n                var initData = [];\n\n                var templateInputChoices = new _choices2.default(input);\n                templateInputChoices.ajax(function (callback) {\n                    (0, _isomorphicFetch2.default)(fred.config.assetsUrl + 'endpoints/ajax.php?action=rte-get-resources').then(function (response) {\n                        return response.json();\n                    }).then(function (data) {\n                        initData = data.data.resources;\n                        callback(data.data.resources, 'value', 'pagetitle');\n                    }).catch(function (error) {\n                        console.log(error);\n                    });\n                });\n\n                var populateOptions = function populateOptions(options) {\n                    var toRemove = [];\n\n                    templateInputChoices.currentState.items.forEach(function (item) {\n                        if (item.active) {\n                            toRemove.push(item.value);\n                        }\n                    });\n\n                    var toKeep = [];\n                    options.forEach(function (option) {\n                        if (toRemove.indexOf(option.id) === -1) {\n                            toKeep.push(option);\n                        }\n                    });\n\n                    templateInputChoices.setChoices(toKeep, 'value', 'pagetitle', true);\n                };\n\n                var serverLookup = function serverLookup() {\n                    var query = templateInputChoices.input.value;\n                    if (query in lookupCache) {\n                        populateOptions(lookupCache[query]);\n                    } else {\n                        (0, _isomorphicFetch2.default)(fred.config.assetsUrl + 'endpoints/ajax.php?action=rte-get-resources&query=' + query).then(function (response) {\n                            return response.json();\n                        }).then(function (data) {\n                            lookupCache[query] = data.data.resources;\n                            populateOptions(data.data.resources);\n                        }).catch(function (error) {\n                            console.log(error);\n                        });\n                    }\n                };\n\n                templateInputChoices.passedElement.addEventListener('search', function (event) {\n                    clearTimeout(lookupTimeout);\n                    lookupTimeout = setTimeout(serverLookup, 200);\n                });\n\n                templateInputChoices.passedElement.addEventListener('choice', function (event) {\n                    templateInputChoices.setChoices(initData, 'value', 'pagetitle', true);\n                    data.page.page = event.detail.choice.value;\n                    data.page.url = event.detail.choice.customProperties.url;\n\n                    var pageAnchorEl = document.getElementById('page_anchor-l');\n                    if (pageAnchorEl) {\n                        pageAnchorEl.innerText = 'Block on \\'' + event.detail.choice.label + '\\'';\n                    }\n                });\n            },\n            stateSelector: 'a[href]'\n        });\n\n        return {\n            getMetadata: function getMetadata() {\n                return {\n                    name: \"Example plugin\",\n                    url: \"http://exampleplugindocsurl.com\"\n                };\n            }\n        };\n    };\n};\n\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL1RpbnlNQ0UvUGx1Z2lucy9tb2R4bGluay9tb2R4bGluay5qcz84MDQ3Il0sIm5hbWVzIjpbImVkaXRvciIsInVybCIsImFkZEJ1dHRvbiIsImljb24iLCJvbmNsaWNrIiwiZWxtIiwiYWN0aXZlVGFiIiwiZGF0YSIsImxpbmtfdGV4dCIsInNlbGVjdGlvbiIsImdldENvbnRlbnQiLCJsaW5rX3RpdGxlIiwiY2xhc3NlcyIsIm5ld193aW5kb3ciLCJwYWdlIiwiYW5jaG9yIiwiZW1haWwiLCJ0byIsInN1YmplY3QiLCJib2R5IiwicGhvbmUiLCJmaWxlIiwiZG9tIiwiZ2V0UGFyZW50IiwiZ2V0U3RhcnQiLCJzZWxlY3QiLCJwYXJzZWREYXRhIiwiZ2V0RGF0YSIsInRhYiIsImNvbnNvbGUiLCJsb2ciLCJ0YWJQYW5lbCIsInRpbnltY2UiLCJ1aSIsIlRhYlBhbmVsIiwidHlwZSIsIml0ZW1zIiwidGl0bGUiLCJpZCIsImxheW91dCIsInBhZGRpbmciLCJjb2x1bW5zIiwibGFiZWwiLCJ2YWx1ZSIsImZyZWQiLCJjb25maWciLCJwYWdlU2V0dGluZ3MiLCJwYWdldGl0bGUiLCJvbmtleXVwIiwibXVsdGlsaW5lIiwid2luIiwid2luZG93TWFuYWdlciIsIm9wZW4iLCJuYW1lIiwib25jaGFuZ2UiLCJvbnN1Ym1pdCIsImFjdGl2ZVRhYklkIiwic2xpY2UiLCJfaWQiLCJmb2N1cyIsInJlbW92ZUFsbEF0dHJpYnMiLCJzZXRBdHRyaWIiLCJpbm5lclRleHQiLCJlbmNvZGUiLCJjb2xsYXBzZSIsImF0dHJzIiwiaHJlZiIsInRhcmdldCIsImNsYXNzIiwiaW5zZXJ0Q29udGVudCIsImNyZWF0ZUhUTUwiLCJtYWlsQXR0cnMiLCJwdXNoIiwiZW5jb2RlVVJJIiwibGVuZ3RoIiwiam9pbiIsImlucHV0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwibG9va3VwVGltZW91dCIsImxvb2t1cENhY2hlIiwiaW5pdERhdGEiLCJ0ZW1wbGF0ZUlucHV0Q2hvaWNlcyIsImFqYXgiLCJhc3NldHNVcmwiLCJ0aGVuIiwicmVzcG9uc2UiLCJqc29uIiwicmVzb3VyY2VzIiwiY2FsbGJhY2siLCJjYXRjaCIsImVycm9yIiwicG9wdWxhdGVPcHRpb25zIiwidG9SZW1vdmUiLCJjdXJyZW50U3RhdGUiLCJmb3JFYWNoIiwiaXRlbSIsImFjdGl2ZSIsInRvS2VlcCIsIm9wdGlvbnMiLCJpbmRleE9mIiwib3B0aW9uIiwic2V0Q2hvaWNlcyIsInNlcnZlckxvb2t1cCIsInF1ZXJ5IiwicGFzc2VkRWxlbWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZXZlbnQiLCJkZXRhaWwiLCJjaG9pY2UiLCJjdXN0b21Qcm9wZXJ0aWVzIiwicGFnZUFuY2hvckVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzdGF0ZVNlbGVjdG9yIiwiZ2V0TWV0YWRhdGEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7a0JBRWUsZ0JBQVE7QUFDbkIsV0FBTyxVQUFDQSxNQUFELEVBQVNDLEdBQVQsRUFBaUI7QUFDcEI7O0FBRUFELGVBQU9FLFNBQVAsQ0FBaUIsVUFBakIsRUFBNkI7QUFDekJDLGtCQUFNLE1BRG1CO0FBRXpCQyxxQkFBUyxtQkFBWTs7QUFFakIsb0JBQUlDLFlBQUo7QUFDQSxvQkFBSUMsWUFBWSxDQUFoQjs7QUFFQSxvQkFBSUMsT0FBTztBQUNQQywrQkFBV1IsT0FBT1MsU0FBUCxDQUFpQkMsVUFBakIsRUFESjtBQUVQQyxnQ0FBWSxFQUZMO0FBR1BDLDZCQUFTLEVBSEY7QUFJUEMsZ0NBQVksS0FKTDtBQUtQQywwQkFBTTtBQUNGQSw4QkFBTSxFQURKO0FBRUZiLDZCQUFLLEVBRkg7QUFHRmMsZ0NBQVE7QUFITixxQkFMQztBQVVQZCx5QkFBSztBQUNEQSw2QkFBSztBQURKLHFCQVZFO0FBYVBlLDJCQUFPO0FBQ0hDLDRCQUFJLEVBREQ7QUFFSEMs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ckIsQ0FBbUNDLGdCQUFuQyxDQUFvRCxRQUFwRCxFQUE4RCxpQkFBUztBQUNuRXhCLHlDQUFxQm9CLFVBQXJCLENBQWdDckIsUUFBaEMsRUFBMEMsT0FBMUMsRUFBbUQsV0FBbkQsRUFBZ0UsSUFBaEU7QUFDQTFFLHlCQUFLTyxJQUFMLENBQVVBLElBQVYsR0FBaUIrRixNQUFNQyxNQUFOLENBQWFDLE1BQWIsQ0FBb0JwRSxLQUFyQztBQUNBcEMseUJBQUtPLElBQUwsQ0FBVWIsR0FBVixHQUFnQjRHLE1BQU1DLE1BQU4sQ0FBYUMsTUFBYixDQUFvQkMsZ0JBQXBCLENBQXFDL0csR0FBckQ7O0FBRUEsd0JBQU1nSCxlQUFlcEMsU0FBU3FDLGNBQVQsQ0FBd0IsZUFBeEIsQ0FBckI7QUFDQSx3QkFBSUQsWUFBSixFQUFrQjtBQUNkQSxxQ0FBYW5ELFNBQWIsR0FBeUIsZ0JBQWdCK0MsTUFBTUMsTUFBTixDQUFhQyxNQUFiLENBQW9CckUsS0FBcEMsR0FBNEMsSUFBckU7QUFDSDtBQUNKLGlCQVREO0FBV0gsYUE1ZHdCO0FBNmR6QnlFLDJCQUFlO0FBN2RVLFNBQTdCOztBQWdlQSxlQUFPO0FBQ0hDLHlCQUFhLHVCQUFZO0FBQ3JCLHVCQUFPO0FBQ0gvRCwwQkFBTSxnQkFESDtBQUVIcEQseUJBQUs7QUFGRixpQkFBUDtBQUlIO0FBTkUsU0FBUDtBQVFILEtBM2VEO0FBNGVILEMiLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hvaWNlcyBmcm9tICdjaG9pY2VzLmpzJztcbmltcG9ydCBmZXRjaCBmcm9tICdpc29tb3JwaGljLWZldGNoJztcbmltcG9ydCBFbGVtZW50SGVscGVyIGZyb20gJy4vRWxlbWVudEhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWQgPT4ge1xuICAgIHJldHVybiAoZWRpdG9yLCB1cmwpID0+IHtcbiAgICAgICAgLy8gQWRkIGEgYnV0dG9uIHRoYXQgb3BlbnMgYSB3aW5kb3dcblxuICAgICAgICBlZGl0b3IuYWRkQnV0dG9uKCdtb2R4bGluaycsIHtcbiAgICAgICAgICAgIGljb246ICdsaW5rJyxcbiAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGxldCBlbG07XG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZVRhYiA9IDA7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGlua190ZXh0OiBlZGl0b3Iuc2VsZWN0aW9uLmdldENvbnRlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgbGlua190aXRsZTogJycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6ICcnLFxuICAgICAgICAgICAgICAgICAgICBuZXdfd2luZG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3Q6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogJydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGhvbmU6IHt9LFxuICAgICAgICAgICAgICAgICAgICBmaWxlOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZWxtID0gZWRpdG9yLmRvbS5nZXRQYXJlbnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCgpLCAnYVtocmVmXScpO1xuICAgICAgICAgICAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3QoZWxtKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gRWxlbWVudEhlbHBlci5nZXREYXRhKGVsbSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwYXJzZWREYXRhLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgIFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnNlZERhdGEudGFiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXJsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWIgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhYiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0YWJQYW5lbCA9IG5ldyB0aW55bWNlLnVpLlRhYlBhbmVsKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RhYnBhbmVsJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NlczogJ2ZyZWQtLW1vZHhsaW5rLXBhbmVsJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFiLFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnUGFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiAnZ3JpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NlbGVjdGJveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdQYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BhZ2VfdXJsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YS5wYWdlLnBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHRib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBgQmxvY2sgb24gJyR7ZnJlZC5jb25maWcucGFnZVNldHRpbmdzLnBhZ2V0aXRsZSB9J2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwYWdlX2FuY2hvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEucGFnZS5hbmNob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25rZXl1cCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wYWdlLmFuY2hvciA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1VSTCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd1cmwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGJveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1VSTCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YS51cmwudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25rZXl1cCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnVybC51cmwgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRW1haWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnZW1haWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGJveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1RvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLmVtYWlsLnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25rZXl1cCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmVtYWlsLnRvID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGJveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1N1YmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEuZW1haWwuc3ViamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ua2V5dXAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5lbWFpbC5zdWJqZWN0ID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGJveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0JvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEuZW1haWwuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ua2V5dXAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5lbWFpbC5ib2R5ID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1Bob25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3Bob25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRmlsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdmaWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBPcGVuIHdpbmRvd1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpbiA9IGVkaXRvci53aW5kb3dNYW5hZ2VyLm9wZW4oe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0xpbmsgdG8nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzOiAnZnJlZC0tbW9keGxpbmsnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHRib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnTGluayBUZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGlua190ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmtleXVwKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmxpbmtfdGV4dCA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6ICdncmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHRib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbmtfdGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdMaW5rIFRpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ua2V5dXAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5saW5rX3RpdGxlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0Ym94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjbGFzc2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnQ2xhc3NlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmtleXVwKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2xhc3NlcyA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICduZXdfd2luZG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnTmV3IFdpbmRvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm5ld193aW5kb3cgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiUGFuZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBvbnN1Ym1pdDogKHRhYlBhbmVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVUYWIgPSB0YWJQYW5lbC5pdGVtcygpW3RhYlBhbmVsLmFjdGl2ZVRhYklkLnNsaWNlKDEpXS5faWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYWN0aXZlVGFiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsbSA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKSwgJ2FbaHJlZl0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVGFiID09PSAncGFnZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnBhZ2UucGFnZSAmJiAhIGRhdGEucGFnZS5hbmNob3IpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZG9tLnJlbW92ZUFsbEF0dHJpYnMoZWxtKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZG9tLnNldEF0dHJpYihlbG0sICdkYXRhLWZyZWQtbGluay1wYWdlJywgZGF0YS5wYWdlLnBhZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wYWdlLmFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20uc2V0QXR0cmliKGVsbSwgJ2RhdGEtZnJlZC1saW5rLWFuY2hvcicsIGRhdGEucGFnZS5hbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20uc2V0QXR0cmliKGVsbSwgJ2hyZWYnLCBkYXRhLnBhZ2UudXJsICsgJyMnICsgZGF0YS5wYWdlLmFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20uc2V0QXR0cmliKGVsbSwgJ2hyZWYnLCBkYXRhLnBhZ2UudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGlua190aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20uc2V0QXR0cmliKGVsbSwgJ3RpdGxlJywgZGF0YS5saW5rX3RpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubmV3X3dpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20uc2V0QXR0cmliKGVsbSwgJ3RhcmdldCcsICdfYmxhbmsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20uc2V0QXR0cmliKGVsbSwgJ2NsYXNzJywgZGF0YS5jbGFzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtLmlubmVyVGV4dCA9IGVkaXRvci5kb20uZW5jb2RlKGRhdGEubGlua190ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGRhdGEucGFnZS51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZnJlZC1saW5rLXBhZ2UnOiBkYXRhLnBhZ2UucGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucGFnZS5hbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1snZGF0YS1mcmVkLWxpbmstYW5jaG9yJ10gPSBkYXRhLnBhZ2UuYW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLmhyZWYgPSBkYXRhLnBhZ2UudXJsICsgJyMnICsgZGF0YS5wYWdlLmFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGlua190aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnRpdGxlID0gZGF0YS5saW5rX3RpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5uZXdfd2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5jbGFzcyA9IGRhdGEuY2xhc3NlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmluc2VydENvbnRlbnQoZWRpdG9yLmRvbS5jcmVhdGVIVE1MKCdhJywgYXR0cnMsIGVkaXRvci5kb20uZW5jb2RlKGRhdGEubGlua190ZXh0KSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVGFiID09PSAndXJsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20ucmVtb3ZlQWxsQXR0cmlicyhlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZG9tLnNldEF0dHJpYihlbG0sICdocmVmJywgZGF0YS51cmwudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGlua190aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20uc2V0QXR0cmliKGVsbSwgJ3RpdGxlJywgZGF0YS5saW5rX3RpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubmV3X3dpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20uc2V0QXR0cmliKGVsbSwgJ3RhcmdldCcsICdfYmxhbmsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20uc2V0QXR0cmliKGVsbSwgJ2NsYXNzJywgZGF0YS5jbGFzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtLmlubmVyVGV4dCA9IGVkaXRvci5kb20uZW5jb2RlKGRhdGEubGlua190ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGRhdGEudXJsLnVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGlua190aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnRpdGxlID0gZGF0YS5saW5rX3RpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5uZXdfd2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5jbGFzcyA9IGRhdGEuY2xhc3NlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmluc2VydENvbnRlbnQoZWRpdG9yLmRvbS5jcmVhdGVIVE1MKCdhJywgYXR0cnMsIGVkaXRvci5kb20uZW5jb2RlKGRhdGEubGlua190ZXh0KSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUYWIgPT09ICdlbWFpbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZG9tLnJlbW92ZUFsbEF0dHJpYnMoZWxtKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhyZWYgPSBgbWFpbHRvOiR7ZGF0YS5lbWFpbC50b31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFpbEF0dHJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVtYWlsLnN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWlsQXR0cnMucHVzaCgnc3ViamVjdD0nICsgZW5jb2RlVVJJKGRhdGEuZW1haWwuc3ViamVjdCkpOyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZW1haWwuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haWxBdHRycy5wdXNoKCdib2R5PScgKyBlbmNvZGVVUkkoZGF0YS5lbWFpbC5ib2R5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWlsQXR0cnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWYgKz0gJz8nICsgbWFpbEF0dHJzLmpvaW4oJyYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZG9tLnNldEF0dHJpYihlbG0sICdocmVmJywgaHJlZik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxpbmtfdGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZG9tLnNldEF0dHJpYihlbG0sICd0aXRsZScsIGRhdGEubGlua190aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm5ld193aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZG9tLnNldEF0dHJpYihlbG0sICd0YXJnZXQnLCAnX2JsYW5rJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZG9tLnNldEF0dHJpYihlbG0sICdjbGFzcycsIGRhdGEuY2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5pbm5lclRleHQgPSBlZGl0b3IuZG9tLmVuY29kZShkYXRhLmxpbmtfdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdChlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaHJlZiA9IGBtYWlsdG86JHtkYXRhLmVtYWlsLnRvfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYWlsQXR0cnMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZW1haWwuc3ViamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haWxBdHRycy5wdXNoKCdzdWJqZWN0PScgKyBlbmNvZGVVUkkoZGF0YS5lbWFpbC5zdWJqZWN0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVtYWlsLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWlsQXR0cnMucHVzaCgnYm9keT0nICsgZW5jb2RlVVJJKGRhdGEuZW1haWwuYm9keSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbEF0dHJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmICs9ICc/JyArIG1haWxBdHRycy5qb2luKCcmJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxpbmtfdGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRycy50aXRsZSA9IGRhdGEubGlua190aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubmV3X3dpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMuY2xhc3MgPSBkYXRhLmNsYXNzZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pbnNlcnRDb250ZW50KGVkaXRvci5kb20uY3JlYXRlSFRNTCgnYScsIGF0dHJzLCBlZGl0b3IuZG9tLmVuY29kZShkYXRhLmxpbmtfdGV4dCkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKHRhYlBhbmVsKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGFnZV91cmwnKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgLy8gd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdjaG9pY2VzX19pbm5lcicpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaW5wdXQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlciwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIC8vIHdyYXBwZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGxvb2t1cFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvb2t1cENhY2hlID0ge307XG4gICAgICAgICAgICAgICAgbGV0IGluaXREYXRhID0gW107XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVJbnB1dENob2ljZXMgPSBuZXcgQ2hvaWNlcyhpbnB1dCk7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVJbnB1dENob2ljZXMuYWpheChjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoKGAke2ZyZWQuY29uZmlnLmFzc2V0c1VybH1lbmRwb2ludHMvYWpheC5waHA/YWN0aW9uPXJ0ZS1nZXQtcmVzb3VyY2VzYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdERhdGEgPSBkYXRhLmRhdGEucmVzb3VyY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEuZGF0YS5yZXNvdXJjZXMsICd2YWx1ZScsICdwYWdldGl0bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcG9wdWxhdGVPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvUmVtb3ZlID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVJbnB1dENob2ljZXMuY3VycmVudFN0YXRlLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKGl0ZW0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0tlZXAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9SZW1vdmUuaW5kZXhPZihvcHRpb24uaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvS2VlcC5wdXNoKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlSW5wdXRDaG9pY2VzLnNldENob2ljZXModG9LZWVwLCAndmFsdWUnLCAncGFnZXRpdGxlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckxvb2t1cCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSB0ZW1wbGF0ZUlucHV0Q2hvaWNlcy5pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5IGluIGxvb2t1cENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZU9wdGlvbnMobG9va3VwQ2FjaGVbcXVlcnldKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKGAke2ZyZWQuY29uZmlnLmFzc2V0c1VybH1lbmRwb2ludHMvYWpheC5waHA/YWN0aW9uPXJ0ZS1nZXQtcmVzb3VyY2VzJnF1ZXJ5PSR7cXVlcnl9YClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBDYWNoZVtxdWVyeV0gPSBkYXRhLmRhdGEucmVzb3VyY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZU9wdGlvbnMoZGF0YS5kYXRhLnJlc291cmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVJbnB1dENob2ljZXMucGFzc2VkRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWFyY2gnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChsb29rdXBUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwVGltZW91dCA9IHNldFRpbWVvdXQoc2VydmVyTG9va3VwLCAyMDApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVJbnB1dENob2ljZXMucGFzc2VkRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaG9pY2UnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlSW5wdXRDaG9pY2VzLnNldENob2ljZXMoaW5pdERhdGEsICd2YWx1ZScsICdwYWdldGl0bGUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wYWdlLnBhZ2UgPSBldmVudC5kZXRhaWwuY2hvaWNlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnBhZ2UudXJsID0gZXZlbnQuZGV0YWlsLmNob2ljZS5jdXN0b21Qcm9wZXJ0aWVzLnVybDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VBbmNob3JFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWdlX2FuY2hvci1sJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWdlQW5jaG9yRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VBbmNob3JFbC5pbm5lclRleHQgPSAnQmxvY2sgb24gXFwnJyArIGV2ZW50LmRldGFpbC5jaG9pY2UubGFiZWwgKyAnXFwnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF0ZVNlbGVjdG9yOiAnYVtocmVmXSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE1ldGFkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJFeGFtcGxlIHBsdWdpblwiLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cDovL2V4YW1wbGVwbHVnaW5kb2NzdXJsLmNvbVwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vX2J1aWxkL2Fzc2V0cy9qcy9UaW55TUNFL1BsdWdpbnMvbW9keGxpbmsvbW9keGxpbmsuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ElementHelper = function () {\n    function ElementHelper() {\n        _classCallCheck(this, ElementHelper);\n    }\n\n    _createClass(ElementHelper, null, [{\n        key: 'getData',\n        value: function getData(el, initData) {\n            var data = {\n                global: {\n                    link_text: '',\n                    link_title: '',\n                    classes: '',\n                    new_window: false\n                },\n                page: _extends({}, initData.page),\n                url: _extends({}, initData.url),\n                email: _extends({}, initData.email)\n            };\n\n            data.global.link_title = el.getAttribute('title');\n            data.global.classes = el.getAttribute('class');\n            data.global.new_window = el.getAttribute('target') === '_blank';\n            data.global.link_text = el.innerText;\n\n            var url = el.getAttribute('href') || '';\n\n            data.page.page = el.getAttribute('data-fred-link-page');\n            data.page.anchor = el.getAttribute('data-fred-link-anchor');\n\n            if (data.page.page || data.page.anchor) {\n                data.page.url = url.replace('#' + data.page.anchor, '');\n\n                return {\n                    tab: 'page',\n                    data: _extends({}, data.global, {\n                        page: _extends({}, data.page)\n                    })\n                };\n            }\n\n            if (url.slice(0, 7) === 'mailto:') {\n                url = url.slice(7);\n                url = url.split('?');\n\n                data.email.to = url[0];\n                if (url[1]) {\n                    var components = url[1].split('&');\n                    components.forEach(function (component) {\n                        component = component.split('=');\n                        if (component[0] === 'subject') {\n                            data.email.subject = decodeURI(component[1]);\n                        }\n\n                        if (component[0] === 'body') {\n                            data.email.body = decodeURI(component[1]);\n                        }\n                    });\n                }\n\n                return {\n                    tab: 'email',\n                    data: _extends({}, data.global, {\n                        email: _extends({}, data.email)\n                    })\n                };\n            }\n\n            data.url.url = url;\n\n            return {\n                tab: 'url',\n                data: _extends({}, data.global, {\n                    url: _extends({}, data.url)\n                })\n            };\n        }\n    }]);\n\n    return ElementHelper;\n}();\n\nexports.default = ElementHelper;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9fYnVpbGQvYXNzZXRzL2pzL1RpbnlNQ0UvUGx1Z2lucy9tb2R4bGluay9FbGVtZW50SGVscGVyLmpzPzU1Y2EiXSwibmFtZXMiOlsiRWxlbWVudEhlbHBlciIsImVsIiwiaW5pdERhdGEiLCJkYXRhIiwiZ2xvYmFsIiwibGlua190ZXh0IiwibGlua190aXRsZSIsImNsYXNzZXMiLCJuZXdfd2luZG93IiwicGFnZSIsInVybCIsImVtYWlsIiwiZ2V0QXR0cmlidXRlIiwiaW5uZXJUZXh0IiwiYW5jaG9yIiwicmVwbGFjZSIsInRhYiIsInNsaWNlIiwic3BsaXQiLCJ0byIsImNvbXBvbmVudHMiLCJmb3JFYWNoIiwiY29tcG9uZW50Iiwic3ViamVjdCIsImRlY29kZVVSSSIsImJvZHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUFxQkEsYTs7Ozs7OztnQ0FDRkMsRSxFQUFJQyxRLEVBQVU7QUFDekIsZ0JBQU1DLE9BQU87QUFDVEMsd0JBQVE7QUFDSkMsK0JBQVcsRUFEUDtBQUVKQyxnQ0FBWSxFQUZSO0FBR0pDLDZCQUFTLEVBSEw7QUFJSkMsZ0NBQVk7QUFKUixpQkFEQztBQU9UQyxtQ0FDUVAsU0FBU08sSUFEakIsQ0FQUztBQVVUQyxrQ0FDUVIsU0FBU1EsR0FEakIsQ0FWUztBQWFUQyxvQ0FDUVQsU0FBU1MsS0FEakI7QUFiUyxhQUFiOztBQWtCQVIsaUJBQUtDLE1BQUwsQ0FBWUUsVUFBWixHQUF5QkwsR0FBR1csWUFBSCxDQUFnQixPQUFoQixDQUF6QjtBQUNBVCxpQkFBS0MsTUFBTCxDQUFZRyxPQUFaLEdBQXNCTixHQUFHVyxZQUFILENBQWdCLE9BQWhCLENBQXRCO0FBQ0FULGlCQUFLQyxNQUFMLENBQVlJLFVBQVosR0FBMEJQLEdBQUdXLFlBQUgsQ0FBZ0IsUUFBaEIsTUFBOEIsUUFBeEQ7QUFDQVQsaUJBQUtDLE1BQUwsQ0FBWUMsU0FBWixHQUF3QkosR0FBR1ksU0FBM0I7O0FBRUEsZ0JBQUlILE1BQU1ULEdBQUdXLFlBQUgsQ0FBZ0IsTUFBaEIsS0FBMkIsRUFBckM7O0FBRUFULGlCQUFLTSxJQUFMLENBQVVBLElBQVYsR0FBaUJSLEdBQUdXLFlBQUgsQ0FBZ0IscUJBQWhCLENBQWpCO0FBQ0FULGlCQUFLTSxJQUFMLENBQVVLLE1BQVYsR0FBbUJiLEdBQUdXLFlBQUgsQ0FBZ0IsdUJBQWhCLENBQW5COztBQUVBLGdCQUFJVCxLQUFLTSxJQUFMLENBQVVBLElBQVYsSUFBa0JOLEtBQUtNLElBQUwsQ0FBVUssTUFBaEMsRUFBd0M7QUFDcENYLHFCQUFLTSxJQUFMLENBQVVDLEdBQVYsR0FBZ0JBLElBQUlLLE9BQUosQ0FBYSxNQUFNWixLQUFLTSxJQUFMLENBQVVLLE1BQTdCLEVBQXNDLEVBQXRDLENBQWhCOztBQUVBLHVCQUFPO0FBQ0hFLHlCQUFLLE1BREY7QUFFSGIsdUNBQ1FBLEtBQUtDLE1BRGI7QUFFSUssMkNBQ1FOLEtBQUtNLElBRGI7QUFGSjtBQUZHLGlCQUFQO0FBU0g7O0FBRUQsZ0JBQUlDLElBQUlPLEtBQUosQ0FBVSxDQUFWLEVBQVksQ0FBWixNQUFtQixTQUF2QixFQUFrQztBQUM5QlAsc0JBQU1BLElBQUlPLEtBQUosQ0FBVSxDQUFWLENBQU47QUFDQVAsc0JBQU1BLElBQUlRLEtBQUosQ0FBVSxHQUFWLENBQU47O0FBRUFmLHFCQUFLUSxLQUFMLENBQVdRLEVBQVgsR0FBZ0JULElBQUksQ0FBSixDQUFoQjtBQUNBLG9CQUFJQSxJQUFJLENBQUosQ0FBSixFQUFZO0FBQ1Isd0JBQU1VLGFBQWFWLElBQUksQ0FBSixFQUFPUSxLQUFQLENBQWEsR0FBYixDQUFuQjtBQUNBRSwrQkFBV0MsT0FBWCxDQUFtQixxQkFBYTtBQUM1QkMsb0NBQVlBLFVBQVVKLEtBQVYsQ0FBZ0IsR0FBaEIsQ0FBWjtBQUNBLDRCQUFJSSxVQUFVLENBQVYsTUFBaUIsU0FBckIsRUFBZ0M7QUFDNUJuQixpQ0FBS1EsS0FBTCxDQUFXWSxPQUFYLEdBQXFCQyxVQUFVRixVQUFVLENBQVYsQ0FBVixDQUFyQjtBQUNIOztBQUVELDRCQUFJQSxVQUFVLENBQVYsTUFBaUIsTUFBckIsRUFBNkI7QUFDekJuQixpQ0FBS1EsS0FBTCxDQUFXYyxJQUFYLEdBQWtCRCxVQUFVRixVQUFVLENBQVYsQ0FBVixDQUFsQjtBQUNIO0FBQ0oscUJBVEQ7QUFVSDs7QUFFRCx1QkFBTztBQUNITix5QkFBSyxPQURGO0FBRUhiLHVDQUNRQSxLQUFLQyxNQURiO0FBRUlPLDRDQUNRUixLQUFLUSxLQURiO0FBRko7QUFGRyxpQkFBUDtBQVNIOztBQUVEUixpQkFBS08sR0FBTCxDQUFTQSxHQUFULEdBQWVBLEdBQWY7O0FBRUEsbUJBQU87QUFDSE0scUJBQUssS0FERjtBQUVIYixtQ0FDUUEsS0FBS0MsTUFEYjtBQUVJTSxzQ0FDUVAsS0FBS08sR0FEYjtBQUZKO0FBRkcsYUFBUDtBQVNIOzs7Ozs7a0JBckZnQlYsYSIsImZpbGUiOiIzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnRIZWxwZXIge1xuICAgIHN0YXRpYyBnZXREYXRhKGVsLCBpbml0RGF0YSkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZ2xvYmFsOiB7XG4gICAgICAgICAgICAgICAgbGlua190ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICBsaW5rX3RpdGxlOiAnJyxcbiAgICAgICAgICAgICAgICBjbGFzc2VzOiAnJyxcbiAgICAgICAgICAgICAgICBuZXdfd2luZG93OiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgICAgICAuLi4oaW5pdERhdGEucGFnZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgICAgICAuLi4oaW5pdERhdGEudXJsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVtYWlsOiB7XG4gICAgICAgICAgICAgICAgLi4uKGluaXREYXRhLmVtYWlsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRhdGEuZ2xvYmFsLmxpbmtfdGl0bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgICAgIGRhdGEuZ2xvYmFsLmNsYXNzZXMgPSBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgIGRhdGEuZ2xvYmFsLm5ld193aW5kb3cgPSAoZWwuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSA9PT0gJ19ibGFuaycpO1xuICAgICAgICBkYXRhLmdsb2JhbC5saW5rX3RleHQgPSBlbC5pbm5lclRleHQ7XG4gICAgICAgIFxuICAgICAgICBsZXQgdXJsID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG5cbiAgICAgICAgZGF0YS5wYWdlLnBhZ2UgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZnJlZC1saW5rLXBhZ2UnKTtcbiAgICAgICAgZGF0YS5wYWdlLmFuY2hvciA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1mcmVkLWxpbmstYW5jaG9yJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGF0YS5wYWdlLnBhZ2UgfHwgZGF0YS5wYWdlLmFuY2hvcikge1xuICAgICAgICAgICAgZGF0YS5wYWdlLnVybCA9IHVybC5yZXBsYWNlKCgnIycgKyBkYXRhLnBhZ2UuYW5jaG9yKSwgJycpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhYjogJ3BhZ2UnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uKGRhdGEuZ2xvYmFsKSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGRhdGEucGFnZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXJsLnNsaWNlKDAsNykgPT09ICdtYWlsdG86Jykge1xuICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKDcpO1xuICAgICAgICAgICAgdXJsID0gdXJsLnNwbGl0KCc/Jyk7XG5cbiAgICAgICAgICAgIGRhdGEuZW1haWwudG8gPSB1cmxbMF07XG4gICAgICAgICAgICBpZiAodXJsWzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHVybFsxXS5zcGxpdCgnJicpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChjb21wb25lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnQuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudFswXSA9PT0gJ3N1YmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmVtYWlsLnN1YmplY3QgPSBkZWNvZGVVUkkoY29tcG9uZW50WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRbMF0gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5lbWFpbC5ib2R5ID0gZGVjb2RlVVJJKGNvbXBvbmVudFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWI6ICdlbWFpbCcsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAuLi4oZGF0YS5nbG9iYWwpLFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGRhdGEuZW1haWwpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cbiAgICAgICAgZGF0YS51cmwudXJsID0gdXJsO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWI6ICd1cmwnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLihkYXRhLmdsb2JhbCksXG4gICAgICAgICAgICAgICAgdXJsOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLihkYXRhLnVybClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL19idWlsZC9hc3NldHMvanMvVGlueU1DRS9QbHVnaW5zL21vZHhsaW5rL0VsZW1lbnRIZWxwZXIuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ])
});
;